; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\dns.o --depend=.\obj\dns.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\dns.crf ..\lwIP\src\core\dns.c]
                          THUMB

                          AREA ||i.dns_check_entries||, CODE, READONLY, ALIGN=1

                  dns_check_entries PROC
;;;723    static void
;;;724    dns_check_entries(void)
000000  b510              PUSH     {r4,lr}
;;;725    {
;;;726      u8_t i;
;;;727    
;;;728      for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000002  2400              MOVS     r4,#0
000004  e004              B        |L1.16|
                  |L1.6|
;;;729        dns_check_entry(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       dns_check_entry
00000c  1c60              ADDS     r0,r4,#1              ;728
00000e  b2c4              UXTB     r4,r0                 ;728
                  |L1.16|
000010  2c04              CMP      r4,#4                 ;728
000012  dbf8              BLT      |L1.6|
;;;730      }
;;;731    }
000014  bd10              POP      {r4,pc}
;;;732    
                          ENDP


                          AREA ||i.dns_check_entry||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dns_check_entry PROC
;;;650    static void
;;;651    dns_check_entry(u8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;652    {
000002  4605              MOV      r5,r0
;;;653      struct dns_table_entry *pEntry = &dns_table[i];
000004  ebc500c5          RSB      r0,r5,r5,LSL #3
000008  eb000080          ADD      r0,r0,r0,LSL #2
00000c  4939              LDR      r1,|L2.244|
00000e  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;654    
;;;655      LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
;;;656    
;;;657      switch(pEntry->state) {
000012  7820              LDRB     r0,[r4,#0]
000014  b3a0              CBZ      r0,|L2.128|
000016  2801              CMP      r0,#1
000018  d004              BEQ      |L2.36|
00001a  2802              CMP      r0,#2
00001c  d011              BEQ      |L2.66|
00001e  2803              CMP      r0,#3
000020  d164              BNE      |L2.236|
000022  e050              B        |L2.198|
                  |L2.36|
;;;658    
;;;659        case DNS_STATE_NEW: {
;;;660          /* initialize new entry */
;;;661          pEntry->state   = DNS_STATE_ASKING;
000024  2002              MOVS     r0,#2
000026  7020              STRB     r0,[r4,#0]
;;;662          pEntry->numdns  = 0;
000028  2000              MOVS     r0,#0
00002a  7060              STRB     r0,[r4,#1]
;;;663          pEntry->tmr     = 1;
00002c  2001              MOVS     r0,#1
00002e  70a0              STRB     r0,[r4,#2]
;;;664          pEntry->retries = 0;
000030  2000              MOVS     r0,#0
000032  70e0              STRB     r0,[r4,#3]
;;;665          
;;;666          /* send DNS packet for this entry */
;;;667          dns_send(pEntry->numdns, pEntry->name, i);
000034  7860              LDRB     r0,[r4,#1]
000036  462a              MOV      r2,r5
000038  f104010c          ADD      r1,r4,#0xc
00003c  f7fffffe          BL       dns_send
;;;668          break;
000040  e055              B        |L2.238|
                  |L2.66|
;;;669        }
;;;670    
;;;671        case DNS_STATE_ASKING: {
;;;672          if (--pEntry->tmr == 0) {
000042  78a0              LDRB     r0,[r4,#2]
000044  1e40              SUBS     r0,r0,#1
000046  f01000ff          ANDS     r0,r0,#0xff
00004a  70a0              STRB     r0,[r4,#2]
00004c  d13a              BNE      |L2.196|
;;;673            if (++pEntry->retries == DNS_MAX_RETRIES) {
00004e  78e0              LDRB     r0,[r4,#3]
000050  1c40              ADDS     r0,r0,#1
000052  b2c0              UXTB     r0,r0
000054  70e0              STRB     r0,[r4,#3]
000056  2804              CMP      r0,#4
000058  d12c              BNE      |L2.180|
;;;674              if ((pEntry->numdns+1<DNS_MAX_SERVERS) && (dns_servers[pEntry->numdns+1].addr!=0)) {
00005a  7860              LDRB     r0,[r4,#1]
00005c  1c40              ADDS     r0,r0,#1
00005e  2802              CMP      r0,#2
000060  da0f              BGE      |L2.130|
000062  7860              LDRB     r0,[r4,#1]
000064  1c40              ADDS     r0,r0,#1
000066  4924              LDR      r1,|L2.248|
000068  eb010080          ADD      r0,r1,r0,LSL #2
00006c  6800              LDR      r0,[r0,#0]
00006e  b140              CBZ      r0,|L2.130|
;;;675                /* change of server */
;;;676                pEntry->numdns++;
000070  7860              LDRB     r0,[r4,#1]
000072  1c40              ADDS     r0,r0,#1
000074  7060              STRB     r0,[r4,#1]
;;;677                pEntry->tmr     = 1;
000076  2001              MOVS     r0,#1
000078  70a0              STRB     r0,[r4,#2]
;;;678                pEntry->retries = 0;
00007a  2000              MOVS     r0,#0
00007c  70e0              STRB     r0,[r4,#3]
;;;679                break;
00007e  e036              B        |L2.238|
                  |L2.128|
000080  e033              B        |L2.234|
                  |L2.130|
;;;680              } else {
;;;681                LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", pEntry->name));
000082  bf00              NOP      
000084  bf00              NOP      
000086  f104010c          ADD      r1,r4,#0xc
00008a  a01c              ADR      r0,|L2.252|
00008c  f7fffffe          BL       __2printf
000090  bf00              NOP      
000092  bf00              NOP      
;;;682                /* call specified callback function if provided */
;;;683                if (pEntry->found)
000094  f8d40110          LDR      r0,[r4,#0x110]
000098  b138              CBZ      r0,|L2.170|
;;;684                  (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
00009a  2100              MOVS     r1,#0
00009c  f104000c          ADD      r0,r4,#0xc
0000a0  f8d43110          LDR      r3,[r4,#0x110]
0000a4  f8d42114          LDR      r2,[r4,#0x114]
0000a8  4798              BLX      r3
                  |L2.170|
;;;685                /* flush this entry */
;;;686                pEntry->state   = DNS_STATE_UNUSED;
0000aa  2000              MOVS     r0,#0
0000ac  7020              STRB     r0,[r4,#0]
;;;687                pEntry->found   = NULL;
0000ae  f8c40110          STR      r0,[r4,#0x110]
;;;688                break;
0000b2  e01c              B        |L2.238|
                  |L2.180|
;;;689              }
;;;690            }
;;;691    
;;;692            /* wait longer for the next retry */
;;;693            pEntry->tmr = pEntry->retries;
0000b4  78e0              LDRB     r0,[r4,#3]
0000b6  70a0              STRB     r0,[r4,#2]
;;;694    
;;;695            /* send DNS packet for this entry */
;;;696            dns_send(pEntry->numdns, pEntry->name, i);
0000b8  7860              LDRB     r0,[r4,#1]
0000ba  462a              MOV      r2,r5
0000bc  f104010c          ADD      r1,r4,#0xc
0000c0  f7fffffe          BL       dns_send
                  |L2.196|
;;;697          }
;;;698          break;
0000c4  e013              B        |L2.238|
                  |L2.198|
;;;699        }
;;;700    
;;;701        case DNS_STATE_DONE: {
;;;702          /* if the time to live is nul */
;;;703          if (--pEntry->ttl == 0) {
0000c6  68a0              LDR      r0,[r4,#8]
0000c8  1e40              SUBS     r0,r0,#1
0000ca  60a0              STR      r0,[r4,#8]
0000cc  d10c              BNE      |L2.232|
;;;704            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
0000ce  bf00              NOP      
0000d0  bf00              NOP      
0000d2  f104010c          ADD      r1,r4,#0xc
0000d6  a011              ADR      r0,|L2.284|
0000d8  f7fffffe          BL       __2printf
0000dc  bf00              NOP      
0000de  bf00              NOP      
;;;705            /* flush this entry */
;;;706            pEntry->state = DNS_STATE_UNUSED;
0000e0  2000              MOVS     r0,#0
0000e2  7020              STRB     r0,[r4,#0]
;;;707            pEntry->found = NULL;
0000e4  f8c40110          STR      r0,[r4,#0x110]
                  |L2.232|
;;;708          }
;;;709          break;
0000e8  e001              B        |L2.238|
                  |L2.234|
;;;710        }
;;;711        case DNS_STATE_UNUSED:
;;;712          /* nothing to do */
;;;713          break;
0000ea  e000              B        |L2.238|
                  |L2.236|
;;;714        default:
;;;715          LWIP_ASSERT("unknown dns_table entry state:", 0);
;;;716          break;
0000ec  bf00              NOP      
                  |L2.238|
0000ee  bf00              NOP                            ;668
;;;717      }
;;;718    }
0000f0  bd70              POP      {r4-r6,pc}
;;;719    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L2.244|
                          DCD      dns_table
                  |L2.248|
                          DCD      dns_servers
                  |L2.252|
0000fc  646e735f          DCB      "dns_check_entry: ""%s"": timeout\n",0
000100  63686563
000104  6b5f656e
000108  7472793a
00010c  20222573
000110  223a2074
000114  696d656f
000118  75740a00
                  |L2.284|
00011c  646e735f          DCB      "dns_check_entry: ""%s"": flush\n",0
000120  63686563
000124  6b5f656e
000128  7472793a
00012c  20222573
000130  223a2066
000134  6c757368
000138  0a00    
00013a  00                DCB      0
00013b  00                DCB      0

                          AREA ||i.dns_compare_name||, CODE, READONLY, ALIGN=1

                  dns_compare_name PROC
;;;507    static u8_t
;;;508    dns_compare_name(unsigned char *query, unsigned char *response)
000000  b510              PUSH     {r4,lr}
;;;509    {
000002  4602              MOV      r2,r0
;;;510      unsigned char n;
;;;511    
;;;512      do {
000004  bf00              NOP      
                  |L3.6|
;;;513        n = *response++;
000006  f8113b01          LDRB     r3,[r1],#1
;;;514        /** @see RFC 1035 - 4.1.4. Message compression */
;;;515        if ((n & 0xc0) == 0xc0) {
00000a  f00300c0          AND      r0,r3,#0xc0
00000e  28c0              CMP      r0,#0xc0
000010  d100              BNE      |L3.20|
;;;516          /* Compressed name */
;;;517          break;
000012  e010              B        |L3.54|
                  |L3.20|
;;;518        } else {
;;;519          /* Not compressed name */
;;;520          while (n > 0) {
000014  e009              B        |L3.42|
                  |L3.22|
;;;521            if ((*query) != (*response)) {
000016  7810              LDRB     r0,[r2,#0]
000018  780c              LDRB     r4,[r1,#0]
00001a  42a0              CMP      r0,r4
00001c  d001              BEQ      |L3.34|
;;;522              return 1;
00001e  2001              MOVS     r0,#1
                  |L3.32|
;;;523            }
;;;524            ++response;
;;;525            ++query;
;;;526            --n;
;;;527          };
;;;528          ++query;
;;;529        }
;;;530      } while (*response != 0);
;;;531    
;;;532      return 0;
;;;533    }
000020  bd10              POP      {r4,pc}
                  |L3.34|
000022  1c49              ADDS     r1,r1,#1              ;524
000024  1c52              ADDS     r2,r2,#1              ;525
000026  1e58              SUBS     r0,r3,#1              ;526
000028  b2c3              UXTB     r3,r0                 ;526
                  |L3.42|
00002a  2b00              CMP      r3,#0                 ;520
00002c  dcf3              BGT      |L3.22|
00002e  1c52              ADDS     r2,r2,#1              ;528
000030  7808              LDRB     r0,[r1,#0]            ;530
000032  2800              CMP      r0,#0                 ;530
000034  d1e7              BNE      |L3.6|
                  |L3.54|
000036  bf00              NOP                            ;517
000038  2000              MOVS     r0,#0                 ;532
00003a  e7f1              B        |L3.32|
;;;534    #endif /* DNS_DOES_NAME_CHECK */
                          ENDP


                          AREA ||i.dns_enqueue||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dns_enqueue PROC
;;;885    static err_t
;;;886    dns_enqueue(const char *name, dns_found_callback found, void *callback_arg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;887    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;888      u8_t i;
;;;889      u8_t lseq, lseqi;
;;;890      struct dns_table_entry *pEntry = NULL;
00000a  2400              MOVS     r4,#0
;;;891    
;;;892      /* search an unused entry, or the oldest one */
;;;893      lseq = lseqi = 0;
00000c  2000              MOVS     r0,#0
00000e  4606              MOV      r6,r0
000010  4682              MOV      r10,r0
;;;894      for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000012  2500              MOVS     r5,#0
000014  e01b              B        |L4.78|
                  |L4.22|
;;;895        pEntry = &dns_table[i];
000016  ebc500c5          RSB      r0,r5,r5,LSL #3
00001a  eb000080          ADD      r0,r0,r0,LSL #2
00001e  492f              LDR      r1,|L4.220|
000020  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;896        /* is it an unused entry ? */
;;;897        if (pEntry->state == DNS_STATE_UNUSED)
000024  7820              LDRB     r0,[r4,#0]
000026  b900              CBNZ     r0,|L4.42|
;;;898          break;
000028  e013              B        |L4.82|
                  |L4.42|
;;;899    
;;;900        /* check if this is the oldest completed entry */
;;;901        if (pEntry->state == DNS_STATE_DONE) {
00002a  7820              LDRB     r0,[r4,#0]
00002c  2803              CMP      r0,#3
00002e  d10c              BNE      |L4.74|
;;;902          if ((dns_seqno - pEntry->seqno) > lseq) {
000030  7920              LDRB     r0,[r4,#4]
000032  492b              LDR      r1,|L4.224|
000034  7809              LDRB     r1,[r1,#0]  ; dns_seqno
000036  1a08              SUBS     r0,r1,r0
000038  4550              CMP      r0,r10
00003a  dd06              BLE      |L4.74|
;;;903            lseq = dns_seqno - pEntry->seqno;
00003c  7920              LDRB     r0,[r4,#4]
00003e  4928              LDR      r1,|L4.224|
000040  7809              LDRB     r1,[r1,#0]  ; dns_seqno
000042  1a08              SUBS     r0,r1,r0
000044  f0000aff          AND      r10,r0,#0xff
;;;904            lseqi = i;
000048  462e              MOV      r6,r5
                  |L4.74|
00004a  1c68              ADDS     r0,r5,#1              ;894
00004c  b2c5              UXTB     r5,r0                 ;894
                  |L4.78|
00004e  2d04              CMP      r5,#4                 ;894
000050  dbe1              BLT      |L4.22|
                  |L4.82|
000052  bf00              NOP                            ;898
;;;905          }
;;;906        }
;;;907      }
;;;908    
;;;909      /* if we don't have found an unused entry, use the oldest completed one */
;;;910      if (i == DNS_TABLE_SIZE) {
000054  2d04              CMP      r5,#4
000056  d11e              BNE      |L4.150|
;;;911        if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
000058  2e04              CMP      r6,#4
00005a  da08              BGE      |L4.110|
00005c  ebc600c6          RSB      r0,r6,r6,LSL #3
000060  eb000080          ADD      r0,r0,r0,LSL #2
000064  491d              LDR      r1,|L4.220|
000066  f8110030          LDRB     r0,[r1,r0,LSL #3]
00006a  2803              CMP      r0,#3
00006c  d00b              BEQ      |L4.134|
                  |L4.110|
;;;912          /* no entry can't be used now, table is full */
;;;913          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
00006e  bf00              NOP      
000070  bf00              NOP      
000072  4639              MOV      r1,r7
000074  a01b              ADR      r0,|L4.228|
000076  f7fffffe          BL       __2printf
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;914          return ERR_MEM;
00007e  f04f30ff          MOV      r0,#0xffffffff
                  |L4.130|
;;;915        } else {
;;;916          /* use the oldest completed one */
;;;917          i = lseqi;
;;;918          pEntry = &dns_table[i];
;;;919        }
;;;920      }
;;;921    
;;;922      /* use this entry */
;;;923      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));
;;;924    
;;;925      /* fill the entry */
;;;926      pEntry->state = DNS_STATE_NEW;
;;;927      pEntry->seqno = dns_seqno++;
;;;928      pEntry->found = found;
;;;929      pEntry->arg   = callback_arg;
;;;930      strcpy(pEntry->name, name);
;;;931    
;;;932      /* force to send query without waiting timer */
;;;933      dns_check_entry(i);
;;;934    
;;;935      /* dns query is enqueued */
;;;936      return ERR_INPROGRESS;
;;;937    }
000082  e8bd87f0          POP      {r4-r10,pc}
                  |L4.134|
000086  4635              MOV      r5,r6                 ;917
000088  ebc500c5          RSB      r0,r5,r5,LSL #3       ;918
00008c  eb000080          ADD      r0,r0,r0,LSL #2       ;918
000090  4912              LDR      r1,|L4.220|
000092  eb0104c0          ADD      r4,r1,r0,LSL #3       ;918
                  |L4.150|
000096  bf00              NOP                            ;923
000098  bf00              NOP                            ;923
00009a  462a              MOV      r2,r5                 ;923
00009c  4639              MOV      r1,r7                 ;923
00009e  a01d              ADR      r0,|L4.276|
0000a0  f7fffffe          BL       __2printf
0000a4  bf00              NOP                            ;923
0000a6  bf00              NOP                            ;923
0000a8  2001              MOVS     r0,#1                 ;926
0000aa  7020              STRB     r0,[r4,#0]            ;926
0000ac  480c              LDR      r0,|L4.224|
0000ae  7800              LDRB     r0,[r0,#0]            ;927  ; dns_seqno
0000b0  7120              STRB     r0,[r4,#4]            ;927
0000b2  480b              LDR      r0,|L4.224|
0000b4  7800              LDRB     r0,[r0,#0]            ;927  ; dns_seqno
0000b6  1c40              ADDS     r0,r0,#1              ;927
0000b8  4909              LDR      r1,|L4.224|
0000ba  7008              STRB     r0,[r1,#0]            ;927
0000bc  f8c48110          STR      r8,[r4,#0x110]        ;928
0000c0  f8c49114          STR      r9,[r4,#0x114]        ;929
0000c4  4639              MOV      r1,r7                 ;930
0000c6  f104000c          ADD      r0,r4,#0xc            ;930
0000ca  f7fffffe          BL       strcpy
0000ce  4628              MOV      r0,r5                 ;933
0000d0  f7fffffe          BL       dns_check_entry
0000d4  f06f000d          MVN      r0,#0xd               ;936
0000d8  e7d3              B        |L4.130|
;;;938    
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
                          DCD      dns_table
                  |L4.224|
                          DCD      dns_seqno
                  |L4.228|
0000e4  646e735f          DCB      "dns_enqueue: ""%s"": DNS entries table is full\n",0
0000e8  656e7175
0000ec  6575653a
0000f0  20222573
0000f4  223a2044
0000f8  4e532065
0000fc  6e747269
000100  65732074
000104  61626c65
000108  20697320
00010c  66756c6c
000110  0a00    
000112  00                DCB      0
000113  00                DCB      0
                  |L4.276|
000114  646e735f          DCB      "dns_enqueue: ""%s"": use DNS entry %4d\n",0
000118  656e7175
00011c  6575653a
000120  20222573
000124  223a2075
000128  73652044
00012c  4e532065
000130  6e747279
000134  20253464
000138  0a00    
00013a  00                DCB      0
00013b  00                DCB      0

                          AREA ||i.dns_gethostbyname||, CODE, READONLY, ALIGN=2

                  dns_gethostbyname PROC
;;;957    err_t
;;;958    dns_gethostbyname(const char *hostname, struct ip_addr *addr, dns_found_callback found,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;959                      void *callback_arg)
;;;960    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;961      /* not initialized or no valid server yet, or invalid addr pointer
;;;962       * or invalid hostname or invalid hostname length */
;;;963      if ((dns_pcb == NULL) || (addr == NULL) ||
00000c  480a              LDR      r0,|L5.56|
00000e  6800              LDR      r0,[r0,#0]  ; dns_pcb
000010  b140              CBZ      r0,|L5.36|
000012  b13d              CBZ      r5,|L5.36|
;;;964          (!hostname) || (!hostname[0]) ||
000014  b134              CBZ      r4,|L5.36|
000016  7820              LDRB     r0,[r4,#0]
000018  b120              CBZ      r0,|L5.36|
;;;965          (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       strlen
000020  28ff              CMP      r0,#0xff
000022  d903              BLS      |L5.44|
                  |L5.36|
;;;966        return ERR_VAL;
000024  f06f0008          MVN      r0,#8
                  |L5.40|
;;;967      }
;;;968    
;;;969    #if LWIP_HAVE_LOOPIF
;;;970      if (strcmp(hostname,"localhost")==0) {
;;;971        addr->addr = INADDR_LOOPBACK;
;;;972        return ERR_OK;
;;;973      }
;;;974    #endif /* LWIP_HAVE_LOOPIF */
;;;975    #if 0//修改必须去实时查询
;;;976      /* host name already in octet notation? set ip addr and return ERR_OK
;;;977       * already have this address cached? */
;;;978      if (((addr->addr = inet_addr(hostname)) != INADDR_NONE) ||
;;;979          ((addr->addr = dns_lookup(hostname)) != INADDR_NONE)) {
;;;980        return ERR_OK;
;;;981      }
;;;982    #endif
;;;983      /* queue query with specified callback */
;;;984      return dns_enqueue(hostname, found, callback_arg);
;;;985    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L5.44|
00002c  463a              MOV      r2,r7                 ;984
00002e  4631              MOV      r1,r6                 ;984
000030  4620              MOV      r0,r4                 ;984
000032  f7fffffe          BL       dns_enqueue
000036  e7f7              B        |L5.40|
;;;986    
                          ENDP

                  |L5.56|
                          DCD      dns_pcb

                          AREA ||i.dns_getserver||, CODE, READONLY, ALIGN=2

                  dns_getserver PROC
;;;313    struct ip_addr
;;;314    dns_getserver(u8_t numdns)
000000  b50c              PUSH     {r2,r3,lr}
;;;315    {
000002  4601              MOV      r1,r0
;;;316      if (numdns < DNS_MAX_SERVERS) {
000004  2902              CMP      r1,#2
000006  da05              BGE      |L6.20|
;;;317        return dns_servers[numdns];
000008  4804              LDR      r0,|L6.28|
00000a  eb000081          ADD      r0,r0,r1,LSL #2
00000e  6800              LDR      r0,[r0,#0]
000010  9001              STR      r0,[sp,#4]
                  |L6.18|
;;;318      } else {
;;;319        return *IP_ADDR_ANY;
;;;320      }
;;;321    }
000012  bd0c              POP      {r2,r3,pc}
                  |L6.20|
000014  4802              LDR      r0,|L6.32|
000016  6800              LDR      r0,[r0,#0]            ;319  ; ip_addr_any
000018  9000              STR      r0,[sp,#0]            ;319
00001a  e7fa              B        |L6.18|
;;;322    
                          ENDP

                  |L6.28|
                          DCD      dns_servers
                  |L6.32|
                          DCD      ip_addr_any

                          AREA ||i.dns_init||, CODE, READONLY, ALIGN=2

                  dns_init PROC
;;;256    void
;;;257    dns_init()
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259    //  struct ip_addr dnsserver;
;;;260      
;;;261      /* initialize default DNS server address */
;;;262     // dnsserver.addr = DNS_SERVER_ADDRESS;
;;;263    /*  IP4_ADDR(&dnsserver,wireless_dns[0], wireless_dns[1],
;;;264        wireless_dns[2], wireless_dns[3]);*/
;;;265    
;;;266      LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));
000002  bf00              NOP      
000004  bf00              NOP      
000006  a00e              ADR      r0,|L7.64|
000008  f7fffffe          BL       __2printf
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;267    
;;;268      /* if dns client not yet initialized... */
;;;269      if (dns_pcb == NULL) {
000010  4811              LDR      r0,|L7.88|
000012  6800              LDR      r0,[r0,#0]  ; dns_pcb
000014  b990              CBNZ     r0,|L7.60|
;;;270        dns_pcb = udp_new();
000016  f7fffffe          BL       udp_new
00001a  490f              LDR      r1,|L7.88|
00001c  6008              STR      r0,[r1,#0]  ; dns_pcb
;;;271    
;;;272        if (dns_pcb != NULL) {
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]  ; dns_pcb
000022  b158              CBZ      r0,|L7.60|
;;;273          /* initialize DNS table not needed (initialized to zero since it is a
;;;274           * global variable) */
;;;275          LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
;;;276            DNS_STATE_UNUSED == 0);
;;;277    
;;;278          /* initialize DNS client */
;;;279          udp_bind(dns_pcb, IP_ADDR_ANY, 0);
000024  2200              MOVS     r2,#0
000026  490d              LDR      r1,|L7.92|
000028  480b              LDR      r0,|L7.88|
00002a  6800              LDR      r0,[r0,#0]  ; dns_pcb
00002c  f7fffffe          BL       udp_bind
;;;280          udp_recv(dns_pcb, dns_recv, NULL);
000030  2200              MOVS     r2,#0
000032  490b              LDR      r1,|L7.96|
000034  4808              LDR      r0,|L7.88|
000036  6800              LDR      r0,[r0,#0]  ; dns_pcb
000038  f7fffffe          BL       udp_recv
                  |L7.60|
;;;281    
;;;282          /* initialize default DNS primary server */
;;;283          //dns_setserver(0, &dnsserver);
;;;284        }
;;;285      }
;;;286    #if DNS_LOCAL_HOSTLIST
;;;287      dns_init_local();
;;;288    #endif
;;;289    }
00003c  bd10              POP      {r4,pc}
;;;290    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
000040  646e735f          DCB      "dns_init: initializing\n",0
000044  696e6974
000048  3a20696e
00004c  69746961
000050  6c697a69
000054  6e670a00
                  |L7.88|
                          DCD      dns_pcb
                  |L7.92|
                          DCD      ip_addr_any
                  |L7.96|
                          DCD      dns_recv

                          AREA ||i.dns_lookup||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  dns_lookup PROC
;;;464    static u32_t
;;;465    dns_lookup(const char *name)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;466    {
000004  4605              MOV      r5,r0
;;;467      u8_t i;
;;;468    #if DNS_LOCAL_HOSTLIST || defined(DNS_LOOKUP_LOCAL_EXTERN)
;;;469      u32_t addr;
;;;470    #endif /* DNS_LOCAL_HOSTLIST || defined(DNS_LOOKUP_LOCAL_EXTERN) */
;;;471    #if DNS_LOCAL_HOSTLIST
;;;472      if ((addr = dns_lookup_local(name)) != INADDR_NONE) {
;;;473        return addr;
;;;474      }
;;;475    #endif /* DNS_LOCAL_HOSTLIST */
;;;476    #ifdef DNS_LOOKUP_LOCAL_EXTERN
;;;477      if((addr = DNS_LOOKUP_LOCAL_EXTERN(name)) != INADDR_NONE) {
;;;478        return addr;
;;;479      }
;;;480    #endif /* DNS_LOOKUP_LOCAL_EXTERN */
;;;481    
;;;482      /* Walk through name list, return entry if found. If not, return NULL. */
;;;483      for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000006  2400              MOVS     r4,#0
000008  e0a3              B        |L8.338|
                  |L8.10|
;;;484        if ((dns_table[i].state == DNS_STATE_DONE) &&
00000a  ebc400c4          RSB      r0,r4,r4,LSL #3
00000e  eb000080          ADD      r0,r0,r0,LSL #2
000012  4953              LDR      r1,|L8.352|
000014  f8110030          LDRB     r0,[r1,r0,LSL #3]
000018  2803              CMP      r0,#3
00001a  d147              BNE      |L8.172|
;;;485            (strcmp(name, dns_table[i].name) == 0)) {
00001c  ebc400c4          RSB      r0,r4,r4,LSL #3
000020  eb000080          ADD      r0,r0,r0,LSL #2
000024  460a              MOV      r2,r1
000026  eb0200c0          ADD      r0,r2,r0,LSL #3
00002a  f100010c          ADD      r1,r0,#0xc
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       strcmp
000034  bbd0              CBNZ     r0,|L8.172|
;;;486          LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
000036  bf00              NOP      
000038  bf00              NOP      
00003a  4629              MOV      r1,r5
00003c  a049              ADR      r0,|L8.356|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP      
000044  bf00              NOP      
;;;487          ip_addr_debug_print(DNS_DEBUG, &(dns_table[i].ipaddr));
000046  bf00              NOP      
000048  bf00              NOP      
00004a  ebc400c4          RSB      r0,r4,r4,LSL #3
00004e  eb000080          ADD      r0,r0,r0,LSL #2
000052  4943              LDR      r1,|L8.352|
000054  eb0100c0          ADD      r0,r1,r0,LSL #3
000058  f5107086          ADDS     r0,r0,#0x10c
00005c  d00c              BEQ      |L8.120|
00005e  ebc401c4          RSB      r1,r4,r4,LSL #3
000062  eb010181          ADD      r1,r1,r1,LSL #2
000066  4a3e              LDR      r2,|L8.352|
000068  eb0201c1          ADD      r1,r2,r1,LSL #3
00006c  f8d1010c          LDR      r0,[r1,#0x10c]
000070  f7fffffe          BL       ntohl
000074  b2c0              UXTB     r0,r0
000076  e000              B        |L8.122|
                  |L8.120|
000078  2000              MOVS     r0,#0
                  |L8.122|
00007a  4606              MOV      r6,r0
00007c  ebc400c4          RSB      r0,r4,r4,LSL #3
000080  eb000080          ADD      r0,r0,r0,LSL #2
000084  4936              LDR      r1,|L8.352|
000086  eb0100c0          ADD      r0,r1,r0,LSL #3
00008a  f5107086          ADDS     r0,r0,#0x10c
00008e  d00e              BEQ      |L8.174|
000090  ebc401c4          RSB      r1,r4,r4,LSL #3
000094  eb010181          ADD      r1,r1,r1,LSL #2
000098  4a31              LDR      r2,|L8.352|
00009a  eb0201c1          ADD      r1,r2,r1,LSL #3
00009e  f8d1010c          LDR      r0,[r1,#0x10c]
0000a2  f7fffffe          BL       ntohl
0000a6  f3c02007          UBFX     r0,r0,#8,#8
0000aa  e001              B        |L8.176|
                  |L8.172|
0000ac  e04f              B        |L8.334|
                  |L8.174|
0000ae  2000              MOVS     r0,#0
                  |L8.176|
0000b0  4607              MOV      r7,r0
0000b2  ebc400c4          RSB      r0,r4,r4,LSL #3
0000b6  eb000080          ADD      r0,r0,r0,LSL #2
0000ba  4929              LDR      r1,|L8.352|
0000bc  eb0100c0          ADD      r0,r1,r0,LSL #3
0000c0  f5107086          ADDS     r0,r0,#0x10c
0000c4  d00d              BEQ      |L8.226|
0000c6  ebc401c4          RSB      r1,r4,r4,LSL #3
0000ca  eb010181          ADD      r1,r1,r1,LSL #2
0000ce  4a24              LDR      r2,|L8.352|
0000d0  eb0201c1          ADD      r1,r2,r1,LSL #3
0000d4  f8d1010c          LDR      r0,[r1,#0x10c]
0000d8  f7fffffe          BL       ntohl
0000dc  f3c04007          UBFX     r0,r0,#16,#8
0000e0  e000              B        |L8.228|
                  |L8.226|
0000e2  2000              MOVS     r0,#0
                  |L8.228|
0000e4  4680              MOV      r8,r0
0000e6  ebc400c4          RSB      r0,r4,r4,LSL #3
0000ea  eb000080          ADD      r0,r0,r0,LSL #2
0000ee  491c              LDR      r1,|L8.352|
0000f0  eb0100c0          ADD      r0,r1,r0,LSL #3
0000f4  f5107086          ADDS     r0,r0,#0x10c
0000f8  d00c              BEQ      |L8.276|
0000fa  ebc401c4          RSB      r1,r4,r4,LSL #3
0000fe  eb010181          ADD      r1,r1,r1,LSL #2
000102  4a17              LDR      r2,|L8.352|
000104  eb0201c1          ADD      r1,r2,r1,LSL #3
000108  f8d1010c          LDR      r0,[r1,#0x10c]
00010c  f7fffffe          BL       ntohl
000110  0e00              LSRS     r0,r0,#24
000112  e000              B        |L8.278|
                  |L8.276|
000114  2000              MOVS     r0,#0
                  |L8.278|
000116  4681              MOV      r9,r0
000118  463b              MOV      r3,r7
00011a  4642              MOV      r2,r8
00011c  4601              MOV      r1,r0
00011e  a018              ADR      r0,|L8.384|
000120  9600              STR      r6,[sp,#0]
000122  f7fffffe          BL       __2printf
000126  bf00              NOP      
000128  bf00              NOP      
;;;488          LWIP_DEBUGF(DNS_DEBUG, ("\n"));
00012a  bf00              NOP      
00012c  bf00              NOP      
00012e  a018              ADR      r0,|L8.400|
000130  f7fffffe          BL       __2printf
000134  bf00              NOP      
000136  bf00              NOP      
;;;489          return dns_table[i].ipaddr.addr;
000138  ebc400c4          RSB      r0,r4,r4,LSL #3
00013c  eb000080          ADD      r0,r0,r0,LSL #2
000140  4907              LDR      r1,|L8.352|
000142  eb0100c0          ADD      r0,r1,r0,LSL #3
000146  f8d0010c          LDR      r0,[r0,#0x10c]
                  |L8.330|
;;;490        }
;;;491      }
;;;492    
;;;493      return INADDR_NONE;
;;;494    }
00014a  e8bd83f8          POP      {r3-r9,pc}
                  |L8.334|
00014e  1c60              ADDS     r0,r4,#1              ;483
000150  b2c4              UXTB     r4,r0                 ;483
                  |L8.338|
000152  2c04              CMP      r4,#4                 ;483
000154  f6ffaf59          BLT      |L8.10|
000158  f04f30ff          MOV      r0,#0xffffffff        ;493
00015c  e7f5              B        |L8.330|
;;;495    
                          ENDP

00015e  0000              DCW      0x0000
                  |L8.352|
                          DCD      dns_table
                  |L8.356|
000164  646e735f          DCB      "dns_lookup: ""%s"": found = ",0
000168  6c6f6f6b
00016c  75703a20
000170  22257322
000174  3a20666f
000178  756e6420
00017c  3d2000  
00017f  00                DCB      0
                  |L8.384|
000180  2534642e          DCB      "%4d.%4d.%4d.%4d",0
000184  2534642e
000188  2534642e
00018c  25346400
                  |L8.400|
000190  0a00              DCB      "\n",0
000192  00                DCB      0
000193  00                DCB      0

                          AREA ||i.dns_parse_name||, CODE, READONLY, ALIGN=1

                  dns_parse_name PROC
;;;542    static unsigned char *
;;;543    dns_parse_name(unsigned char *query)
000000  4601              MOV      r1,r0
;;;544    {
;;;545      unsigned char n;
;;;546    
;;;547      do {
000002  bf00              NOP      
                  |L9.4|
;;;548        n = *query++;
000004  f8112b01          LDRB     r2,[r1],#1
;;;549        /** @see RFC 1035 - 4.1.4. Message compression */
;;;550        if ((n & 0xc0) == 0xc0) {
000008  f00200c0          AND      r0,r2,#0xc0
00000c  28c0              CMP      r0,#0xc0
00000e  d100              BNE      |L9.18|
;;;551          /* Compressed name */
;;;552          break;
000010  e008              B        |L9.36|
                  |L9.18|
;;;553        } else {
;;;554          /* Not compressed name */
;;;555          while (n > 0) {
000012  e002              B        |L9.26|
                  |L9.20|
;;;556            ++query;
000014  1c49              ADDS     r1,r1,#1
;;;557            --n;
000016  1e50              SUBS     r0,r2,#1
000018  b2c2              UXTB     r2,r0
                  |L9.26|
00001a  2a00              CMP      r2,#0                 ;555
00001c  dcfa              BGT      |L9.20|
;;;558          };
;;;559        }
;;;560      } while (*query != 0);
00001e  7808              LDRB     r0,[r1,#0]
000020  2800              CMP      r0,#0
000022  d1ef              BNE      |L9.4|
                  |L9.36|
000024  bf00              NOP                            ;552
;;;561    
;;;562      return query + 1;
000026  1c48              ADDS     r0,r1,#1
;;;563    }
000028  4770              BX       lr
;;;564    
                          ENDP


                          AREA ||i.dns_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dns_recv PROC
;;;738    static void
;;;739    dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;740    {
000004  b087              SUB      sp,sp,#0x1c
000006  4615              MOV      r5,r2
;;;741      u8_t i;
;;;742      char *pHostname;
;;;743      struct dns_hdr *hdr;
;;;744      struct dns_answer ans;
;;;745      struct dns_table_entry *pEntry;
;;;746      u8_t nquestions, nanswers;
;;;747    #if (DNS_USES_STATIC_BUF == 0)
;;;748      u8_t dns_payload[DNS_MSG_SIZE];
;;;749    #endif /* (DNS_USES_STATIC_BUF == 0) */
;;;750    #if (DNS_USES_STATIC_BUF == 2)
;;;751      u8_t* dns_payload;
;;;752    #endif /* (DNS_USES_STATIC_BUF == 2) */
;;;753    
;;;754      LWIP_UNUSED_ARG(arg);
;;;755      LWIP_UNUSED_ARG(pcb);
;;;756      LWIP_UNUSED_ARG(addr);
;;;757      LWIP_UNUSED_ARG(port);
;;;758    
;;;759      /* is the dns message too big ? */
;;;760      if (p->tot_len > DNS_MSG_SIZE) {
000008  8928              LDRH     r0,[r5,#8]
00000a  f5b07f00          CMP      r0,#0x200
00000e  dd07              BLE      |L10.32|
;;;761        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too big\n"));
000010  bf00              NOP      
000012  bf00              NOP      
000014  a08d              ADR      r0,|L10.588|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;762        /* free pbuf and return */
;;;763        goto memerr1;
00001e  e10f              B        |L10.576|
                  |L10.32|
;;;764      }
;;;765    
;;;766      /* is the dns message big enough ? */
;;;767      if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
000020  8928              LDRH     r0,[r5,#8]
000022  281a              CMP      r0,#0x1a
000024  da07              BGE      |L10.54|
;;;768        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
000026  bf00              NOP      
000028  bf00              NOP      
00002a  a08e              ADR      r0,|L10.612|
00002c  f7fffffe          BL       __2printf
000030  bf00              NOP      
000032  bf00              NOP      
;;;769        /* free pbuf and return */
;;;770        goto memerr1;
000034  e104              B        |L10.576|
                  |L10.54|
;;;771      }
;;;772    
;;;773    #if (DNS_USES_STATIC_BUF == 2)
;;;774      dns_payload = mem_malloc(p->tot_len);
;;;775      if (dns_payload == NULL) {
;;;776        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: mem_malloc error\n"));
;;;777        /* free pbuf and return */
;;;778        goto memerr1;
;;;779      }
;;;780    #endif /* (DNS_USES_STATIC_BUF == 2) */
;;;781    
;;;782      /* copy dns payload inside static buffer for processing */ 
;;;783      if (pbuf_copy_partial(p, dns_payload, p->tot_len, 0) == p->tot_len) {
000036  892a              LDRH     r2,[r5,#8]
000038  2300              MOVS     r3,#0
00003a  4991              LDR      r1,|L10.640|
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       pbuf_copy_partial
000042  8929              LDRH     r1,[r5,#8]
000044  4288              CMP      r0,r1
000046  d17d              BNE      |L10.324|
;;;784        /* The ID in the DNS header should be our entry into the name table. */
;;;785        hdr = (struct dns_hdr*)dns_payload;
000048  4e8d              LDR      r6,|L10.640|
;;;786        i = htons(hdr->id);
00004a  8830              LDRH     r0,[r6,#0]
00004c  f7fffffe          BL       htons
000050  f00008ff          AND      r8,r0,#0xff
;;;787        if (i < DNS_TABLE_SIZE) {
000054  f1b80f04          CMP      r8,#4
000058  da74              BGE      |L10.324|
;;;788          pEntry = &dns_table[i];
00005a  ebc800c8          RSB      r0,r8,r8,LSL #3
00005e  eb000080          ADD      r0,r0,r0,LSL #2
000062  4988              LDR      r1,|L10.644|
000064  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;789          if(pEntry->state == DNS_STATE_ASKING) {
000068  7820              LDRB     r0,[r4,#0]
00006a  2802              CMP      r0,#2
00006c  d16a              BNE      |L10.324|
;;;790            /* This entry is now completed. */
;;;791            pEntry->state = DNS_STATE_DONE;
00006e  2003              MOVS     r0,#3
000070  7020              STRB     r0,[r4,#0]
;;;792            pEntry->err   = hdr->flags2 & DNS_FLAG2_ERR_MASK;
000072  78f0              LDRB     r0,[r6,#3]
000074  f000000f          AND      r0,r0,#0xf
000078  7160              STRB     r0,[r4,#5]
;;;793    
;;;794            /* We only care about the question(s) and the answers. The authrr
;;;795               and the extrarr are simply discarded. */
;;;796            nquestions = htons(hdr->numquestions);
00007a  88b0              LDRH     r0,[r6,#4]
00007c  f7fffffe          BL       htons
000080  f0000aff          AND      r10,r0,#0xff
;;;797            nanswers   = htons(hdr->numanswers);
000084  88f0              LDRH     r0,[r6,#6]
000086  f7fffffe          BL       htons
00008a  f00009ff          AND      r9,r0,#0xff
;;;798    
;;;799            /* Check for error. If so, call callback to inform. */
;;;800            if (((hdr->flags1 & DNS_FLAG1_RESPONSE) == 0) || (pEntry->err != 0) || (nquestions != 1)) {
00008e  78b0              LDRB     r0,[r6,#2]
000090  f0100f80          TST      r0,#0x80
000094  d004              BEQ      |L10.160|
000096  7960              LDRB     r0,[r4,#5]
000098  b910              CBNZ     r0,|L10.160|
00009a  f1ba0f01          CMP      r10,#1
00009e  d009              BEQ      |L10.180|
                  |L10.160|
;;;801              LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", pEntry->name));
0000a0  bf00              NOP      
0000a2  bf00              NOP      
0000a4  f104010c          ADD      r1,r4,#0xc
0000a8  a077              ADR      r0,|L10.648|
0000aa  f7fffffe          BL       __2printf
0000ae  bf00              NOP      
0000b0  bf00              NOP      
;;;802              /* call callback to indicate error, clean up memory and return */
;;;803              goto responseerr;
0000b2  e0b4              B        |L10.542|
                  |L10.180|
;;;804            }
;;;805    
;;;806    #if DNS_DOES_NAME_CHECK
;;;807            /* Check if the name in the "question" part match with the name in the entry. */
;;;808            if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
0000b4  4972              LDR      r1,|L10.640|
0000b6  310c              ADDS     r1,r1,#0xc
0000b8  f104000c          ADD      r0,r4,#0xc
0000bc  f7fffffe          BL       dns_compare_name
0000c0  b148              CBZ      r0,|L10.214|
;;;809              LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", pEntry->name));
0000c2  bf00              NOP      
0000c4  bf00              NOP      
0000c6  f104010c          ADD      r1,r4,#0xc
0000ca  a077              ADR      r0,|L10.680|
0000cc  f7fffffe          BL       __2printf
0000d0  bf00              NOP      
0000d2  bf00              NOP      
;;;810              /* call callback to indicate error, clean up memory and return */
;;;811              goto responseerr;
0000d4  e0a3              B        |L10.542|
                  |L10.214|
;;;812            }
;;;813    #endif /* DNS_DOES_NAME_CHECK */
;;;814    
;;;815            /* Skip the name in the "question" part */
;;;816            pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;
0000d6  486a              LDR      r0,|L10.640|
0000d8  300c              ADDS     r0,r0,#0xc
0000da  f7fffffe          BL       dns_parse_name
0000de  1d07              ADDS     r7,r0,#4
;;;817    
;;;818            while(nanswers > 0) {
0000e0  e08e              B        |L10.512|
                  |L10.226|
;;;819              /* skip answer resource record's host name */
;;;820              pHostname = (char *) dns_parse_name((unsigned char *)pHostname);
0000e2  4638              MOV      r0,r7
0000e4  f7fffffe          BL       dns_parse_name
0000e8  4607              MOV      r7,r0
;;;821    
;;;822              /* Check for IP address type and Internet class. Others are discarded. */
;;;823              MEMCPY(&ans, pHostname, SIZEOF_DNS_ANSWER);
0000ea  6838              LDR      r0,[r7,#0]
0000ec  9004              STR      r0,[sp,#0x10]
0000ee  6878              LDR      r0,[r7,#4]
0000f0  9005              STR      r0,[sp,#0x14]
0000f2  8938              LDRH     r0,[r7,#8]
0000f4  f8ad0018          STRH     r0,[sp,#0x18]
;;;824              if((ntohs(ans.type) == DNS_RRTYPE_A) && (ntohs(ans.class) == DNS_RRCLASS_IN) && (ntohs(ans.len) == sizeof(struct ip_addr)) ) {
0000f8  f8bd0010          LDRH     r0,[sp,#0x10]
0000fc  f7fffffe          BL       ntohs
000100  2801              CMP      r0,#1
000102  d172              BNE      |L10.490|
000104  f8bd0012          LDRH     r0,[sp,#0x12]
000108  f7fffffe          BL       ntohs
00010c  2801              CMP      r0,#1
00010e  d16c              BNE      |L10.490|
000110  f8bd0018          LDRH     r0,[sp,#0x18]
000114  f7fffffe          BL       ntohs
000118  2804              CMP      r0,#4
00011a  d166              BNE      |L10.490|
;;;825                /* read the answer resource record's TTL, and maximize it if needed */
;;;826                pEntry->ttl = ntohl(ans.ttl);
00011c  9805              LDR      r0,[sp,#0x14]
00011e  f7fffffe          BL       ntohl
000122  60a0              STR      r0,[r4,#8]
;;;827                if (pEntry->ttl > DNS_MAX_TTL) {
000124  496c              LDR      r1,|L10.728|
000126  68a0              LDR      r0,[r4,#8]
000128  4288              CMP      r0,r1
00012a  d901              BLS      |L10.304|
;;;828                  pEntry->ttl = DNS_MAX_TTL;
00012c  4608              MOV      r0,r1
00012e  60a0              STR      r0,[r4,#8]
                  |L10.304|
;;;829                }
;;;830                /* read the IP address after answer resource record's header */
;;;831                MEMCPY( &(pEntry->ipaddr), (pHostname+SIZEOF_DNS_ANSWER), sizeof(struct ip_addr));
000130  f8d7100a          LDR      r1,[r7,#0xa]
000134  f8c4110c          STR      r1,[r4,#0x10c]
;;;832                LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", pEntry->name));
000138  bf00              NOP      
00013a  bf00              NOP      
00013c  f104010c          ADD      r1,r4,#0xc
000140  a066              ADR      r0,|L10.732|
000142  e000              B        |L10.326|
                  |L10.324|
000144  e06a              B        |L10.540|
                  |L10.326|
000146  f7fffffe          BL       __2printf
00014a  bf00              NOP      
00014c  bf00              NOP      
;;;833                ip_addr_debug_print(DNS_DEBUG, (&(pEntry->ipaddr)));
00014e  bf00              NOP      
000150  bf00              NOP      
000152  f5147086          ADDS     r0,r4,#0x10c
000156  d005              BEQ      |L10.356|
000158  f8d4010c          LDR      r0,[r4,#0x10c]
00015c  f7fffffe          BL       ntohl
000160  b2c0              UXTB     r0,r0
000162  e000              B        |L10.358|
                  |L10.356|
000164  2000              MOVS     r0,#0
                  |L10.358|
000166  4683              MOV      r11,r0
000168  f5147086          ADDS     r0,r4,#0x10c
00016c  d006              BEQ      |L10.380|
00016e  f8d4010c          LDR      r0,[r4,#0x10c]
000172  f7fffffe          BL       ntohl
000176  f3c02007          UBFX     r0,r0,#8,#8
00017a  e000              B        |L10.382|
                  |L10.380|
00017c  2000              MOVS     r0,#0
                  |L10.382|
00017e  9003              STR      r0,[sp,#0xc]
000180  f5147086          ADDS     r0,r4,#0x10c
000184  d006              BEQ      |L10.404|
000186  f8d4010c          LDR      r0,[r4,#0x10c]
00018a  f7fffffe          BL       ntohl
00018e  f3c04007          UBFX     r0,r0,#16,#8
000192  e000              B        |L10.406|
                  |L10.404|
000194  2000              MOVS     r0,#0
                  |L10.406|
000196  9002              STR      r0,[sp,#8]
000198  f5147086          ADDS     r0,r4,#0x10c
00019c  d005              BEQ      |L10.426|
00019e  f8d4010c          LDR      r0,[r4,#0x10c]
0001a2  f7fffffe          BL       ntohl
0001a6  0e00              LSRS     r0,r0,#24
0001a8  e000              B        |L10.428|
                  |L10.426|
0001aa  2000              MOVS     r0,#0
                  |L10.428|
0001ac  e9cdb000          STRD     r11,r0,[sp,#0]
0001b0  4601              MOV      r1,r0
0001b2  a051              ADR      r0,|L10.760|
0001b4  e9dd2302          LDRD     r2,r3,[sp,#8]
0001b8  f7fffffe          BL       __2printf
0001bc  bf00              NOP      
0001be  bf00              NOP      
;;;834                LWIP_DEBUGF(DNS_DEBUG, ("\n"));
0001c0  bf00              NOP      
0001c2  bf00              NOP      
0001c4  a02d              ADR      r0,|L10.636|
0001c6  f7fffffe          BL       __2printf
0001ca  bf00              NOP      
0001cc  bf00              NOP      
;;;835                /* call specified callback function if provided */
;;;836                if (pEntry->found) {
0001ce  f8d40110          LDR      r0,[r4,#0x110]
0001d2  b140              CBZ      r0,|L10.486|
;;;837                  (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
0001d4  f5047186          ADD      r1,r4,#0x10c
0001d8  f104000c          ADD      r0,r4,#0xc
0001dc  f8d43110          LDR      r3,[r4,#0x110]
0001e0  f8d42114          LDR      r2,[r4,#0x114]
0001e4  4798              BLX      r3
                  |L10.486|
;;;838                }
;;;839                /* deallocate memory and return */
;;;840                goto memerr2;
0001e6  e02a              B        |L10.574|
0001e8  e7ff              B        |L10.490|
                  |L10.490|
;;;841              } else {
;;;842                pHostname = pHostname + SIZEOF_DNS_ANSWER + htons(ans.len);
0001ea  f8bd0018          LDRH     r0,[sp,#0x18]
0001ee  f7fffffe          BL       htons
0001f2  f107010a          ADD      r1,r7,#0xa
0001f6  1847              ADDS     r7,r0,r1
;;;843              }
;;;844              --nanswers;
0001f8  f1a90001          SUB      r0,r9,#1
0001fc  f00009ff          AND      r9,r0,#0xff
                  |L10.512|
000200  f1b90f00          CMP      r9,#0                 ;818
000204  f73faf6d          BGT      |L10.226|
;;;845            }
;;;846            LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", pEntry->name));
000208  bf00              NOP      
00020a  bf00              NOP      
00020c  f104010c          ADD      r1,r4,#0xc
000210  a03d              ADR      r0,|L10.776|
000212  f7fffffe          BL       __2printf
000216  bf00              NOP      
000218  bf00              NOP      
;;;847            /* call callback to indicate error, clean up memory and return */
;;;848            goto responseerr;
00021a  e000              B        |L10.542|
                  |L10.540|
;;;849          }
;;;850        }
;;;851      }
;;;852    
;;;853      /* deallocate memory and return */
;;;854      goto memerr2;
00021c  e00f              B        |L10.574|
                  |L10.542|
;;;855    
;;;856    responseerr:
;;;857      /* ERROR: call specified callback function with NULL as name to indicate an error */
;;;858      if (pEntry->found) {
00021e  f8d40110          LDR      r0,[r4,#0x110]
000222  b138              CBZ      r0,|L10.564|
;;;859        (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
000224  2100              MOVS     r1,#0
000226  f104000c          ADD      r0,r4,#0xc
00022a  f8d43110          LDR      r3,[r4,#0x110]
00022e  f8d42114          LDR      r2,[r4,#0x114]
000232  4798              BLX      r3
                  |L10.564|
;;;860      }
;;;861      /* flush this entry */
;;;862      pEntry->state = DNS_STATE_UNUSED;
000234  2000              MOVS     r0,#0
000236  7020              STRB     r0,[r4,#0]
;;;863      pEntry->found = NULL;
000238  f8c40110          STR      r0,[r4,#0x110]
;;;864    
;;;865    memerr2:
00023c  bf00              NOP      
                  |L10.574|
;;;866    #if (DNS_USES_STATIC_BUF == 2)
;;;867      /* free dns buffer */
;;;868      mem_free(dns_payload);
;;;869    #endif /* (DNS_USES_STATIC_BUF == 2) */
;;;870    
;;;871    memerr1:
00023e  bf00              NOP      
                  |L10.576|
;;;872      /* free pbuf */
;;;873      pbuf_free(p);
000240  4628              MOV      r0,r5
000242  f7fffffe          BL       pbuf_free
;;;874      return;
;;;875    }
000246  b007              ADD      sp,sp,#0x1c
000248  e8bd8ff0          POP      {r4-r11,pc}
;;;876    
                          ENDP

                  |L10.588|
00024c  646e735f          DCB      "dns_recv: pbuf too big\n",0
000250  72656376
000254  3a207062
000258  75662074
00025c  6f6f2062
000260  69670a00
                  |L10.612|
000264  646e735f          DCB      "dns_recv: pbuf too small"
000268  72656376
00026c  3a207062
000270  75662074
000274  6f6f2073
000278  6d616c6c
                  |L10.636|
00027c  0a00              DCB      "\n",0
00027e  00                DCB      0
00027f  00                DCB      0
                  |L10.640|
                          DCD      dns_payload
                  |L10.644|
                          DCD      dns_table
                  |L10.648|
000288  646e735f          DCB      "dns_recv: ""%s"": error in flags\n",0
00028c  72656376
000290  3a202225
000294  73223a20
000298  6572726f
00029c  7220696e
0002a0  20666c61
0002a4  67730a00
                  |L10.680|
0002a8  646e735f          DCB      "dns_recv: ""%s"": response not match to query\n",0
0002ac  72656376
0002b0  3a202225
0002b4  73223a20
0002b8  72657370
0002bc  6f6e7365
0002c0  206e6f74
0002c4  206d6174
0002c8  63682074
0002cc  6f207175
0002d0  6572790a
0002d4  00      
0002d5  00                DCB      0
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L10.728|
                          DCD      0x00093a80
                  |L10.732|
0002dc  646e735f          DCB      "dns_recv: ""%s"": response = ",0
0002e0  72656376
0002e4  3a202225
0002e8  73223a20
0002ec  72657370
0002f0  6f6e7365
0002f4  203d2000
                  |L10.760|
0002f8  2534642e          DCB      "%4d.%4d.%4d.%4d",0
0002fc  2534642e
000300  2534642e
000304  25346400
                  |L10.776|
000308  646e735f          DCB      "dns_recv: ""%s"": error in response\n",0
00030c  72656376
000310  3a202225
000314  73223a20
000318  6572726f
00031c  7220696e
000320  20726573
000324  706f6e73
000328  650a00  
00032b  00                DCB      0

                          AREA ||i.dns_send||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dns_send PROC
;;;574    static err_t
;;;575    dns_send(u8_t numdns, const char* name, u8_t id)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;576    {
000004  b082              SUB      sp,sp,#8
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
;;;577      err_t err;
;;;578      struct dns_hdr *hdr;
;;;579      struct dns_query qry;
;;;580      struct pbuf *p;
;;;581      char *query, *nptr;
;;;582      const char *pHostname;
;;;583      u8_t n;
;;;584    
;;;585      LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  464a              MOV      r2,r9
000010  4641              MOV      r1,r8
000012  a036              ADR      r0,|L11.236|
000014  f7fffffe          BL       __2printf
000018  bf00              NOP      
00001a  bf00              NOP      
;;;586                  (u16_t)(numdns), name));
;;;587      LWIP_ASSERT("dns server out of array", numdns < DNS_MAX_SERVERS);
;;;588      LWIP_ASSERT("dns server has no IP address set", dns_servers[numdns].addr != 0);
;;;589    
;;;590      /* if here, we have either a new query or a retry on a previous query to process */
;;;591      p = pbuf_alloc(PBUF_TRANSPORT, SIZEOF_DNS_HDR + DNS_MAX_NAME_LENGTH +
00001c  2200              MOVS     r2,#0
00001e  f44f7188          MOV      r1,#0x110
000022  4610              MOV      r0,r2
000024  f7fffffe          BL       pbuf_alloc
000028  4607              MOV      r7,r0
;;;592                     SIZEOF_DNS_QUERY, PBUF_RAM);
;;;593      if (p != NULL) {
00002a  b3f7              CBZ      r7,|L11.170|
;;;594        LWIP_ASSERT("pbuf must be in one piece", p->next == NULL);
;;;595        /* fill dns header */
;;;596        hdr = (struct dns_hdr*)p->payload;
00002c  687e              LDR      r6,[r7,#4]
;;;597        memset(hdr, 0, SIZEOF_DNS_HDR);
00002e  2000              MOVS     r0,#0
000030  6030              STR      r0,[r6,#0]
000032  6070              STR      r0,[r6,#4]
000034  60b0              STR      r0,[r6,#8]
;;;598        hdr->id = htons(id);
000036  9804              LDR      r0,[sp,#0x10]
000038  f7fffffe          BL       htons
00003c  8030              STRH     r0,[r6,#0]
;;;599        hdr->flags1 = DNS_FLAG1_RD;
00003e  2001              MOVS     r0,#1
000040  70b0              STRB     r0,[r6,#2]
;;;600        hdr->numquestions = htons(1);
000042  f7fffffe          BL       htons
000046  80b0              STRH     r0,[r6,#4]
;;;601        query = (char*)hdr + SIZEOF_DNS_HDR;
000048  f106040c          ADD      r4,r6,#0xc
;;;602        pHostname = name;
00004c  464d              MOV      r5,r9
;;;603        --pHostname;
00004e  1e6d              SUBS     r5,r5,#1
;;;604    
;;;605        /* convert hostname into suitable query format. */
;;;606        do {
000050  bf00              NOP      
                  |L11.82|
;;;607          ++pHostname;
000052  1c6d              ADDS     r5,r5,#1
;;;608          nptr = query;
000054  46a3              MOV      r11,r4
;;;609          ++query;
000056  1c64              ADDS     r4,r4,#1
;;;610          for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
00005c  e007              B        |L11.110|
                  |L11.94|
;;;611            *query = *pHostname;
00005e  7828              LDRB     r0,[r5,#0]
000060  7020              STRB     r0,[r4,#0]
;;;612            ++query;
000062  1c64              ADDS     r4,r4,#1
;;;613            ++n;
000064  9800              LDR      r0,[sp,#0]
000066  1c40              ADDS     r0,r0,#1
000068  b2c0              UXTB     r0,r0
00006a  9000              STR      r0,[sp,#0]
00006c  1c6d              ADDS     r5,r5,#1              ;610
                  |L11.110|
00006e  7828              LDRB     r0,[r5,#0]            ;610
000070  282e              CMP      r0,#0x2e              ;610
000072  d002              BEQ      |L11.122|
000074  7828              LDRB     r0,[r5,#0]            ;610
000076  2800              CMP      r0,#0                 ;610
000078  d1f1              BNE      |L11.94|
                  |L11.122|
;;;614          }
;;;615          *nptr = n;
00007a  9800              LDR      r0,[sp,#0]
00007c  f88b0000          STRB     r0,[r11,#0]
;;;616        } while(*pHostname != 0);
000080  7828              LDRB     r0,[r5,#0]
000082  2800              CMP      r0,#0
000084  d1e5              BNE      |L11.82|
;;;617        *query++='\0';
000086  f8040b01          STRB     r0,[r4],#1
;;;618    
;;;619        /* fill dns query */
;;;620        qry.type  = htons(DNS_RRTYPE_A);
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       htons
000090  f8ad0004          STRH     r0,[sp,#4]
;;;621        qry.class = htons(DNS_RRCLASS_IN);
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       htons
00009a  f8ad0006          STRH     r0,[sp,#6]
;;;622        MEMCPY( query, &qry, SIZEOF_DNS_QUERY);
00009e  9801              LDR      r0,[sp,#4]
0000a0  6020              STR      r0,[r4,#0]
;;;623    
;;;624        /* resize pbuf to the exact dns query */
;;;625        pbuf_realloc(p, (query + SIZEOF_DNS_QUERY) - ((char*)(p->payload)));
0000a2  1d20              ADDS     r0,r4,#4
0000a4  687a              LDR      r2,[r7,#4]
0000a6  1a80              SUBS     r0,r0,r2
0000a8  e000              B        |L11.172|
                  |L11.170|
0000aa  e019              B        |L11.224|
                  |L11.172|
0000ac  b281              UXTH     r1,r0
0000ae  4638              MOV      r0,r7
0000b0  f7fffffe          BL       pbuf_realloc
;;;626    
;;;627        /* connect to the server for faster receiving */
;;;628        udp_connect(dns_pcb, &dns_servers[numdns], DNS_SERVER_PORT);
0000b4  4818              LDR      r0,|L11.280|
0000b6  eb000188          ADD      r1,r0,r8,LSL #2
0000ba  2235              MOVS     r2,#0x35
0000bc  4817              LDR      r0,|L11.284|
0000be  6800              LDR      r0,[r0,#0]  ; dns_pcb
0000c0  f7fffffe          BL       udp_connect
;;;629        /* send dns packet */
;;;630        err = udp_sendto(dns_pcb, p, &dns_servers[numdns], DNS_SERVER_PORT);
0000c4  4814              LDR      r0,|L11.280|
0000c6  eb000288          ADD      r2,r0,r8,LSL #2
0000ca  2335              MOVS     r3,#0x35
0000cc  4639              MOV      r1,r7
0000ce  4813              LDR      r0,|L11.284|
0000d0  6800              LDR      r0,[r0,#0]  ; dns_pcb
0000d2  f7fffffe          BL       udp_sendto
0000d6  4682              MOV      r10,r0
;;;631    
;;;632        /* free pbuf */
;;;633        pbuf_free(p);
0000d8  4638              MOV      r0,r7
0000da  f7fffffe          BL       pbuf_free
0000de  e001              B        |L11.228|
                  |L11.224|
;;;634      } else {
;;;635        err = ERR_MEM;
0000e0  f04f3aff          MOV      r10,#0xffffffff
                  |L11.228|
;;;636      }
;;;637    
;;;638      return err;
0000e4  4650              MOV      r0,r10
;;;639    }
0000e6  b005              ADD      sp,sp,#0x14
0000e8  e8bd8ff0          POP      {r4-r11,pc}
;;;640    
                          ENDP

                  |L11.236|
0000ec  646e735f          DCB      "dns_send: dns_servers[%4d] ""%s"": request\n",0
0000f0  73656e64
0000f4  3a20646e
0000f8  735f7365
0000fc  72766572
000100  735b2534
000104  645d2022
000108  2573223a
00010c  20726571
000110  75657374
000114  0a00    
000116  00                DCB      0
000117  00                DCB      0
                  |L11.280|
                          DCD      dns_servers
                  |L11.284|
                          DCD      dns_pcb

                          AREA ||i.dns_setserver||, CODE, READONLY, ALIGN=2

                  dns_setserver PROC
;;;297    void
;;;298    dns_setserver(u8_t numdns, struct ip_addr *dnsserver)
000000  2802              CMP      r0,#2
;;;299    {
;;;300      if ((numdns < DNS_MAX_SERVERS) && (dns_pcb != NULL) &&
000002  da0a              BGE      |L12.26|
000004  4a05              LDR      r2,|L12.28|
000006  6812              LDR      r2,[r2,#0]  ; dns_pcb
000008  b13a              CBZ      r2,|L12.26|
;;;301          (dnsserver != NULL) && (dnsserver->addr !=0 )) {
00000a  b131              CBZ      r1,|L12.26|
00000c  680a              LDR      r2,[r1,#0]
00000e  b122              CBZ      r2,|L12.26|
;;;302        dns_servers[numdns] = (*dnsserver);
000010  4a03              LDR      r2,|L12.32|
000012  eb020280          ADD      r2,r2,r0,LSL #2
000016  680b              LDR      r3,[r1,#0]
000018  6013              STR      r3,[r2,#0]
                  |L12.26|
;;;303      }
;;;304    }
00001a  4770              BX       lr
;;;305    
                          ENDP

                  |L12.28|
                          DCD      dns_pcb
                  |L12.32|
                          DCD      dns_servers

                          AREA ||i.dns_tmr||, CODE, READONLY, ALIGN=2

                  dns_tmr PROC
;;;327    void
;;;328    dns_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;329    {
;;;330      if (dns_pcb != NULL) {
000002  4806              LDR      r0,|L13.28|
000004  6800              LDR      r0,[r0,#0]  ; dns_pcb
000006  b140              CBZ      r0,|L13.26|
;;;331        LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  a004              ADR      r0,|L13.32|
00000e  f7fffffe          BL       __2printf
000012  bf00              NOP      
000014  bf00              NOP      
;;;332        dns_check_entries();
000016  f7fffffe          BL       dns_check_entries
                  |L13.26|
;;;333      }
;;;334    }
00001a  bd10              POP      {r4,pc}
;;;335    
                          ENDP

                  |L13.28|
                          DCD      dns_pcb
                  |L13.32|
000020  646e735f          DCB      "dns_tmr: dns_check_entries\n",0
000024  746d723a
000028  20646e73
00002c  5f636865
000030  636b5f65
000034  6e747269
000038  65730a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dns_table
                          %        1120
                  dns_payload
                          %        512

                          AREA ||.data||, DATA, ALIGN=2

                  dns_pcb
                          DCD      0x00000000
                  dns_seqno
000004  00                DCB      0x00
                  dns_servers
000005  000000            DCB      0x00,0x00,0x00
                          DCD      0x00000000
00000c  00                DCB      0x00
