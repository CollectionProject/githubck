; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\ms_funcs.o --depend=.\obj\ms_funcs.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\ms_funcs.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto\ms_funcs.c]
                          THUMB

                          AREA ||i.challenge_hash||, CODE, READONLY, ALIGN=1

                  challenge_hash PROC
;;;31      */
;;;32     static int challenge_hash(const u8 *peer_challenge, const u8 *auth_challenge,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;33     			  const u8 *username, size_t username_len,
;;;34     			  u8 *challenge)
;;;35     {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  f8dd8048          LDR      r8,[sp,#0x48]
;;;36     	u8 hash[SHA1_MAC_LEN];
;;;37     	const unsigned char *addr[3];
;;;38     	size_t len[3];
;;;39     
;;;40     	addr[0] = peer_challenge;
000012  9404              STR      r4,[sp,#0x10]
;;;41     	len[0] = 16;
000014  2010              MOVS     r0,#0x10
000016  9001              STR      r0,[sp,#4]
;;;42     	addr[1] = auth_challenge;
000018  9505              STR      r5,[sp,#0x14]
;;;43     	len[1] = 16;
00001a  9002              STR      r0,[sp,#8]
;;;44     	addr[2] = username;
00001c  9606              STR      r6,[sp,#0x18]
;;;45     	len[2] = username_len;
00001e  9703              STR      r7,[sp,#0xc]
;;;46     
;;;47     	if (sha1_vector(3, addr, len, hash))
000020  ab07              ADD      r3,sp,#0x1c
000022  aa01              ADD      r2,sp,#4
000024  a904              ADD      r1,sp,#0x10
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       sha1_vector
00002c  b120              CBZ      r0,|L1.56|
;;;48     		return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.50|
;;;49     	os_memcpy(challenge, hash, 8);
;;;50     	return 0;
;;;51     }
000032  b00c              ADD      sp,sp,#0x30
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L1.56|
000038  9807              LDR      r0,[sp,#0x1c]         ;49
00003a  f8c80000          STR      r0,[r8,#0]            ;49
00003e  9808              LDR      r0,[sp,#0x20]         ;49
000040  f8c80004          STR      r0,[r8,#4]            ;49
000044  2000              MOVS     r0,#0                 ;50
000046  e7f4              B        |L1.50|
;;;52     
                          ENDP


                          AREA ||i.challenge_response||, CODE, READONLY, ALIGN=1

                  challenge_response PROC
;;;100     */
;;;101    void challenge_response(const u8 *challenge, const u8 *password_hash,
000000  b57c              PUSH     {r2-r6,lr}
;;;102    			u8 *response)
;;;103    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;104    	u8 zpwd[7];
;;;105    	des_encrypt(challenge, password_hash, response);
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       des_encrypt
;;;106    	des_encrypt(challenge, password_hash + 7, response + 8);
000012  f1050208          ADD      r2,r5,#8
000016  1de1              ADDS     r1,r4,#7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       des_encrypt
;;;107    	zpwd[0] = password_hash[14];
00001e  7ba0              LDRB     r0,[r4,#0xe]
000020  f88d0000          STRB     r0,[sp,#0]
;;;108    	zpwd[1] = password_hash[15];
000024  7be0              LDRB     r0,[r4,#0xf]
000026  f88d0001          STRB     r0,[sp,#1]
;;;109    	os_memset(zpwd + 2, 0, 5);
00002a  2000              MOVS     r0,#0
00002c  f8cd0002          STR      r0,[sp,#2]
000030  f88d0006          STRB     r0,[sp,#6]
;;;110    	des_encrypt(challenge, zpwd, response + 16);
000034  f1050210          ADD      r2,r5,#0x10
000038  4669              MOV      r1,sp
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       des_encrypt
;;;111    }
000040  bd7c              POP      {r2-r6,pc}
;;;112    
                          ENDP


                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.encrypt_pw_block_with_password_hash||, CODE, READONLY, ALIGN=1

                  encrypt_pw_block_with_password_hash PROC
;;;383     */
;;;384    int encrypt_pw_block_with_password_hash(
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;385    	const u8 *password, size_t password_len,
;;;386    	const u8 *password_hash, u8 *pw_block)
;;;387    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;388    	size_t i, offset;
;;;389    	u8 *pos;
;;;390    
;;;391    	if (password_len > 256)
00000c  f5b47f80          CMP      r4,#0x100
000010  d903              BLS      |L4.26|
;;;392    		return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L4.22|
;;;393    
;;;394    	os_memset(pw_block, 0, PWBLOCK_LEN);
;;;395    	offset = (256 - password_len) * 2;
;;;396    	if (os_get_random(pw_block, offset) < 0)
;;;397    		return -1;
;;;398    	for (i = 0; i < password_len; i++)
;;;399    		pw_block[offset + i * 2] = password[i];
;;;400    	/*
;;;401    	 * PasswordLength is 4 octets, but since the maximum password length is
;;;402    	 * 256, only first two (in little endian byte order) can be non-zero.
;;;403    	 */
;;;404    	pos = &pw_block[2 * 256];
;;;405    	WPA_PUT_LE16(pos, password_len * 2);
;;;406    	rc4_skip(password_hash, 16, 0, pw_block, PWBLOCK_LEN);
;;;407    	return 0;
;;;408    }
000016  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.26|
00001a  f44f7101          MOV      r1,#0x204             ;394
00001e  4630              MOV      r0,r6                 ;394
000020  f7fffffe          BL       __aeabi_memclr
000024  f5c47080          RSB      r0,r4,#0x100          ;395
000028  0047              LSLS     r7,r0,#1              ;395
00002a  4639              MOV      r1,r7                 ;396
00002c  4630              MOV      r0,r6                 ;396
00002e  f7fffffe          BL       os_get_random
000032  2800              CMP      r0,#0                 ;396
000034  da02              BGE      |L4.60|
000036  f04f30ff          MOV      r0,#0xffffffff        ;397
00003a  e7ec              B        |L4.22|
                  |L4.60|
00003c  2500              MOVS     r5,#0                 ;398
00003e  e005              B        |L4.76|
                  |L4.64|
000040  f8190005          LDRB     r0,[r9,r5]            ;399
000044  eb070145          ADD      r1,r7,r5,LSL #1       ;399
000048  5470              STRB     r0,[r6,r1]            ;399
00004a  1c6d              ADDS     r5,r5,#1              ;398
                  |L4.76|
00004c  42a5              CMP      r5,r4                 ;398
00004e  d3f7              BCC      |L4.64|
000050  f5067800          ADD      r8,r6,#0x200          ;404
000054  bf00              NOP                            ;405
000056  f3c410c7          UBFX     r0,r4,#7,#8           ;405
00005a  f8880001          STRB     r0,[r8,#1]            ;405
00005e  0660              LSLS     r0,r4,#25             ;405
000060  0e00              LSRS     r0,r0,#24             ;405
000062  f8880000          STRB     r0,[r8,#0]            ;405
000066  bf00              NOP                            ;405
000068  f44f7301          MOV      r3,#0x204             ;406
00006c  9300              STR      r3,[sp,#0]            ;406
00006e  4633              MOV      r3,r6                 ;406
000070  2200              MOVS     r2,#0                 ;406
000072  2110              MOVS     r1,#0x10              ;406
000074  4650              MOV      r0,r10                ;406
000076  f7fffffe          BL       rc4_skip
00007a  2000              MOVS     r0,#0                 ;407
00007c  e7cb              B        |L4.22|
;;;409    
                          ENDP


                          AREA ||i.generate_authenticator_response||, CODE, READONLY, ALIGN=1

                  generate_authenticator_response PROC
;;;238     */
;;;239    int generate_authenticator_response(const u8 *password, size_t password_len,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;240    				    const u8 *peer_challenge,
;;;241    				    const u8 *auth_challenge,
;;;242    				    const u8 *username, size_t username_len,
;;;243    				    const u8 *nt_response, u8 *response)
;;;244    {
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
00000e  e9ddab12          LDRD     r10,r11,[sp,#0x48]
000012  e9dd8910          LDRD     r8,r9,[sp,#0x40]
;;;245    	u8 password_hash[16];
;;;246    	if (nt_password_hash(password, password_len, password_hash))
000016  aa03              ADD      r2,sp,#0xc
000018  4639              MOV      r1,r7
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       nt_password_hash
000020  b120              CBZ      r0,|L5.44|
;;;247    		return -1;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L5.38|
;;;248    	return generate_authenticator_response_pwhash(
;;;249    		password_hash, peer_challenge, auth_challenge,
;;;250    		username, username_len, nt_response, response);
;;;251    }
000026  b007              ADD      sp,sp,#0x1c
000028  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.44|
00002c  4643              MOV      r3,r8                 ;248
00002e  462a              MOV      r2,r5                 ;248
000030  4621              MOV      r1,r4                 ;248
000032  a803              ADD      r0,sp,#0xc            ;248
000034  e88d0e00          STM      sp,{r9-r11}           ;248
000038  f7fffffe          BL       generate_authenticator_response_pwhash
00003c  e7f3              B        |L5.38|
;;;252    
                          ENDP


                          AREA ||i.generate_authenticator_response_pwhash||, CODE, READONLY, ALIGN=2

                  generate_authenticator_response_pwhash PROC
;;;180     */
;;;181    int generate_authenticator_response_pwhash(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;182    	const u8 *password_hash,
;;;183    	const u8 *peer_challenge, const u8 *auth_challenge,
;;;184    	const u8 *username, size_t username_len,
;;;185    	const u8 *nt_response, u8 *response)
;;;186    {
000004  b094              SUB      sp,sp,#0x50
000006  4680              MOV      r8,r0
000008  460c              MOV      r4,r1
00000a  4615              MOV      r5,r2
00000c  461e              MOV      r6,r3
00000e  e9dd9a1c          LDRD     r9,r10,[sp,#0x70]
000012  9f1e              LDR      r7,[sp,#0x78]
;;;187    	static const u8 magic1[39] = {
;;;188    		0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
;;;189    		0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
;;;190    		0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
;;;191    		0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74
;;;192    	};
;;;193    	static const u8 magic2[41] = {
;;;194    		0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
;;;195    		0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
;;;196    		0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
;;;197    		0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
;;;198    		0x6E
;;;199    	};
;;;200    
;;;201    	u8 password_hash_hash[16], challenge[8];
;;;202    	const unsigned char *addr1[3];
;;;203    	const size_t len1[3] = { 16, 24, sizeof(magic1) };
000014  4a1c              LDR      r2,|L6.136|
000016  ca07              LDM      r2,{r0-r2}
000018  e9cd1209          STRD     r1,r2,[sp,#0x24]
00001c  9008              STR      r0,[sp,#0x20]
;;;204    	const unsigned char *addr2[3];
;;;205    	const size_t len2[3] = { SHA1_MAC_LEN, 8, sizeof(magic2) };
00001e  4a1a              LDR      r2,|L6.136|
000020  320c              ADDS     r2,r2,#0xc
000022  ca07              LDM      r2,{r0-r2}
000024  e9cd1203          STRD     r1,r2,[sp,#0xc]
000028  9002              STR      r0,[sp,#8]
;;;206    
;;;207    	addr1[0] = password_hash_hash;
00002a  a810              ADD      r0,sp,#0x40
00002c  900b              STR      r0,[sp,#0x2c]
;;;208    	addr1[1] = nt_response;
00002e  f8cda030          STR      r10,[sp,#0x30]
;;;209    	addr1[2] = magic1;
000032  4816              LDR      r0,|L6.140|
000034  900d              STR      r0,[sp,#0x34]
;;;210    
;;;211    	addr2[0] = response;
000036  9705              STR      r7,[sp,#0x14]
;;;212    	addr2[1] = challenge;
000038  a80e              ADD      r0,sp,#0x38
00003a  9006              STR      r0,[sp,#0x18]
;;;213    	addr2[2] = magic2;
00003c  4814              LDR      r0,|L6.144|
00003e  9007              STR      r0,[sp,#0x1c]
;;;214    
;;;215    	if (hash_nt_password_hash(password_hash, password_hash_hash))
000040  a910              ADD      r1,sp,#0x40
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       hash_nt_password_hash
000048  b120              CBZ      r0,|L6.84|
;;;216    		return -1;
00004a  f04f30ff          MOV      r0,#0xffffffff
                  |L6.78|
;;;217    	if (sha1_vector(3, addr1, len1, response))
;;;218    		return -1;
;;;219    
;;;220    	challenge_hash(peer_challenge, auth_challenge, username, username_len,
;;;221    		       challenge);
;;;222    	return sha1_vector(3, addr2, len2, response);
;;;223    }
00004e  b014              ADD      sp,sp,#0x50
000050  e8bd87f0          POP      {r4-r10,pc}
                  |L6.84|
000054  463b              MOV      r3,r7                 ;217
000056  aa08              ADD      r2,sp,#0x20           ;217
000058  a90b              ADD      r1,sp,#0x2c           ;217
00005a  2003              MOVS     r0,#3                 ;217
00005c  f7fffffe          BL       sha1_vector
000060  b110              CBZ      r0,|L6.104|
000062  f04f30ff          MOV      r0,#0xffffffff        ;218
000066  e7f2              B        |L6.78|
                  |L6.104|
000068  ab0e              ADD      r3,sp,#0x38           ;220
00006a  9300              STR      r3,[sp,#0]            ;220
00006c  464b              MOV      r3,r9                 ;220
00006e  4632              MOV      r2,r6                 ;220
000070  4629              MOV      r1,r5                 ;220
000072  4620              MOV      r0,r4                 ;220
000074  f7fffffe          BL       challenge_hash
000078  463b              MOV      r3,r7                 ;222
00007a  aa02              ADD      r2,sp,#8              ;222
00007c  a905              ADD      r1,sp,#0x14           ;222
00007e  2003              MOVS     r0,#3                 ;222
000080  f7fffffe          BL       sha1_vector
000084  e7e3              B        |L6.78|
;;;224    
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      ||.constdata||+0x50
                  |L6.140|
                          DCD      magic1
                  |L6.144|
                          DCD      magic2

                          AREA ||i.generate_nt_response||, CODE, READONLY, ALIGN=1

                  generate_nt_response PROC
;;;124     */
;;;125    int generate_nt_response(const u8 *auth_challenge, const u8 *peer_challenge,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;126    			 const u8 *username, size_t username_len,
;;;127    			 const u8 *password, size_t password_len,
;;;128    			 u8 *response)
;;;129    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9dd9a11          LDRD     r9,r10,[sp,#0x44]
000012  f8dd8040          LDR      r8,[sp,#0x40]
;;;130    	u8 challenge[8];
;;;131    	u8 password_hash[16];
;;;132    
;;;133    	challenge_hash(peer_challenge, auth_challenge, username, username_len,
000016  ab06              ADD      r3,sp,#0x18
000018  9300              STR      r3,[sp,#0]
00001a  463b              MOV      r3,r7
00001c  4632              MOV      r2,r6
00001e  4621              MOV      r1,r4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       challenge_hash
;;;134    		       challenge);
;;;135    	if (nt_password_hash(password, password_len, password_hash))
000026  aa02              ADD      r2,sp,#8
000028  4649              MOV      r1,r9
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       nt_password_hash
000030  b120              CBZ      r0,|L7.60|
;;;136    		return -1;
000032  f04f30ff          MOV      r0,#0xffffffff
                  |L7.54|
;;;137    	challenge_response(challenge, password_hash, response);
;;;138    	return 0;
;;;139    }
000036  b008              ADD      sp,sp,#0x20
000038  e8bd87f0          POP      {r4-r10,pc}
                  |L7.60|
00003c  4652              MOV      r2,r10                ;137
00003e  a902              ADD      r1,sp,#8              ;137
000040  a806              ADD      r0,sp,#0x18           ;137
000042  f7fffffe          BL       challenge_response
000046  2000              MOVS     r0,#0                 ;138
000048  e7f5              B        |L7.54|
;;;140    
                          ENDP


                          AREA ||i.generate_nt_response_pwhash||, CODE, READONLY, ALIGN=1

                  generate_nt_response_pwhash PROC
;;;151     */
;;;152    int generate_nt_response_pwhash(const u8 *auth_challenge,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;153    				const u8 *peer_challenge,
;;;154    				const u8 *username, size_t username_len,
;;;155    				const u8 *password_hash,
;;;156    				u8 *response)
;;;157    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;158    	u8 challenge[8];
;;;159    
;;;160    	if (challenge_hash(peer_challenge, auth_challenge,
000010  ab01              ADD      r3,sp,#4
000012  9300              STR      r3,[sp,#0]
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       challenge_hash
000020  b118              CBZ      r0,|L8.42|
;;;161    			   username, username_len,
;;;162    			   challenge))
;;;163    		return -1;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L8.38|
;;;164    	challenge_response(challenge, password_hash, response);
;;;165    	return 0;
;;;166    }
000026  e8bd83fe          POP      {r1-r9,pc}
                  |L8.42|
00002a  464a              MOV      r2,r9                 ;164
00002c  4641              MOV      r1,r8                 ;164
00002e  a801              ADD      r0,sp,#4              ;164
000030  f7fffffe          BL       challenge_response
000034  2000              MOVS     r0,#0                 ;165
000036  e7f6              B        |L8.38|
;;;167    
                          ENDP


                          AREA ||i.get_asymetric_start_key||, CODE, READONLY, ALIGN=2

                  get_asymetric_start_key PROC
;;;311     */
;;;312    int get_asymetric_start_key(const u8 *master_key, u8 *session_key,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;313    			    size_t session_key_len, int is_send,
;;;314    			    int is_server)
;;;315    {
000004  b08e              SUB      sp,sp,#0x38
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
00000e  9e14              LDR      r6,[sp,#0x50]
;;;316    	static const u8 magic2[84] = {
;;;317    		0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
;;;318    		0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
;;;319    		0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
;;;320    		0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79,
;;;321    		0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
;;;322    		0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
;;;323    		0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
;;;324    		0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
;;;325    		0x6b, 0x65, 0x79, 0x2e
;;;326    	};
;;;327    	static const u8 magic3[84] = {
;;;328    		0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
;;;329    		0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
;;;330    		0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
;;;331    		0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
;;;332    		0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68,
;;;333    		0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
;;;334    		0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
;;;335    		0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20,
;;;336    		0x6b, 0x65, 0x79, 0x2e
;;;337    	};
;;;338    	static const u8 shs_pad1[40] = {
;;;339    		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;;;340    		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;;;341    		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;;;342    		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
;;;343    	};
;;;344    
;;;345    	static const u8 shs_pad2[40] = {
;;;346    		0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
;;;347    		0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
;;;348    		0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
;;;349    		0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2
;;;350    	};
;;;351    	u8 digest[SHA1_MAC_LEN];
;;;352    	const unsigned char *addr[4];
;;;353    	const size_t len[4] = { 16, 40, 84, 40 };
000010  4b17              LDR      r3,|L9.112|
000012  cb0f              LDM      r3,{r0-r3}
000014  e9cd2303          STRD     r2,r3,[sp,#0xc]
000018  e9cd0101          STRD     r0,r1,[sp,#4]
;;;354    
;;;355    	addr[0] = master_key;
00001c  9405              STR      r4,[sp,#0x14]
;;;356    	addr[1] = shs_pad1;
00001e  4815              LDR      r0,|L9.116|
000020  9006              STR      r0,[sp,#0x18]
;;;357    	if (is_send) {
000022  f1b80f00          CMP      r8,#0
000026  d005              BEQ      |L9.52|
;;;358    		addr[2] = is_server ? magic3 : magic2;
000028  b10e              CBZ      r6,|L9.46|
00002a  4813              LDR      r0,|L9.120|
00002c  e000              B        |L9.48|
                  |L9.46|
00002e  4813              LDR      r0,|L9.124|
                  |L9.48|
000030  9007              STR      r0,[sp,#0x1c]
000032  e004              B        |L9.62|
                  |L9.52|
;;;359    	} else {
;;;360    		addr[2] = is_server ? magic2 : magic3;
000034  b10e              CBZ      r6,|L9.58|
000036  4811              LDR      r0,|L9.124|
000038  e000              B        |L9.60|
                  |L9.58|
00003a  480f              LDR      r0,|L9.120|
                  |L9.60|
00003c  9007              STR      r0,[sp,#0x1c]
                  |L9.62|
;;;361    	}
;;;362    	addr[3] = shs_pad2;
00003e  4810              LDR      r0,|L9.128|
000040  9008              STR      r0,[sp,#0x20]
;;;363    
;;;364    	if (sha1_vector(4, addr, len, digest))
000042  ab09              ADD      r3,sp,#0x24
000044  aa01              ADD      r2,sp,#4
000046  a905              ADD      r1,sp,#0x14
000048  2004              MOVS     r0,#4
00004a  f7fffffe          BL       sha1_vector
00004e  b120              CBZ      r0,|L9.90|
;;;365    		return -1;
000050  f04f30ff          MOV      r0,#0xffffffff
                  |L9.84|
;;;366    
;;;367    	if (session_key_len > SHA1_MAC_LEN)
;;;368    		session_key_len = SHA1_MAC_LEN;
;;;369    	os_memcpy(session_key, digest, session_key_len);
;;;370    	return 0;
;;;371    }
000054  b00e              ADD      sp,sp,#0x38
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L9.90|
00005a  2f14              CMP      r7,#0x14              ;367
00005c  d900              BLS      |L9.96|
00005e  2714              MOVS     r7,#0x14              ;368
                  |L9.96|
000060  463a              MOV      r2,r7                 ;369
000062  a909              ADD      r1,sp,#0x24           ;369
000064  4628              MOV      r0,r5                 ;369
000066  f7fffffe          BL       __aeabi_memcpy
00006a  2000              MOVS     r0,#0                 ;370
00006c  e7f2              B        |L9.84|
;;;372    
                          ENDP

00006e  0000              DCW      0x0000
                  |L9.112|
                          DCD      ||.constdata||+0x188
                  |L9.116|
                          DCD      shs_pad1
                  |L9.120|
                          DCD      magic3
                  |L9.124|
                          DCD      |symbol_number.87|
                  |L9.128|
                          DCD      shs_pad2

                          AREA ||i.get_master_key||, CODE, READONLY, ALIGN=2

                  get_master_key PROC
;;;279     */
;;;280    int get_master_key(const u8 *password_hash_hash, const u8 *nt_response,
000000  b570              PUSH     {r4-r6,lr}
;;;281    		   u8 *master_key)
;;;282    {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;283    	static const u8 magic1[27] = {
;;;284    		0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
;;;285    		0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
;;;286    		0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79
;;;287    	};
;;;288    	const unsigned char *addr[3];
;;;289    	const size_t len[3] = { 16, 24, sizeof(magic1) };
00000a  4a0d              LDR      r2,|L10.64|
00000c  ca07              LDM      r2,{r0-r2}
00000e  ab06              ADD      r3,sp,#0x18
000010  c307              STM      r3!,{r0-r2}
;;;290    	u8 hash[SHA1_MAC_LEN];
;;;291    
;;;292    	addr[0] = password_hash_hash;
000012  9409              STR      r4,[sp,#0x24]
;;;293    	addr[1] = nt_response;
000014  950a              STR      r5,[sp,#0x28]
;;;294    	addr[2] = magic1;
000016  480b              LDR      r0,|L10.68|
000018  900b              STR      r0,[sp,#0x2c]
;;;295    
;;;296    	if (sha1_vector(3, addr, len, hash))
00001a  ab01              ADD      r3,sp,#4
00001c  aa06              ADD      r2,sp,#0x18
00001e  a909              ADD      r1,sp,#0x24
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       sha1_vector
000026  b118              CBZ      r0,|L10.48|
;;;297    		return -1;
000028  f04f30ff          MOV      r0,#0xffffffff
                  |L10.44|
;;;298    	os_memcpy(master_key, hash, 16);
;;;299    	return 0;
;;;300    }
00002c  b00c              ADD      sp,sp,#0x30
00002e  bd70              POP      {r4-r6,pc}
                  |L10.48|
000030  2210              MOVS     r2,#0x10              ;298
000032  a901              ADD      r1,sp,#4              ;298
000034  4630              MOV      r0,r6                 ;298
000036  f7fffffe          BL       __aeabi_memcpy
00003a  2000              MOVS     r0,#0                 ;299
00003c  e7f6              B        |L10.44|
;;;301    
                          ENDP

00003e  0000              DCW      0x0000
                  |L10.64|
                          DCD      ||.constdata||+0x84
                  |L10.68|
                          DCD      |symbol_number.86|

                          AREA ||i.hash_nt_password_hash||, CODE, READONLY, ALIGN=1

                  hash_nt_password_hash PROC
;;;87      */
;;;88     int hash_nt_password_hash(const u8 *password_hash, u8 *password_hash_hash)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;89     {
000002  b082              SUB      sp,sp,#8
000004  460c              MOV      r4,r1
;;;90     	size_t len = 16;
000006  2010              MOVS     r0,#0x10
000008  9001              STR      r0,[sp,#4]
;;;91     	return md4_vector(1, &password_hash, &len, password_hash_hash);
00000a  4623              MOV      r3,r4
00000c  aa01              ADD      r2,sp,#4
00000e  a902              ADD      r1,sp,#8
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       md4_vector
;;;92     }
000016  b004              ADD      sp,sp,#0x10
000018  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L12.30|
00001a  2001              MOVS     r0,#1
                  |L12.28|
;;;495    }
00001c  4770              BX       lr
                  |L12.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L12.28|
;;;496    
                          ENDP


                          AREA ||i.new_password_encrypted_with_old_nt_password_hash||, CODE, READONLY, ALIGN=1

                  new_password_encrypted_with_old_nt_password_hash PROC
;;;419     */
;;;420    int new_password_encrypted_with_old_nt_password_hash(
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;421    	const u8 *new_password, size_t new_password_len,
;;;422    	const u8 *old_password, size_t old_password_len,
;;;423    	u8 *encrypted_pw_block)
;;;424    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;425    	u8 password_hash[16];
;;;426    
;;;427    	if (nt_password_hash(old_password, old_password_len, password_hash))
000010  466a              MOV      r2,sp
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       nt_password_hash
00001a  b120              CBZ      r0,|L13.38|
;;;428    		return -1;
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L13.32|
;;;429    	if (encrypt_pw_block_with_password_hash(new_password, new_password_len,
;;;430    						password_hash,
;;;431    						encrypted_pw_block))
;;;432    		return -1;
;;;433    	return 0;
;;;434    }
000020  b004              ADD      sp,sp,#0x10
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L13.38|
000026  4643              MOV      r3,r8                 ;429
000028  466a              MOV      r2,sp                 ;429
00002a  4639              MOV      r1,r7                 ;429
00002c  4630              MOV      r0,r6                 ;429
00002e  f7fffffe          BL       encrypt_pw_block_with_password_hash
000032  b110              CBZ      r0,|L13.58|
000034  f04f30ff          MOV      r0,#0xffffffff        ;432
000038  e7f2              B        |L13.32|
                  |L13.58|
00003a  2000              MOVS     r0,#0                 ;433
00003c  e7f0              B        |L13.32|
;;;435    
                          ENDP


                          AREA ||i.nt_challenge_response||, CODE, READONLY, ALIGN=1

                  nt_challenge_response PROC
;;;261     */
;;;262    int nt_challenge_response(const u8 *challenge, const u8 *password,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;263    			  size_t password_len, u8 *response)
;;;264    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;265    	u8 password_hash[16];
;;;266    	if (nt_password_hash(password, password_len, password_hash))
00000c  466a              MOV      r2,sp
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nt_password_hash
000016  b120              CBZ      r0,|L14.34|
;;;267    		return -1;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L14.28|
;;;268    	challenge_response(challenge, password_hash, response);
;;;269    	return 0;
;;;270    }
00001c  b004              ADD      sp,sp,#0x10
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L14.34|
000022  4632              MOV      r2,r6                 ;268
000024  4669              MOV      r1,sp                 ;268
000026  4638              MOV      r0,r7                 ;268
000028  f7fffffe          BL       challenge_response
00002c  2000              MOVS     r0,#0                 ;269
00002e  e7f5              B        |L14.28|
;;;271    
                          ENDP


                          AREA ||i.nt_password_hash||, CODE, READONLY, ALIGN=1

                  nt_password_hash PROC
;;;60      */
;;;61     int nt_password_hash(const u8 *password, size_t password_len,
000000  b5f0              PUSH     {r4-r7,lr}
;;;62     		      u8 *password_hash)
;;;63     {
000002  f5ad7d03          SUB      sp,sp,#0x20c
000006  4606              MOV      r6,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
;;;64     	u8 buf[512], *pos;
;;;65     	size_t i, len;
;;;66     
;;;67     	if (password_len > 256)
00000c  f5b57f80          CMP      r5,#0x100
000010  d901              BLS      |L15.22|
;;;68     		password_len = 256;
000012  f44f7580          MOV      r5,#0x100
                  |L15.22|
;;;69     
;;;70     	/* Convert password into unicode */
;;;71     	for (i = 0; i < password_len; i++) {
000016  2400              MOVS     r4,#0
000018  e008              B        |L15.44|
                  |L15.26|
;;;72     		buf[2 * i] = password[i];
00001a  5d30              LDRB     r0,[r6,r4]
00001c  aa03              ADD      r2,sp,#0xc
00001e  f8020014          STRB     r0,[r2,r4,LSL #1]
;;;73     		buf[2 * i + 1] = 0;
000022  2100              MOVS     r1,#0
000024  0060              LSLS     r0,r4,#1
000026  1c40              ADDS     r0,r0,#1
000028  5411              STRB     r1,[r2,r0]
00002a  1c64              ADDS     r4,r4,#1              ;71
                  |L15.44|
00002c  42ac              CMP      r4,r5                 ;71
00002e  d3f4              BCC      |L15.26|
;;;74     	}
;;;75     
;;;76     	len = password_len * 2;
000030  0068              LSLS     r0,r5,#1
000032  9001              STR      r0,[sp,#4]
;;;77     	pos = buf;
000034  a803              ADD      r0,sp,#0xc
000036  9002              STR      r0,[sp,#8]
;;;78     	return md4_vector(1, (const u8 **) &pos, &len, password_hash);
000038  463b              MOV      r3,r7
00003a  aa01              ADD      r2,sp,#4
00003c  a902              ADD      r1,sp,#8
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       md4_vector
;;;79     }
000044  f50d7d03          ADD      sp,sp,#0x20c
000048  bdf0              POP      {r4-r7,pc}
;;;80     
                          ENDP


                          AREA ||i.nt_password_hash_encrypted_with_block||, CODE, READONLY, ALIGN=1

                  nt_password_hash_encrypted_with_block PROC
;;;442     */
;;;443    void nt_password_hash_encrypted_with_block(const u8 *password_hash,
000000  b570              PUSH     {r4-r6,lr}
;;;444    					   const u8 *block, u8 *cypher)
;;;445    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;446    	des_encrypt(password_hash, block, cypher);
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       des_encrypt
;;;447    	des_encrypt(password_hash + 8, block + 7, cypher + 8);
000012  f1050208          ADD      r2,r5,#8
000016  1de1              ADDS     r1,r4,#7
000018  f1060008          ADD      r0,r6,#8
00001c  f7fffffe          BL       des_encrypt
;;;448    }
000020  bd70              POP      {r4-r6,pc}
;;;449    
                          ENDP


                          AREA ||i.old_nt_password_hash_encrypted_with_new_nt_password_hash||, CODE, READONLY, ALIGN=1

                  old_nt_password_hash_encrypted_with_new_nt_password_hash PROC
;;;459     */
;;;460    int old_nt_password_hash_encrypted_with_new_nt_password_hash(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;461    	const u8 *new_password, size_t new_password_len,
;;;462    	const u8 *old_password, size_t old_password_len,
;;;463    	u8 *encrypted_password_hash)
;;;464    {
000004  b088              SUB      sp,sp,#0x20
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
00000e  f8dd8038          LDR      r8,[sp,#0x38]
;;;465    	u8 old_password_hash[16], new_password_hash[16];
;;;466    
;;;467    	if (nt_password_hash(old_password, old_password_len,
000012  aa04              ADD      r2,sp,#0x10
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       nt_password_hash
00001c  b928              CBNZ     r0,|L17.42|
;;;468    			     old_password_hash) ||
;;;469    	    nt_password_hash(new_password, new_password_len,
00001e  466a              MOV      r2,sp
000020  4639              MOV      r1,r7
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       nt_password_hash
000028  b120              CBZ      r0,|L17.52|
                  |L17.42|
;;;470    			     new_password_hash))
;;;471    		return -1;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L17.46|
;;;472    	nt_password_hash_encrypted_with_block(old_password_hash,
;;;473    					      new_password_hash,
;;;474    					      encrypted_password_hash);
;;;475    	return 0;
;;;476    }
00002e  b008              ADD      sp,sp,#0x20
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L17.52|
000034  4642              MOV      r2,r8                 ;472
000036  4669              MOV      r1,sp                 ;472
000038  a804              ADD      r0,sp,#0x10           ;472
00003a  f7fffffe          BL       nt_password_hash_encrypted_with_block
00003e  2000              MOVS     r0,#0                 ;475
000040  e7f5              B        |L17.46|
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L22.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L22.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L22.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L22.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L25.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L25.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L25.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L25.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L31.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       __aeabi_memcpy
                  |L31.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L38.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L38.32|
                  |L38.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L38.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L38.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L38.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L38.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L38.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L38.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L38.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  magic1
000000  4d616769          DCB      0x4d,0x61,0x67,0x69
000004  63207365          DCB      0x63,0x20,0x73,0x65
000008  72766572          DCB      0x72,0x76,0x65,0x72
00000c  20746f20          DCB      0x20,0x74,0x6f,0x20
000010  636c6965          DCB      0x63,0x6c,0x69,0x65
000014  6e742073          DCB      0x6e,0x74,0x20,0x73
000018  69676e69          DCB      0x69,0x67,0x6e,0x69
00001c  6e672063          DCB      0x6e,0x67,0x20,0x63
000020  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000024  616e74            DCB      0x61,0x6e,0x74
                  magic2
000027  50                DCB      0x50
000028  61642074          DCB      0x61,0x64,0x20,0x74
00002c  6f206d61          DCB      0x6f,0x20,0x6d,0x61
000030  6b652069          DCB      0x6b,0x65,0x20,0x69
000034  7420646f          DCB      0x74,0x20,0x64,0x6f
000038  206d6f72          DCB      0x20,0x6d,0x6f,0x72
00003c  65207468          DCB      0x65,0x20,0x74,0x68
000040  616e206f          DCB      0x61,0x6e,0x20,0x6f
000044  6e652069          DCB      0x6e,0x65,0x20,0x69
000048  74657261          DCB      0x74,0x65,0x72,0x61
00004c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
                          DCD      0x00000010
                          DCD      0x00000018
                          DCD      0x00000027
                          DCD      0x00000014
                          DCD      0x00000008
                          DCD      0x00000029
                  |symbol_number.86|
000068  54686973          DCB      0x54,0x68,0x69,0x73
00006c  20697320          DCB      0x20,0x69,0x73,0x20
000070  74686520          DCB      0x74,0x68,0x65,0x20
000074  4d505045          DCB      0x4d,0x50,0x50,0x45
000078  204d6173          DCB      0x20,0x4d,0x61,0x73
00007c  74657220          DCB      0x74,0x65,0x72,0x20
000080  4b657900          DCB      0x4b,0x65,0x79,0x00
                          DCD      0x00000010
                          DCD      0x00000018
                          DCD      0x0000001b
                  |symbol_number.87|
000090  4f6e2074          DCB      0x4f,0x6e,0x20,0x74
000094  68652063          DCB      0x68,0x65,0x20,0x63
000098  6c69656e          DCB      0x6c,0x69,0x65,0x6e
00009c  74207369          DCB      0x74,0x20,0x73,0x69
0000a0  64652c20          DCB      0x64,0x65,0x2c,0x20
0000a4  74686973          DCB      0x74,0x68,0x69,0x73
0000a8  20697320          DCB      0x20,0x69,0x73,0x20
0000ac  74686520          DCB      0x74,0x68,0x65,0x20
0000b0  73656e64          DCB      0x73,0x65,0x6e,0x64
0000b4  206b6579          DCB      0x20,0x6b,0x65,0x79
0000b8  3b206f6e          DCB      0x3b,0x20,0x6f,0x6e
0000bc  20746865          DCB      0x20,0x74,0x68,0x65
0000c0  20736572          DCB      0x20,0x73,0x65,0x72
0000c4  76657220          DCB      0x76,0x65,0x72,0x20
0000c8  73696465          DCB      0x73,0x69,0x64,0x65
0000cc  2c206974          DCB      0x2c,0x20,0x69,0x74
0000d0  20697320          DCB      0x20,0x69,0x73,0x20
0000d4  74686520          DCB      0x74,0x68,0x65,0x20
0000d8  72656365          DCB      0x72,0x65,0x63,0x65
0000dc  69766520          DCB      0x69,0x76,0x65,0x20
0000e0  6b65792e          DCB      0x6b,0x65,0x79,0x2e
                  magic3
0000e4  4f6e2074          DCB      0x4f,0x6e,0x20,0x74
0000e8  68652063          DCB      0x68,0x65,0x20,0x63
0000ec  6c69656e          DCB      0x6c,0x69,0x65,0x6e
0000f0  74207369          DCB      0x74,0x20,0x73,0x69
0000f4  64652c20          DCB      0x64,0x65,0x2c,0x20
0000f8  74686973          DCB      0x74,0x68,0x69,0x73
0000fc  20697320          DCB      0x20,0x69,0x73,0x20
000100  74686520          DCB      0x74,0x68,0x65,0x20
000104  72656365          DCB      0x72,0x65,0x63,0x65
000108  69766520          DCB      0x69,0x76,0x65,0x20
00010c  6b65793b          DCB      0x6b,0x65,0x79,0x3b
000110  206f6e20          DCB      0x20,0x6f,0x6e,0x20
000114  74686520          DCB      0x74,0x68,0x65,0x20
000118  73657276          DCB      0x73,0x65,0x72,0x76
00011c  65722073          DCB      0x65,0x72,0x20,0x73
000120  6964652c          DCB      0x69,0x64,0x65,0x2c
000124  20697420          DCB      0x20,0x69,0x74,0x20
000128  69732074          DCB      0x69,0x73,0x20,0x74
00012c  68652073          DCB      0x68,0x65,0x20,0x73
000130  656e6420          DCB      0x65,0x6e,0x64,0x20
000134  6b65792e          DCB      0x6b,0x65,0x79,0x2e
                  shs_pad1
000138  00000000          DCB      0x00,0x00,0x00,0x00
00013c  00000000          DCB      0x00,0x00,0x00,0x00
000140  00000000          DCB      0x00,0x00,0x00,0x00
000144  00000000          DCB      0x00,0x00,0x00,0x00
000148  00000000          DCB      0x00,0x00,0x00,0x00
00014c  00000000          DCB      0x00,0x00,0x00,0x00
000150  00000000          DCB      0x00,0x00,0x00,0x00
000154  00000000          DCB      0x00,0x00,0x00,0x00
000158  00000000          DCB      0x00,0x00,0x00,0x00
00015c  00000000          DCB      0x00,0x00,0x00,0x00
                  shs_pad2
000160  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000164  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000168  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
00016c  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000170  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000174  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000178  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
00017c  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000180  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
000184  f2f2f2f2          DCB      0xf2,0xf2,0xf2,0xf2
                          DCD      0x00000010
                          DCD      0x00000028
                          DCD      0x00000054
                          DCD      0x00000028
