; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eap_aka.o --depend=.\obj\eap_aka.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eap_aka.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer\eap_aka.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_aka_add_checkcode||, CODE, READONLY, ALIGN=2

                  eap_aka_add_checkcode PROC
;;;328    
;;;329    static void eap_aka_add_checkcode(struct eap_aka_data *data,
000000  b530              PUSH     {r4,r5,lr}
;;;330    				  struct eap_sim_msg *msg)
;;;331    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;332    	const u8 *addr;
;;;333    	size_t len;
;;;334    	u8 hash[SHA256_MAC_LEN];
;;;335    
;;;336    	wpa_printf(MSG_DEBUG, "   AT_CHECKCODE");
000008  a11a              ADR      r1,|L2.116|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       wpa_printf
;;;337    
;;;338    	if (data->id_msgs == NULL) {
000010  f8d40188          LDR      r0,[r4,#0x188]
000014  b940              CBNZ     r0,|L2.40|
;;;339    		/*
;;;340    		 * No EAP-AKA/Identity packets were exchanged - send empty
;;;341    		 * checkcode.
;;;342    		 */
;;;343    		eap_sim_msg_add(msg, EAP_SIM_AT_CHECKCODE, 0, NULL, 0);
000016  2300              MOVS     r3,#0
000018  461a              MOV      r2,r3
00001a  2186              MOVS     r1,#0x86
00001c  4628              MOV      r0,r5
00001e  9300              STR      r3,[sp,#0]
000020  f7fffffe          BL       eap_sim_msg_add
                  |L2.36|
;;;344    		return;
;;;345    	}
;;;346    
;;;347    	/* Checkcode is SHA1/SHA256 hash over all EAP-AKA/Identity packets. */
;;;348    	addr = wpabuf_head(data->id_msgs);
;;;349    	len = wpabuf_len(data->id_msgs);
;;;350    	wpa_hexdump(MSG_MSGDUMP, "EAP-AKA: AT_CHECKCODE data", addr, len);
;;;351    #ifdef EAP_AKA_PRIME
;;;352    	if (data->eap_method == EAP_TYPE_AKA_PRIME)
;;;353    		sha256_vector(1, &addr, &len, hash);
;;;354    	else
;;;355    #endif /* EAP_AKA_PRIME */
;;;356    		sha1_vector(1, &addr, &len, hash);
;;;357    
;;;358    	eap_sim_msg_add(msg, EAP_SIM_AT_CHECKCODE, 0, hash,
;;;359    			data->eap_method == EAP_TYPE_AKA_PRIME ?
;;;360    			EAP_AKA_PRIME_CHECKCODE_LEN : EAP_AKA_CHECKCODE_LEN);
;;;361    }
000024  b00b              ADD      sp,sp,#0x2c
000026  bd30              POP      {r4,r5,pc}
                  |L2.40|
000028  f8d40188          LDR      r0,[r4,#0x188]        ;348
00002c  f7fffffe          BL       wpabuf_head
000030  900a              STR      r0,[sp,#0x28]         ;348
000032  f8d40188          LDR      r0,[r4,#0x188]        ;349
000036  f7fffffe          BL       wpabuf_len
00003a  9009              STR      r0,[sp,#0x24]         ;349
00003c  a111              ADR      r1,|L2.132|
00003e  2000              MOVS     r0,#0                 ;350
000040  e9dd3209          LDRD     r3,r2,[sp,#0x24]      ;350
000044  f7fffffe          BL       wpa_hexdump
000048  ab01              ADD      r3,sp,#4              ;356
00004a  aa09              ADD      r2,sp,#0x24           ;356
00004c  a90a              ADD      r1,sp,#0x28           ;356
00004e  2001              MOVS     r0,#1                 ;356
000050  f7fffffe          BL       sha1_vector
000054  f8940198          LDRB     r0,[r4,#0x198]        ;358
000058  2832              CMP      r0,#0x32              ;358
00005a  d101              BNE      |L2.96|
00005c  2320              MOVS     r3,#0x20              ;360
00005e  e000              B        |L2.98|
                  |L2.96|
000060  2314              MOVS     r3,#0x14              ;360
                  |L2.98|
000062  9300              STR      r3,[sp,#0]            ;360
000064  ab01              ADD      r3,sp,#4              ;360
000066  2200              MOVS     r2,#0                 ;360
000068  2186              MOVS     r1,#0x86              ;360
00006a  4628              MOV      r0,r5                 ;360
00006c  f7fffffe          BL       eap_sim_msg_add
000070  bf00              NOP      
000072  e7d7              B        |L2.36|
;;;362    
                          ENDP

                  |L2.116|
000074  20202041          DCB      "   AT_CHECKCODE",0
000078  545f4348
00007c  45434b43
000080  4f444500
                  |L2.132|
000084  4541502d          DCB      "EAP-AKA: AT_CHECKCODE data",0
000088  414b413a
00008c  2041545f
000090  43484543
000094  4b434f44
000098  45206461
00009c  746100  
00009f  00                DCB      0

                          AREA ||i.eap_aka_add_id_msg||, CODE, READONLY, ALIGN=1

                  eap_aka_add_id_msg PROC
;;;309    
;;;310    static int eap_aka_add_id_msg(struct eap_aka_data *data,
000000  b570              PUSH     {r4-r6,lr}
;;;311    			      const struct wpabuf *msg)
;;;312    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;313    	if (msg == NULL)
000006  b915              CBNZ     r5,|L3.14|
;;;314    		return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L3.12|
;;;315    
;;;316    	if (data->id_msgs == NULL) {
;;;317    		data->id_msgs = wpabuf_dup(msg);
;;;318    		return data->id_msgs == NULL ? -1 : 0;
;;;319    	}
;;;320    
;;;321    	if (wpabuf_resize(&data->id_msgs, wpabuf_len(msg)) < 0)
;;;322    		return -1;
;;;323    	wpabuf_put_buf(data->id_msgs, msg);
;;;324    
;;;325    	return 0;
;;;326    }
00000c  bd70              POP      {r4-r6,pc}
                  |L3.14|
00000e  f8d40188          LDR      r0,[r4,#0x188]        ;316
000012  b960              CBNZ     r0,|L3.46|
000014  4628              MOV      r0,r5                 ;317
000016  f7fffffe          BL       wpabuf_dup
00001a  f8c40188          STR      r0,[r4,#0x188]        ;317
00001e  f8d40188          LDR      r0,[r4,#0x188]        ;318
000022  b910              CBNZ     r0,|L3.42|
000024  f04f30ff          MOV      r0,#0xffffffff        ;318
000028  e7f0              B        |L3.12|
                  |L3.42|
00002a  2000              MOVS     r0,#0                 ;318
00002c  e7ee              B        |L3.12|
                  |L3.46|
00002e  4628              MOV      r0,r5                 ;321
000030  f7fffffe          BL       wpabuf_len
000034  4606              MOV      r6,r0                 ;321
000036  4601              MOV      r1,r0                 ;321
000038  f50470c4          ADD      r0,r4,#0x188          ;321
00003c  f7fffffe          BL       wpabuf_resize
000040  2800              CMP      r0,#0                 ;321
000042  da02              BGE      |L3.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;322
000048  e7e0              B        |L3.12|
                  |L3.74|
00004a  4629              MOV      r1,r5                 ;323
00004c  f8d40188          LDR      r0,[r4,#0x188]        ;323
000050  f7fffffe          BL       wpabuf_put_buf
000054  2000              MOVS     r0,#0                 ;325
000056  e7d9              B        |L3.12|
;;;327    
                          ENDP


                          AREA ||i.eap_aka_authentication_reject||, CODE, READONLY, ALIGN=2

                  eap_aka_authentication_reject PROC
;;;429    
;;;430    static struct wpabuf * eap_aka_authentication_reject(struct eap_aka_data *data,
000000  b570              PUSH     {r4-r6,lr}
;;;431    						     u8 id)
;;;432    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;433    	struct eap_sim_msg *msg;
;;;434    
;;;435    	eap_aka_state(data, FAILURE);
000006  2104              MOVS     r1,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       eap_aka_state
;;;436    	data->num_id_req = 0;
00000e  2000              MOVS     r0,#0
000010  f8c40158          STR      r0,[r4,#0x158]
;;;437    	data->num_notification = 0;
000014  f8c4015c          STR      r0,[r4,#0x15c]
;;;438    
;;;439    	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Authentication-Reject "
000018  462a              MOV      r2,r5
00001a  a109              ADR      r1,|L4.64|
00001c  f7fffffe          BL       wpa_printf
;;;440    		   "(id=%d)", id);
;;;441    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
000020  f8942198          LDRB     r2,[r4,#0x198]
000024  2302              MOVS     r3,#2
000026  4629              MOV      r1,r5
000028  4618              MOV      r0,r3
00002a  f7fffffe          BL       eap_sim_msg_init
00002e  4606              MOV      r6,r0
;;;442    			       EAP_AKA_SUBTYPE_AUTHENTICATION_REJECT);
;;;443    	return eap_sim_msg_finish(msg, NULL, NULL, 0);
000030  2300              MOVS     r3,#0
000032  461a              MOV      r2,r3
000034  4619              MOV      r1,r3
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       eap_sim_msg_finish
;;;444    }
00003c  bd70              POP      {r4-r6,pc}
;;;445    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
000040  47656e65          DCB      "Generating EAP-AKA Authentication-Reject (id=%d)",0
000044  72617469
000048  6e672045
00004c  41502d41
000050  4b412041
000054  75746865
000058  6e746963
00005c  6174696f
000060  6e2d5265
000064  6a656374
000068  20286964
00006c  3d256429
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.eap_aka_clear_identities||, CODE, READONLY, ALIGN=2

                  eap_aka_clear_identities PROC
;;;244    
;;;245    static void eap_aka_clear_identities(struct eap_aka_data *data, int id)
000000  b538              PUSH     {r3-r5,lr}
;;;246    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;247    	wpa_printf(MSG_DEBUG, "EAP-AKA: forgetting old%s%s%s",
000006  f0150f04          TST      r5,#4
00000a  d001              BEQ      |L5.16|
;;;248    		   id & CLEAR_PSEUDONYM ? " pseudonym" : "",
;;;249    		   id & CLEAR_REAUTH_ID ? " reauth_id" : "",
;;;250    		   id & CLEAR_EAP_ID ? " eap_id" : "");
00000c  a31d              ADR      r3,|L5.132|
00000e  e000              B        |L5.18|
                  |L5.16|
000010  a31e              ADR      r3,|L5.140|
                  |L5.18|
000012  9300              STR      r3,[sp,#0]
000014  f0150f02          TST      r5,#2
000018  d001              BEQ      |L5.30|
00001a  a01d              ADR      r0,|L5.144|
00001c  e000              B        |L5.32|
                  |L5.30|
00001e  a01b              ADR      r0,|L5.140|
                  |L5.32|
000020  4603              MOV      r3,r0                 ;249
000022  f0150f01          TST      r5,#1                 ;249
000026  d001              BEQ      |L5.44|
000028  a01c              ADR      r0,|L5.156|
00002a  e000              B        |L5.46|
                  |L5.44|
00002c  a017              ADR      r0,|L5.140|
                  |L5.46|
00002e  4602              MOV      r2,r0                 ;248
000030  a11d              ADR      r1,|L5.168|
000032  2000              MOVS     r0,#0                 ;248
000034  f7fffffe          BL       wpa_printf
;;;251    	if (id & CLEAR_PSEUDONYM) {
000038  f0150f01          TST      r5,#1
00003c  d008              BEQ      |L5.80|
;;;252    		os_free(data->pseudonym);
00003e  f8d40160          LDR      r0,[r4,#0x160]
000042  f7fffffe          BL       os_free
;;;253    		data->pseudonym = NULL;
000046  2000              MOVS     r0,#0
000048  f8c40160          STR      r0,[r4,#0x160]
;;;254    		data->pseudonym_len = 0;
00004c  f8c40164          STR      r0,[r4,#0x164]
                  |L5.80|
;;;255    	}
;;;256    	if (id & CLEAR_REAUTH_ID) {
000050  f0150f02          TST      r5,#2
000054  d008              BEQ      |L5.104|
;;;257    		os_free(data->reauth_id);
000056  f8d40168          LDR      r0,[r4,#0x168]
00005a  f7fffffe          BL       os_free
;;;258    		data->reauth_id = NULL;
00005e  2000              MOVS     r0,#0
000060  f8c40168          STR      r0,[r4,#0x168]
;;;259    		data->reauth_id_len = 0;
000064  f8c4016c          STR      r0,[r4,#0x16c]
                  |L5.104|
;;;260    	}
;;;261    	if (id & CLEAR_EAP_ID) {
000068  f0150f04          TST      r5,#4
00006c  d008              BEQ      |L5.128|
;;;262    		os_free(data->last_eap_identity);
00006e  f8d4017c          LDR      r0,[r4,#0x17c]
000072  f7fffffe          BL       os_free
;;;263    		data->last_eap_identity = NULL;
000076  2000              MOVS     r0,#0
000078  f8c4017c          STR      r0,[r4,#0x17c]
;;;264    		data->last_eap_identity_len = 0;
00007c  f8c40180          STR      r0,[r4,#0x180]
                  |L5.128|
;;;265    	}
;;;266    }
000080  bd38              POP      {r3-r5,pc}
;;;267    
                          ENDP

000082  0000              DCW      0x0000
                  |L5.132|
000084  20656170          DCB      " eap_id",0
000088  5f696400
                  |L5.140|
00008c  00                DCB      0
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L5.144|
000090  20726561          DCB      " reauth_id",0
000094  7574685f
000098  696400  
00009b  00                DCB      0
                  |L5.156|
00009c  20707365          DCB      " pseudonym",0
0000a0  75646f6e
0000a4  796d00  
0000a7  00                DCB      0
                  |L5.168|
0000a8  4541502d          DCB      "EAP-AKA: forgetting old%s%s%s",0
0000ac  414b413a
0000b0  20666f72
0000b4  67657474
0000b8  696e6720
0000bc  6f6c6425
0000c0  73257325
0000c4  7300    
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.eap_aka_client_error||, CODE, READONLY, ALIGN=1

                  eap_aka_client_error PROC
;;;413    
;;;414    static struct wpabuf * eap_aka_client_error(struct eap_aka_data *data, u8 id,
000000  b5f8              PUSH     {r3-r7,lr}
;;;415    					    int err)
;;;416    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;417    	struct eap_sim_msg *msg;
;;;418    
;;;419    	eap_aka_state(data, FAILURE);
000008  2104              MOVS     r1,#4
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eap_aka_state
;;;420    	data->num_id_req = 0;
000010  2000              MOVS     r0,#0
000012  f8c40158          STR      r0,[r4,#0x158]
;;;421    	data->num_notification = 0;
000016  f8c4015c          STR      r0,[r4,#0x15c]
;;;422    
;;;423    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
00001a  f8942198          LDRB     r2,[r4,#0x198]
00001e  230e              MOVS     r3,#0xe
000020  4631              MOV      r1,r6
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       eap_sim_msg_init
000028  4607              MOV      r7,r0
;;;424    			       EAP_AKA_SUBTYPE_CLIENT_ERROR);
;;;425    	eap_sim_msg_add(msg, EAP_SIM_AT_CLIENT_ERROR_CODE, err, NULL, 0);
00002a  2300              MOVS     r3,#0
00002c  b2aa              UXTH     r2,r5
00002e  2116              MOVS     r1,#0x16
000030  4638              MOV      r0,r7
000032  9300              STR      r3,[sp,#0]
000034  f7fffffe          BL       eap_sim_msg_add
;;;426    	return eap_sim_msg_finish(msg, NULL, NULL, 0);
000038  2300              MOVS     r3,#0
00003a  461a              MOV      r2,r3
00003c  4619              MOV      r1,r3
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       eap_sim_msg_finish
;;;427    }
000044  bdf8              POP      {r3-r7,pc}
;;;428    
                          ENDP


                          AREA ||i.eap_aka_deinit||, CODE, READONLY, ALIGN=1

                  eap_aka_deinit PROC
;;;135    
;;;136    static void eap_aka_deinit(struct eap_sm *sm, void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;138    	struct eap_aka_data *data = priv;
000006  462c              MOV      r4,r5
;;;139    	if (data) {
000008  b1ac              CBZ      r4,|L7.54|
;;;140    		os_free(data->pseudonym);
00000a  f50474b0          ADD      r4,r4,#0x160
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       os_free
;;;141    		os_free(data->reauth_id);
000014  68a0              LDR      r0,[r4,#8]
000016  f7fffffe          BL       os_free
;;;142    		os_free(data->last_eap_identity);
00001a  69e0              LDR      r0,[r4,#0x1c]
00001c  f7fffffe          BL       os_free
;;;143    		wpabuf_free(data->id_msgs);
000020  6aa0              LDR      r0,[r4,#0x28]
000022  f7fffffe          BL       wpabuf_free
;;;144    		os_free(data->network_name);
000026  6be0              LDR      r0,[r4,#0x3c]
000028  f5a474b0          SUB      r4,r4,#0x160
00002c  f7fffffe          BL       os_free
;;;145    		os_free(data);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       os_free
                  |L7.54|
;;;146    	}
;;;147    }
000036  bd70              POP      {r4-r6,pc}
;;;148    
                          ENDP


                          AREA ||i.eap_aka_deinit_for_reauth||, CODE, READONLY, ALIGN=1

                  eap_aka_deinit_for_reauth PROC
;;;1254   
;;;1255   static void eap_aka_deinit_for_reauth(struct eap_sm *sm, void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;1256   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1257   	struct eap_aka_data *data = priv;
000006  4625              MOV      r5,r4
;;;1258   	eap_aka_clear_identities(data, CLEAR_EAP_ID);
000008  2104              MOVS     r1,#4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       eap_aka_clear_identities
;;;1259   	data->prev_id = -1;
000010  f04f30ff          MOV      r0,#0xffffffff
000014  f50575c4          ADD      r5,r5,#0x188
000018  6068              STR      r0,[r5,#4]
;;;1260   	wpabuf_free(data->id_msgs);
00001a  6828              LDR      r0,[r5,#0]
00001c  f7fffffe          BL       wpabuf_free
;;;1261   	data->id_msgs = NULL;
000020  2000              MOVS     r0,#0
000022  6028              STR      r0,[r5,#0]
;;;1262   	data->use_result_ind = 0;
000024  60e8              STR      r0,[r5,#0xc]
;;;1263   	data->kdf_negotiation = 0;
000026  6228              STR      r0,[r5,#0x20]
000028  f5a575c4          SUB      r5,r5,#0x188
;;;1264   }
00002c  bd70              POP      {r4-r6,pc}
;;;1265   
                          ENDP


                          AREA ||i.eap_aka_getKey||, CODE, READONLY, ALIGN=1

                  eap_aka_getKey PROC
;;;1302   
;;;1303   static u8 * eap_aka_getKey(struct eap_sm *sm, void *priv, size_t *len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1304   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;1305   	struct eap_aka_data *data = priv;
00000a  4627              MOV      r7,r4
;;;1306   	u8 *key;
;;;1307   
;;;1308   	if (data->state != SUCCESS)
00000c  f8d70184          LDR      r0,[r7,#0x184]
000010  2803              CMP      r0,#3
000012  d002              BEQ      |L9.26|
;;;1309   		return NULL;
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;1310   
;;;1311   	key = os_malloc(EAP_SIM_KEYING_DATA_LEN);
;;;1312   	if (key == NULL)
;;;1313   		return NULL;
;;;1314   
;;;1315   	*len = EAP_SIM_KEYING_DATA_LEN;
;;;1316   	os_memcpy(key, data->msk, EAP_SIM_KEYING_DATA_LEN);
;;;1317   
;;;1318   	return key;
;;;1319   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  2040              MOVS     r0,#0x40              ;1311
00001c  f7fffffe          BL       os_malloc
000020  4605              MOV      r5,r0                 ;1311
000022  b90d              CBNZ     r5,|L9.40|
000024  2000              MOVS     r0,#0                 ;1313
000026  e7f6              B        |L9.22|
                  |L9.40|
000028  2040              MOVS     r0,#0x40              ;1315
00002a  6030              STR      r0,[r6,#0]            ;1315
00002c  2240              MOVS     r2,#0x40              ;1316
00002e  f10701a8          ADD      r1,r7,#0xa8           ;1316
000032  4628              MOV      r0,r5                 ;1316
000034  f7fffffe          BL       os_memcpy
000038  4628              MOV      r0,r5                 ;1318
00003a  e7ec              B        |L9.22|
;;;1320   
                          ENDP


                          AREA ||i.eap_aka_get_emsk||, CODE, READONLY, ALIGN=1

                  eap_aka_get_emsk PROC
;;;1321   
;;;1322   static u8 * eap_aka_get_emsk(struct eap_sm *sm, void *priv, size_t *len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1323   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;1324   	struct eap_aka_data *data = priv;
00000a  4627              MOV      r7,r4
;;;1325   	u8 *key;
;;;1326   
;;;1327   	if (data->state != SUCCESS)
00000c  f8d70184          LDR      r0,[r7,#0x184]
000010  2803              CMP      r0,#3
000012  d002              BEQ      |L10.26|
;;;1328   		return NULL;
000014  2000              MOVS     r0,#0
                  |L10.22|
;;;1329   
;;;1330   	key = os_malloc(EAP_EMSK_LEN);
;;;1331   	if (key == NULL)
;;;1332   		return NULL;
;;;1333   
;;;1334   	*len = EAP_EMSK_LEN;
;;;1335   	os_memcpy(key, data->emsk, EAP_EMSK_LEN);
;;;1336   
;;;1337   	return key;
;;;1338   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L10.26|
00001a  2040              MOVS     r0,#0x40              ;1330
00001c  f7fffffe          BL       os_malloc
000020  4605              MOV      r5,r0                 ;1330
000022  b90d              CBNZ     r5,|L10.40|
000024  2000              MOVS     r0,#0                 ;1332
000026  e7f6              B        |L10.22|
                  |L10.40|
000028  2040              MOVS     r0,#0x40              ;1334
00002a  6030              STR      r0,[r6,#0]            ;1334
00002c  2240              MOVS     r2,#0x40              ;1335
00002e  f10701e8          ADD      r1,r7,#0xe8           ;1335
000032  4628              MOV      r0,r5                 ;1335
000034  f7fffffe          BL       os_memcpy
000038  4628              MOV      r0,r5                 ;1337
00003a  e7ec              B        |L10.22|
;;;1339   
                          ENDP


                          AREA ||i.eap_aka_get_identity||, CODE, READONLY, ALIGN=1

                  eap_aka_get_identity PROC
;;;1276   
;;;1277   static const u8 * eap_aka_get_identity(struct eap_sm *sm, void *priv,
000000  b510              PUSH     {r4,lr}
;;;1278   				       size_t *len)
;;;1279   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1280   	struct eap_aka_data *data = priv;
000006  4619              MOV      r1,r3
;;;1281   
;;;1282   	if (data->reauth_id) {
000008  f8d10168          LDR      r0,[r1,#0x168]
00000c  b128              CBZ      r0,|L11.26|
;;;1283   		*len = data->reauth_id_len;
00000e  f8d1016c          LDR      r0,[r1,#0x16c]
000012  6010              STR      r0,[r2,#0]
;;;1284   		return data->reauth_id;
000014  f8d10168          LDR      r0,[r1,#0x168]
                  |L11.24|
;;;1285   	}
;;;1286   
;;;1287   	if (data->pseudonym) {
;;;1288   		*len = data->pseudonym_len;
;;;1289   		return data->pseudonym;
;;;1290   	}
;;;1291   
;;;1292   	return NULL;
;;;1293   }
000018  bd10              POP      {r4,pc}
                  |L11.26|
00001a  f8d10160          LDR      r0,[r1,#0x160]        ;1287
00001e  b128              CBZ      r0,|L11.44|
000020  f8d10164          LDR      r0,[r1,#0x164]        ;1288
000024  6010              STR      r0,[r2,#0]            ;1288
000026  f8d10160          LDR      r0,[r1,#0x160]        ;1289
00002a  e7f5              B        |L11.24|
                  |L11.44|
00002c  2000              MOVS     r0,#0                 ;1292
00002e  e7f3              B        |L11.24|
;;;1294   
                          ENDP


                          AREA ||i.eap_aka_has_reauth_data||, CODE, READONLY, ALIGN=1

                  eap_aka_has_reauth_data PROC
;;;1247   
;;;1248   static Boolean eap_aka_has_reauth_data(struct eap_sm *sm, void *priv)
000000  4603              MOV      r3,r0
;;;1249   {
;;;1250   	struct eap_aka_data *data = priv;
000002  460a              MOV      r2,r1
;;;1251   	return data->pseudonym || data->reauth_id;
000004  f8d20160          LDR      r0,[r2,#0x160]
000008  b910              CBNZ     r0,|L12.16|
00000a  f8d20168          LDR      r0,[r2,#0x168]
00000e  b108              CBZ      r0,|L12.20|
                  |L12.16|
000010  2001              MOVS     r0,#1
                  |L12.18|
;;;1252   }
000012  4770              BX       lr
                  |L12.20|
000014  2000              MOVS     r0,#0                 ;1251
000016  e7fc              B        |L12.18|
;;;1253   
                          ENDP


                          AREA ||i.eap_aka_init||, CODE, READONLY, ALIGN=2

                  eap_aka_init PROC
;;;103    
;;;104    static void * eap_aka_init(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;105    {
000002  4606              MOV      r6,r0
;;;106    	struct eap_aka_data *data;
;;;107    	const char *phase1 = eap_get_config_phase1(sm);
000004  4630              MOV      r0,r6
000006  f7fffffe          BL       eap_get_config_phase1
00000a  4605              MOV      r5,r0
;;;108    
;;;109    	data = os_zalloc(sizeof(*data));
00000c  f44f70d6          MOV      r0,#0x1ac
000010  f7fffffe          BL       os_zalloc
000014  4604              MOV      r4,r0
;;;110    	if (data == NULL)
000016  b90c              CBNZ     r4,|L13.28|
;;;111    		return NULL;
000018  2000              MOVS     r0,#0
                  |L13.26|
;;;112    
;;;113    	data->eap_method = EAP_TYPE_AKA;
;;;114    
;;;115    	eap_aka_state(data, CONTINUE);
;;;116    	data->prev_id = -1;
;;;117    
;;;118    	data->result_ind = phase1 && os_strstr(phase1, "result_ind=1") != NULL;
;;;119    
;;;120    	return data;
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
                  |L13.28|
00001c  2017              MOVS     r0,#0x17              ;113
00001e  f8840198          STRB     r0,[r4,#0x198]        ;113
000022  2100              MOVS     r1,#0                 ;115
000024  4620              MOV      r0,r4                 ;115
000026  f7fffffe          BL       eap_aka_state
00002a  f04f30ff          MOV      r0,#0xffffffff        ;116
00002e  f8c4018c          STR      r0,[r4,#0x18c]        ;116
000032  b135              CBZ      r5,|L13.66|
000034  a105              ADR      r1,|L13.76|
000036  4628              MOV      r0,r5                 ;118
000038  f7fffffe          BL       os_strstr
00003c  b108              CBZ      r0,|L13.66|
00003e  2001              MOVS     r0,#1                 ;118
000040  e000              B        |L13.68|
                  |L13.66|
000042  2000              MOVS     r0,#0                 ;118
                  |L13.68|
000044  f8c40190          STR      r0,[r4,#0x190]        ;118
000048  4620              MOV      r0,r4                 ;120
00004a  e7e6              B        |L13.26|
;;;122    
                          ENDP

                  |L13.76|
00004c  72657375          DCB      "result_ind=1",0
000050  6c745f69
000054  6e643d31
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.eap_aka_init_for_reauth||, CODE, READONLY, ALIGN=1

                  eap_aka_init_for_reauth PROC
;;;1266   
;;;1267   static void * eap_aka_init_for_reauth(struct eap_sm *sm, void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;1268   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1269   	struct eap_aka_data *data = priv;
000006  4625              MOV      r5,r4
;;;1270   	data->num_id_req = 0;
000008  2000              MOVS     r0,#0
00000a  f8c50158          STR      r0,[r5,#0x158]
;;;1271   	data->num_notification = 0;
00000e  f8c5015c          STR      r0,[r5,#0x15c]
;;;1272   	eap_aka_state(data, CONTINUE);
000012  2100              MOVS     r1,#0
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       eap_aka_state
;;;1273   	return priv;
00001a  4620              MOV      r0,r4
;;;1274   }
00001c  bd70              POP      {r4-r6,pc}
;;;1275   
                          ENDP


                          AREA ||i.eap_aka_isKeyAvailable||, CODE, READONLY, ALIGN=1

                  eap_aka_isKeyAvailable PROC
;;;1295   
;;;1296   static Boolean eap_aka_isKeyAvailable(struct eap_sm *sm, void *priv)
000000  4603              MOV      r3,r0
;;;1297   {
;;;1298   	struct eap_aka_data *data = priv;
000002  460a              MOV      r2,r1
;;;1299   	return data->state == SUCCESS;
000004  f8d20184          LDR      r0,[r2,#0x184]
000008  2803              CMP      r0,#3
00000a  d101              BNE      |L15.16|
00000c  2001              MOVS     r0,#1
                  |L15.14|
;;;1300   }
00000e  4770              BX       lr
                  |L15.16|
000010  2000              MOVS     r0,#0                 ;1299
000012  e7fc              B        |L15.14|
;;;1301   
                          ENDP


                          AREA ||i.eap_aka_learn_ids||, CODE, READONLY, ALIGN=2

                  eap_aka_learn_ids PROC
;;;268    
;;;269    static int eap_aka_learn_ids(struct eap_aka_data *data,
000000  b570              PUSH     {r4-r6,lr}
;;;270    			     struct eap_sim_attrs *attr)
;;;271    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;272    	if (attr->next_pseudonym) {
000006  69e8              LDR      r0,[r5,#0x1c]
000008  b310              CBZ      r0,|L16.80|
;;;273    		os_free(data->pseudonym);
00000a  f8d40160          LDR      r0,[r4,#0x160]
00000e  f7fffffe          BL       os_free
;;;274    		data->pseudonym = os_malloc(attr->next_pseudonym_len);
000012  6ce8              LDR      r0,[r5,#0x4c]
000014  f7fffffe          BL       os_malloc
000018  f8c40160          STR      r0,[r4,#0x160]
;;;275    		if (data->pseudonym == NULL) {
00001c  f8d40160          LDR      r0,[r4,#0x160]
000020  b930              CBNZ     r0,|L16.48|
;;;276    			wpa_printf(MSG_INFO, "EAP-AKA: (encr) No memory for "
000022  a11f              ADR      r1,|L16.160|
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       wpa_printf
;;;277    				   "next pseudonym");
;;;278    			return -1;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L16.46|
;;;279    		}
;;;280    		os_memcpy(data->pseudonym, attr->next_pseudonym,
;;;281    			  attr->next_pseudonym_len);
;;;282    		data->pseudonym_len = attr->next_pseudonym_len;
;;;283    		wpa_hexdump_ascii(MSG_DEBUG,
;;;284    				  "EAP-AKA: (encr) AT_NEXT_PSEUDONYM",
;;;285    				  data->pseudonym,
;;;286    				  data->pseudonym_len);
;;;287    	}
;;;288    
;;;289    	if (attr->next_reauth_id) {
;;;290    		os_free(data->reauth_id);
;;;291    		data->reauth_id = os_malloc(attr->next_reauth_id_len);
;;;292    		if (data->reauth_id == NULL) {
;;;293    			wpa_printf(MSG_INFO, "EAP-AKA: (encr) No memory for "
;;;294    				   "next reauth_id");
;;;295    			return -1;
;;;296    		}
;;;297    		os_memcpy(data->reauth_id, attr->next_reauth_id,
;;;298    			  attr->next_reauth_id_len);
;;;299    		data->reauth_id_len = attr->next_reauth_id_len;
;;;300    		wpa_hexdump_ascii(MSG_DEBUG,
;;;301    				  "EAP-AKA: (encr) AT_NEXT_REAUTH_ID",
;;;302    				  data->reauth_id,
;;;303    				  data->reauth_id_len);
;;;304    	}
;;;305    
;;;306    	return 0;
;;;307    }
00002e  bd70              POP      {r4-r6,pc}
                  |L16.48|
000030  6cea              LDR      r2,[r5,#0x4c]         ;280
000032  69e9              LDR      r1,[r5,#0x1c]         ;280
000034  f8d40160          LDR      r0,[r4,#0x160]        ;280
000038  f7fffffe          BL       os_memcpy
00003c  6ce8              LDR      r0,[r5,#0x4c]         ;282
00003e  f8c40164          STR      r0,[r4,#0x164]        ;282
000042  a123              ADR      r1,|L16.208|
000044  2000              MOVS     r0,#0                 ;283
000046  f50472b0          ADD      r2,r4,#0x160          ;283
00004a  ca0c              LDM      r2,{r2,r3}            ;283
00004c  f7fffffe          BL       wpa_hexdump_ascii
                  |L16.80|
000050  6a28              LDR      r0,[r5,#0x20]         ;289
000052  b310              CBZ      r0,|L16.154|
000054  f8d40168          LDR      r0,[r4,#0x168]        ;290
000058  f7fffffe          BL       os_free
00005c  6d28              LDR      r0,[r5,#0x50]         ;291
00005e  f7fffffe          BL       os_malloc
000062  f8c40168          STR      r0,[r4,#0x168]        ;291
000066  f8d40168          LDR      r0,[r4,#0x168]        ;292
00006a  b930              CBNZ     r0,|L16.122|
00006c  a121              ADR      r1,|L16.244|
00006e  2000              MOVS     r0,#0                 ;293
000070  f7fffffe          BL       wpa_printf
000074  f04f30ff          MOV      r0,#0xffffffff        ;295
000078  e7d9              B        |L16.46|
                  |L16.122|
00007a  6d2a              LDR      r2,[r5,#0x50]         ;297
00007c  6a29              LDR      r1,[r5,#0x20]         ;297
00007e  f8d40168          LDR      r0,[r4,#0x168]        ;297
000082  f7fffffe          BL       os_memcpy
000086  6d28              LDR      r0,[r5,#0x50]         ;299
000088  f8c4016c          STR      r0,[r4,#0x16c]        ;299
00008c  a125              ADR      r1,|L16.292|
00008e  2000              MOVS     r0,#0                 ;300
000090  f50472b4          ADD      r2,r4,#0x168          ;300
000094  ca0c              LDM      r2,{r2,r3}            ;300
000096  f7fffffe          BL       wpa_hexdump_ascii
                  |L16.154|
00009a  2000              MOVS     r0,#0                 ;306
00009c  e7c7              B        |L16.46|
;;;308    
                          ENDP

00009e  0000              DCW      0x0000
                  |L16.160|
0000a0  4541502d          DCB      "EAP-AKA: (encr) No memory for next pseudonym",0
0000a4  414b413a
0000a8  2028656e
0000ac  63722920
0000b0  4e6f206d
0000b4  656d6f72
0000b8  7920666f
0000bc  72206e65
0000c0  78742070
0000c4  73657564
0000c8  6f6e796d
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L16.208|
0000d0  4541502d          DCB      "EAP-AKA: (encr) AT_NEXT_PSEUDONYM",0
0000d4  414b413a
0000d8  2028656e
0000dc  63722920
0000e0  41545f4e
0000e4  4558545f
0000e8  50534555
0000ec  444f4e59
0000f0  4d00    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L16.244|
0000f4  4541502d          DCB      "EAP-AKA: (encr) No memory for next reauth_id",0
0000f8  414b413a
0000fc  2028656e
000100  63722920
000104  4e6f206d
000108  656d6f72
00010c  7920666f
000110  72206e65
000114  78742072
000118  65617574
00011c  685f6964
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L16.292|
000124  4541502d          DCB      "EAP-AKA: (encr) AT_NEXT_REAUTH_ID",0
000128  414b413a
00012c  2028656e
000130  63722920
000134  41545f4e
000138  4558545f
00013c  52454155
000140  54485f49
000144  4400    
000146  00                DCB      0
000147  00                DCB      0

                          AREA ||i.eap_aka_prime_derive_keys||, CODE, READONLY, ALIGN=1

                  eap_aka_prime_derive_keys PROC
;;;113    #else /* EAP_AKA_PRIME || EAP_SERVER_AKA_PRIME */
;;;114    static inline void eap_aka_prime_derive_keys(const u8 *identity,
000000  b5f0              PUSH     {r4-r7,lr}
;;;115    					     size_t identity_len,
;;;116    					     const u8 *ik, const u8 *ck,
;;;117    					     u8 *k_encr, u8 *k_aut, u8 *k_re,
;;;118    					     u8 *msk, u8 *emsk)
;;;119    {
000002  ac05              ADD      r4,sp,#0x14
000004  e89410f0          LDM      r4,{r4-r7,r12}
;;;120    }
000008  bdf0              POP      {r4-r7,pc}
;;;121    
                          ENDP


                          AREA ||i.eap_aka_prime_derive_keys_reauth||, CODE, READONLY, ALIGN=1

                  eap_aka_prime_derive_keys_reauth PROC
;;;121    
;;;122    static inline int eap_aka_prime_derive_keys_reauth(const u8 *k_re, u16 counter,
000000  b5f0              PUSH     {r4-r7,lr}
;;;123    						   const u8 *identity,
;;;124    						   size_t identity_len,
;;;125    						   const u8 *nonce_s, u8 *msk,
;;;126    						   u8 *emsk)
;;;127    {
000002  4607              MOV      r7,r0
000004  ac05              ADD      r4,sp,#0x14
000006  cc70              LDM      r4,{r4-r6}
;;;128    	return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
;;;129    }
00000c  bdf0              POP      {r4-r7,pc}
;;;130    
                          ENDP


                          AREA ||i.eap_aka_process||, CODE, READONLY, ALIGN=2

                  eap_aka_process PROC
;;;1146   
;;;1147   static struct wpabuf * eap_aka_process(struct eap_sm *sm, void *priv,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1148   				       struct eap_method_ret *ret,
;;;1149   				       const struct wpabuf *reqData)
;;;1150   {
000004  b0ab              SUB      sp,sp,#0xac
000006  4614              MOV      r4,r2
000008  4699              MOV      r9,r3
;;;1151   	struct eap_aka_data *data = priv;
00000a  9d2c              LDR      r5,[sp,#0xb0]
;;;1152   	const struct eap_hdr *req;
;;;1153   	u8 subtype, id;
;;;1154   	struct wpabuf *res;
;;;1155   	const u8 *pos;
;;;1156   	struct eap_sim_attrs attr;
;;;1157   	size_t len;
;;;1158   
;;;1159   	wpa_hexdump_buf(MSG_DEBUG, "EAP-AKA: EAP data", reqData);
00000c  464a              MOV      r2,r9
00000e  a172              ADR      r1,|L19.472|
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       wpa_hexdump_buf
;;;1160   	if (eap_get_config_identity(sm, &len) == NULL) {
000016  a903              ADD      r1,sp,#0xc
000018  982b              LDR      r0,[sp,#0xac]
00001a  f7fffffe          BL       eap_get_config_identity
00001e  b960              CBNZ     r0,|L19.58|
;;;1161   		wpa_printf(MSG_INFO, "EAP-AKA: Identity not configured");
000020  a172              ADR      r1,|L19.492|
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       wpa_printf
;;;1162   		eap_sm_request_identity(sm);
000028  982b              LDR      r0,[sp,#0xac]
00002a  f7fffffe          BL       eap_sm_request_identity
;;;1163   		ret->ignore = TRUE;
00002e  2001              MOVS     r0,#1
000030  6020              STR      r0,[r4,#0]
;;;1164   		return NULL;
000032  2000              MOVS     r0,#0
                  |L19.52|
;;;1165   	}
;;;1166   
;;;1167   	pos = eap_hdr_validate(EAP_VENDOR_IETF, data->eap_method, reqData,
;;;1168   			       &len);
;;;1169   	if (pos == NULL || len < 1) {
;;;1170   		ret->ignore = TRUE;
;;;1171   		return NULL;
;;;1172   	}
;;;1173   	req = wpabuf_head(reqData);
;;;1174   	id = req->identifier;
;;;1175   	len = be_to_host16(req->length);
;;;1176   
;;;1177   	ret->ignore = FALSE;
;;;1178   	ret->methodState = METHOD_MAY_CONT;
;;;1179   	ret->decision = DECISION_FAIL;
;;;1180   	ret->allowNotifications = TRUE;
;;;1181   
;;;1182   	subtype = *pos++;
;;;1183   	wpa_printf(MSG_DEBUG, "EAP-AKA: Subtype=%d", subtype);
;;;1184   	pos += 2; /* Reserved */
;;;1185   
;;;1186   	if (eap_sim_parse_attr(pos, wpabuf_head_u8(reqData) + len, &attr,
;;;1187   			       data->eap_method == EAP_TYPE_AKA_PRIME ? 2 : 1,
;;;1188   			       0)) {
;;;1189   		res = eap_aka_client_error(data, id,
;;;1190   					   EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1191   		goto done;
;;;1192   	}
;;;1193   
;;;1194   	switch (subtype) {
;;;1195   	case EAP_AKA_SUBTYPE_IDENTITY:
;;;1196   		res = eap_aka_process_identity(sm, data, id, reqData, &attr);
;;;1197   		break;
;;;1198   	case EAP_AKA_SUBTYPE_CHALLENGE:
;;;1199   		res = eap_aka_process_challenge(sm, data, id, reqData, &attr);
;;;1200   		break;
;;;1201   	case EAP_AKA_SUBTYPE_NOTIFICATION:
;;;1202   		res = eap_aka_process_notification(sm, data, id, reqData,
;;;1203   						   &attr);
;;;1204   		break;
;;;1205   	case EAP_AKA_SUBTYPE_REAUTHENTICATION:
;;;1206   		res = eap_aka_process_reauthentication(sm, data, id, reqData,
;;;1207   						       &attr);
;;;1208   		break;
;;;1209   	case EAP_AKA_SUBTYPE_CLIENT_ERROR:
;;;1210   		wpa_printf(MSG_DEBUG, "EAP-AKA: subtype Client-Error");
;;;1211   		res = eap_aka_client_error(data, id,
;;;1212   					   EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1213   		break;
;;;1214   	default:
;;;1215   		wpa_printf(MSG_DEBUG, "EAP-AKA: Unknown subtype=%d", subtype);
;;;1216   		res = eap_aka_client_error(data, id,
;;;1217   					   EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1218   		break;
;;;1219   	}
;;;1220   
;;;1221   done:
;;;1222   	if (data->state == FAILURE) {
;;;1223   		ret->decision = DECISION_FAIL;
;;;1224   		ret->methodState = METHOD_DONE;
;;;1225   	} else if (data->state == SUCCESS) {
;;;1226   		ret->decision = data->use_result_ind ?
;;;1227   			DECISION_UNCOND_SUCC : DECISION_COND_SUCC;
;;;1228   		/*
;;;1229   		 * It is possible for the server to reply with AKA
;;;1230   		 * Notification, so we must allow the method to continue and
;;;1231   		 * not only accept EAP-Success at this point.
;;;1232   		 */
;;;1233   		ret->methodState = data->use_result_ind ?
;;;1234   			METHOD_DONE : METHOD_MAY_CONT;
;;;1235   	} else if (data->state == RESULT_FAILURE)
;;;1236   		ret->methodState = METHOD_CONT;
;;;1237   	else if (data->state == RESULT_SUCCESS)
;;;1238   		ret->methodState = METHOD_CONT;
;;;1239   
;;;1240   	if (ret->methodState == METHOD_DONE) {
;;;1241   		ret->allowNotifications = FALSE;
;;;1242   	}
;;;1243   
;;;1244   	return res;
;;;1245   }
000034  b02f              ADD      sp,sp,#0xbc
000036  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.58|
00003a  f8951198          LDRB     r1,[r5,#0x198]        ;1167
00003e  ab03              ADD      r3,sp,#0xc            ;1167
000040  464a              MOV      r2,r9                 ;1167
000042  2000              MOVS     r0,#0                 ;1167
000044  f7fffffe          BL       eap_hdr_validate
000048  4607              MOV      r7,r0                 ;1167
00004a  b10f              CBZ      r7,|L19.80|
00004c  9803              LDR      r0,[sp,#0xc]          ;1169
00004e  b918              CBNZ     r0,|L19.88|
                  |L19.80|
000050  2001              MOVS     r0,#1                 ;1170
000052  6020              STR      r0,[r4,#0]            ;1170
000054  2000              MOVS     r0,#0                 ;1171
000056  e7ed              B        |L19.52|
                  |L19.88|
000058  4648              MOV      r0,r9                 ;1173
00005a  f7fffffe          BL       wpabuf_head
00005e  4680              MOV      r8,r0                 ;1173
000060  f898b001          LDRB     r11,[r8,#1]           ;1174
000064  f8b80002          LDRH     r0,[r8,#2]            ;1175
000068  f44f417f          MOV      r1,#0xff00            ;1175
00006c  ea012000          AND      r0,r1,r0,LSL #8       ;1175
000070  f8b81002          LDRH     r1,[r8,#2]            ;1175
000074  ea402011          ORR      r0,r0,r1,LSR #8       ;1175
000078  9003              STR      r0,[sp,#0xc]          ;1175
00007a  2000              MOVS     r0,#0                 ;1177
00007c  6020              STR      r0,[r4,#0]            ;1177
00007e  2003              MOVS     r0,#3                 ;1178
000080  7120              STRB     r0,[r4,#4]            ;1178
000082  2000              MOVS     r0,#0                 ;1179
000084  7160              STRB     r0,[r4,#5]            ;1179
000086  2001              MOVS     r0,#1                 ;1180
000088  60a0              STR      r0,[r4,#8]            ;1180
00008a  f817ab01          LDRB     r10,[r7],#1           ;1182
00008e  4652              MOV      r2,r10                ;1183
000090  a15f              ADR      r1,|L19.528|
000092  2000              MOVS     r0,#0                 ;1183
000094  f7fffffe          BL       wpa_printf
000098  1cbf              ADDS     r7,r7,#2              ;1184
00009a  4648              MOV      r0,r9                 ;1186
00009c  f7fffffe          BL       wpabuf_head_u8
0000a0  9903              LDR      r1,[sp,#0xc]          ;1186
0000a2  4408              ADD      r0,r0,r1              ;1186
0000a4  2300              MOVS     r3,#0                 ;1186
0000a6  9300              STR      r3,[sp,#0]            ;1186
0000a8  9002              STR      r0,[sp,#8]            ;1186
0000aa  f8950198          LDRB     r0,[r5,#0x198]        ;1186
0000ae  2832              CMP      r0,#0x32              ;1186
0000b0  d101              BNE      |L19.182|
0000b2  2002              MOVS     r0,#2                 ;1187
0000b4  e000              B        |L19.184|
                  |L19.182|
0000b6  2001              MOVS     r0,#1                 ;1187
                  |L19.184|
0000b8  4603              MOV      r3,r0                 ;1187
0000ba  aa04              ADD      r2,sp,#0x10           ;1187
0000bc  4638              MOV      r0,r7                 ;1187
0000be  9902              LDR      r1,[sp,#8]            ;1187
0000c0  f7fffffe          BL       eap_sim_parse_attr
0000c4  b130              CBZ      r0,|L19.212|
0000c6  2200              MOVS     r2,#0                 ;1189
0000c8  4659              MOV      r1,r11                ;1189
0000ca  4628              MOV      r0,r5                 ;1189
0000cc  f7fffffe          BL       eap_aka_client_error
0000d0  4606              MOV      r6,r0                 ;1189
0000d2  e052              B        |L19.378|
                  |L19.212|
0000d4  f1ba0f0c          CMP      r10,#0xc              ;1194
0000d8  d022              BEQ      |L19.288|
0000da  dc06              BGT      |L19.234|
0000dc  f1ba0f01          CMP      r10,#1                ;1194
0000e0  d014              BEQ      |L19.268|
0000e2  f1ba0f05          CMP      r10,#5                ;1194
0000e6  d13a              BNE      |L19.350|
0000e8  e006              B        |L19.248|
                  |L19.234|
0000ea  f1ba0f0d          CMP      r10,#0xd              ;1194
0000ee  d021              BEQ      |L19.308|
0000f0  f1ba0f0e          CMP      r10,#0xe              ;1194
0000f4  d133              BNE      |L19.350|
0000f6  e027              B        |L19.328|
                  |L19.248|
0000f8  ab04              ADD      r3,sp,#0x10           ;1196
0000fa  9300              STR      r3,[sp,#0]            ;1196
0000fc  464b              MOV      r3,r9                 ;1196
0000fe  465a              MOV      r2,r11                ;1196
000100  4629              MOV      r1,r5                 ;1196
000102  982b              LDR      r0,[sp,#0xac]         ;1196
000104  f7fffffe          BL       eap_aka_process_identity
000108  4606              MOV      r6,r0                 ;1196
00010a  e034              B        |L19.374|
                  |L19.268|
00010c  ab04              ADD      r3,sp,#0x10           ;1199
00010e  9300              STR      r3,[sp,#0]            ;1199
000110  464b              MOV      r3,r9                 ;1199
000112  465a              MOV      r2,r11                ;1199
000114  4629              MOV      r1,r5                 ;1199
000116  982b              LDR      r0,[sp,#0xac]         ;1199
000118  f7fffffe          BL       eap_aka_process_challenge
00011c  4606              MOV      r6,r0                 ;1199
00011e  e02a              B        |L19.374|
                  |L19.288|
000120  ab04              ADD      r3,sp,#0x10           ;1202
000122  9300              STR      r3,[sp,#0]            ;1202
000124  464b              MOV      r3,r9                 ;1202
000126  465a              MOV      r2,r11                ;1202
000128  4629              MOV      r1,r5                 ;1202
00012a  982b              LDR      r0,[sp,#0xac]         ;1202
00012c  f7fffffe          BL       eap_aka_process_notification
000130  4606              MOV      r6,r0                 ;1202
000132  e020              B        |L19.374|
                  |L19.308|
000134  ab04              ADD      r3,sp,#0x10           ;1206
000136  9300              STR      r3,[sp,#0]            ;1206
000138  464b              MOV      r3,r9                 ;1206
00013a  465a              MOV      r2,r11                ;1206
00013c  4629              MOV      r1,r5                 ;1206
00013e  982b              LDR      r0,[sp,#0xac]         ;1206
000140  f7fffffe          BL       eap_aka_process_reauthentication
000144  4606              MOV      r6,r0                 ;1206
000146  e016              B        |L19.374|
                  |L19.328|
000148  a136              ADR      r1,|L19.548|
00014a  2000              MOVS     r0,#0                 ;1210
00014c  f7fffffe          BL       wpa_printf
000150  2200              MOVS     r2,#0                 ;1211
000152  4659              MOV      r1,r11                ;1211
000154  4628              MOV      r0,r5                 ;1211
000156  f7fffffe          BL       eap_aka_client_error
00015a  4606              MOV      r6,r0                 ;1211
00015c  e00b              B        |L19.374|
                  |L19.350|
00015e  4652              MOV      r2,r10                ;1215
000160  a138              ADR      r1,|L19.580|
000162  2000              MOVS     r0,#0                 ;1215
000164  f7fffffe          BL       wpa_printf
000168  2200              MOVS     r2,#0                 ;1216
00016a  4659              MOV      r1,r11                ;1216
00016c  4628              MOV      r0,r5                 ;1216
00016e  f7fffffe          BL       eap_aka_client_error
000172  4606              MOV      r6,r0                 ;1216
000174  bf00              NOP                            ;1218
                  |L19.374|
000176  bf00              NOP                            ;1197
000178  bf00              NOP                            ;1221
                  |L19.378|
00017a  f8d50184          LDR      r0,[r5,#0x184]        ;1222
00017e  2804              CMP      r0,#4                 ;1222
000180  d104              BNE      |L19.396|
000182  2000              MOVS     r0,#0                 ;1223
000184  7160              STRB     r0,[r4,#5]            ;1223
000186  2004              MOVS     r0,#4                 ;1224
000188  7120              STRB     r0,[r4,#4]            ;1224
00018a  e01e              B        |L19.458|
                  |L19.396|
00018c  f8d50184          LDR      r0,[r5,#0x184]        ;1225
000190  2803              CMP      r0,#3                 ;1225
000192  d10e              BNE      |L19.434|
000194  f8d50194          LDR      r0,[r5,#0x194]        ;1226
000198  b108              CBZ      r0,|L19.414|
00019a  2002              MOVS     r0,#2                 ;1227
00019c  e000              B        |L19.416|
                  |L19.414|
00019e  2001              MOVS     r0,#1                 ;1227
                  |L19.416|
0001a0  7160              STRB     r0,[r4,#5]            ;1227
0001a2  f8d50194          LDR      r0,[r5,#0x194]        ;1233
0001a6  b108              CBZ      r0,|L19.428|
0001a8  2004              MOVS     r0,#4                 ;1234
0001aa  e000              B        |L19.430|
                  |L19.428|
0001ac  2003              MOVS     r0,#3                 ;1234
                  |L19.430|
0001ae  7120              STRB     r0,[r4,#4]            ;1234
0001b0  e00b              B        |L19.458|
                  |L19.434|
0001b2  f8d50184          LDR      r0,[r5,#0x184]        ;1235
0001b6  2802              CMP      r0,#2                 ;1235
0001b8  d101              BNE      |L19.446|
0001ba  7120              STRB     r0,[r4,#4]            ;1236
0001bc  e005              B        |L19.458|
                  |L19.446|
0001be  f8d50184          LDR      r0,[r5,#0x184]        ;1237
0001c2  2801              CMP      r0,#1                 ;1237
0001c4  d101              BNE      |L19.458|
0001c6  2002              MOVS     r0,#2                 ;1238
0001c8  7120              STRB     r0,[r4,#4]            ;1238
                  |L19.458|
0001ca  7920              LDRB     r0,[r4,#4]            ;1240
0001cc  2804              CMP      r0,#4                 ;1240
0001ce  d101              BNE      |L19.468|
0001d0  2000              MOVS     r0,#0                 ;1241
0001d2  60a0              STR      r0,[r4,#8]            ;1241
                  |L19.468|
0001d4  4630              MOV      r0,r6                 ;1244
0001d6  e72d              B        |L19.52|
;;;1246   
                          ENDP

                  |L19.472|
0001d8  4541502d          DCB      "EAP-AKA: EAP data",0
0001dc  414b413a
0001e0  20454150
0001e4  20646174
0001e8  6100    
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L19.492|
0001ec  4541502d          DCB      "EAP-AKA: Identity not configured",0
0001f0  414b413a
0001f4  20496465
0001f8  6e746974
0001fc  79206e6f
000200  7420636f
000204  6e666967
000208  75726564
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L19.528|
000210  4541502d          DCB      "EAP-AKA: Subtype=%d",0
000214  414b413a
000218  20537562
00021c  74797065
000220  3d256400
                  |L19.548|
000224  4541502d          DCB      "EAP-AKA: subtype Client-Error",0
000228  414b413a
00022c  20737562
000230  74797065
000234  20436c69
000238  656e742d
00023c  4572726f
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L19.580|
000244  4541502d          DCB      "EAP-AKA: Unknown subtype=%d",0
000248  414b413a
00024c  20556e6b
000250  6e6f776e
000254  20737562
000258  74797065
00025c  3d256400

                          AREA ||i.eap_aka_process_challenge||, CODE, READONLY, ALIGN=2

                  eap_aka_process_challenge PROC
;;;753    
;;;754    static struct wpabuf * eap_aka_process_challenge(struct eap_sm *sm,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;755    						 struct eap_aka_data *data,
;;;756    						 u8 id,
;;;757    						 const struct wpabuf *reqData,
;;;758    						 struct eap_sim_attrs *attr)
;;;759    {
000004  b0ad              SUB      sp,sp,#0xb4
000006  4683              MOV      r11,r0
000008  460c              MOV      r4,r1
00000a  4690              MOV      r8,r2
00000c  4699              MOV      r9,r3
00000e  9d36              LDR      r5,[sp,#0xd8]
;;;760    	const u8 *identity;
;;;761    	size_t identity_len;
;;;762    	int res;
;;;763    	struct eap_sim_attrs eattr;
;;;764    
;;;765    	wpa_printf(MSG_DEBUG, "EAP-AKA: subtype Challenge");
000010  a18a              ADR      r1,|L20.572|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
;;;766    
;;;767    	if (attr->checkcode &&
000018  6b68              LDR      r0,[r5,#0x34]
00001a  b188              CBZ      r0,|L20.64|
;;;768    	    eap_aka_verify_checkcode(data, attr->checkcode,
00001c  4620              MOV      r0,r4
00001e  6e2a              LDR      r2,[r5,#0x60]
000020  6b69              LDR      r1,[r5,#0x34]
000022  f7fffffe          BL       eap_aka_verify_checkcode
000026  b158              CBZ      r0,|L20.64|
;;;769    				     attr->checkcode_len)) {
;;;770    		wpa_printf(MSG_WARNING, "EAP-AKA: Invalid AT_CHECKCODE in the "
000028  a18b              ADR      r1,|L20.600|
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       wpa_printf
;;;771    			   "message");
;;;772    		return eap_aka_client_error(data, id,
000030  2200              MOVS     r2,#0
000032  4641              MOV      r1,r8
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       eap_aka_client_error
                  |L20.58|
;;;773    					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;774    	}
;;;775    
;;;776    #ifdef EAP_AKA_PRIME
;;;777    	if (data->eap_method == EAP_TYPE_AKA_PRIME) {
;;;778    		if (!attr->kdf_input || attr->kdf_input_len == 0) {
;;;779    			wpa_printf(MSG_WARNING, "EAP-AKA': Challenge message "
;;;780    				   "did not include non-empty AT_KDF_INPUT");
;;;781    			/* Fail authentication as if AUTN had been incorrect */
;;;782    			return eap_aka_authentication_reject(data, id);
;;;783    		}
;;;784    		os_free(data->network_name);
;;;785    		data->network_name = os_malloc(attr->kdf_input_len);
;;;786    		if (data->network_name == NULL) {
;;;787    			wpa_printf(MSG_WARNING, "EAP-AKA': No memory for "
;;;788    				   "storing Network Name");
;;;789    			return eap_aka_authentication_reject(data, id);
;;;790    		}
;;;791    		os_memcpy(data->network_name, attr->kdf_input,
;;;792    			  attr->kdf_input_len);
;;;793    		data->network_name_len = attr->kdf_input_len;
;;;794    		wpa_hexdump_ascii(MSG_DEBUG, "EAP-AKA': Network Name "
;;;795    				  "(AT_KDF_INPUT)",
;;;796    				  data->network_name, data->network_name_len);
;;;797    		/* TODO: check Network Name per 3GPP.33.402 */
;;;798    
;;;799    		if (!eap_aka_prime_kdf_valid(data, attr))
;;;800    			return eap_aka_authentication_reject(data, id);
;;;801    
;;;802    		if (attr->kdf[0] != EAP_AKA_PRIME_KDF)
;;;803    			return eap_aka_prime_kdf_neg(data, id, attr);
;;;804    
;;;805    		data->kdf = EAP_AKA_PRIME_KDF;
;;;806    		wpa_printf(MSG_DEBUG, "EAP-AKA': KDF %d selected", data->kdf);
;;;807    	}
;;;808    
;;;809    	if (data->eap_method == EAP_TYPE_AKA && attr->bidding) {
;;;810    		u16 flags = WPA_GET_BE16(attr->bidding);
;;;811    		if ((flags & EAP_AKA_BIDDING_FLAG_D) &&
;;;812    		    eap_allowed_method(sm, EAP_VENDOR_IETF,
;;;813    				       EAP_TYPE_AKA_PRIME)) {
;;;814    			wpa_printf(MSG_WARNING, "EAP-AKA: Bidding down from "
;;;815    				   "AKA' to AKA detected");
;;;816    			/* Fail authentication as if AUTN had been incorrect */
;;;817    			return eap_aka_authentication_reject(data, id);
;;;818    		}
;;;819    	}
;;;820    #endif /* EAP_AKA_PRIME */
;;;821    
;;;822    	data->reauth = 0;
;;;823    	if (!attr->mac || !attr->rand || !attr->autn) {
;;;824    		wpa_printf(MSG_WARNING, "EAP-AKA: Challenge message "
;;;825    			   "did not include%s%s%s",
;;;826    			   !attr->mac ? " AT_MAC" : "",
;;;827    			   !attr->rand ? " AT_RAND" : "",
;;;828    			   !attr->autn ? " AT_AUTN" : "");
;;;829    		return eap_aka_client_error(data, id,
;;;830    					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;831    	}
;;;832    	os_memcpy(data->rand, attr->rand, EAP_AKA_RAND_LEN);
;;;833    	os_memcpy(data->autn, attr->autn, EAP_AKA_AUTN_LEN);
;;;834    
;;;835    	res = eap_aka_umts_auth(sm, data);
;;;836    	if (res == -1) {
;;;837    		wpa_printf(MSG_WARNING, "EAP-AKA: UMTS authentication "
;;;838    			   "failed (AUTN)");
;;;839    		return eap_aka_authentication_reject(data, id);
;;;840    	} else if (res == -2) {
;;;841    		wpa_printf(MSG_WARNING, "EAP-AKA: UMTS authentication "
;;;842    			   "failed (AUTN seq# -> AUTS)");
;;;843    		return eap_aka_synchronization_failure(data, id);
;;;844    	} else if (res) {
;;;845    		wpa_printf(MSG_WARNING, "EAP-AKA: UMTS authentication failed");
;;;846    		return eap_aka_client_error(data, id,
;;;847    					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;848    	}
;;;849    #ifdef EAP_AKA_PRIME
;;;850    	if (data->eap_method == EAP_TYPE_AKA_PRIME) {
;;;851    		/* Note: AUTN = (SQN ^ AK) || AMF || MAC which gives us the
;;;852    		 * needed 6-octet SQN ^ AK for CK',IK' derivation */
;;;853    		u16 amf = WPA_GET_BE16(data->autn + 6);
;;;854    		if (!(amf & 0x8000)) {
;;;855    			wpa_printf(MSG_WARNING, "EAP-AKA': AMF separation bit "
;;;856    				   "not set (AMF=0x%4x)", amf);
;;;857    			return eap_aka_authentication_reject(data, id);
;;;858    		}
;;;859    		eap_aka_prime_derive_ck_ik_prime(data->ck, data->ik,
;;;860    						 data->autn,
;;;861    						 data->network_name,
;;;862    						 data->network_name_len);
;;;863    	}
;;;864    #endif /* EAP_AKA_PRIME */
;;;865    	if (data->last_eap_identity) {
;;;866    		identity = data->last_eap_identity;
;;;867    		identity_len = data->last_eap_identity_len;
;;;868    	} else if (data->pseudonym) {
;;;869    		identity = data->pseudonym;
;;;870    		identity_len = data->pseudonym_len;
;;;871    	} else
;;;872    		identity = eap_get_config_identity(sm, &identity_len);
;;;873    	wpa_hexdump_ascii(MSG_DEBUG, "EAP-AKA: Selected identity for MK "
;;;874    			  "derivation", identity, identity_len);
;;;875    	if (data->eap_method == EAP_TYPE_AKA_PRIME) {
;;;876    		eap_aka_prime_derive_keys(identity, identity_len, data->ik,
;;;877    					  data->ck, data->k_encr, data->k_aut,
;;;878    					  data->k_re, data->msk, data->emsk);
;;;879    	} else {
;;;880    		eap_aka_derive_mk(identity, identity_len, data->ik, data->ck,
;;;881    				  data->mk);
;;;882    		eap_sim_derive_keys(data->mk, data->k_encr, data->k_aut,
;;;883    				    data->msk, data->emsk);
;;;884    	}
;;;885    	if (eap_aka_verify_mac(data, reqData, attr->mac, (u8 *) "", 0)) {
;;;886    		wpa_printf(MSG_WARNING, "EAP-AKA: Challenge message "
;;;887    			   "used invalid AT_MAC");
;;;888    		return eap_aka_client_error(data, id,
;;;889    					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;890    	}
;;;891    
;;;892    	/* Old reauthentication and pseudonym identities must not be used
;;;893    	 * anymore. In other words, if no new identities are received, full
;;;894    	 * authentication will be used on next reauthentication. */
;;;895    	eap_aka_clear_identities(data, CLEAR_PSEUDONYM | CLEAR_REAUTH_ID |
;;;896    				 CLEAR_EAP_ID);
;;;897    
;;;898    	if (attr->encr_data) {
;;;899    		u8 *decrypted;
;;;900    		decrypted = eap_sim_parse_encr(data->k_encr, attr->encr_data,
;;;901    					       attr->encr_data_len, attr->iv,
;;;902    					       &eattr, 0);
;;;903    		if (decrypted == NULL) {
;;;904    			return eap_aka_client_error(
;;;905    				data, id, EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;906    		}
;;;907    		eap_aka_learn_ids(data, &eattr);
;;;908    		os_free(decrypted);
;;;909    	}
;;;910    
;;;911    	if (data->result_ind && attr->result_ind)
;;;912    		data->use_result_ind = 1;
;;;913    
;;;914    	if (data->state != FAILURE && data->state != RESULT_FAILURE) {
;;;915    		eap_aka_state(data, data->use_result_ind ?
;;;916    			      RESULT_SUCCESS : SUCCESS);
;;;917    	}
;;;918    
;;;919    	data->num_id_req = 0;
;;;920    	data->num_notification = 0;
;;;921    	/* RFC 4187 specifies that counter is initialized to one after
;;;922    	 * fullauth, but initializing it to zero makes it easier to implement
;;;923    	 * reauth verification. */
;;;924    	data->counter = 0;
;;;925    	return eap_aka_response_challenge(data, id);
;;;926    }
00003a  b02d              ADD      sp,sp,#0xb4
00003c  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.64|
000040  2000              MOVS     r0,#0                 ;822
000042  f8c40170          STR      r0,[r4,#0x170]        ;822
000046  68a8              LDR      r0,[r5,#8]            ;823
000048  b118              CBZ      r0,|L20.82|
00004a  6828              LDR      r0,[r5,#0]            ;823
00004c  b108              CBZ      r0,|L20.82|
00004e  6868              LDR      r0,[r5,#4]            ;823
000050  b9d8              CBNZ     r0,|L20.138|
                  |L20.82|
000052  6868              LDR      r0,[r5,#4]            ;824
000054  b908              CBNZ     r0,|L20.90|
000056  a38c              ADR      r3,|L20.648|
000058  e000              B        |L20.92|
                  |L20.90|
00005a  a38a              ADR      r3,|L20.644|
                  |L20.92|
00005c  9300              STR      r3,[sp,#0]            ;828
00005e  6828              LDR      r0,[r5,#0]            ;828
000060  b908              CBNZ     r0,|L20.102|
000062  a08c              ADR      r0,|L20.660|
000064  e000              B        |L20.104|
                  |L20.102|
000066  a087              ADR      r0,|L20.644|
                  |L20.104|
000068  4603              MOV      r3,r0                 ;827
00006a  68a8              LDR      r0,[r5,#8]            ;827
00006c  b908              CBNZ     r0,|L20.114|
00006e  a08c              ADR      r0,|L20.672|
000070  e000              B        |L20.116|
                  |L20.114|
000072  a084              ADR      r0,|L20.644|
                  |L20.116|
000074  4602              MOV      r2,r0                 ;826
000076  a18c              ADR      r1,|L20.680|
000078  2000              MOVS     r0,#0                 ;826
00007a  f7fffffe          BL       wpa_printf
00007e  2200              MOVS     r2,#0                 ;829
000080  4641              MOV      r1,r8                 ;829
000082  4620              MOV      r0,r4                 ;829
000084  f7fffffe          BL       eap_aka_client_error
000088  e7d7              B        |L20.58|
                  |L20.138|
00008a  2210              MOVS     r2,#0x10              ;832
00008c  f5047094          ADD      r0,r4,#0x128          ;832
000090  6829              LDR      r1,[r5,#0]            ;832
000092  f7fffffe          BL       os_memcpy
000096  2210              MOVS     r2,#0x10              ;833
000098  f504709c          ADD      r0,r4,#0x138          ;833
00009c  6869              LDR      r1,[r5,#4]            ;833
00009e  f7fffffe          BL       os_memcpy
0000a2  4621              MOV      r1,r4                 ;835
0000a4  4658              MOV      r0,r11                ;835
0000a6  f7fffffe          BL       eap_aka_umts_auth
0000aa  4607              MOV      r7,r0                 ;835
0000ac  1c78              ADDS     r0,r7,#1              ;836
0000ae  d107              BNE      |L20.192|
0000b0  a18a              ADR      r1,|L20.732|
0000b2  f7fffffe          BL       wpa_printf
0000b6  4641              MOV      r1,r8                 ;839
0000b8  4620              MOV      r0,r4                 ;839
0000ba  f7fffffe          BL       eap_aka_authentication_reject
0000be  e7bc              B        |L20.58|
                  |L20.192|
0000c0  1cb8              ADDS     r0,r7,#2              ;840
0000c2  d107              BNE      |L20.212|
0000c4  a190              ADR      r1,|L20.776|
0000c6  f7fffffe          BL       wpa_printf
0000ca  4641              MOV      r1,r8                 ;843
0000cc  4620              MOV      r0,r4                 ;843
0000ce  f7fffffe          BL       eap_aka_synchronization_failure
0000d2  e7b2              B        |L20.58|
                  |L20.212|
0000d4  b14f              CBZ      r7,|L20.234|
0000d6  a19a              ADR      r1,|L20.832|
0000d8  2000              MOVS     r0,#0                 ;845
0000da  f7fffffe          BL       wpa_printf
0000de  2200              MOVS     r2,#0                 ;846
0000e0  4641              MOV      r1,r8                 ;846
0000e2  4620              MOV      r0,r4                 ;846
0000e4  f7fffffe          BL       eap_aka_client_error
0000e8  e7a7              B        |L20.58|
                  |L20.234|
0000ea  f8d4017c          LDR      r0,[r4,#0x17c]        ;865
0000ee  b128              CBZ      r0,|L20.252|
0000f0  f8d4617c          LDR      r6,[r4,#0x17c]        ;866
0000f4  f8d40180          LDR      r0,[r4,#0x180]        ;867
0000f8  902c              STR      r0,[sp,#0xb0]         ;867
0000fa  e00d              B        |L20.280|
                  |L20.252|
0000fc  f8d40160          LDR      r0,[r4,#0x160]        ;868
000100  b128              CBZ      r0,|L20.270|
000102  f8d46160          LDR      r6,[r4,#0x160]        ;869
000106  f8d40164          LDR      r0,[r4,#0x164]        ;870
00010a  902c              STR      r0,[sp,#0xb0]         ;870
00010c  e004              B        |L20.280|
                  |L20.270|
00010e  a92c              ADD      r1,sp,#0xb0           ;872
000110  4658              MOV      r0,r11                ;872
000112  f7fffffe          BL       eap_get_config_identity
000116  4606              MOV      r6,r0                 ;872
                  |L20.280|
000118  4632              MOV      r2,r6                 ;873
00011a  a192              ADR      r1,|L20.868|
00011c  2000              MOVS     r0,#0                 ;873
00011e  9b2c              LDR      r3,[sp,#0xb0]         ;873
000120  f7fffffe          BL       wpa_hexdump_ascii
000124  f8940198          LDRB     r0,[r4,#0x198]        ;875
000128  2832              CMP      r0,#0x32              ;875
00012a  d114              BNE      |L20.342|
00012c  f10403e8          ADD      r3,r4,#0xe8           ;876
000130  f10402a8          ADD      r2,r4,#0xa8           ;876
000134  f1040188          ADD      r1,r4,#0x88           ;876
000138  f1040058          ADD      r0,r4,#0x58           ;876
00013c  e9cd2303          STRD     r2,r3,[sp,#0xc]       ;876
000140  e9cd0101          STRD     r0,r1,[sp,#4]         ;876
000144  3b70              SUBS     r3,r3,#0x70           ;876
000146  9300              STR      r3,[sp,#0]            ;876
000148  3b68              SUBS     r3,r3,#0x68           ;876
00014a  4622              MOV      r2,r4                 ;876
00014c  4630              MOV      r0,r6                 ;876
00014e  992c              LDR      r1,[sp,#0xb0]         ;876
000150  f7fffffe          BL       eap_aka_prime_derive_keys
000154  e014              B        |L20.384|
                  |L20.342|
000156  f1040344          ADD      r3,r4,#0x44           ;880
00015a  9300              STR      r3,[sp,#0]            ;880
00015c  3b34              SUBS     r3,r3,#0x34           ;880
00015e  4622              MOV      r2,r4                 ;880
000160  4630              MOV      r0,r6                 ;880
000162  992c              LDR      r1,[sp,#0xb0]         ;880
000164  f7fffffe          BL       eap_aka_derive_mk
000168  f10403e8          ADD      r3,r4,#0xe8           ;882
00016c  9300              STR      r3,[sp,#0]            ;882
00016e  3b40              SUBS     r3,r3,#0x40           ;882
000170  f1040258          ADD      r2,r4,#0x58           ;882
000174  f1040178          ADD      r1,r4,#0x78           ;882
000178  f1040044          ADD      r0,r4,#0x44           ;882
00017c  f7fffffe          BL       eap_sim_derive_keys
                  |L20.384|
000180  2300              MOVS     r3,#0                 ;885
000182  9300              STR      r3,[sp,#0]            ;885
000184  a33f              ADR      r3,|L20.644|
000186  4649              MOV      r1,r9                 ;885
000188  4620              MOV      r0,r4                 ;885
00018a  68aa              LDR      r2,[r5,#8]            ;885
00018c  f7fffffe          BL       eap_aka_verify_mac
000190  b148              CBZ      r0,|L20.422|
000192  a180              ADR      r1,|L20.916|
000194  2000              MOVS     r0,#0                 ;886
000196  f7fffffe          BL       wpa_printf
00019a  2200              MOVS     r2,#0                 ;888
00019c  4641              MOV      r1,r8                 ;888
00019e  4620              MOV      r0,r4                 ;888
0001a0  f7fffffe          BL       eap_aka_client_error
0001a4  e749              B        |L20.58|
                  |L20.422|
0001a6  2107              MOVS     r1,#7                 ;895
0001a8  4620              MOV      r0,r4                 ;895
0001aa  f7fffffe          BL       eap_aka_clear_identities
0001ae  6928              LDR      r0,[r5,#0x10]         ;898
0001b0  b1e0              CBZ      r0,|L20.492|
0001b2  2300              MOVS     r3,#0                 ;900
0001b4  aa05              ADD      r2,sp,#0x14           ;900
0001b6  e9cd2300          STRD     r2,r3,[sp,#0]         ;900
0001ba  f1040078          ADD      r0,r4,#0x78           ;900
0001be  e9d53103          LDRD     r3,r1,[r5,#0xc]       ;900
0001c2  6caa              LDR      r2,[r5,#0x48]         ;900
0001c4  f7fffffe          BL       eap_sim_parse_encr
0001c8  4682              MOV      r10,r0                ;900
0001ca  f1ba0f00          CMP      r10,#0                ;903
0001ce  d105              BNE      |L20.476|
0001d0  2200              MOVS     r2,#0                 ;904
0001d2  4641              MOV      r1,r8                 ;904
0001d4  4620              MOV      r0,r4                 ;904
0001d6  f7fffffe          BL       eap_aka_client_error
0001da  e72e              B        |L20.58|
                  |L20.476|
0001dc  a905              ADD      r1,sp,#0x14           ;907
0001de  4620              MOV      r0,r4                 ;907
0001e0  f7fffffe          BL       eap_aka_learn_ids
0001e4  4650              MOV      r0,r10                ;908
0001e6  f7fffffe          BL       os_free
0001ea  bf00              NOP                            ;909
                  |L20.492|
0001ec  f8d40190          LDR      r0,[r4,#0x190]        ;911
0001f0  b128              CBZ      r0,|L20.510|
0001f2  f8d50080          LDR      r0,[r5,#0x80]         ;911
0001f6  b110              CBZ      r0,|L20.510|
0001f8  2001              MOVS     r0,#1                 ;912
0001fa  f8c40194          STR      r0,[r4,#0x194]        ;912
                  |L20.510|
0001fe  f8d40184          LDR      r0,[r4,#0x184]        ;914
000202  2804              CMP      r0,#4                 ;914
000204  d00d              BEQ      |L20.546|
000206  f8d40184          LDR      r0,[r4,#0x184]        ;914
00020a  2802              CMP      r0,#2                 ;914
00020c  d009              BEQ      |L20.546|
00020e  f8d40194          LDR      r0,[r4,#0x194]        ;915
000212  b108              CBZ      r0,|L20.536|
000214  2001              MOVS     r0,#1                 ;916
000216  e000              B        |L20.538|
                  |L20.536|
000218  2003              MOVS     r0,#3                 ;916
                  |L20.538|
00021a  4601              MOV      r1,r0                 ;916
00021c  4620              MOV      r0,r4                 ;916
00021e  f7fffffe          BL       eap_aka_state
                  |L20.546|
000222  2000              MOVS     r0,#0                 ;919
000224  f8c40158          STR      r0,[r4,#0x158]        ;919
000228  f8c4015c          STR      r0,[r4,#0x15c]        ;920
00022c  f8c40174          STR      r0,[r4,#0x174]        ;924
000230  4641              MOV      r1,r8                 ;925
000232  4620              MOV      r0,r4                 ;925
000234  f7fffffe          BL       eap_aka_response_challenge
000238  e6ff              B        |L20.58|
;;;927    
                          ENDP

00023a  0000              DCW      0x0000
                  |L20.572|
00023c  4541502d          DCB      "EAP-AKA: subtype Challenge",0
000240  414b413a
000244  20737562
000248  74797065
00024c  20436861
000250  6c6c656e
000254  676500  
000257  00                DCB      0
                  |L20.600|
000258  4541502d          DCB      "EAP-AKA: Invalid AT_CHECKCODE in the message"
00025c  414b413a
000260  20496e76
000264  616c6964
000268  2041545f
00026c  43484543
000270  4b434f44
000274  4520696e
000278  20746865
00027c  206d6573
000280  73616765
                  |L20.644|
000284  00                DCB      0
000285  00                DCB      0
000286  00                DCB      0
000287  00                DCB      0
                  |L20.648|
000288  2041545f          DCB      " AT_AUTN",0
00028c  4155544e
000290  00      
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0
                  |L20.660|
000294  2041545f          DCB      " AT_RAND",0
000298  52414e44
00029c  00      
00029d  00                DCB      0
00029e  00                DCB      0
00029f  00                DCB      0
                  |L20.672|
0002a0  2041545f          DCB      " AT_MAC",0
0002a4  4d414300
                  |L20.680|
0002a8  4541502d          DCB      "EAP-AKA: Challenge message did not include%s%s%s",0
0002ac  414b413a
0002b0  20436861
0002b4  6c6c656e
0002b8  6765206d
0002bc  65737361
0002c0  67652064
0002c4  6964206e
0002c8  6f742069
0002cc  6e636c75
0002d0  64652573
0002d4  25732573
0002d8  00      
0002d9  00                DCB      0
0002da  00                DCB      0
0002db  00                DCB      0
                  |L20.732|
0002dc  4541502d          DCB      "EAP-AKA: UMTS authentication failed (AUTN)",0
0002e0  414b413a
0002e4  20554d54
0002e8  53206175
0002ec  7468656e
0002f0  74696361
0002f4  74696f6e
0002f8  20666169
0002fc  6c656420
000300  28415554
000304  4e2900  
000307  00                DCB      0
                  |L20.776|
000308  4541502d          DCB      "EAP-AKA: UMTS authentication failed (AUTN seq# -> AUTS)"
00030c  414b413a
000310  20554d54
000314  53206175
000318  7468656e
00031c  74696361
000320  74696f6e
000324  20666169
000328  6c656420
00032c  28415554
000330  4e207365
000334  7123202d
000338  3e204155
00033c  545329  
00033f  00                DCB      0
                  |L20.832|
000340  4541502d          DCB      "EAP-AKA: UMTS authentication failed",0
000344  414b413a
000348  20554d54
00034c  53206175
000350  7468656e
000354  74696361
000358  74696f6e
00035c  20666169
000360  6c656400
                  |L20.868|
000364  4541502d          DCB      "EAP-AKA: Selected identity for MK derivation",0
000368  414b413a
00036c  2053656c
000370  65637465
000374  64206964
000378  656e7469
00037c  74792066
000380  6f72204d
000384  4b206465
000388  72697661
00038c  74696f6e
000390  00      
000391  00                DCB      0
000392  00                DCB      0
000393  00                DCB      0
                  |L20.916|
000394  4541502d          DCB      "EAP-AKA: Challenge message used invalid AT_MAC",0
000398  414b413a
00039c  20436861
0003a0  6c6c656e
0003a4  6765206d
0003a8  65737361
0003ac  67652075
0003b0  73656420
0003b4  696e7661
0003b8  6c696420
0003bc  41545f4d
0003c0  414300  
0003c3  00                DCB      0

                          AREA ||i.eap_aka_process_identity||, CODE, READONLY, ALIGN=2

                  eap_aka_process_identity PROC
;;;607    
;;;608    static struct wpabuf * eap_aka_process_identity(struct eap_sm *sm,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;609    						struct eap_aka_data *data,
;;;610    						u8 id,
;;;611    						const struct wpabuf *reqData,
;;;612    						struct eap_sim_attrs *attr)
;;;613    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;614    	int id_error;
;;;615    	struct wpabuf *buf;
;;;616    
;;;617    	wpa_printf(MSG_DEBUG, "EAP-AKA: subtype Identity");
000010  a12a              ADR      r1,|L21.188|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
;;;618    
;;;619    	id_error = 0;
000018  2600              MOVS     r6,#0
;;;620    	switch (attr->id_req) {
00001a  f8980068          LDRB     r0,[r8,#0x68]
00001e  b130              CBZ      r0,|L21.46|
000020  2801              CMP      r0,#1
000022  d005              BEQ      |L21.48|
000024  2802              CMP      r0,#2
000026  d00e              BEQ      |L21.70|
000028  2803              CMP      r0,#3
00002a  d122              BNE      |L21.114|
00002c  e016              B        |L21.92|
                  |L21.46|
;;;621    	case NO_ID_REQ:
;;;622    		break;
00002e  e020              B        |L21.114|
                  |L21.48|
;;;623    	case ANY_ID:
;;;624    		if (data->num_id_req > 0)
000030  f8d40158          LDR      r0,[r4,#0x158]
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L21.58|
;;;625    			id_error++;
000038  1c76              ADDS     r6,r6,#1
                  |L21.58|
;;;626    		data->num_id_req++;
00003a  f8d40158          LDR      r0,[r4,#0x158]
00003e  1c40              ADDS     r0,r0,#1
000040  f8c40158          STR      r0,[r4,#0x158]
;;;627    		break;
000044  e015              B        |L21.114|
                  |L21.70|
;;;628    	case FULLAUTH_ID:
;;;629    		if (data->num_id_req > 1)
000046  f8d40158          LDR      r0,[r4,#0x158]
00004a  2801              CMP      r0,#1
00004c  dd00              BLE      |L21.80|
;;;630    			id_error++;
00004e  1c76              ADDS     r6,r6,#1
                  |L21.80|
;;;631    		data->num_id_req++;
000050  f8d40158          LDR      r0,[r4,#0x158]
000054  1c40              ADDS     r0,r0,#1
000056  f8c40158          STR      r0,[r4,#0x158]
;;;632    		break;
00005a  e00a              B        |L21.114|
                  |L21.92|
;;;633    	case PERMANENT_ID:
;;;634    		if (data->num_id_req > 2)
00005c  f8d40158          LDR      r0,[r4,#0x158]
000060  2802              CMP      r0,#2
000062  dd00              BLE      |L21.102|
;;;635    			id_error++;
000064  1c76              ADDS     r6,r6,#1
                  |L21.102|
;;;636    		data->num_id_req++;
000066  f8d40158          LDR      r0,[r4,#0x158]
00006a  1c40              ADDS     r0,r0,#1
00006c  f8c40158          STR      r0,[r4,#0x158]
;;;637    		break;
000070  bf00              NOP      
                  |L21.114|
000072  bf00              NOP                            ;622
;;;638    	}
;;;639    	if (id_error) {
000074  b156              CBZ      r6,|L21.140|
;;;640    		wpa_printf(MSG_INFO, "EAP-AKA: Too many ID requests "
000076  a118              ADR      r1,|L21.216|
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       wpa_printf
;;;641    			   "used within one authentication");
;;;642    		return eap_aka_client_error(data, id,
00007e  2200              MOVS     r2,#0
000080  4629              MOV      r1,r5
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       eap_aka_client_error
                  |L21.136|
;;;643    					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;644    	}
;;;645    
;;;646    	buf = eap_aka_response_identity(sm, data, id, attr->id_req);
;;;647    
;;;648    	if (data->prev_id != id) {
;;;649    		eap_aka_add_id_msg(data, reqData);
;;;650    		eap_aka_add_id_msg(data, buf);
;;;651    		data->prev_id = id;
;;;652    	}
;;;653    
;;;654    	return buf;
;;;655    }
000088  e8bd87f0          POP      {r4-r10,pc}
                  |L21.140|
00008c  f8983068          LDRB     r3,[r8,#0x68]         ;646
000090  462a              MOV      r2,r5                 ;646
000092  4621              MOV      r1,r4                 ;646
000094  4648              MOV      r0,r9                 ;646
000096  f7fffffe          BL       eap_aka_response_identity
00009a  4682              MOV      r10,r0                ;646
00009c  f8d4018c          LDR      r0,[r4,#0x18c]        ;648
0000a0  42a8              CMP      r0,r5                 ;648
0000a2  d009              BEQ      |L21.184|
0000a4  4639              MOV      r1,r7                 ;649
0000a6  4620              MOV      r0,r4                 ;649
0000a8  f7fffffe          BL       eap_aka_add_id_msg
0000ac  4651              MOV      r1,r10                ;650
0000ae  4620              MOV      r0,r4                 ;650
0000b0  f7fffffe          BL       eap_aka_add_id_msg
0000b4  f8c4518c          STR      r5,[r4,#0x18c]        ;651
                  |L21.184|
0000b8  4650              MOV      r0,r10                ;654
0000ba  e7e5              B        |L21.136|
;;;656    
                          ENDP

                  |L21.188|
0000bc  4541502d          DCB      "EAP-AKA: subtype Identity",0
0000c0  414b413a
0000c4  20737562
0000c8  74797065
0000cc  20496465
0000d0  6e746974
0000d4  7900    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L21.216|
0000d8  4541502d          DCB      "EAP-AKA: Too many ID requests used within one authentic"
0000dc  414b413a
0000e0  20546f6f
0000e4  206d616e
0000e8  79204944
0000ec  20726571
0000f0  75657374
0000f4  73207573
0000f8  65642077
0000fc  69746869
000100  6e206f6e
000104  65206175
000108  7468656e
00010c  746963  
00010f  6174696f          DCB      "ation",0
000113  6e00    
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0

                          AREA ||i.eap_aka_process_notification||, CODE, READONLY, ALIGN=2

                  eap_aka_process_notification PROC
;;;989    
;;;990    static struct wpabuf * eap_aka_process_notification(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;991    	struct eap_sm *sm, struct eap_aka_data *data, u8 id,
;;;992    	const struct wpabuf *reqData, struct eap_sim_attrs *attr)
;;;993    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c06              LDR      r4,[sp,#0x18]
;;;994    	wpa_printf(MSG_DEBUG, "EAP-AKA: subtype Notification");
00000e  a12c              ADR      r1,|L22.192|
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       wpa_printf
;;;995    	if (data->num_notification > 0) {
000016  f8d5015c          LDR      r0,[r5,#0x15c]
00001a  2800              CMP      r0,#0
00001c  dd0a              BLE      |L22.52|
;;;996    		wpa_printf(MSG_INFO, "EAP-AKA: too many notification "
00001e  a130              ADR      r1,|L22.224|
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       wpa_printf
;;;997    			   "rounds (only one allowed)");
;;;998    		return eap_aka_client_error(data, id,
000026  2200              MOVS     r2,#0
000028  4639              MOV      r1,r7
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       eap_aka_client_error
                  |L22.48|
;;;999    					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1000   	}
;;;1001   	data->num_notification++;
;;;1002   	if (attr->notification == -1) {
;;;1003   		wpa_printf(MSG_INFO, "EAP-AKA: no AT_NOTIFICATION in "
;;;1004   			   "Notification message");
;;;1005   		return eap_aka_client_error(data, id,
;;;1006   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1007   	}
;;;1008   
;;;1009   	if ((attr->notification & 0x4000) == 0 &&
;;;1010   	    eap_aka_process_notification_auth(data, reqData, attr)) {
;;;1011   		return eap_aka_client_error(data, id,
;;;1012   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1013   	}
;;;1014   
;;;1015   	eap_sim_report_notification(sm->msg_ctx, attr->notification, 1);
;;;1016   	if (attr->notification >= 0 && attr->notification < 32768) {
;;;1017   		eap_aka_state(data, FAILURE);
;;;1018   	} else if (attr->notification == EAP_SIM_SUCCESS &&
;;;1019   		   data->state == RESULT_SUCCESS)
;;;1020   		eap_aka_state(data, SUCCESS);
;;;1021   	return eap_aka_response_notification(data, id, attr->notification);
;;;1022   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L22.52|
000034  f8d5015c          LDR      r0,[r5,#0x15c]        ;1001
000038  1c40              ADDS     r0,r0,#1              ;1001
00003a  f8c5015c          STR      r0,[r5,#0x15c]        ;1001
00003e  6ee0              LDR      r0,[r4,#0x6c]         ;1002
000040  1c40              ADDS     r0,r0,#1              ;1002
000042  d108              BNE      |L22.86|
000044  a135              ADR      r1,|L22.284|
000046  f7fffffe          BL       wpa_printf
00004a  2200              MOVS     r2,#0                 ;1005
00004c  4639              MOV      r1,r7                 ;1005
00004e  4628              MOV      r0,r5                 ;1005
000050  f7fffffe          BL       eap_aka_client_error
000054  e7ec              B        |L22.48|
                  |L22.86|
000056  6ee0              LDR      r0,[r4,#0x6c]         ;1009
000058  f4104f80          TST      r0,#0x4000            ;1009
00005c  d10b              BNE      |L22.118|
00005e  4622              MOV      r2,r4                 ;1010
000060  4641              MOV      r1,r8                 ;1010
000062  4628              MOV      r0,r5                 ;1010
000064  f7fffffe          BL       eap_aka_process_notification_auth
000068  b128              CBZ      r0,|L22.118|
00006a  2200              MOVS     r2,#0                 ;1011
00006c  4639              MOV      r1,r7                 ;1011
00006e  4628              MOV      r0,r5                 ;1011
000070  f7fffffe          BL       eap_aka_client_error
000074  e7dc              B        |L22.48|
                  |L22.118|
000076  6ee1              LDR      r1,[r4,#0x6c]         ;1015
000078  2201              MOVS     r2,#1                 ;1015
00007a  f8d60090          LDR      r0,[r6,#0x90]         ;1015
00007e  f7fffffe          BL       eap_sim_report_notification
000082  6ee0              LDR      r0,[r4,#0x6c]         ;1016
000084  2800              CMP      r0,#0                 ;1016
000086  db08              BLT      |L22.154|
000088  6ee0              LDR      r0,[r4,#0x6c]         ;1016
00008a  f5b04f00          CMP      r0,#0x8000            ;1016
00008e  da04              BGE      |L22.154|
000090  2104              MOVS     r1,#4                 ;1017
000092  4628              MOV      r0,r5                 ;1017
000094  f7fffffe          BL       eap_aka_state
000098  e00b              B        |L22.178|
                  |L22.154|
00009a  6ee0              LDR      r0,[r4,#0x6c]         ;1018
00009c  f5b04f00          CMP      r0,#0x8000            ;1018
0000a0  d107              BNE      |L22.178|
0000a2  f8d50184          LDR      r0,[r5,#0x184]        ;1019
0000a6  2801              CMP      r0,#1                 ;1019
0000a8  d103              BNE      |L22.178|
0000aa  2103              MOVS     r1,#3                 ;1020
0000ac  4628              MOV      r0,r5                 ;1020
0000ae  f7fffffe          BL       eap_aka_state
                  |L22.178|
0000b2  6ee0              LDR      r0,[r4,#0x6c]         ;1021
0000b4  b282              UXTH     r2,r0                 ;1021
0000b6  4639              MOV      r1,r7                 ;1021
0000b8  4628              MOV      r0,r5                 ;1021
0000ba  f7fffffe          BL       eap_aka_response_notification
0000be  e7b7              B        |L22.48|
;;;1023   
                          ENDP

                  |L22.192|
0000c0  4541502d          DCB      "EAP-AKA: subtype Notification",0
0000c4  414b413a
0000c8  20737562
0000cc  74797065
0000d0  204e6f74
0000d4  69666963
0000d8  6174696f
0000dc  6e00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L22.224|
0000e0  4541502d          DCB      "EAP-AKA: too many notification rounds (only one allowed"
0000e4  414b413a
0000e8  20746f6f
0000ec  206d616e
0000f0  79206e6f
0000f4  74696669
0000f8  63617469
0000fc  6f6e2072
000100  6f756e64
000104  7320286f
000108  6e6c7920
00010c  6f6e6520
000110  616c6c6f
000114  776564  
000117  2900              DCB      ")",0
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L22.284|
00011c  4541502d          DCB      "EAP-AKA: no AT_NOTIFICATION in Notification message",0
000120  414b413a
000124  206e6f20
000128  41545f4e
00012c  4f544946
000130  49434154
000134  494f4e20
000138  696e204e
00013c  6f746966
000140  69636174
000144  696f6e20
000148  6d657373
00014c  61676500

                          AREA ||i.eap_aka_process_notification_auth||, CODE, READONLY, ALIGN=2

                  eap_aka_process_notification_auth PROC
;;;962    
;;;963    static int eap_aka_process_notification_auth(struct eap_aka_data *data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;964    					     const struct wpabuf *reqData,
;;;965    					     struct eap_sim_attrs *attr)
;;;966    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;967    	if (attr->mac == NULL) {
000008  68a0              LDR      r0,[r4,#8]
00000a  b930              CBNZ     r0,|L23.26|
;;;968    		wpa_printf(MSG_INFO, "EAP-AKA: no AT_MAC in after_auth "
00000c  a113              ADR      r1,|L23.92|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       wpa_printf
;;;969    			   "Notification message");
;;;970    		return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L23.24|
;;;971    	}
;;;972    
;;;973    	if (eap_aka_verify_mac(data, reqData, attr->mac, (u8 *) "", 0)) {
;;;974    		wpa_printf(MSG_WARNING, "EAP-AKA: Notification message "
;;;975    			   "used invalid AT_MAC");
;;;976    		return -1;
;;;977    	}
;;;978    
;;;979    	if (data->reauth &&
;;;980    	    eap_aka_process_notification_reauth(data, attr)) {
;;;981    		wpa_printf(MSG_WARNING, "EAP-AKA: Invalid notification "
;;;982    			   "message after reauth");
;;;983    		return -1;
;;;984    	}
;;;985    
;;;986    	return 0;
;;;987    }
000018  bdf8              POP      {r3-r7,pc}
                  |L23.26|
00001a  2300              MOVS     r3,#0                 ;973
00001c  9300              STR      r3,[sp,#0]            ;973
00001e  a31d              ADR      r3,|L23.148|
000020  4631              MOV      r1,r6                 ;973
000022  4628              MOV      r0,r5                 ;973
000024  68a2              LDR      r2,[r4,#8]            ;973
000026  f7fffffe          BL       eap_aka_verify_mac
00002a  b130              CBZ      r0,|L23.58|
00002c  a11a              ADR      r1,|L23.152|
00002e  2000              MOVS     r0,#0                 ;974
000030  f7fffffe          BL       wpa_printf
000034  f04f30ff          MOV      r0,#0xffffffff        ;976
000038  e7ee              B        |L23.24|
                  |L23.58|
00003a  f8d50170          LDR      r0,[r5,#0x170]        ;979
00003e  b158              CBZ      r0,|L23.88|
000040  4621              MOV      r1,r4                 ;980
000042  4628              MOV      r0,r5                 ;980
000044  f7fffffe          BL       eap_aka_process_notification_reauth
000048  b130              CBZ      r0,|L23.88|
00004a  a120              ADR      r1,|L23.204|
00004c  2000              MOVS     r0,#0                 ;981
00004e  f7fffffe          BL       wpa_printf
000052  f04f30ff          MOV      r0,#0xffffffff        ;983
000056  e7df              B        |L23.24|
                  |L23.88|
000058  2000              MOVS     r0,#0                 ;986
00005a  e7dd              B        |L23.24|
;;;988    
                          ENDP

                  |L23.92|
00005c  4541502d          DCB      "EAP-AKA: no AT_MAC in after_auth Notification message",0
000060  414b413a
000064  206e6f20
000068  41545f4d
00006c  41432069
000070  6e206166
000074  7465725f
000078  61757468
00007c  204e6f74
000080  69666963
000084  6174696f
000088  6e206d65
00008c  73736167
000090  6500    
000092  00                DCB      0
000093  00                DCB      0
                  |L23.148|
000094  00                DCB      0
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L23.152|
000098  4541502d          DCB      "EAP-AKA: Notification message used invalid AT_MAC",0
00009c  414b413a
0000a0  204e6f74
0000a4  69666963
0000a8  6174696f
0000ac  6e206d65
0000b0  73736167
0000b4  65207573
0000b8  65642069
0000bc  6e76616c
0000c0  69642041
0000c4  545f4d41
0000c8  4300    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L23.204|
0000cc  4541502d          DCB      "EAP-AKA: Invalid notification message after reauth",0
0000d0  414b413a
0000d4  20496e76
0000d8  616c6964
0000dc  206e6f74
0000e0  69666963
0000e4  6174696f
0000e8  6e206d65
0000ec  73736167
0000f0  65206166
0000f4  74657220
0000f8  72656175
0000fc  746800  
0000ff  00                DCB      0

                          AREA ||i.eap_aka_process_notification_reauth||, CODE, READONLY, ALIGN=2

                  eap_aka_process_notification_reauth PROC
;;;928    
;;;929    static int eap_aka_process_notification_reauth(struct eap_aka_data *data,
000000  b570              PUSH     {r4-r6,lr}
;;;930    					       struct eap_sim_attrs *attr)
;;;931    {
000002  b0aa              SUB      sp,sp,#0xa8
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;932    	struct eap_sim_attrs eattr;
;;;933    	u8 *decrypted;
;;;934    
;;;935    	if (attr->encr_data == NULL || attr->iv == NULL) {
000008  6920              LDR      r0,[r4,#0x10]
00000a  b108              CBZ      r0,|L24.16|
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  b938              CBNZ     r0,|L24.32|
                  |L24.16|
;;;936    		wpa_printf(MSG_WARNING, "EAP-AKA: Notification message after "
000010  491a              LDR      r1,|L24.124|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
;;;937    			   "reauth did not include encrypted data");
;;;938    		return -1;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L24.28|
;;;939    	}
;;;940    
;;;941    	decrypted = eap_sim_parse_encr(data->k_encr, attr->encr_data,
;;;942    				       attr->encr_data_len, attr->iv, &eattr,
;;;943    				       0);
;;;944    	if (decrypted == NULL) {
;;;945    		wpa_printf(MSG_WARNING, "EAP-AKA: Failed to parse encrypted "
;;;946    			   "data from notification message");
;;;947    		return -1;
;;;948    	}
;;;949    
;;;950    	if (eattr.counter < 0 || (size_t) eattr.counter != data->counter) {
;;;951    		wpa_printf(MSG_WARNING, "EAP-AKA: Counter in notification "
;;;952    			   "message does not match with counter in reauth "
;;;953    			   "message");
;;;954    		os_free(decrypted);
;;;955    		return -1;
;;;956    	}
;;;957    
;;;958    	os_free(decrypted);
;;;959    	return 0;
;;;960    }
00001c  b02a              ADD      sp,sp,#0xa8
00001e  bd70              POP      {r4-r6,pc}
                  |L24.32|
000020  2300              MOVS     r3,#0                 ;941
000022  aa03              ADD      r2,sp,#0xc            ;941
000024  e9cd2300          STRD     r2,r3,[sp,#0]         ;941
000028  f1050078          ADD      r0,r5,#0x78           ;941
00002c  e9d43103          LDRD     r3,r1,[r4,#0xc]       ;941
000030  6ca2              LDR      r2,[r4,#0x48]         ;941
000032  f7fffffe          BL       eap_sim_parse_encr
000036  4606              MOV      r6,r0                 ;941
000038  b93e              CBNZ     r6,|L24.74|
00003a  4910              LDR      r1,|L24.124|
00003c  314c              ADDS     r1,r1,#0x4c           ;945
00003e  2000              MOVS     r0,#0                 ;945
000040  f7fffffe          BL       wpa_printf
000044  f04f30ff          MOV      r0,#0xffffffff        ;947
000048  e7e8              B        |L24.28|
                  |L24.74|
00004a  981f              LDR      r0,[sp,#0x7c]         ;950
00004c  2800              CMP      r0,#0                 ;950
00004e  db04              BLT      |L24.90|
000050  981f              LDR      r0,[sp,#0x7c]         ;950
000052  f8d51174          LDR      r1,[r5,#0x174]        ;950
000056  4288              CMP      r0,r1                 ;950
000058  d00a              BEQ      |L24.112|
                  |L24.90|
00005a  4908              LDR      r1,|L24.124|
00005c  3190              ADDS     r1,r1,#0x90           ;951
00005e  2000              MOVS     r0,#0                 ;951
000060  f7fffffe          BL       wpa_printf
000064  4630              MOV      r0,r6                 ;954
000066  f7fffffe          BL       os_free
00006a  f04f30ff          MOV      r0,#0xffffffff        ;955
00006e  e7d5              B        |L24.28|
                  |L24.112|
000070  4630              MOV      r0,r6                 ;958
000072  f7fffffe          BL       os_free
000076  2000              MOVS     r0,#0                 ;959
000078  e7d0              B        |L24.28|
;;;961    
                          ENDP

00007a  0000              DCW      0x0000
                  |L24.124|
                          DCD      ||.constdata||+0xc4

                          AREA ||i.eap_aka_process_reauthentication||, CODE, READONLY, ALIGN=2

                  eap_aka_process_reauthentication PROC
;;;1024   
;;;1025   static struct wpabuf * eap_aka_process_reauthentication(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1026   	struct eap_sm *sm, struct eap_aka_data *data, u8 id,
;;;1027   	const struct wpabuf *reqData, struct eap_sim_attrs *attr)
;;;1028   {
000004  b0aa              SUB      sp,sp,#0xa8
000006  4682              MOV      r10,r0
000008  460c              MOV      r4,r1
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
00000e  9d32              LDR      r5,[sp,#0xc8]
;;;1029   	struct eap_sim_attrs eattr;
;;;1030   	u8 *decrypted;
;;;1031   
;;;1032   	wpa_printf(MSG_DEBUG, "EAP-AKA: subtype Reauthentication");
000010  a193              ADR      r1,|L25.608|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
;;;1033   
;;;1034   	if (attr->checkcode &&
000018  6b68              LDR      r0,[r5,#0x34]
00001a  b188              CBZ      r0,|L25.64|
;;;1035   	    eap_aka_verify_checkcode(data, attr->checkcode,
00001c  4620              MOV      r0,r4
00001e  6e2a              LDR      r2,[r5,#0x60]
000020  6b69              LDR      r1,[r5,#0x34]
000022  f7fffffe          BL       eap_aka_verify_checkcode
000026  b158              CBZ      r0,|L25.64|
;;;1036   				     attr->checkcode_len)) {
;;;1037   		wpa_printf(MSG_WARNING, "EAP-AKA: Invalid AT_CHECKCODE in the "
000028  a196              ADR      r1,|L25.644|
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       wpa_printf
;;;1038   			   "message");
;;;1039   		return eap_aka_client_error(data, id,
000030  2200              MOVS     r2,#0
000032  4639              MOV      r1,r7
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       eap_aka_client_error
                  |L25.58|
;;;1040   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1041   	}
;;;1042   
;;;1043   	if (data->reauth_id == NULL) {
;;;1044   		wpa_printf(MSG_WARNING, "EAP-AKA: Server is trying "
;;;1045   			   "reauthentication, but no reauth_id available");
;;;1046   		return eap_aka_client_error(data, id,
;;;1047   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1048   	}
;;;1049   
;;;1050   	data->reauth = 1;
;;;1051   	if (eap_aka_verify_mac(data, reqData, attr->mac, (u8 *) "", 0)) {
;;;1052   		wpa_printf(MSG_WARNING, "EAP-AKA: Reauthentication "
;;;1053   			   "did not have valid AT_MAC");
;;;1054   		return eap_aka_client_error(data, id,
;;;1055   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1056   	}
;;;1057   
;;;1058   	if (attr->encr_data == NULL || attr->iv == NULL) {
;;;1059   		wpa_printf(MSG_WARNING, "EAP-AKA: Reauthentication "
;;;1060   			   "message did not include encrypted data");
;;;1061   		return eap_aka_client_error(data, id,
;;;1062   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1063   	}
;;;1064   
;;;1065   	decrypted = eap_sim_parse_encr(data->k_encr, attr->encr_data,
;;;1066   				       attr->encr_data_len, attr->iv, &eattr,
;;;1067   				       0);
;;;1068   	if (decrypted == NULL) {
;;;1069   		wpa_printf(MSG_WARNING, "EAP-AKA: Failed to parse encrypted "
;;;1070   			   "data from reauthentication message");
;;;1071   		return eap_aka_client_error(data, id,
;;;1072   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1073   	}
;;;1074   
;;;1075   	if (eattr.nonce_s == NULL || eattr.counter < 0) {
;;;1076   		wpa_printf(MSG_INFO, "EAP-AKA: (encr) No%s%s in reauth packet",
;;;1077   			   !eattr.nonce_s ? " AT_NONCE_S" : "",
;;;1078   			   eattr.counter < 0 ? " AT_COUNTER" : "");
;;;1079   		os_free(decrypted);
;;;1080   		return eap_aka_client_error(data, id,
;;;1081   					    EAP_AKA_UNABLE_TO_PROCESS_PACKET);
;;;1082   	}
;;;1083   
;;;1084   	if (eattr.counter < 0 || (size_t) eattr.counter <= data->counter) {
;;;1085   		struct wpabuf *res;
;;;1086   		wpa_printf(MSG_INFO, "EAP-AKA: (encr) Invalid counter "
;;;1087   			   "(%d <= %d)", eattr.counter, data->counter);
;;;1088   		data->counter_too_small = eattr.counter;
;;;1089   
;;;1090   		/* Reply using Re-auth w/ AT_COUNTER_TOO_SMALL. The current
;;;1091   		 * reauth_id must not be used to start a new reauthentication.
;;;1092   		 * However, since it was used in the last EAP-Response-Identity
;;;1093   		 * packet, it has to saved for the following fullauth to be
;;;1094   		 * used in MK derivation. */
;;;1095   		os_free(data->last_eap_identity);
;;;1096   		data->last_eap_identity = data->reauth_id;
;;;1097   		data->last_eap_identity_len = data->reauth_id_len;
;;;1098   		data->reauth_id = NULL;
;;;1099   		data->reauth_id_len = 0;
;;;1100   
;;;1101   		res = eap_aka_response_reauth(data, id, 1, eattr.nonce_s);
;;;1102   		os_free(decrypted);
;;;1103   
;;;1104   		return res;
;;;1105   	}
;;;1106   	data->counter = eattr.counter;
;;;1107   
;;;1108   	os_memcpy(data->nonce_s, eattr.nonce_s, EAP_SIM_NONCE_S_LEN);
;;;1109   	wpa_hexdump(MSG_DEBUG, "EAP-AKA: (encr) AT_NONCE_S",
;;;1110   		    data->nonce_s, EAP_SIM_NONCE_S_LEN);
;;;1111   
;;;1112   	if (data->eap_method == EAP_TYPE_AKA_PRIME) {
;;;1113   		eap_aka_prime_derive_keys_reauth(data->k_re, data->counter,
;;;1114   						 data->reauth_id,
;;;1115   						 data->reauth_id_len,
;;;1116   						 data->nonce_s,
;;;1117   						 data->msk, data->emsk);
;;;1118   	} else {
;;;1119   		eap_sim_derive_keys_reauth(data->counter, data->reauth_id,
;;;1120   					   data->reauth_id_len,
;;;1121   					   data->nonce_s, data->mk,
;;;1122   					   data->msk, data->emsk);
;;;1123   	}
;;;1124   	eap_aka_clear_identities(data, CLEAR_REAUTH_ID | CLEAR_EAP_ID);
;;;1125   	eap_aka_learn_ids(data, &eattr);
;;;1126   
;;;1127   	if (data->result_ind && attr->result_ind)
;;;1128   		data->use_result_ind = 1;
;;;1129   
;;;1130   	if (data->state != FAILURE && data->state != RESULT_FAILURE) {
;;;1131   		eap_aka_state(data, data->use_result_ind ?
;;;1132   			      RESULT_SUCCESS : SUCCESS);
;;;1133   	}
;;;1134   
;;;1135   	data->num_id_req = 0;
;;;1136   	data->num_notification = 0;
;;;1137   	if (data->counter > EAP_AKA_MAX_FAST_REAUTHS) {
;;;1138   		wpa_printf(MSG_DEBUG, "EAP-AKA: Maximum number of "
;;;1139   			   "fast reauths performed - force fullauth");
;;;1140   		eap_aka_clear_identities(data, CLEAR_REAUTH_ID | CLEAR_EAP_ID);
;;;1141   	}
;;;1142   	os_free(decrypted);
;;;1143   	return eap_aka_response_reauth(data, id, 0, data->nonce_s);
;;;1144   }
00003a  b02a              ADD      sp,sp,#0xa8
00003c  e8bd87f0          POP      {r4-r10,pc}
                  |L25.64|
000040  f8d40168          LDR      r0,[r4,#0x168]        ;1043
000044  b948              CBNZ     r0,|L25.90|
000046  499b              LDR      r1,|L25.692|
000048  2000              MOVS     r0,#0                 ;1044
00004a  f7fffffe          BL       wpa_printf
00004e  2200              MOVS     r2,#0                 ;1046
000050  4639              MOV      r1,r7                 ;1046
000052  4620              MOV      r0,r4                 ;1046
000054  f7fffffe          BL       eap_aka_client_error
000058  e7ef              B        |L25.58|
                  |L25.90|
00005a  2001              MOVS     r0,#1                 ;1050
00005c  f8c40170          STR      r0,[r4,#0x170]        ;1050
000060  2300              MOVS     r3,#0                 ;1051
000062  9300              STR      r3,[sp,#0]            ;1051
000064  a392              ADR      r3,|L25.688|
000066  4641              MOV      r1,r8                 ;1051
000068  4620              MOV      r0,r4                 ;1051
00006a  68aa              LDR      r2,[r5,#8]            ;1051
00006c  f7fffffe          BL       eap_aka_verify_mac
000070  b148              CBZ      r0,|L25.134|
000072  a191              ADR      r1,|L25.696|
000074  2000              MOVS     r0,#0                 ;1052
000076  f7fffffe          BL       wpa_printf
00007a  2200              MOVS     r2,#0                 ;1054
00007c  4639              MOV      r1,r7                 ;1054
00007e  4620              MOV      r0,r4                 ;1054
000080  f7fffffe          BL       eap_aka_client_error
000084  e7d9              B        |L25.58|
                  |L25.134|
000086  6928              LDR      r0,[r5,#0x10]         ;1058
000088  b108              CBZ      r0,|L25.142|
00008a  68e8              LDR      r0,[r5,#0xc]          ;1058
00008c  b950              CBNZ     r0,|L25.164|
                  |L25.142|
00008e  4989              LDR      r1,|L25.692|
000090  3148              ADDS     r1,r1,#0x48           ;1059
000092  2000              MOVS     r0,#0                 ;1059
000094  f7fffffe          BL       wpa_printf
000098  2200              MOVS     r2,#0                 ;1061
00009a  4639              MOV      r1,r7                 ;1061
00009c  4620              MOV      r0,r4                 ;1061
00009e  f7fffffe          BL       eap_aka_client_error
0000a2  e7ca              B        |L25.58|
                  |L25.164|
0000a4  2300              MOVS     r3,#0                 ;1065
0000a6  aa03              ADD      r2,sp,#0xc            ;1065
0000a8  e9cd2300          STRD     r2,r3,[sp,#0]         ;1065
0000ac  f1040078          ADD      r0,r4,#0x78           ;1065
0000b0  e9d53103          LDRD     r3,r1,[r5,#0xc]       ;1065
0000b4  6caa              LDR      r2,[r5,#0x48]         ;1065
0000b6  f7fffffe          BL       eap_sim_parse_encr
0000ba  4606              MOV      r6,r0                 ;1065
0000bc  b956              CBNZ     r6,|L25.212|
0000be  497d              LDR      r1,|L25.692|
0000c0  318c              ADDS     r1,r1,#0x8c           ;1069
0000c2  2000              MOVS     r0,#0                 ;1069
0000c4  f7fffffe          BL       wpa_printf
0000c8  2200              MOVS     r2,#0                 ;1071
0000ca  4639              MOV      r1,r7                 ;1071
0000cc  4620              MOV      r0,r4                 ;1071
0000ce  f7fffffe          BL       eap_aka_client_error
0000d2  e7b2              B        |L25.58|
                  |L25.212|
0000d4  9809              LDR      r0,[sp,#0x24]         ;1075
0000d6  b110              CBZ      r0,|L25.222|
0000d8  981f              LDR      r0,[sp,#0x7c]         ;1075
0000da  2800              CMP      r0,#0                 ;1075
0000dc  da19              BGE      |L25.274|
                  |L25.222|
0000de  981f              LDR      r0,[sp,#0x7c]         ;1076
0000e0  2800              CMP      r0,#0                 ;1076
0000e2  da01              BGE      |L25.232|
0000e4  a081              ADR      r0,|L25.748|
0000e6  e000              B        |L25.234|
                  |L25.232|
0000e8  a071              ADR      r0,|L25.688|
                  |L25.234|
0000ea  4603              MOV      r3,r0                 ;1078
0000ec  9809              LDR      r0,[sp,#0x24]         ;1078
0000ee  b908              CBNZ     r0,|L25.244|
0000f0  a081              ADR      r0,|L25.760|
0000f2  e000              B        |L25.246|
                  |L25.244|
0000f4  a06e              ADR      r0,|L25.688|
                  |L25.246|
0000f6  4602              MOV      r2,r0                 ;1077
0000f8  a182              ADR      r1,|L25.772|
0000fa  2000              MOVS     r0,#0                 ;1077
0000fc  f7fffffe          BL       wpa_printf
000100  4630              MOV      r0,r6                 ;1079
000102  f7fffffe          BL       os_free
000106  2200              MOVS     r2,#0                 ;1080
000108  4639              MOV      r1,r7                 ;1080
00010a  4620              MOV      r0,r4                 ;1080
00010c  f7fffffe          BL       eap_aka_client_error
000110  e793              B        |L25.58|
                  |L25.274|
000112  981f              LDR      r0,[sp,#0x7c]         ;1084
000114  2800              CMP      r0,#0                 ;1084
000116  db04              BLT      |L25.290|
000118  981f              LDR      r0,[sp,#0x7c]         ;1084
00011a  f8d41174          LDR      r1,[r4,#0x174]        ;1084
00011e  4288              CMP      r0,r1                 ;1084
000120  d823              BHI      |L25.362|
                  |L25.290|
000122  f50474b4          ADD      r4,r4,#0x168          ;1086
000126  68e3              LDR      r3,[r4,#0xc]          ;1086
000128  a180              ADR      r1,|L25.812|
00012a  f04f0000          MOV      r0,#0                 ;1086
00012e  9a1f              LDR      r2,[sp,#0x7c]         ;1086
000130  f7fffffe          BL       wpa_printf
000134  981f              LDR      r0,[sp,#0x7c]         ;1088
000136  6120              STR      r0,[r4,#0x10]         ;1088
000138  6960              LDR      r0,[r4,#0x14]         ;1095
00013a  f7fffffe          BL       os_free
00013e  6820              LDR      r0,[r4,#0]            ;1096
000140  6160              STR      r0,[r4,#0x14]         ;1096
000142  6860              LDR      r0,[r4,#4]            ;1097
000144  61a0              STR      r0,[r4,#0x18]         ;1097
000146  2000              MOVS     r0,#0                 ;1098
000148  6020              STR      r0,[r4,#0]            ;1098
00014a  6060              STR      r0,[r4,#4]            ;1099
00014c  f5a474b4          SUB      r4,r4,#0x168          ;1099
000150  f04f0201          MOV      r2,#1                 ;1101
000154  4639              MOV      r1,r7                 ;1101
000156  4620              MOV      r0,r4                 ;1101
000158  9b09              LDR      r3,[sp,#0x24]         ;1101
00015a  f7fffffe          BL       eap_aka_response_reauth
00015e  4681              MOV      r9,r0                 ;1101
000160  4630              MOV      r0,r6                 ;1102
000162  f7fffffe          BL       os_free
000166  4648              MOV      r0,r9                 ;1104
000168  e767              B        |L25.58|
                  |L25.362|
00016a  981f              LDR      r0,[sp,#0x7c]         ;1106
00016c  f8c40174          STR      r0,[r4,#0x174]        ;1106
000170  2210              MOVS     r2,#0x10              ;1108
000172  f1040034          ADD      r0,r4,#0x34           ;1108
000176  9909              LDR      r1,[sp,#0x24]         ;1108
000178  f7fffffe          BL       os_memcpy
00017c  2310              MOVS     r3,#0x10              ;1109
00017e  f1040234          ADD      r2,r4,#0x34           ;1109
000182  a175              ADR      r1,|L25.856|
000184  2000              MOVS     r0,#0                 ;1109
000186  f7fffffe          BL       wpa_hexdump
00018a  f8940198          LDRB     r0,[r4,#0x198]        ;1112
00018e  2832              CMP      r0,#0x32              ;1112
000190  d112              BNE      |L25.440|
000192  f10403e8          ADD      r3,r4,#0xe8           ;1113
000196  f10402a8          ADD      r2,r4,#0xa8           ;1113
00019a  f1040134          ADD      r1,r4,#0x34           ;1113
00019e  e88d000e          STM      sp,{r1-r3}            ;1113
0001a2  f8d40174          LDR      r0,[r4,#0x174]        ;1113
0001a6  b281              UXTH     r1,r0                 ;1113
0001a8  f1040088          ADD      r0,r4,#0x88           ;1113
0001ac  f50472b4          ADD      r2,r4,#0x168          ;1113
0001b0  ca0c              LDM      r2,{r2,r3}            ;1113
0001b2  f7fffffe          BL       eap_aka_prime_derive_keys_reauth
0001b6  e011              B        |L25.476|
                  |L25.440|
0001b8  f10403e8          ADD      r3,r4,#0xe8           ;1119
0001bc  f10402a8          ADD      r2,r4,#0xa8           ;1119
0001c0  f1040144          ADD      r1,r4,#0x44           ;1119
0001c4  e88d000e          STM      sp,{r1-r3}            ;1119
0001c8  f8d43174          LDR      r3,[r4,#0x174]        ;1119
0001cc  b298              UXTH     r0,r3                 ;1119
0001ce  f1040334          ADD      r3,r4,#0x34           ;1119
0001d2  f50471b4          ADD      r1,r4,#0x168          ;1119
0001d6  c906              LDM      r1,{r1,r2}            ;1119
0001d8  f7fffffe          BL       eap_sim_derive_keys_reauth
                  |L25.476|
0001dc  2106              MOVS     r1,#6                 ;1124
0001de  4620              MOV      r0,r4                 ;1124
0001e0  f7fffffe          BL       eap_aka_clear_identities
0001e4  a903              ADD      r1,sp,#0xc            ;1125
0001e6  4620              MOV      r0,r4                 ;1125
0001e8  f7fffffe          BL       eap_aka_learn_ids
0001ec  f8d40190          LDR      r0,[r4,#0x190]        ;1127
0001f0  b128              CBZ      r0,|L25.510|
0001f2  f8d50080          LDR      r0,[r5,#0x80]         ;1127
0001f6  b110              CBZ      r0,|L25.510|
0001f8  2001              MOVS     r0,#1                 ;1128
0001fa  f8c40194          STR      r0,[r4,#0x194]        ;1128
                  |L25.510|
0001fe  f8d40184          LDR      r0,[r4,#0x184]        ;1130
000202  2804              CMP      r0,#4                 ;1130
000204  d00d              BEQ      |L25.546|
000206  f8d40184          LDR      r0,[r4,#0x184]        ;1130
00020a  2802              CMP      r0,#2                 ;1130
00020c  d009              BEQ      |L25.546|
00020e  f8d40194          LDR      r0,[r4,#0x194]        ;1131
000212  b108              CBZ      r0,|L25.536|
000214  2001              MOVS     r0,#1                 ;1132
000216  e000              B        |L25.538|
                  |L25.536|
000218  2003              MOVS     r0,#3                 ;1132
                  |L25.538|
00021a  4601              MOV      r1,r0                 ;1132
00021c  4620              MOV      r0,r4                 ;1132
00021e  f7fffffe          BL       eap_aka_state
                  |L25.546|
000222  2000              MOVS     r0,#0                 ;1135
000224  f8c40158          STR      r0,[r4,#0x158]        ;1135
000228  f8c4015c          STR      r0,[r4,#0x15c]        ;1136
00022c  f8d40174          LDR      r0,[r4,#0x174]        ;1137
000230  f5b07f7a          CMP      r0,#0x3e8             ;1137
000234  d908              BLS      |L25.584|
000236  491f              LDR      r1,|L25.692|
000238  31d4              ADDS     r1,r1,#0xd4           ;1138
00023a  2000              MOVS     r0,#0                 ;1138
00023c  f7fffffe          BL       wpa_printf
000240  2106              MOVS     r1,#6                 ;1140
000242  4620              MOV      r0,r4                 ;1140
000244  f7fffffe          BL       eap_aka_clear_identities
                  |L25.584|
000248  4630              MOV      r0,r6                 ;1142
00024a  f7fffffe          BL       os_free
00024e  f1040334          ADD      r3,r4,#0x34           ;1143
000252  2200              MOVS     r2,#0                 ;1143
000254  4639              MOV      r1,r7                 ;1143
000256  4620              MOV      r0,r4                 ;1143
000258  f7fffffe          BL       eap_aka_response_reauth
00025c  e6ed              B        |L25.58|
;;;1145   
                          ENDP

00025e  0000              DCW      0x0000
                  |L25.608|
000260  4541502d          DCB      "EAP-AKA: subtype Reauthentication",0
000264  414b413a
000268  20737562
00026c  74797065
000270  20526561
000274  75746865
000278  6e746963
00027c  6174696f
000280  6e00    
000282  00                DCB      0
000283  00                DCB      0
                  |L25.644|
000284  4541502d          DCB      "EAP-AKA: Invalid AT_CHECKCODE in the message"
000288  414b413a
00028c  20496e76
000290  616c6964
000294  2041545f
000298  43484543
00029c  4b434f44
0002a0  4520696e
0002a4  20746865
0002a8  206d6573
0002ac  73616765
                  |L25.688|
0002b0  00                DCB      0
0002b1  00                DCB      0
0002b2  00                DCB      0
0002b3  00                DCB      0
                  |L25.692|
                          DCD      ||.constdata||+0x1ac
                  |L25.696|
0002b8  4541502d          DCB      "EAP-AKA: Reauthentication did not have valid AT_MAC",0
0002bc  414b413a
0002c0  20526561
0002c4  75746865
0002c8  6e746963
0002cc  6174696f
0002d0  6e206469
0002d4  64206e6f
0002d8  74206861
0002dc  76652076
0002e0  616c6964
0002e4  2041545f
0002e8  4d414300
                  |L25.748|
0002ec  2041545f          DCB      " AT_COUNTER",0
0002f0  434f554e
0002f4  54455200
                  |L25.760|
0002f8  2041545f          DCB      " AT_NONCE_S",0
0002fc  4e4f4e43
000300  455f5300
                  |L25.772|
000304  4541502d          DCB      "EAP-AKA: (encr) No%s%s in reauth packet",0
000308  414b413a
00030c  2028656e
000310  63722920
000314  4e6f2573
000318  25732069
00031c  6e207265
000320  61757468
000324  20706163
000328  6b657400
                  |L25.812|
00032c  4541502d          DCB      "EAP-AKA: (encr) Invalid counter (%d <= %d)",0
000330  414b413a
000334  2028656e
000338  63722920
00033c  496e7661
000340  6c696420
000344  636f756e
000348  74657220
00034c  28256420
000350  3c3d2025
000354  642900  
000357  00                DCB      0
                  |L25.856|
000358  4541502d          DCB      "EAP-AKA: (encr) AT_NONCE_S",0
00035c  414b413a
000360  2028656e
000364  63722920
000368  41545f4e
00036c  4f4e4345
000370  5f5300  
000373  00                DCB      0

                          AREA ||i.eap_aka_response_challenge||, CODE, READONLY, ALIGN=2

                  eap_aka_response_challenge PROC
;;;509    
;;;510    static struct wpabuf * eap_aka_response_challenge(struct eap_aka_data *data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;511    						  u8 id)
;;;512    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;513    	struct eap_sim_msg *msg;
;;;514    
;;;515    	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Challenge (id=%d)", id);
000006  462a              MOV      r2,r5
000008  a11e              ADR      r1,|L26.132|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       wpa_printf
;;;516    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
000010  f8942198          LDRB     r2,[r4,#0x198]
000014  2301              MOVS     r3,#1
000016  4629              MOV      r1,r5
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       eap_sim_msg_init
00001e  4606              MOV      r6,r0
;;;517    			       EAP_AKA_SUBTYPE_CHALLENGE);
;;;518    	wpa_printf(MSG_DEBUG, "   AT_RES");
000020  a122              ADR      r1,|L26.172|
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       wpa_printf
;;;519    	eap_sim_msg_add(msg, EAP_SIM_AT_RES, data->res_len * 8,
000028  6b23              LDR      r3,[r4,#0x30]
00002a  9300              STR      r3,[sp,#0]
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  04c0              LSLS     r0,r0,#19
000030  0c02              LSRS     r2,r0,#16
000032  f1040320          ADD      r3,r4,#0x20
000036  2103              MOVS     r1,#3
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       eap_sim_msg_add
;;;520    			data->res, data->res_len);
;;;521    	eap_aka_add_checkcode(data, msg);
00003e  4631              MOV      r1,r6
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       eap_aka_add_checkcode
;;;522    	if (data->use_result_ind) {
000046  f8d40194          LDR      r0,[r4,#0x194]
00004a  b150              CBZ      r0,|L26.98|
;;;523    		wpa_printf(MSG_DEBUG, "   AT_RESULT_IND");
00004c  a11a              ADR      r1,|L26.184|
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       wpa_printf
;;;524    		eap_sim_msg_add(msg, EAP_SIM_AT_RESULT_IND, 0, NULL, 0);
000054  2300              MOVS     r3,#0
000056  461a              MOV      r2,r3
000058  2187              MOVS     r1,#0x87
00005a  4630              MOV      r0,r6
00005c  9300              STR      r3,[sp,#0]
00005e  f7fffffe          BL       eap_sim_msg_add
                  |L26.98|
;;;525    	}
;;;526    	wpa_printf(MSG_DEBUG, "   AT_MAC");
000062  a11a              ADR      r1,|L26.204|
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       wpa_printf
;;;527    	eap_sim_msg_add_mac(msg, EAP_SIM_AT_MAC);
00006a  210b              MOVS     r1,#0xb
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       eap_sim_msg_add_mac
;;;528    	return eap_sim_msg_finish(msg, data->k_aut, (u8 *) "", 0);
000072  2300              MOVS     r3,#0
000074  a20c              ADR      r2,|L26.168|
000076  f1040158          ADD      r1,r4,#0x58
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       eap_sim_msg_finish
;;;529    }
000080  bdf8              POP      {r3-r7,pc}
;;;530    
                          ENDP

000082  0000              DCW      0x0000
                  |L26.132|
000084  47656e65          DCB      "Generating EAP-AKA Challenge (id=%d)"
000088  72617469
00008c  6e672045
000090  41502d41
000094  4b412043
000098  68616c6c
00009c  656e6765
0000a0  20286964
0000a4  3d256429
                  |L26.168|
0000a8  00                DCB      0
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L26.172|
0000ac  20202041          DCB      "   AT_RES",0
0000b0  545f5245
0000b4  5300    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L26.184|
0000b8  20202041          DCB      "   AT_RESULT_IND",0
0000bc  545f5245
0000c0  53554c54
0000c4  5f494e44
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L26.204|
0000cc  20202041          DCB      "   AT_MAC",0
0000d0  545f4d41
0000d4  4300    
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.eap_aka_response_identity||, CODE, READONLY, ALIGN=2

                  eap_aka_response_identity PROC
;;;465    
;;;466    static struct wpabuf * eap_aka_response_identity(struct eap_sm *sm,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;467    						 struct eap_aka_data *data,
;;;468    						 u8 id,
;;;469    						 enum eap_sim_id_req id_req)
;;;470    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;471    	const u8 *identity = NULL;
00000c  2600              MOVS     r6,#0
;;;472    	size_t identity_len = 0;
00000e  2000              MOVS     r0,#0
000010  9001              STR      r0,[sp,#4]
;;;473    	struct eap_sim_msg *msg;
;;;474    
;;;475    	data->reauth = 0;
000012  f8c40170          STR      r0,[r4,#0x170]
;;;476    	if (id_req == ANY_ID && data->reauth_id) {
000016  2d01              CMP      r5,#1
000018  d10b              BNE      |L27.50|
00001a  f8d40168          LDR      r0,[r4,#0x168]
00001e  b140              CBZ      r0,|L27.50|
;;;477    		identity = data->reauth_id;
000020  f8d46168          LDR      r6,[r4,#0x168]
;;;478    		identity_len = data->reauth_id_len;
000024  f8d4016c          LDR      r0,[r4,#0x16c]
000028  9001              STR      r0,[sp,#4]
;;;479    		data->reauth = 1;
00002a  2001              MOVS     r0,#1
00002c  f8c40170          STR      r0,[r4,#0x170]
000030  e01b              B        |L27.106|
                  |L27.50|
;;;480    	} else if ((id_req == ANY_ID || id_req == FULLAUTH_ID) &&
000032  2d01              CMP      r5,#1
000034  d001              BEQ      |L27.58|
000036  2d02              CMP      r5,#2
000038  d10c              BNE      |L27.84|
                  |L27.58|
;;;481    		   data->pseudonym) {
00003a  f8d40160          LDR      r0,[r4,#0x160]
00003e  b148              CBZ      r0,|L27.84|
;;;482    		identity = data->pseudonym;
000040  f8d46160          LDR      r6,[r4,#0x160]
;;;483    		identity_len = data->pseudonym_len;
000044  f8d40164          LDR      r0,[r4,#0x164]
000048  9001              STR      r0,[sp,#4]
;;;484    		eap_aka_clear_identities(data, CLEAR_REAUTH_ID);
00004a  2102              MOVS     r1,#2
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       eap_aka_clear_identities
000052  e00a              B        |L27.106|
                  |L27.84|
;;;485    	} else if (id_req != NO_ID_REQ) {
000054  b14d              CBZ      r5,|L27.106|
;;;486    		identity = eap_get_config_identity(sm, &identity_len);
000056  a901              ADD      r1,sp,#4
000058  4640              MOV      r0,r8
00005a  f7fffffe          BL       eap_get_config_identity
00005e  4606              MOV      r6,r0
;;;487    		if (identity) {
000060  b11e              CBZ      r6,|L27.106|
;;;488    			eap_aka_clear_identities(data, CLEAR_PSEUDONYM |
000062  2103              MOVS     r1,#3
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       eap_aka_clear_identities
                  |L27.106|
;;;489    						 CLEAR_REAUTH_ID);
;;;490    		}
;;;491    	}
;;;492    	if (id_req != NO_ID_REQ)
00006a  b11d              CBZ      r5,|L27.116|
;;;493    		eap_aka_clear_identities(data, CLEAR_EAP_ID);
00006c  2104              MOVS     r1,#4
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       eap_aka_clear_identities
                  |L27.116|
;;;494    
;;;495    	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Identity (id=%d)", id);
000074  463a              MOV      r2,r7
000076  a112              ADR      r1,|L27.192|
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       wpa_printf
;;;496    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
00007e  f8942198          LDRB     r2,[r4,#0x198]
000082  2305              MOVS     r3,#5
000084  4639              MOV      r1,r7
000086  2002              MOVS     r0,#2
000088  f7fffffe          BL       eap_sim_msg_init
00008c  4681              MOV      r9,r0
;;;497    			       EAP_AKA_SUBTYPE_IDENTITY);
;;;498    
;;;499    	if (identity) {
00008e  b176              CBZ      r6,|L27.174|
;;;500    		wpa_hexdump_ascii(MSG_DEBUG, "   AT_IDENTITY",
000090  4632              MOV      r2,r6
000092  a114              ADR      r1,|L27.228|
000094  2000              MOVS     r0,#0
000096  9b01              LDR      r3,[sp,#4]
000098  f7fffffe          BL       wpa_hexdump_ascii
;;;501    				  identity, identity_len);
;;;502    		eap_sim_msg_add(msg, EAP_SIM_AT_IDENTITY, identity_len,
00009c  9b01              LDR      r3,[sp,#4]
00009e  9300              STR      r3,[sp,#0]
0000a0  4633              MOV      r3,r6
0000a2  9801              LDR      r0,[sp,#4]
0000a4  b282              UXTH     r2,r0
0000a6  210e              MOVS     r1,#0xe
0000a8  4648              MOV      r0,r9
0000aa  f7fffffe          BL       eap_sim_msg_add
                  |L27.174|
;;;503    				identity, identity_len);
;;;504    	}
;;;505    
;;;506    	return eap_sim_msg_finish(msg, NULL, NULL, 0);
0000ae  2300              MOVS     r3,#0
0000b0  461a              MOV      r2,r3
0000b2  4619              MOV      r1,r3
0000b4  4648              MOV      r0,r9
0000b6  f7fffffe          BL       eap_sim_msg_finish
;;;507    }
0000ba  e8bd87fc          POP      {r2-r10,pc}
;;;508    
                          ENDP

0000be  0000              DCW      0x0000
                  |L27.192|
0000c0  47656e65          DCB      "Generating EAP-AKA Identity (id=%d)",0
0000c4  72617469
0000c8  6e672045
0000cc  41502d41
0000d0  4b412049
0000d4  64656e74
0000d8  69747920
0000dc  2869643d
0000e0  25642900
                  |L27.228|
0000e4  20202041          DCB      "   AT_IDENTITY",0
0000e8  545f4944
0000ec  454e5449
0000f0  545900  
0000f3  00                DCB      0

                          AREA ||i.eap_aka_response_notification||, CODE, READONLY, ALIGN=2

                  eap_aka_response_notification PROC
;;;574    
;;;575    static struct wpabuf * eap_aka_response_notification(struct eap_aka_data *data,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;576    						     u8 id, u16 notification)
;;;577    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;578    	struct eap_sim_msg *msg;
;;;579    	u8 *k_aut = (notification & 0x4000) == 0 ? data->k_aut : NULL;
00000a  f4174f80          TST      r7,#0x4000
00000e  d102              BNE      |L28.22|
000010  f1040058          ADD      r0,r4,#0x58
000014  e000              B        |L28.24|
                  |L28.22|
000016  2000              MOVS     r0,#0
                  |L28.24|
000018  4605              MOV      r5,r0
;;;580    
;;;581    	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Notification (id=%d)", id);
00001a  4632              MOV      r2,r6
00001c  a126              ADR      r1,|L28.184|
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       wpa_printf
;;;582    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
000024  f8942198          LDRB     r2,[r4,#0x198]
000028  230c              MOVS     r3,#0xc
00002a  4631              MOV      r1,r6
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       eap_sim_msg_init
000032  4680              MOV      r8,r0
;;;583    			       EAP_AKA_SUBTYPE_NOTIFICATION);
;;;584    	if (k_aut && data->reauth) {
000034  b37d              CBZ      r5,|L28.150|
000036  f8d40170          LDR      r0,[r4,#0x170]
00003a  b360              CBZ      r0,|L28.150|
;;;585    		wpa_printf(MSG_DEBUG, "   AT_IV");
00003c  a128              ADR      r1,|L28.224|
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       wpa_printf
;;;586    		wpa_printf(MSG_DEBUG, "   AT_ENCR_DATA");
000044  a129              ADR      r1,|L28.236|
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       wpa_printf
;;;587    		eap_sim_msg_add_encr_start(msg, EAP_SIM_AT_IV,
00004c  2282              MOVS     r2,#0x82
00004e  2181              MOVS     r1,#0x81
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       eap_sim_msg_add_encr_start
;;;588    					   EAP_SIM_AT_ENCR_DATA);
;;;589    		wpa_printf(MSG_DEBUG, "   *AT_COUNTER %d", data->counter);
000056  a129              ADR      r1,|L28.252|
000058  2000              MOVS     r0,#0
00005a  f8d42174          LDR      r2,[r4,#0x174]
00005e  f7fffffe          BL       wpa_printf
;;;590    		eap_sim_msg_add(msg, EAP_SIM_AT_COUNTER, data->counter,
000062  2300              MOVS     r3,#0
000064  9300              STR      r3,[sp,#0]
000066  f8d40174          LDR      r0,[r4,#0x174]
00006a  b282              UXTH     r2,r0
00006c  2113              MOVS     r1,#0x13
00006e  4640              MOV      r0,r8
000070  f7fffffe          BL       eap_sim_msg_add
;;;591    				NULL, 0);
;;;592    		if (eap_sim_msg_add_encr_end(msg, data->k_encr,
000074  2206              MOVS     r2,#6
000076  f1040178          ADD      r1,r4,#0x78
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       eap_sim_msg_add_encr_end
000080  b148              CBZ      r0,|L28.150|
;;;593    					     EAP_SIM_AT_PADDING)) {
;;;594    			wpa_printf(MSG_WARNING, "EAP-AKA: Failed to encrypt "
000082  a123              ADR      r1,|L28.272|
000084  2000              MOVS     r0,#0
000086  f7fffffe          BL       wpa_printf
;;;595    				   "AT_ENCR_DATA");
;;;596    			eap_sim_msg_free(msg);
00008a  4640              MOV      r0,r8
00008c  f7fffffe          BL       eap_sim_msg_free
;;;597    			return NULL;
000090  2000              MOVS     r0,#0
                  |L28.146|
;;;598    		}
;;;599    	}
;;;600    	if (k_aut) {
;;;601    		wpa_printf(MSG_DEBUG, "   AT_MAC");
;;;602    		eap_sim_msg_add_mac(msg, EAP_SIM_AT_MAC);
;;;603    	}
;;;604    	return eap_sim_msg_finish(msg, k_aut, (u8 *) "", 0);
;;;605    }
000092  e8bd83f8          POP      {r3-r9,pc}
                  |L28.150|
000096  e7ff              B        |L28.152|
                  |L28.152|
000098  b13d              CBZ      r5,|L28.170|
00009a  a127              ADR      r1,|L28.312|
00009c  2000              MOVS     r0,#0                 ;601
00009e  f7fffffe          BL       wpa_printf
0000a2  210b              MOVS     r1,#0xb               ;602
0000a4  4640              MOV      r0,r8                 ;602
0000a6  f7fffffe          BL       eap_sim_msg_add_mac
                  |L28.170|
0000aa  2300              MOVS     r3,#0                 ;604
0000ac  a20e              ADR      r2,|L28.232|
0000ae  4629              MOV      r1,r5                 ;604
0000b0  4640              MOV      r0,r8                 ;604
0000b2  f7fffffe          BL       eap_sim_msg_finish
0000b6  e7ec              B        |L28.146|
;;;606    
                          ENDP

                  |L28.184|
0000b8  47656e65          DCB      "Generating EAP-AKA Notification (id=%d)",0
0000bc  72617469
0000c0  6e672045
0000c4  41502d41
0000c8  4b41204e
0000cc  6f746966
0000d0  69636174
0000d4  696f6e20
0000d8  2869643d
0000dc  25642900
                  |L28.224|
0000e0  20202041          DCB      "   AT_IV"
0000e4  545f4956
                  |L28.232|
0000e8  00                DCB      0
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L28.236|
0000ec  20202041          DCB      "   AT_ENCR_DATA",0
0000f0  545f454e
0000f4  43525f44
0000f8  41544100
                  |L28.252|
0000fc  2020202a          DCB      "   *AT_COUNTER %d",0
000100  41545f43
000104  4f554e54
000108  45522025
00010c  6400    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L28.272|
000110  4541502d          DCB      "EAP-AKA: Failed to encrypt AT_ENCR_DATA",0
000114  414b413a
000118  20466169
00011c  6c656420
000120  746f2065
000124  6e637279
000128  70742041
00012c  545f454e
000130  43525f44
000134  41544100
                  |L28.312|
000138  20202041          DCB      "   AT_MAC",0
00013c  545f4d41
000140  4300    
000142  00                DCB      0
000143  00                DCB      0

                          AREA ||i.eap_aka_response_reauth||, CODE, READONLY, ALIGN=2

                  eap_aka_response_reauth PROC
;;;531    
;;;532    static struct wpabuf * eap_aka_response_reauth(struct eap_aka_data *data,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;533    					       u8 id, int counter_too_small,
;;;534    					       const u8 *nonce_s)
;;;535    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;536    	struct eap_sim_msg *msg;
;;;537    	unsigned int counter;
;;;538    
;;;539    	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Reauthentication (id=%d)",
00000c  4632              MOV      r2,r6
00000e  a134              ADR      r1,|L29.224|
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       wpa_printf
;;;540    		   id);
;;;541    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
000016  f8942198          LDRB     r2,[r4,#0x198]
00001a  230d              MOVS     r3,#0xd
00001c  4631              MOV      r1,r6
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       eap_sim_msg_init
000024  4681              MOV      r9,r0
;;;542    			       EAP_AKA_SUBTYPE_REAUTHENTICATION);
;;;543    	wpa_printf(MSG_DEBUG, "   AT_IV");
000026  a139              ADR      r1,|L29.268|
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       wpa_printf
;;;544    	wpa_printf(MSG_DEBUG, "   AT_ENCR_DATA");
00002e  a13a              ADR      r1,|L29.280|
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       wpa_printf
;;;545    	eap_sim_msg_add_encr_start(msg, EAP_SIM_AT_IV, EAP_SIM_AT_ENCR_DATA);
000036  2282              MOVS     r2,#0x82
000038  2181              MOVS     r1,#0x81
00003a  4648              MOV      r0,r9
00003c  f7fffffe          BL       eap_sim_msg_add_encr_start
;;;546    
;;;547    	if (counter_too_small) {
000040  b16f              CBZ      r7,|L29.94|
;;;548    		wpa_printf(MSG_DEBUG, "   *AT_COUNTER_TOO_SMALL");
000042  a139              ADR      r1,|L29.296|
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       wpa_printf
;;;549    		eap_sim_msg_add(msg, EAP_SIM_AT_COUNTER_TOO_SMALL, 0, NULL, 0);
00004a  2300              MOVS     r3,#0
00004c  461a              MOV      r2,r3
00004e  2114              MOVS     r1,#0x14
000050  4648              MOV      r0,r9
000052  9300              STR      r3,[sp,#0]
000054  f7fffffe          BL       eap_sim_msg_add
;;;550    		counter = data->counter_too_small;
000058  f8d45178          LDR      r5,[r4,#0x178]
00005c  e001              B        |L29.98|
                  |L29.94|
;;;551    	} else
;;;552    		counter = data->counter;
00005e  f8d45174          LDR      r5,[r4,#0x174]
                  |L29.98|
;;;553    
;;;554    	wpa_printf(MSG_DEBUG, "   *AT_COUNTER %d", counter);
000062  462a              MOV      r2,r5
000064  a137              ADR      r1,|L29.324|
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       wpa_printf
;;;555    	eap_sim_msg_add(msg, EAP_SIM_AT_COUNTER, counter, NULL, 0);
00006c  2300              MOVS     r3,#0
00006e  b2aa              UXTH     r2,r5
000070  2113              MOVS     r1,#0x13
000072  4648              MOV      r0,r9
000074  9300              STR      r3,[sp,#0]
000076  f7fffffe          BL       eap_sim_msg_add
;;;556    
;;;557    	if (eap_sim_msg_add_encr_end(msg, data->k_encr, EAP_SIM_AT_PADDING)) {
00007a  2206              MOVS     r2,#6
00007c  f1040178          ADD      r1,r4,#0x78
000080  4648              MOV      r0,r9
000082  f7fffffe          BL       eap_sim_msg_add_encr_end
000086  b148              CBZ      r0,|L29.156|
;;;558    		wpa_printf(MSG_WARNING, "EAP-AKA: Failed to encrypt "
000088  a133              ADR      r1,|L29.344|
00008a  2000              MOVS     r0,#0
00008c  f7fffffe          BL       wpa_printf
;;;559    			   "AT_ENCR_DATA");
;;;560    		eap_sim_msg_free(msg);
000090  4648              MOV      r0,r9
000092  f7fffffe          BL       eap_sim_msg_free
;;;561    		return NULL;
000096  2000              MOVS     r0,#0
                  |L29.152|
;;;562    	}
;;;563    	eap_aka_add_checkcode(data, msg);
;;;564    	if (data->use_result_ind) {
;;;565    		wpa_printf(MSG_DEBUG, "   AT_RESULT_IND");
;;;566    		eap_sim_msg_add(msg, EAP_SIM_AT_RESULT_IND, 0, NULL, 0);
;;;567    	}
;;;568    	wpa_printf(MSG_DEBUG, "   AT_MAC");
;;;569    	eap_sim_msg_add_mac(msg, EAP_SIM_AT_MAC);
;;;570    	return eap_sim_msg_finish(msg, data->k_aut, nonce_s,
;;;571    				  EAP_SIM_NONCE_S_LEN);
;;;572    }
000098  e8bd83f8          POP      {r3-r9,pc}
                  |L29.156|
00009c  4649              MOV      r1,r9                 ;563
00009e  4620              MOV      r0,r4                 ;563
0000a0  f7fffffe          BL       eap_aka_add_checkcode
0000a4  f8d40194          LDR      r0,[r4,#0x194]        ;564
0000a8  b150              CBZ      r0,|L29.192|
0000aa  a135              ADR      r1,|L29.384|
0000ac  2000              MOVS     r0,#0                 ;565
0000ae  f7fffffe          BL       wpa_printf
0000b2  2300              MOVS     r3,#0                 ;566
0000b4  461a              MOV      r2,r3                 ;566
0000b6  2187              MOVS     r1,#0x87              ;566
0000b8  4648              MOV      r0,r9                 ;566
0000ba  9300              STR      r3,[sp,#0]            ;566
0000bc  f7fffffe          BL       eap_sim_msg_add
                  |L29.192|
0000c0  a134              ADR      r1,|L29.404|
0000c2  2000              MOVS     r0,#0                 ;568
0000c4  f7fffffe          BL       wpa_printf
0000c8  210b              MOVS     r1,#0xb               ;569
0000ca  4648              MOV      r0,r9                 ;569
0000cc  f7fffffe          BL       eap_sim_msg_add_mac
0000d0  2310              MOVS     r3,#0x10              ;570
0000d2  4642              MOV      r2,r8                 ;570
0000d4  f1040158          ADD      r1,r4,#0x58           ;570
0000d8  4648              MOV      r0,r9                 ;570
0000da  f7fffffe          BL       eap_sim_msg_finish
0000de  e7db              B        |L29.152|
;;;573    
                          ENDP

                  |L29.224|
0000e0  47656e65          DCB      "Generating EAP-AKA Reauthentication (id=%d)",0
0000e4  72617469
0000e8  6e672045
0000ec  41502d41
0000f0  4b412052
0000f4  65617574
0000f8  68656e74
0000fc  69636174
000100  696f6e20
000104  2869643d
000108  25642900
                  |L29.268|
00010c  20202041          DCB      "   AT_IV",0
000110  545f4956
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L29.280|
000118  20202041          DCB      "   AT_ENCR_DATA",0
00011c  545f454e
000120  43525f44
000124  41544100
                  |L29.296|
000128  2020202a          DCB      "   *AT_COUNTER_TOO_SMALL",0
00012c  41545f43
000130  4f554e54
000134  45525f54
000138  4f4f5f53
00013c  4d414c4c
000140  00      
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0
                  |L29.324|
000144  2020202a          DCB      "   *AT_COUNTER %d",0
000148  41545f43
00014c  4f554e54
000150  45522025
000154  6400    
000156  00                DCB      0
000157  00                DCB      0
                  |L29.344|
000158  4541502d          DCB      "EAP-AKA: Failed to encrypt AT_ENCR_DATA",0
00015c  414b413a
000160  20466169
000164  6c656420
000168  746f2065
00016c  6e637279
000170  70742041
000174  545f454e
000178  43525f44
00017c  41544100
                  |L29.384|
000180  20202041          DCB      "   AT_RESULT_IND",0
000184  545f5245
000188  53554c54
00018c  5f494e44
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L29.404|
000194  20202041          DCB      "   AT_MAC",0
000198  545f4d41
00019c  4300    
00019e  00                DCB      0
00019f  00                DCB      0

                          AREA ||i.eap_aka_state||, CODE, READONLY, ALIGN=2

                  eap_aka_state PROC
;;;94     
;;;95     static void eap_aka_state(struct eap_aka_data *data, int state)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;97     	wpa_printf(MSG_DEBUG, "EAP-AKA: %s -> %s",
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       eap_aka_state_txt
00000e  4606              MOV      r6,r0
000010  f8d40184          LDR      r0,[r4,#0x184]
000014  f7fffffe          BL       eap_aka_state_txt
000018  4607              MOV      r7,r0
00001a  4633              MOV      r3,r6
00001c  4602              MOV      r2,r0
00001e  a104              ADR      r1,|L30.48|
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       wpa_printf
;;;98     		   eap_aka_state_txt(data->state),
;;;99     		   eap_aka_state_txt(state));
;;;100    	data->state = state;
000026  f8c45184          STR      r5,[r4,#0x184]
;;;101    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;102    
                          ENDP

00002e  0000              DCW      0x0000
                  |L30.48|
000030  4541502d          DCB      "EAP-AKA: %s -> %s",0
000034  414b413a
000038  20257320
00003c  2d3e2025
000040  7300    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.eap_aka_state_txt||, CODE, READONLY, ALIGN=2

                  eap_aka_state_txt PROC
;;;74     #ifndef CONFIG_NO_STDOUT_DEBUG
;;;75     static const char * eap_aka_state_txt(int state)
000000  4601              MOV      r1,r0
;;;76     {
;;;77     	switch (state) {
000002  2905              CMP      r1,#5
000004  d20e              BCS      |L31.36|
000006  e8dff001          TBB      [pc,r1]
00000a  0305              DCB      0x03,0x05
00000c  07090b00          DCB      0x07,0x09,0x0b,0x00
;;;78     	case CONTINUE:
;;;79     		return "CONTINUE";
000010  a005              ADR      r0,|L31.40|
                  |L31.18|
;;;80     	case RESULT_SUCCESS:
;;;81     		return "RESULT_SUCCESS";
;;;82     	case RESULT_FAILURE:
;;;83     		return "RESULT_FAILURE";
;;;84     	case SUCCESS:
;;;85     		return "SUCCESS";
;;;86     	case FAILURE:
;;;87     		return "FAILURE";
;;;88     	default:
;;;89     		return "?";
;;;90     	}
;;;91     }
000012  4770              BX       lr
000014  a007              ADR      r0,|L31.52|
000016  e7fc              B        |L31.18|
000018  a00a              ADR      r0,|L31.68|
00001a  e7fa              B        |L31.18|
00001c  a00d              ADR      r0,|L31.84|
00001e  e7f8              B        |L31.18|
000020  a00e              ADR      r0,|L31.92|
000022  e7f6              B        |L31.18|
                  |L31.36|
000024  a00f              ADR      r0,|L31.100|
000026  e7f4              B        |L31.18|
;;;92     #endif /* CONFIG_NO_STDOUT_DEBUG */
                          ENDP

                  |L31.40|
000028  434f4e54          DCB      "CONTINUE",0
00002c  494e5545
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L31.52|
000034  52455355          DCB      "RESULT_SUCCESS",0
000038  4c545f53
00003c  55434345
000040  535300  
000043  00                DCB      0
                  |L31.68|
000044  52455355          DCB      "RESULT_FAILURE",0
000048  4c545f46
00004c  41494c55
000050  524500  
000053  00                DCB      0
                  |L31.84|
000054  53554343          DCB      "SUCCESS",0
000058  45535300
                  |L31.92|
00005c  4641494c          DCB      "FAILURE",0
000060  55524500
                  |L31.100|
000064  3f00              DCB      "?",0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.eap_aka_synchronization_failure||, CODE, READONLY, ALIGN=2

                  eap_aka_synchronization_failure PROC
;;;446    
;;;447    static struct wpabuf * eap_aka_synchronization_failure(
000000  b570              PUSH     {r4-r6,lr}
;;;448    	struct eap_aka_data *data, u8 id)
;;;449    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;450    	struct eap_sim_msg *msg;
;;;451    
;;;452    	data->num_id_req = 0;
000006  2000              MOVS     r0,#0
000008  f8c40158          STR      r0,[r4,#0x158]
;;;453    	data->num_notification = 0;
00000c  f8c4015c          STR      r0,[r4,#0x15c]
;;;454    
;;;455    	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Synchronization-Failure "
000010  462a              MOV      r2,r5
000012  a10e              ADR      r1,|L32.76|
000014  f7fffffe          BL       wpa_printf
;;;456    		   "(id=%d)", id);
;;;457    	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
000018  f8942198          LDRB     r2,[r4,#0x198]
00001c  2304              MOVS     r3,#4
00001e  4629              MOV      r1,r5
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       eap_sim_msg_init
000026  4606              MOV      r6,r0
;;;458    			       EAP_AKA_SUBTYPE_SYNCHRONIZATION_FAILURE);
;;;459    	wpa_printf(MSG_DEBUG, "   AT_AUTS");
000028  a115              ADR      r1,|L32.128|
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       wpa_printf
;;;460    	eap_sim_msg_add_full(msg, EAP_SIM_AT_AUTS, data->auts,
000030  230e              MOVS     r3,#0xe
000032  f50472a4          ADD      r2,r4,#0x148
000036  2104              MOVS     r1,#4
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       eap_sim_msg_add_full
;;;461    			     EAP_AKA_AUTS_LEN);
;;;462    	return eap_sim_msg_finish(msg, NULL, NULL, 0);
00003e  2300              MOVS     r3,#0
000040  461a              MOV      r2,r3
000042  4619              MOV      r1,r3
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       eap_sim_msg_finish
;;;463    }
00004a  bd70              POP      {r4-r6,pc}
;;;464    
                          ENDP

                  |L32.76|
00004c  47656e65          DCB      "Generating EAP-AKA Synchronization-Failure (id=%d)",0
000050  72617469
000054  6e672045
000058  41502d41
00005c  4b412053
000060  796e6368
000064  726f6e69
000068  7a617469
00006c  6f6e2d46
000070  61696c75
000074  72652028
000078  69643d25
00007c  642900  
00007f  00                DCB      0
                  |L32.128|
000080  20202041          DCB      "   AT_AUTS",0
000084  545f4155
000088  545300  
00008b  00                DCB      0

                          AREA ||i.eap_aka_umts_auth||, CODE, READONLY, ALIGN=2

                  eap_aka_umts_auth PROC
;;;149    
;;;150    static int eap_aka_umts_auth(struct eap_sm *sm, struct eap_aka_data *data)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;152    	struct eap_peer_config *conf;
;;;153    
;;;154    	wpa_printf(MSG_DEBUG, "EAP-AKA: UMTS authentication algorithm");
000006  a10c              ADR      r1,|L33.56|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       wpa_printf
;;;155    
;;;156    	conf = eap_get_config(sm);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       eap_get_config
000014  4604              MOV      r4,r0
;;;157    	if (conf == NULL)
000016  b914              CBNZ     r4,|L33.30|
;;;158    		return -1;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L33.28|
;;;159    	if (conf->pcsc) {
;;;160    		return scard_umts_auth(sm->scard_ctx, data->rand,
;;;161    				       data->autn, data->res, &data->res_len,
;;;162    				       data->ik, data->ck, data->auts);
;;;163    	}
;;;164    
;;;165    #ifdef CONFIG_USIM_SIMULATOR
;;;166    	if (conf->password) {
;;;167    		u8 opc[16], k[16], sqn[6];
;;;168    		const char *pos;
;;;169    		wpa_printf(MSG_DEBUG, "EAP-AKA: Use internal Milenage "
;;;170    			   "implementation for UMTS authentication");
;;;171    		if (conf->password_len < 78) {
;;;172    			wpa_printf(MSG_DEBUG, "EAP-AKA: invalid Milenage "
;;;173    				   "password");
;;;174    			return -1;
;;;175    		}
;;;176    		pos = (const char *) conf->password;
;;;177    		if (hexstr2bin(pos, k, 16))
;;;178    			return -1;
;;;179    		pos += 32;
;;;180    		if (*pos != ':')
;;;181    			return -1;
;;;182    		pos++;
;;;183    
;;;184    		if (hexstr2bin(pos, opc, 16))
;;;185    			return -1;
;;;186    		pos += 32;
;;;187    		if (*pos != ':')
;;;188    			return -1;
;;;189    		pos++;
;;;190    
;;;191    		if (hexstr2bin(pos, sqn, 6))
;;;192    			return -1;
;;;193    
;;;194    		return milenage_check(opc, k, sqn, data->rand, data->autn,
;;;195    				      data->ik, data->ck,
;;;196    				      data->res, &data->res_len, data->auts);
;;;197    	}
;;;198    #endif /* CONFIG_USIM_SIMULATOR */
;;;199    
;;;200    #ifdef CONFIG_USIM_HARDCODED
;;;201    	wpa_printf(MSG_DEBUG, "EAP-AKA: Use hardcoded Kc and SRES values for "
;;;202    		   "testing");
;;;203    
;;;204    	/* These hardcoded Kc and SRES values are used for testing.
;;;205    	 * Could consider making them configurable. */
;;;206    	os_memset(data->res, '2', EAP_AKA_RES_MAX_LEN);
;;;207    	data->res_len = EAP_AKA_RES_MAX_LEN;
;;;208    	os_memset(data->ik, '3', EAP_AKA_IK_LEN);
;;;209    	os_memset(data->ck, '4', EAP_AKA_CK_LEN);
;;;210    	{
;;;211    		u8 autn[EAP_AKA_AUTN_LEN];
;;;212    		os_memset(autn, '1', EAP_AKA_AUTN_LEN);
;;;213    		if (os_memcmp(autn, data->autn, EAP_AKA_AUTN_LEN) != 0) {
;;;214    			wpa_printf(MSG_WARNING, "EAP-AKA: AUTN did not match "
;;;215    				   "with expected value");
;;;216    			return -1;
;;;217    		}
;;;218    	}
;;;219    #if 0
;;;220    	{
;;;221    		static int test_resync = 1;
;;;222    		if (test_resync) {
;;;223    			/* Test Resynchronization */
;;;224    			test_resync = 0;
;;;225    			return -2;
;;;226    		}
;;;227    	}
;;;228    #endif
;;;229    	return 0;
;;;230    
;;;231    #else /* CONFIG_USIM_HARDCODED */
;;;232    
;;;233    	wpa_printf(MSG_DEBUG, "EAP-AKA: No UMTS authentication algorith "
;;;234    		   "enabled");
;;;235    	return -1;
;;;236    
;;;237    #endif /* CONFIG_USIM_HARDCODED */
;;;238    }
00001c  bd70              POP      {r4-r6,pc}
                  |L33.30|
00001e  6e60              LDR      r0,[r4,#0x64]         ;159
000020  b110              CBZ      r0,|L33.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;160
000026  e7f9              B        |L33.28|
                  |L33.40|
000028  a10d              ADR      r1,|L33.96|
00002a  2000              MOVS     r0,#0                 ;233
00002c  f7fffffe          BL       wpa_printf
000030  f04f30ff          MOV      r0,#0xffffffff        ;235
000034  e7f2              B        |L33.28|
;;;239    
                          ENDP

000036  0000              DCW      0x0000
                  |L33.56|
000038  4541502d          DCB      "EAP-AKA: UMTS authentication algorithm",0
00003c  414b413a
000040  20554d54
000044  53206175
000048  7468656e
00004c  74696361
000050  74696f6e
000054  20616c67
000058  6f726974
00005c  686d00  
00005f  00                DCB      0
                  |L33.96|
000060  4541502d          DCB      "EAP-AKA: No UMTS authentication algorith enabled",0
000064  414b413a
000068  204e6f20
00006c  554d5453
000070  20617574
000074  68656e74
000078  69636174
00007c  696f6e20
000080  616c676f
000084  72697468
000088  20656e61
00008c  626c6564
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.eap_aka_verify_checkcode||, CODE, READONLY, ALIGN=2

                  eap_aka_verify_checkcode PROC
;;;363    
;;;364    static int eap_aka_verify_checkcode(struct eap_aka_data *data,
000000  b5f0              PUSH     {r4-r7,lr}
;;;365    				    const u8 *checkcode, size_t checkcode_len)
;;;366    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;367    	const u8 *addr;
;;;368    	size_t len;
;;;369    	u8 hash[SHA256_MAC_LEN];
;;;370    	size_t hash_len;
;;;371    
;;;372    	if (checkcode == NULL)
00000a  b91e              CBNZ     r6,|L34.20|
;;;373    		return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L34.16|
;;;374    
;;;375    	if (data->id_msgs == NULL) {
;;;376    		if (checkcode_len != 0) {
;;;377    			wpa_printf(MSG_DEBUG, "EAP-AKA: Checkcode from server "
;;;378    				   "indicates that AKA/Identity messages were "
;;;379    				   "used, but they were not");
;;;380    			return -1;
;;;381    		}
;;;382    		return 0;
;;;383    	}
;;;384    
;;;385    	hash_len = data->eap_method == EAP_TYPE_AKA_PRIME ?
;;;386    		EAP_AKA_PRIME_CHECKCODE_LEN : EAP_AKA_CHECKCODE_LEN;
;;;387    
;;;388    	if (checkcode_len != hash_len) {
;;;389    		wpa_printf(MSG_DEBUG, "EAP-AKA: Checkcode from server "
;;;390    			   "indicates that AKA/Identity message were not "
;;;391    			   "used, but they were");
;;;392    		return -1;
;;;393    	}
;;;394    
;;;395    	/* Checkcode is SHA1/SHA256 hash over all EAP-AKA/Identity packets. */
;;;396    	addr = wpabuf_head(data->id_msgs);
;;;397    	len = wpabuf_len(data->id_msgs);
;;;398    #ifdef EAP_AKA_PRIME
;;;399    	if (data->eap_method == EAP_TYPE_AKA_PRIME)
;;;400    		sha256_vector(1, &addr, &len, hash);
;;;401    	else
;;;402    #endif /* EAP_AKA_PRIME */
;;;403    		sha1_vector(1, &addr, &len, hash);
;;;404    
;;;405    	if (os_memcmp(hash, checkcode, hash_len) != 0) {
;;;406    		wpa_printf(MSG_DEBUG, "EAP-AKA: Mismatch in AT_CHECKCODE");
;;;407    		return -1;
;;;408    	}
;;;409    
;;;410    	return 0;
;;;411    }
000010  b00b              ADD      sp,sp,#0x2c
000012  bdf0              POP      {r4-r7,pc}
                  |L34.20|
000014  f8d40188          LDR      r0,[r4,#0x188]        ;375
000018  b948              CBNZ     r0,|L34.46|
00001a  b135              CBZ      r5,|L34.42|
00001c  491c              LDR      r1,|L34.144|
00001e  2000              MOVS     r0,#0                 ;377
000020  f7fffffe          BL       wpa_printf
000024  f04f30ff          MOV      r0,#0xffffffff        ;380
000028  e7f2              B        |L34.16|
                  |L34.42|
00002a  2000              MOVS     r0,#0                 ;382
00002c  e7f0              B        |L34.16|
                  |L34.46|
00002e  f8940198          LDRB     r0,[r4,#0x198]        ;385
000032  2832              CMP      r0,#0x32              ;385
000034  d101              BNE      |L34.58|
000036  2020              MOVS     r0,#0x20              ;386
000038  e000              B        |L34.60|
                  |L34.58|
00003a  2014              MOVS     r0,#0x14              ;386
                  |L34.60|
00003c  4607              MOV      r7,r0                 ;386
00003e  42bd              CMP      r5,r7                 ;388
000040  d007              BEQ      |L34.82|
000042  4913              LDR      r1,|L34.144|
000044  3164              ADDS     r1,r1,#0x64           ;389
000046  2000              MOVS     r0,#0                 ;389
000048  f7fffffe          BL       wpa_printf
00004c  f04f30ff          MOV      r0,#0xffffffff        ;392
000050  e7de              B        |L34.16|
                  |L34.82|
000052  f8d40188          LDR      r0,[r4,#0x188]        ;396
000056  f7fffffe          BL       wpabuf_head
00005a  900a              STR      r0,[sp,#0x28]         ;396
00005c  f8d40188          LDR      r0,[r4,#0x188]        ;397
000060  f7fffffe          BL       wpabuf_len
000064  9009              STR      r0,[sp,#0x24]         ;397
000066  ab01              ADD      r3,sp,#4              ;403
000068  aa09              ADD      r2,sp,#0x24           ;403
00006a  a90a              ADD      r1,sp,#0x28           ;403
00006c  2001              MOVS     r0,#1                 ;403
00006e  f7fffffe          BL       sha1_vector
000072  463a              MOV      r2,r7                 ;405
000074  4631              MOV      r1,r6                 ;405
000076  a801              ADD      r0,sp,#4              ;405
000078  f7fffffe          BL       os_memcmp
00007c  b130              CBZ      r0,|L34.140|
00007e  a105              ADR      r1,|L34.148|
000080  2000              MOVS     r0,#0                 ;406
000082  f7fffffe          BL       wpa_printf
000086  f04f30ff          MOV      r0,#0xffffffff        ;407
00008a  e7c1              B        |L34.16|
                  |L34.140|
00008c  2000              MOVS     r0,#0                 ;410
00008e  e7bf              B        |L34.16|
;;;412    
                          ENDP

                  |L34.144|
                          DCD      ||.constdata||
                  |L34.148|
000094  4541502d          DCB      "EAP-AKA: Mismatch in AT_CHECKCODE",0
000098  414b413a
00009c  204d6973
0000a0  6d617463
0000a4  6820696e
0000a8  2041545f
0000ac  43484543
0000b0  4b434f44
0000b4  4500    
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.eap_aka_verify_mac||, CODE, READONLY, ALIGN=1

                  eap_aka_verify_mac PROC
;;;657    
;;;658    static int eap_aka_verify_mac(struct eap_aka_data *data,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;659    			      const struct wpabuf *req,
;;;660    			      const u8 *mac, const u8 *extra,
;;;661    			      size_t extra_len)
;;;662    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;663    	if (data->eap_method == EAP_TYPE_AKA_PRIME)
000010  f8940198          LDRB     r0,[r4,#0x198]
000014  2832              CMP      r0,#0x32
000016  d10a              BNE      |L35.46|
;;;664    		return eap_sim_verify_mac_sha256(data->k_aut, req, mac, extra,
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  f1040058          ADD      r0,r4,#0x58
000022  f8cd8000          STR      r8,[sp,#0]
000026  f7fffffe          BL       eap_sim_verify_mac_sha256
                  |L35.42|
;;;665    						 extra_len);
;;;666    	return eap_sim_verify_mac(data->k_aut, req, mac, extra, extra_len);
;;;667    }
00002a  e8bd83f8          POP      {r3-r9,pc}
                  |L35.46|
00002e  463b              MOV      r3,r7                 ;666
000030  4632              MOV      r2,r6                 ;666
000032  4629              MOV      r1,r5                 ;666
000034  f1040058          ADD      r0,r4,#0x58           ;666
000038  f8cd8000          STR      r8,[sp,#0]            ;666
00003c  f7fffffe          BL       eap_sim_verify_mac
000040  e7f3              B        |L35.42|
;;;668    
                          ENDP


                          AREA ||i.eap_peer_aka_register||, CODE, READONLY, ALIGN=2

                  eap_peer_aka_register PROC
;;;1340   
;;;1341   int eap_peer_aka_register(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1342   {
;;;1343   	struct eap_method *eap;
;;;1344   	int ret;
;;;1345   
;;;1346   	eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
000002  a314              ADR      r3,|L36.84|
000004  2217              MOVS     r2,#0x17
000006  2100              MOVS     r1,#0
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       eap_peer_method_alloc
00000e  4604              MOV      r4,r0
;;;1347   				    EAP_VENDOR_IETF, EAP_TYPE_AKA, "AKA");
;;;1348   	if (eap == NULL)
000010  b914              CBNZ     r4,|L36.24|
;;;1349   		return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L36.22|
;;;1350   
;;;1351   	eap->init = eap_aka_init;
;;;1352   	eap->deinit = eap_aka_deinit;
;;;1353   	eap->process = eap_aka_process;
;;;1354   	eap->isKeyAvailable = eap_aka_isKeyAvailable;
;;;1355   	eap->getKey = eap_aka_getKey;
;;;1356   	eap->has_reauth_data = eap_aka_has_reauth_data;
;;;1357   	eap->deinit_for_reauth = eap_aka_deinit_for_reauth;
;;;1358   	eap->init_for_reauth = eap_aka_init_for_reauth;
;;;1359   	eap->get_identity = eap_aka_get_identity;
;;;1360   	eap->get_emsk = eap_aka_get_emsk;
;;;1361   
;;;1362   	ret = eap_peer_method_register(eap);
;;;1363   	if (ret)
;;;1364   		eap_peer_method_free(eap);
;;;1365   	return ret;
;;;1366   }
000016  bd70              POP      {r4-r6,pc}
                  |L36.24|
000018  480f              LDR      r0,|L36.88|
00001a  60e0              STR      r0,[r4,#0xc]          ;1351
00001c  480f              LDR      r0,|L36.92|
00001e  6120              STR      r0,[r4,#0x10]         ;1352
000020  480f              LDR      r0,|L36.96|
000022  6160              STR      r0,[r4,#0x14]         ;1353
000024  480f              LDR      r0,|L36.100|
000026  61a0              STR      r0,[r4,#0x18]         ;1354
000028  480f              LDR      r0,|L36.104|
00002a  61e0              STR      r0,[r4,#0x1c]         ;1355
00002c  480f              LDR      r0,|L36.108|
00002e  6260              STR      r0,[r4,#0x24]         ;1356
000030  480f              LDR      r0,|L36.112|
000032  62a0              STR      r0,[r4,#0x28]         ;1357
000034  480f              LDR      r0,|L36.116|
000036  62e0              STR      r0,[r4,#0x2c]         ;1358
000038  480f              LDR      r0,|L36.120|
00003a  6320              STR      r0,[r4,#0x30]         ;1359
00003c  480f              LDR      r0,|L36.124|
00003e  6420              STR      r0,[r4,#0x40]         ;1360
000040  4620              MOV      r0,r4                 ;1362
000042  f7fffffe          BL       eap_peer_method_register
000046  4605              MOV      r5,r0                 ;1362
000048  b115              CBZ      r5,|L36.80|
00004a  4620              MOV      r0,r4                 ;1364
00004c  f7fffffe          BL       eap_peer_method_free
                  |L36.80|
000050  4628              MOV      r0,r5                 ;1365
000052  e7e0              B        |L36.22|
;;;1367   
                          ENDP

                  |L36.84|
000054  414b4100          DCB      "AKA",0
                  |L36.88|
                          DCD      eap_aka_init
                  |L36.92|
                          DCD      eap_aka_deinit
                  |L36.96|
                          DCD      eap_aka_process
                  |L36.100|
                          DCD      eap_aka_isKeyAvailable
                  |L36.104|
                          DCD      eap_aka_getKey
                  |L36.108|
                          DCD      eap_aka_has_reauth_data
                  |L36.112|
                          DCD      eap_aka_deinit_for_reauth
                  |L36.116|
                          DCD      eap_aka_init_for_reauth
                  |L36.120|
                          DCD      eap_aka_get_identity
                  |L36.124|
                          DCD      eap_aka_get_emsk

                          AREA ||i.eap_peer_method_load||, CODE, READONLY, ALIGN=1

                  eap_peer_method_load PROC
;;;78     
;;;79     static inline int eap_peer_method_load(const char *so)
000000  4601              MOV      r1,r0
;;;80     {
;;;81     	return 0;
000002  2000              MOVS     r0,#0
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.eap_peer_method_unload||, CODE, READONLY, ALIGN=1

                  eap_peer_method_unload PROC
;;;83     
;;;84     static inline int eap_peer_method_unload(struct eap_method *method)
000000  4601              MOV      r1,r0
;;;85     {
;;;86     	return 0;
000002  2000              MOVS     r0,#0
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.eap_sim_verify_mac_sha256||, CODE, READONLY, ALIGN=1

                  eap_sim_verify_mac_sha256 PROC
;;;130    
;;;131    static inline int eap_sim_verify_mac_sha256(const u8 *k_aut,
000000  b530              PUSH     {r4,r5,lr}
;;;132    					    const struct wpabuf *req,
;;;133    					    const u8 *mac, const u8 *extra,
;;;134    					    size_t extra_len)
;;;135    {
000002  4605              MOV      r5,r0
000004  9c03              LDR      r4,[sp,#0xc]
;;;136    	return -1;
000006  f04f30ff          MOV      r0,#0xffffffff
;;;137    }
00000a  bd30              POP      {r4,r5,pc}
;;;138    #endif /* EAP_AKA_PRIME || EAP_SERVER_AKA_PRIME */
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L40.30|
00001a  2001              MOVS     r0,#1
                  |L40.28|
;;;495    }
00001c  4770              BX       lr
                  |L40.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L40.28|
;;;496    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpa_key_mgmt_ft||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_ft PROC
;;;65     
;;;66     static inline int wpa_key_mgmt_ft(int akm)
000000  4601              MOV      r1,r0
;;;67     {
;;;68     	return akm == WPA_KEY_MGMT_FT_PSK ||
000002  2940              CMP      r1,#0x40
000004  d001              BEQ      |L45.10|
;;;69     		akm == WPA_KEY_MGMT_FT_IEEE8021X;
000006  2920              CMP      r1,#0x20
000008  d101              BNE      |L45.14|
                  |L45.10|
00000a  2001              MOVS     r0,#1                 ;68
                  |L45.12|
;;;70     }
00000c  4770              BX       lr
                  |L45.14|
00000e  2000              MOVS     r0,#0                 ;68
000010  e7fc              B        |L45.12|
;;;71     
                          ENDP


                          AREA ||i.wpa_key_mgmt_sha256||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_sha256 PROC
;;;71     
;;;72     static inline int wpa_key_mgmt_sha256(int akm)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return akm == WPA_KEY_MGMT_PSK_SHA256 ||
000002  f5b17f80          CMP      r1,#0x100
000006  d001              BEQ      |L46.12|
;;;75     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
000008  2980              CMP      r1,#0x80
00000a  d101              BNE      |L46.16|
                  |L46.12|
00000c  2001              MOVS     r0,#1                 ;74
                  |L46.14|
;;;76     }
00000e  4770              BX       lr
                  |L46.16|
000010  2000              MOVS     r0,#0                 ;74
000012  e7fc              B        |L46.14|
;;;77     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_ieee8021x||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_ieee8021x PROC
;;;51     
;;;52     static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return akm == WPA_KEY_MGMT_IEEE8021X ||
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L47.14|
;;;55     		akm == WPA_KEY_MGMT_FT_IEEE8021X ||
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L47.14|
;;;56     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
00000a  2980              CMP      r1,#0x80
00000c  d101              BNE      |L47.18|
                  |L47.14|
00000e  2001              MOVS     r0,#1                 ;54
                  |L47.16|
;;;57     }
000010  4770              BX       lr
                  |L47.18|
000012  2000              MOVS     r0,#0                 ;54
000014  e7fc              B        |L47.16|
;;;58     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_psk||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_psk PROC
;;;58     
;;;59     static inline int wpa_key_mgmt_wpa_psk(int akm)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     	return akm == WPA_KEY_MGMT_PSK ||
000002  2902              CMP      r1,#2
000004  d004              BEQ      |L48.16|
;;;62     		akm == WPA_KEY_MGMT_FT_PSK ||
000006  2940              CMP      r1,#0x40
000008  d002              BEQ      |L48.16|
;;;63     		akm == WPA_KEY_MGMT_PSK_SHA256;
00000a  f5b17f80          CMP      r1,#0x100
00000e  d101              BNE      |L48.20|
                  |L48.16|
000010  2001              MOVS     r0,#1                 ;61
                  |L48.18|
;;;64     }
000012  4770              BX       lr
                  |L48.20|
000014  2000              MOVS     r0,#0                 ;61
000016  e7fc              B        |L48.18|
;;;65     
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L49.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L49.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L49.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L49.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L52.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L52.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L52.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L52.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L58.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L58.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  4541502d          DCB      0x45,0x41,0x50,0x2d
000004  414b413a          DCB      0x41,0x4b,0x41,0x3a
000008  20436865          DCB      0x20,0x43,0x68,0x65
00000c  636b636f          DCB      0x63,0x6b,0x63,0x6f
000010  64652066          DCB      0x64,0x65,0x20,0x66
000014  726f6d20          DCB      0x72,0x6f,0x6d,0x20
000018  73657276          DCB      0x73,0x65,0x72,0x76
00001c  65722069          DCB      0x65,0x72,0x20,0x69
000020  6e646963          DCB      0x6e,0x64,0x69,0x63
000024  61746573          DCB      0x61,0x74,0x65,0x73
000028  20746861          DCB      0x20,0x74,0x68,0x61
00002c  7420414b          DCB      0x74,0x20,0x41,0x4b
000030  412f4964          DCB      0x41,0x2f,0x49,0x64
000034  656e7469          DCB      0x65,0x6e,0x74,0x69
000038  7479206d          DCB      0x74,0x79,0x20,0x6d
00003c  65737361          DCB      0x65,0x73,0x73,0x61
000040  67657320          DCB      0x67,0x65,0x73,0x20
000044  77657265          DCB      0x77,0x65,0x72,0x65
000048  20757365          DCB      0x20,0x75,0x73,0x65
00004c  642c2062          DCB      0x64,0x2c,0x20,0x62
000050  75742074          DCB      0x75,0x74,0x20,0x74
000054  68657920          DCB      0x68,0x65,0x79,0x20
000058  77657265          DCB      0x77,0x65,0x72,0x65
00005c  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000060  00000000          DCB      0x00,0x00,0x00,0x00
000064  4541502d          DCB      0x45,0x41,0x50,0x2d
000068  414b413a          DCB      0x41,0x4b,0x41,0x3a
00006c  20436865          DCB      0x20,0x43,0x68,0x65
000070  636b636f          DCB      0x63,0x6b,0x63,0x6f
000074  64652066          DCB      0x64,0x65,0x20,0x66
000078  726f6d20          DCB      0x72,0x6f,0x6d,0x20
00007c  73657276          DCB      0x73,0x65,0x72,0x76
000080  65722069          DCB      0x65,0x72,0x20,0x69
000084  6e646963          DCB      0x6e,0x64,0x69,0x63
000088  61746573          DCB      0x61,0x74,0x65,0x73
00008c  20746861          DCB      0x20,0x74,0x68,0x61
000090  7420414b          DCB      0x74,0x20,0x41,0x4b
000094  412f4964          DCB      0x41,0x2f,0x49,0x64
000098  656e7469          DCB      0x65,0x6e,0x74,0x69
00009c  7479206d          DCB      0x74,0x79,0x20,0x6d
0000a0  65737361          DCB      0x65,0x73,0x73,0x61
0000a4  67652077          DCB      0x67,0x65,0x20,0x77
0000a8  65726520          DCB      0x65,0x72,0x65,0x20
0000ac  6e6f7420          DCB      0x6e,0x6f,0x74,0x20
0000b0  75736564          DCB      0x75,0x73,0x65,0x64
0000b4  2c206275          DCB      0x2c,0x20,0x62,0x75
0000b8  74207468          DCB      0x74,0x20,0x74,0x68
0000bc  65792077          DCB      0x65,0x79,0x20,0x77
0000c0  65726500          DCB      0x65,0x72,0x65,0x00
0000c4  4541502d          DCB      0x45,0x41,0x50,0x2d
0000c8  414b413a          DCB      0x41,0x4b,0x41,0x3a
0000cc  204e6f74          DCB      0x20,0x4e,0x6f,0x74
0000d0  69666963          DCB      0x69,0x66,0x69,0x63
0000d4  6174696f          DCB      0x61,0x74,0x69,0x6f
0000d8  6e206d65          DCB      0x6e,0x20,0x6d,0x65
0000dc  73736167          DCB      0x73,0x73,0x61,0x67
0000e0  65206166          DCB      0x65,0x20,0x61,0x66
0000e4  74657220          DCB      0x74,0x65,0x72,0x20
0000e8  72656175          DCB      0x72,0x65,0x61,0x75
0000ec  74682064          DCB      0x74,0x68,0x20,0x64
0000f0  6964206e          DCB      0x69,0x64,0x20,0x6e
0000f4  6f742069          DCB      0x6f,0x74,0x20,0x69
0000f8  6e636c75          DCB      0x6e,0x63,0x6c,0x75
0000fc  64652065          DCB      0x64,0x65,0x20,0x65
000100  6e637279          DCB      0x6e,0x63,0x72,0x79
000104  70746564          DCB      0x70,0x74,0x65,0x64
000108  20646174          DCB      0x20,0x64,0x61,0x74
00010c  61000000          DCB      0x61,0x00,0x00,0x00
000110  4541502d          DCB      0x45,0x41,0x50,0x2d
000114  414b413a          DCB      0x41,0x4b,0x41,0x3a
000118  20466169          DCB      0x20,0x46,0x61,0x69
00011c  6c656420          DCB      0x6c,0x65,0x64,0x20
000120  746f2070          DCB      0x74,0x6f,0x20,0x70
000124  61727365          DCB      0x61,0x72,0x73,0x65
000128  20656e63          DCB      0x20,0x65,0x6e,0x63
00012c  72797074          DCB      0x72,0x79,0x70,0x74
000130  65642064          DCB      0x65,0x64,0x20,0x64
000134  61746120          DCB      0x61,0x74,0x61,0x20
000138  66726f6d          DCB      0x66,0x72,0x6f,0x6d
00013c  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000140  69666963          DCB      0x69,0x66,0x69,0x63
000144  6174696f          DCB      0x61,0x74,0x69,0x6f
000148  6e206d65          DCB      0x6e,0x20,0x6d,0x65
00014c  73736167          DCB      0x73,0x73,0x61,0x67
000150  65000000          DCB      0x65,0x00,0x00,0x00
000154  4541502d          DCB      0x45,0x41,0x50,0x2d
000158  414b413a          DCB      0x41,0x4b,0x41,0x3a
00015c  20436f75          DCB      0x20,0x43,0x6f,0x75
000160  6e746572          DCB      0x6e,0x74,0x65,0x72
000164  20696e20          DCB      0x20,0x69,0x6e,0x20
000168  6e6f7469          DCB      0x6e,0x6f,0x74,0x69
00016c  66696361          DCB      0x66,0x69,0x63,0x61
000170  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000174  206d6573          DCB      0x20,0x6d,0x65,0x73
000178  73616765          DCB      0x73,0x61,0x67,0x65
00017c  20646f65          DCB      0x20,0x64,0x6f,0x65
000180  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000184  74206d61          DCB      0x74,0x20,0x6d,0x61
000188  74636820          DCB      0x74,0x63,0x68,0x20
00018c  77697468          DCB      0x77,0x69,0x74,0x68
000190  20636f75          DCB      0x20,0x63,0x6f,0x75
000194  6e746572          DCB      0x6e,0x74,0x65,0x72
000198  20696e20          DCB      0x20,0x69,0x6e,0x20
00019c  72656175          DCB      0x72,0x65,0x61,0x75
0001a0  7468206d          DCB      0x74,0x68,0x20,0x6d
0001a4  65737361          DCB      0x65,0x73,0x73,0x61
0001a8  67650000          DCB      0x67,0x65,0x00,0x00
0001ac  4541502d          DCB      0x45,0x41,0x50,0x2d
0001b0  414b413a          DCB      0x41,0x4b,0x41,0x3a
0001b4  20536572          DCB      0x20,0x53,0x65,0x72
0001b8  76657220          DCB      0x76,0x65,0x72,0x20
0001bc  69732074          DCB      0x69,0x73,0x20,0x74
0001c0  7279696e          DCB      0x72,0x79,0x69,0x6e
0001c4  67207265          DCB      0x67,0x20,0x72,0x65
0001c8  61757468          DCB      0x61,0x75,0x74,0x68
0001cc  656e7469          DCB      0x65,0x6e,0x74,0x69
0001d0  63617469          DCB      0x63,0x61,0x74,0x69
0001d4  6f6e2c20          DCB      0x6f,0x6e,0x2c,0x20
0001d8  62757420          DCB      0x62,0x75,0x74,0x20
0001dc  6e6f2072          DCB      0x6e,0x6f,0x20,0x72
0001e0  65617574          DCB      0x65,0x61,0x75,0x74
0001e4  685f6964          DCB      0x68,0x5f,0x69,0x64
0001e8  20617661          DCB      0x20,0x61,0x76,0x61
0001ec  696c6162          DCB      0x69,0x6c,0x61,0x62
0001f0  6c650000          DCB      0x6c,0x65,0x00,0x00
0001f4  4541502d          DCB      0x45,0x41,0x50,0x2d
0001f8  414b413a          DCB      0x41,0x4b,0x41,0x3a
0001fc  20526561          DCB      0x20,0x52,0x65,0x61
000200  75746865          DCB      0x75,0x74,0x68,0x65
000204  6e746963          DCB      0x6e,0x74,0x69,0x63
000208  6174696f          DCB      0x61,0x74,0x69,0x6f
00020c  6e206d65          DCB      0x6e,0x20,0x6d,0x65
000210  73736167          DCB      0x73,0x73,0x61,0x67
000214  65206469          DCB      0x65,0x20,0x64,0x69
000218  64206e6f          DCB      0x64,0x20,0x6e,0x6f
00021c  7420696e          DCB      0x74,0x20,0x69,0x6e
000220  636c7564          DCB      0x63,0x6c,0x75,0x64
000224  6520656e          DCB      0x65,0x20,0x65,0x6e
000228  63727970          DCB      0x63,0x72,0x79,0x70
00022c  74656420          DCB      0x74,0x65,0x64,0x20
000230  64617461          DCB      0x64,0x61,0x74,0x61
000234  00000000          DCB      0x00,0x00,0x00,0x00
000238  4541502d          DCB      0x45,0x41,0x50,0x2d
00023c  414b413a          DCB      0x41,0x4b,0x41,0x3a
000240  20466169          DCB      0x20,0x46,0x61,0x69
000244  6c656420          DCB      0x6c,0x65,0x64,0x20
000248  746f2070          DCB      0x74,0x6f,0x20,0x70
00024c  61727365          DCB      0x61,0x72,0x73,0x65
000250  20656e63          DCB      0x20,0x65,0x6e,0x63
000254  72797074          DCB      0x72,0x79,0x70,0x74
000258  65642064          DCB      0x65,0x64,0x20,0x64
00025c  61746120          DCB      0x61,0x74,0x61,0x20
000260  66726f6d          DCB      0x66,0x72,0x6f,0x6d
000264  20726561          DCB      0x20,0x72,0x65,0x61
000268  75746865          DCB      0x75,0x74,0x68,0x65
00026c  6e746963          DCB      0x6e,0x74,0x69,0x63
000270  6174696f          DCB      0x61,0x74,0x69,0x6f
000274  6e206d65          DCB      0x6e,0x20,0x6d,0x65
000278  73736167          DCB      0x73,0x73,0x61,0x67
00027c  65000000          DCB      0x65,0x00,0x00,0x00
000280  4541502d          DCB      0x45,0x41,0x50,0x2d
000284  414b413a          DCB      0x41,0x4b,0x41,0x3a
000288  204d6178          DCB      0x20,0x4d,0x61,0x78
00028c  696d756d          DCB      0x69,0x6d,0x75,0x6d
000290  206e756d          DCB      0x20,0x6e,0x75,0x6d
000294  62657220          DCB      0x62,0x65,0x72,0x20
000298  6f662066          DCB      0x6f,0x66,0x20,0x66
00029c  61737420          DCB      0x61,0x73,0x74,0x20
0002a0  72656175          DCB      0x72,0x65,0x61,0x75
0002a4  74687320          DCB      0x74,0x68,0x73,0x20
0002a8  70657266          DCB      0x70,0x65,0x72,0x66
0002ac  6f726d65          DCB      0x6f,0x72,0x6d,0x65
0002b0  64202d20          DCB      0x64,0x20,0x2d,0x20
0002b4  666f7263          DCB      0x66,0x6f,0x72,0x63
0002b8  65206675          DCB      0x65,0x20,0x66,0x75
0002bc  6c6c6175          DCB      0x6c,0x6c,0x61,0x75
0002c0  746800            DCB      0x74,0x68,0x00
