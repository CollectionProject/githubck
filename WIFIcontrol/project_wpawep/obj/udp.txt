; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\udp.o --depend=.\obj\udp.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\udp.crf ..\lwIP\src\core\udp.c]
                          THUMB

                          AREA ||i.udp_bind||, CODE, READONLY, ALIGN=2

                  udp_bind PROC
;;;577    err_t
;;;578    udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
000000  b530              PUSH     {r4,r5,lr}
;;;579    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;580      struct udp_pcb *ipcb;
;;;581      u8_t rebind;
;;;582    
;;;583      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
000006  bf00              NOP      
000008  bf00              NOP      
;;;584      ip_addr_debug_print(UDP_DEBUG, ipaddr);
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;585      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;586    
;;;587      rebind = 0;
000012  2500              MOVS     r5,#0
;;;588      /* Check for double bind and rebind of the same pcb */
;;;589      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
000014  4819              LDR      r0,|L1.124|
000016  6801              LDR      r1,[r0,#0]  ; udp_pcbs
000018  e003              B        |L1.34|
                  |L1.26|
;;;590        /* is this UDP PCB already on active list? */
;;;591        if (pcb == ipcb) {
00001a  428b              CMP      r3,r1
00001c  d100              BNE      |L1.32|
;;;592          /* pcb may occur at most once in active list */
;;;593          LWIP_ASSERT("rebind == 0", rebind == 0);
;;;594          /* pcb already in list, just rebind */
;;;595          rebind = 1;
00001e  2501              MOVS     r5,#1
                  |L1.32|
000020  68c9              LDR      r1,[r1,#0xc]          ;589
                  |L1.34|
000022  2900              CMP      r1,#0                 ;589
000024  d1f9              BNE      |L1.26|
;;;596        }
;;;597    
;;;598        /* this code does not allow upper layer to share a UDP port for
;;;599           listening to broadcast or multicast traffic (See SO_REUSE_ADDR and
;;;600           SO_REUSE_PORT under *BSD). TODO: See where it fits instead, OR
;;;601           combine with implementation of UDP PCB flags. Leon Woestenberg. */
;;;602    #ifdef LWIP_UDP_TODO
;;;603        /* port matches that of PCB in list? */
;;;604        else
;;;605          if ((ipcb->local_port == port) &&
;;;606              /* IP address matches, or one is IP_ADDR_ANY? */
;;;607              (ip_addr_isany(&(ipcb->local_ip)) ||
;;;608               ip_addr_isany(ipaddr) ||
;;;609               ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
;;;610            /* other PCB already binds to this local IP and port */
;;;611            LWIP_DEBUGF(UDP_DEBUG,
;;;612                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
;;;613            return ERR_USE;
;;;614          }
;;;615    #endif
;;;616      }
;;;617    
;;;618      ip_addr_set(&pcb->local_ip, ipaddr);
000026  b90c              CBNZ     r4,|L1.44|
000028  2000              MOVS     r0,#0
00002a  e000              B        |L1.46|
                  |L1.44|
00002c  6820              LDR      r0,[r4,#0]
                  |L1.46|
00002e  6018              STR      r0,[r3,#0]
;;;619    
;;;620      /* no port specified? */
;;;621      if (port == 0) {
000030  b9c2              CBNZ     r2,|L1.100|
;;;622    #ifndef UDP_LOCAL_PORT_RANGE_START
;;;623    #define UDP_LOCAL_PORT_RANGE_START 4096
;;;624    #define UDP_LOCAL_PORT_RANGE_END   0x7fff
;;;625    #endif
;;;626        port = UDP_LOCAL_PORT_RANGE_START;
000032  f44f5280          MOV      r2,#0x1000
;;;627        ipcb = udp_pcbs;
000036  4811              LDR      r0,|L1.124|
000038  6801              LDR      r1,[r0,#0]  ; udp_pcbs
;;;628        while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
00003a  e008              B        |L1.78|
                  |L1.60|
;;;629          if (ipcb->local_port == port) {
00003c  8a48              LDRH     r0,[r1,#0x12]
00003e  4290              CMP      r0,r2
000040  d104              BNE      |L1.76|
;;;630            /* port is already used by another udp_pcb */
;;;631            port++;
000042  1c50              ADDS     r0,r2,#1
000044  b282              UXTH     r2,r0
;;;632            /* restart scanning all udp pcbs */
;;;633            ipcb = udp_pcbs;
000046  480d              LDR      r0,|L1.124|
000048  6801              LDR      r1,[r0,#0]  ; udp_pcbs
00004a  e000              B        |L1.78|
                  |L1.76|
;;;634          } else
;;;635            /* go on with next udp pcb */
;;;636            ipcb = ipcb->next;
00004c  68c9              LDR      r1,[r1,#0xc]
                  |L1.78|
00004e  b119              CBZ      r1,|L1.88|
000050  f5a240fe          SUB      r0,r2,#0x7f00         ;628
000054  38ff              SUBS     r0,r0,#0xff           ;628
000056  d1f1              BNE      |L1.60|
                  |L1.88|
;;;637        }
;;;638        if (ipcb != NULL) {
000058  b121              CBZ      r1,|L1.100|
;;;639          /* no more ports available in local range */
;;;640          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
00005a  bf00              NOP      
00005c  bf00              NOP      
;;;641          return ERR_USE;
00005e  f06f000a          MVN      r0,#0xa
                  |L1.98|
;;;642        }
;;;643      }
;;;644      pcb->local_port = port;
;;;645      snmp_insert_udpidx_tree(pcb);
;;;646      /* pcb not active yet? */
;;;647      if (rebind == 0) {
;;;648        /* place the PCB on the active list if not already there */
;;;649        pcb->next = udp_pcbs;
;;;650        udp_pcbs = pcb;
;;;651      }
;;;652      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;653                  ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
;;;654                   (u16_t)((ntohl(pcb->local_ip.addr) >> 24) & 0xff),
;;;655                   (u16_t)((ntohl(pcb->local_ip.addr) >> 16) & 0xff),
;;;656                   (u16_t)((ntohl(pcb->local_ip.addr) >> 8) & 0xff),
;;;657                   (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
;;;658      return ERR_OK;
;;;659    }
000062  bd30              POP      {r4,r5,pc}
                  |L1.100|
000064  825a              STRH     r2,[r3,#0x12]         ;644
000066  b925              CBNZ     r5,|L1.114|
000068  4804              LDR      r0,|L1.124|
00006a  6800              LDR      r0,[r0,#0]            ;649  ; udp_pcbs
00006c  60d8              STR      r0,[r3,#0xc]          ;649
00006e  4803              LDR      r0,|L1.124|
000070  6003              STR      r3,[r0,#0]            ;650  ; udp_pcbs
                  |L1.114|
000072  bf00              NOP                            ;652
000074  bf00              NOP                            ;652
000076  2000              MOVS     r0,#0                 ;658
000078  e7f3              B        |L1.98|
;;;660    /**
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      udp_pcbs

                          AREA ||i.udp_connect||, CODE, READONLY, ALIGN=2

                  udp_connect PROC
;;;677    err_t
;;;678    udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;679    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;680      struct udp_pcb *ipcb;
;;;681    
;;;682      if (pcb->local_port == 0) {
00000a  8a60              LDRH     r0,[r4,#0x12]
00000c  b960              CBNZ     r0,|L2.40|
;;;683        err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
00000e  8a62              LDRH     r2,[r4,#0x12]
000010  4621              MOV      r1,r4
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       udp_bind
000018  4680              MOV      r8,r0
;;;684        if (err != ERR_OK)
00001a  f1b80f00          CMP      r8,#0
00001e  d002              BEQ      |L2.38|
;;;685          return err;
000020  4640              MOV      r0,r8
                  |L2.34|
;;;686      }
;;;687    
;;;688      ip_addr_set(&pcb->remote_ip, ipaddr);
;;;689      pcb->remote_port = port;
;;;690      pcb->flags |= UDP_FLAGS_CONNECTED;
;;;691    /** TODO: this functionality belongs in upper layers */
;;;692    #ifdef LWIP_UDP_TODO
;;;693      /* Nail down local IP for netconn_addr()/getsockname() */
;;;694      if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
;;;695        struct netif *netif;
;;;696    
;;;697        if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
;;;698          LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
;;;699          UDP_STATS_INC(udp.rterr);
;;;700          return ERR_RTE;
;;;701        }
;;;702        /** TODO: this will bind the udp pcb locally, to the interface which
;;;703            is used to route output packets to the remote address. However, we
;;;704            might want to accept incoming packets on any interface! */
;;;705        pcb->local_ip = netif->ip_addr;
;;;706      } else if (ip_addr_isany(&pcb->remote_ip)) {
;;;707        pcb->local_ip.addr = 0;
;;;708      }
;;;709    #endif
;;;710      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;711                  ("udp_connect: connected to %"U16_F".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",
;;;712                   (u16_t)((ntohl(pcb->remote_ip.addr) >> 24) & 0xff),
;;;713                   (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
;;;714                   (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
;;;715                   (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));
;;;716    
;;;717      /* Insert UDP PCB into the list of active UDP PCBs. */
;;;718      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
;;;719        if (pcb == ipcb) {
;;;720          /* already on the list, just return */
;;;721          return ERR_OK;
;;;722        }
;;;723      }
;;;724      /* PCB not yet on the list, add PCB now */
;;;725      pcb->next = udp_pcbs;
;;;726      udp_pcbs = pcb;
;;;727      return ERR_OK;
;;;728    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L2.38|
000026  bf00              NOP                            ;686
                  |L2.40|
000028  b90e              CBNZ     r6,|L2.46|
00002a  2000              MOVS     r0,#0                 ;688
00002c  e000              B        |L2.48|
                  |L2.46|
00002e  6830              LDR      r0,[r6,#0]            ;688
                  |L2.48|
000030  6060              STR      r0,[r4,#4]            ;688
000032  82a7              STRH     r7,[r4,#0x14]         ;689
000034  7c20              LDRB     r0,[r4,#0x10]         ;690
000036  f0400004          ORR      r0,r0,#4              ;690
00003a  7420              STRB     r0,[r4,#0x10]         ;690
00003c  bf00              NOP                            ;710
00003e  bf00              NOP                            ;710
000040  4808              LDR      r0,|L2.100|
000042  6805              LDR      r5,[r0,#0]            ;718  ; udp_pcbs
000044  e004              B        |L2.80|
                  |L2.70|
000046  42ac              CMP      r4,r5                 ;719
000048  d101              BNE      |L2.78|
00004a  2000              MOVS     r0,#0                 ;721
00004c  e7e9              B        |L2.34|
                  |L2.78|
00004e  68ed              LDR      r5,[r5,#0xc]          ;718
                  |L2.80|
000050  2d00              CMP      r5,#0                 ;718
000052  d1f8              BNE      |L2.70|
000054  4803              LDR      r0,|L2.100|
000056  6800              LDR      r0,[r0,#0]            ;725  ; udp_pcbs
000058  60e0              STR      r0,[r4,#0xc]          ;725
00005a  4802              LDR      r0,|L2.100|
00005c  6004              STR      r4,[r0,#0]            ;726  ; udp_pcbs
00005e  2000              MOVS     r0,#0                 ;727
000060  e7df              B        |L2.34|
;;;729    
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      udp_pcbs

                          AREA ||i.udp_disconnect||, CODE, READONLY, ALIGN=2

                  udp_disconnect PROC
;;;735    void
;;;736    udp_disconnect(struct udp_pcb *pcb)
000000  4906              LDR      r1,|L3.28|
;;;737    {
;;;738      /* reset remote address association */
;;;739      ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
000002  b909              CBNZ     r1,|L3.8|
000004  2100              MOVS     r1,#0
000006  e001              B        |L3.12|
                  |L3.8|
000008  4904              LDR      r1,|L3.28|
00000a  6809              LDR      r1,[r1,#0]  ; ip_addr_any
                  |L3.12|
00000c  6041              STR      r1,[r0,#4]
;;;740      pcb->remote_port = 0;
00000e  2100              MOVS     r1,#0
000010  8281              STRH     r1,[r0,#0x14]
;;;741      /* mark PCB as unconnected */
;;;742      pcb->flags &= ~UDP_FLAGS_CONNECTED;
000012  7c01              LDRB     r1,[r0,#0x10]
000014  f0210104          BIC      r1,r1,#4
000018  7401              STRB     r1,[r0,#0x10]
;;;743    }
00001a  4770              BX       lr
;;;744    
                          ENDP

                  |L3.28|
                          DCD      ip_addr_any

                          AREA ||i.udp_input||, CODE, READONLY, ALIGN=2

                  udp_input PROC
;;;84     void
;;;85     udp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;86     {
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  460e              MOV      r6,r1
;;;87       struct udp_hdr *udphdr;
;;;88       struct udp_pcb *pcb, *prev;
;;;89       struct udp_pcb *uncon_pcb;
;;;90       struct ip_hdr *iphdr;
;;;91       u16_t src, dest;
;;;92       u8_t local_match;
;;;93       u8_t broadcast;
;;;94     
;;;95       PERF_START;
;;;96     
;;;97       UDP_STATS_INC(udp.recv);
;;;98     
;;;99       iphdr = p->payload;
00000a  687d              LDR      r5,[r7,#4]
;;;100    
;;;101      /* Check minimum length (IP header + UDP header)
;;;102       * and move payload pointer to UDP header */
;;;103      if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
00000c  8828              LDRH     r0,[r5,#0]
00000e  f7fffffe          BL       ntohs
000012  f3c02003          UBFX     r0,r0,#8,#4
000016  2108              MOVS     r1,#8
000018  eb010080          ADD      r0,r1,r0,LSL #2
00001c  8939              LDRH     r1,[r7,#8]
00001e  4288              CMP      r0,r1
000020  dc0c              BGT      |L4.60|
000022  8828              LDRH     r0,[r5,#0]
000024  f7fffffe          BL       ntohs
000028  f3c02003          UBFX     r0,r0,#8,#4
00002c  0080              LSLS     r0,r0,#2
00002e  f1c00b00          RSB      r11,r0,#0
000032  4659              MOV      r1,r11
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       pbuf_header
00003a  b128              CBZ      r0,|L4.72|
                  |L4.60|
;;;104        /* drop short packets */
;;;105        LWIP_DEBUGF(UDP_DEBUG,
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;106                    ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
;;;107        UDP_STATS_INC(udp.lenerr);
;;;108        UDP_STATS_INC(udp.drop);
;;;109        snmp_inc_udpinerrors();
;;;110        pbuf_free(p);
000040  4638              MOV      r0,r7
000042  f7fffffe          BL       pbuf_free
;;;111        goto end;
000046  e0da              B        |L4.510|
                  |L4.72|
;;;112      }
;;;113    
;;;114      udphdr = (struct udp_hdr *)p->payload;
000048  f8d79004          LDR      r9,[r7,#4]
;;;115    
;;;116      /* is broadcast packet ? */
;;;117      broadcast = ip_addr_isbroadcast(&(iphdr->dest), inp);
00004c  4631              MOV      r1,r6
00004e  f1050010          ADD      r0,r5,#0x10
000052  f7fffffe          BL       ip_addr_isbroadcast
000056  4680              MOV      r8,r0
;;;118    
;;;119      LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
000058  bf00              NOP      
00005a  bf00              NOP      
;;;120    
;;;121      /* convert src and dest ports to host byte order */
;;;122      src = ntohs(udphdr->src);
00005c  f8b90000          LDRH     r0,[r9,#0]
000060  f7fffffe          BL       ntohs
000064  9003              STR      r0,[sp,#0xc]
;;;123      dest = ntohs(udphdr->dest);
000066  f8b90002          LDRH     r0,[r9,#2]
00006a  f7fffffe          BL       ntohs
00006e  9002              STR      r0,[sp,#8]
;;;124    
;;;125      udp_debug_print(udphdr);
;;;126    
;;;127      /* print the UDP source and destination */
;;;128      LWIP_DEBUGF(UDP_DEBUG,
000070  bf00              NOP      
000072  bf00              NOP      
;;;129                  ("udp (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "
;;;130                   "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
;;;131                   ip4_addr1(&iphdr->dest), ip4_addr2(&iphdr->dest),
;;;132                   ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
;;;133                   ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
;;;134                   ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));
;;;135    
;;;136    #if LWIP_DHCP
;;;137      pcb = NULL;
000074  2400              MOVS     r4,#0
;;;138      /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
;;;139         the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
;;;140      if (dest == DHCP_CLIENT_PORT) {
000076  9802              LDR      r0,[sp,#8]
000078  2844              CMP      r0,#0x44
00007a  d118              BNE      |L4.174|
;;;141        /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
;;;142        if (src == DHCP_SERVER_PORT) {
00007c  9803              LDR      r0,[sp,#0xc]
00007e  2843              CMP      r0,#0x43
000080  d15e              BNE      |L4.320|
;;;143          if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
000082  6a30              LDR      r0,[r6,#0x20]
000084  b3f0              CBZ      r0,|L4.260|
000086  6a30              LDR      r0,[r6,#0x20]
000088  6880              LDR      r0,[r0,#8]
00008a  b3d8              CBZ      r0,|L4.260|
;;;144            /* accept the packe if 
;;;145               (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
;;;146               - inp->dhcp->pcb->remote == ANY or iphdr->src */
;;;147            if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
00008c  6a30              LDR      r0,[r6,#0x20]
00008e  6880              LDR      r0,[r0,#8]
000090  1d00              ADDS     r0,r0,#4
000092  d009              BEQ      |L4.168|
000094  6a30              LDR      r0,[r6,#0x20]
000096  6880              LDR      r0,[r0,#8]
000098  6840              LDR      r0,[r0,#4]
00009a  b128              CBZ      r0,|L4.168|
;;;148               ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
00009c  6a30              LDR      r0,[r6,#0x20]
00009e  6880              LDR      r0,[r0,#8]
0000a0  6840              LDR      r0,[r0,#4]
0000a2  68e9              LDR      r1,[r5,#0xc]
0000a4  4288              CMP      r0,r1
0000a6  d14b              BNE      |L4.320|
                  |L4.168|
;;;149              pcb = inp->dhcp->pcb;
0000a8  6a30              LDR      r0,[r6,#0x20]
0000aa  6884              LDR      r4,[r0,#8]
0000ac  e048              B        |L4.320|
                  |L4.174|
;;;150            }
;;;151          }
;;;152        }
;;;153      } else
;;;154    #endif /* LWIP_DHCP */
;;;155      {
;;;156        prev = NULL;
0000ae  f04f0a00          MOV      r10,#0
;;;157        local_match = 0;
0000b2  2000              MOVS     r0,#0
0000b4  9001              STR      r0,[sp,#4]
;;;158        uncon_pcb = NULL;
0000b6  9004              STR      r0,[sp,#0x10]
;;;159        /* Iterate through the UDP pcb list for a matching pcb.
;;;160         * 'Perfect match' pcbs (connected to the remote port & ip address) are
;;;161         * preferred. If no perfect match is found, the first unconnected pcb that
;;;162         * matches the local port and ip address gets the datagram. */
;;;163        for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
0000b8  4852              LDR      r0,|L4.516|
0000ba  6804              LDR      r4,[r0,#0]  ; udp_pcbs
0000bc  e03b              B        |L4.310|
                  |L4.190|
;;;164          local_match = 0;
0000be  2000              MOVS     r0,#0
0000c0  9001              STR      r0,[sp,#4]
;;;165          /* print the PCB local and remote address */
;;;166          LWIP_DEBUGF(UDP_DEBUG,
0000c2  bf00              NOP      
0000c4  bf00              NOP      
;;;167                      ("pcb (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "
;;;168                       "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
;;;169                       ip4_addr1(&pcb->local_ip), ip4_addr2(&pcb->local_ip),
;;;170                       ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
;;;171                       ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
;;;172                       ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));
;;;173    
;;;174          /* compare PCB local addr+port to UDP destination addr+port */
;;;175          if ((pcb->local_port == dest) &&
0000c6  8a61              LDRH     r1,[r4,#0x12]
0000c8  9802              LDR      r0,[sp,#8]
0000ca  4281              CMP      r1,r0
0000cc  d115              BNE      |L4.250|
;;;176              ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
0000ce  f1b80f00          CMP      r8,#0
0000d2  d102              BNE      |L4.218|
0000d4  b144              CBZ      r4,|L4.232|
0000d6  6820              LDR      r0,[r4,#0]
0000d8  b130              CBZ      r0,|L4.232|
                  |L4.218|
;;;177               ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
0000da  6820              LDR      r0,[r4,#0]
0000dc  6929              LDR      r1,[r5,#0x10]
0000de  4288              CMP      r0,r1
0000e0  d002              BEQ      |L4.232|
;;;178    #if LWIP_IGMP
;;;179               ip_addr_ismulticast(&(iphdr->dest)) ||
;;;180    #endif /* LWIP_IGMP */
;;;181    #if IP_SOF_BROADCAST_RECV
;;;182               (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
;;;183    #else  /* IP_SOF_BROADCAST_RECV */
;;;184               (broadcast))) {
0000e2  f1b80f00          CMP      r8,#0
0000e6  d008              BEQ      |L4.250|
                  |L4.232|
;;;185    #endif /* IP_SOF_BROADCAST_RECV */
;;;186            local_match = 1;
0000e8  2001              MOVS     r0,#1
0000ea  9001              STR      r0,[sp,#4]
;;;187            if ((uncon_pcb == NULL) && 
0000ec  9804              LDR      r0,[sp,#0x10]
0000ee  b920              CBNZ     r0,|L4.250|
;;;188                ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
0000f0  7c20              LDRB     r0,[r4,#0x10]
0000f2  f0100f04          TST      r0,#4
0000f6  d100              BNE      |L4.250|
;;;189              /* the first unconnected matching PCB */
;;;190              uncon_pcb = pcb;
0000f8  9404              STR      r4,[sp,#0x10]
                  |L4.250|
;;;191            }
;;;192          }
;;;193          /* compare PCB remote addr+port to UDP source addr+port */
;;;194          if ((local_match != 0) &&
0000fa  9801              LDR      r0,[sp,#4]
0000fc  b1c8              CBZ      r0,|L4.306|
;;;195              (pcb->remote_port == src) &&
0000fe  8aa1              LDRH     r1,[r4,#0x14]
000100  9803              LDR      r0,[sp,#0xc]
000102  e000              B        |L4.262|
                  |L4.260|
000104  e01c              B        |L4.320|
                  |L4.262|
000106  4281              CMP      r1,r0
000108  d113              BNE      |L4.306|
;;;196              (ip_addr_isany(&pcb->remote_ip) ||
00010a  1d20              ADDS     r0,r4,#4
00010c  d005              BEQ      |L4.282|
00010e  6860              LDR      r0,[r4,#4]
000110  b118              CBZ      r0,|L4.282|
;;;197               ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
000112  6860              LDR      r0,[r4,#4]
000114  68e9              LDR      r1,[r5,#0xc]
000116  4288              CMP      r0,r1
000118  d10b              BNE      |L4.306|
                  |L4.282|
;;;198            /* the first fully matching PCB */
;;;199            if (prev != NULL) {
00011a  f1ba0f00          CMP      r10,#0
00011e  d007              BEQ      |L4.304|
;;;200              /* move the pcb to the front of udp_pcbs so that is
;;;201                 found faster next time */
;;;202              prev->next = pcb->next;
000120  68e0              LDR      r0,[r4,#0xc]
000122  f8ca000c          STR      r0,[r10,#0xc]
;;;203              pcb->next = udp_pcbs;
000126  4837              LDR      r0,|L4.516|
000128  6800              LDR      r0,[r0,#0]  ; udp_pcbs
00012a  60e0              STR      r0,[r4,#0xc]
;;;204              udp_pcbs = pcb;
00012c  4835              LDR      r0,|L4.516|
00012e  6004              STR      r4,[r0,#0]  ; udp_pcbs
                  |L4.304|
;;;205            } else {
;;;206              UDP_STATS_INC(udp.cachehit);
;;;207            }
;;;208            break;
000130  e003              B        |L4.314|
                  |L4.306|
;;;209          }
;;;210          prev = pcb;
000132  46a2              MOV      r10,r4
000134  68e4              LDR      r4,[r4,#0xc]          ;163
                  |L4.310|
000136  2c00              CMP      r4,#0                 ;163
000138  d1c1              BNE      |L4.190|
                  |L4.314|
00013a  bf00              NOP                            ;208
;;;211        }
;;;212        /* no fully matching pcb found? then look for an unconnected pcb */
;;;213        if (pcb == NULL) {
00013c  b904              CBNZ     r4,|L4.320|
;;;214          pcb = uncon_pcb;
00013e  9c04              LDR      r4,[sp,#0x10]
                  |L4.320|
;;;215        }
;;;216      }
;;;217    
;;;218      /* Check checksum if this is a match or if it was directed at us. */
;;;219      if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
000140  b91c              CBNZ     r4,|L4.330|
000142  6870              LDR      r0,[r6,#4]
000144  6929              LDR      r1,[r5,#0x10]
000146  4288              CMP      r0,r1
000148  d155              BNE      |L4.502|
                  |L4.330|
;;;220        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
00014a  bf00              NOP      
00014c  bf00              NOP      
;;;221    #if LWIP_UDPLITE
;;;222        if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
;;;223          /* Do the UDP Lite checksum */
;;;224    #if CHECKSUM_CHECK_UDP
;;;225          u16_t chklen = ntohs(udphdr->len);
;;;226          if (chklen < sizeof(struct udp_hdr)) {
;;;227            if (chklen == 0) {
;;;228              /* For UDP-Lite, checksum length of 0 means checksum
;;;229                 over the complete packet (See RFC 3828 chap. 3.1) */
;;;230              chklen = p->tot_len;
;;;231            } else {
;;;232              /* At least the UDP-Lite header must be covered by the
;;;233                 checksum! (Again, see RFC 3828 chap. 3.1) */
;;;234              UDP_STATS_INC(udp.chkerr);
;;;235              UDP_STATS_INC(udp.drop);
;;;236              snmp_inc_udpinerrors();
;;;237              pbuf_free(p);
;;;238              goto end;
;;;239            }
;;;240          }
;;;241          if (inet_chksum_pseudo_partial(p, (struct ip_addr *)&(iphdr->src),
;;;242                                 (struct ip_addr *)&(iphdr->dest),
;;;243                                 IP_PROTO_UDPLITE, p->tot_len, chklen) != 0) {
;;;244            LWIP_DEBUGF(UDP_DEBUG | 2,
;;;245                        ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
;;;246            UDP_STATS_INC(udp.chkerr);
;;;247            UDP_STATS_INC(udp.drop);
;;;248            snmp_inc_udpinerrors();
;;;249            pbuf_free(p);
;;;250            goto end;
;;;251          }
;;;252    #endif /* CHECKSUM_CHECK_UDP */
;;;253        } else
;;;254    #endif /* LWIP_UDPLITE */
;;;255        {
;;;256    #if CHECKSUM_CHECK_UDP
;;;257          if (udphdr->chksum != 0) {
00014e  f8b90006          LDRH     r0,[r9,#6]
000152  b178              CBZ      r0,|L4.372|
;;;258            if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
000154  893b              LDRH     r3,[r7,#8]
000156  9300              STR      r3,[sp,#0]
000158  2311              MOVS     r3,#0x11
00015a  f1050210          ADD      r2,r5,#0x10
00015e  1f11              SUBS     r1,r2,#4
000160  4638              MOV      r0,r7
000162  f7fffffe          BL       inet_chksum_pseudo
000166  b128              CBZ      r0,|L4.372|
;;;259                                   (struct ip_addr *)&(iphdr->dest),
;;;260                                   IP_PROTO_UDP, p->tot_len) != 0) {
;;;261              LWIP_DEBUGF(UDP_DEBUG | 2,
000168  bf00              NOP      
00016a  bf00              NOP      
;;;262                          ("udp_input: UDP datagram discarded due to failing checksum\n"));
;;;263              UDP_STATS_INC(udp.chkerr);
;;;264              UDP_STATS_INC(udp.drop);
;;;265              snmp_inc_udpinerrors();
;;;266              pbuf_free(p);
00016c  4638              MOV      r0,r7
00016e  f7fffffe          BL       pbuf_free
;;;267              goto end;
000172  e044              B        |L4.510|
                  |L4.372|
;;;268            }
;;;269          }
;;;270    #endif /* CHECKSUM_CHECK_UDP */
;;;271        }
;;;272        if(pbuf_header(p, -UDP_HLEN)) {
000174  f06f0107          MVN      r1,#7
000178  4638              MOV      r0,r7
00017a  f7fffffe          BL       pbuf_header
00017e  b118              CBZ      r0,|L4.392|
;;;273          /* Can we cope with this failing? Just assert for now */
;;;274          LWIP_ASSERT("pbuf_header failed\n", 0);
;;;275          UDP_STATS_INC(udp.drop);
;;;276          snmp_inc_udpinerrors();
;;;277          pbuf_free(p);
000180  4638              MOV      r0,r7
000182  f7fffffe          BL       pbuf_free
;;;278          goto end;
000186  e03a              B        |L4.510|
                  |L4.392|
;;;279        }
;;;280        if (pcb != NULL) {
000188  b17c              CBZ      r4,|L4.426|
;;;281          snmp_inc_udpindatagrams();
;;;282          /* callback */
;;;283          if (pcb->recv != NULL) {
00018a  69a0              LDR      r0,[r4,#0x18]
00018c  b148              CBZ      r0,|L4.418|
;;;284            /* now the recv function is responsible for freeing p */
;;;285            pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
00018e  9b03              LDR      r3,[sp,#0xc]
000190  9300              STR      r3,[sp,#0]
000192  f105030c          ADD      r3,r5,#0xc
000196  463a              MOV      r2,r7
000198  4621              MOV      r1,r4
00019a  e9d4c006          LDRD     r12,r0,[r4,#0x18]
00019e  47e0              BLX      r12
0001a0  e02c              B        |L4.508|
                  |L4.418|
;;;286          } else {
;;;287            /* no recv function registered? then we have to free the pbuf! */
;;;288            pbuf_free(p);
0001a2  4638              MOV      r0,r7
0001a4  f7fffffe          BL       pbuf_free
;;;289            goto end;
0001a8  e029              B        |L4.510|
                  |L4.426|
;;;290          }
;;;291        } else {
;;;292          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
0001aa  bf00              NOP      
0001ac  bf00              NOP      
;;;293    
;;;294    #if LWIP_ICMP
;;;295          /* No match was found, send ICMP destination port unreachable unless
;;;296             destination address was broadcast/multicast. */
;;;297          if (!broadcast &&
0001ae  f1b80f00          CMP      r8,#0
0001b2  d11c              BNE      |L4.494|
;;;298              !ip_addr_ismulticast(&iphdr->dest)) {
0001b4  f04f4070          MOV      r0,#0xf0000000
0001b8  f7fffffe          BL       ntohl
0001bc  6929              LDR      r1,[r5,#0x10]
0001be  ea000b01          AND      r11,r0,r1
0001c2  f04f4060          MOV      r0,#0xe0000000
0001c6  f7fffffe          BL       ntohl
0001ca  4583              CMP      r11,r0
0001cc  d00f              BEQ      |L4.494|
;;;299            /* move payload pointer back to ip header */
;;;300            pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
0001ce  8828              LDRH     r0,[r5,#0]
0001d0  f7fffffe          BL       ntohs
0001d4  f3c02003          UBFX     r0,r0,#8,#4
0001d8  2108              MOVS     r1,#8
0001da  eb010b80          ADD      r11,r1,r0,LSL #2
0001de  4659              MOV      r1,r11
0001e0  4638              MOV      r0,r7
0001e2  f7fffffe          BL       pbuf_header
;;;301            LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
;;;302            icmp_dest_unreach(p, ICMP_DUR_PORT);
0001e6  2103              MOVS     r1,#3
0001e8  4638              MOV      r0,r7
0001ea  f7fffffe          BL       icmp_dest_unreach
                  |L4.494|
;;;303          }
;;;304    #endif /* LWIP_ICMP */
;;;305          UDP_STATS_INC(udp.proterr);
;;;306          UDP_STATS_INC(udp.drop);
;;;307          snmp_inc_udpnoports();
;;;308          pbuf_free(p);
0001ee  4638              MOV      r0,r7
0001f0  f7fffffe          BL       pbuf_free
0001f4  e002              B        |L4.508|
                  |L4.502|
;;;309        }
;;;310      } else {
;;;311        pbuf_free(p);
0001f6  4638              MOV      r0,r7
0001f8  f7fffffe          BL       pbuf_free
                  |L4.508|
;;;312      }
;;;313    end:
0001fc  bf00              NOP      
                  |L4.510|
;;;314      PERF_STOP("udp_input");
;;;315    }
0001fe  b005              ADD      sp,sp,#0x14
000200  e8bd8ff0          POP      {r4-r11,pc}
;;;316    
                          ENDP

                  |L4.516|
                          DCD      udp_pcbs

                          AREA ||i.udp_new||, CODE, READONLY, ALIGN=1

                  udp_new PROC
;;;803    struct udp_pcb *
;;;804    udp_new(void)
000000  b510              PUSH     {r4,lr}
;;;805    {
;;;806      struct udp_pcb *pcb;
;;;807      pcb = memp_malloc(MEMP_UDP_PCB);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       memp_malloc
000008  4604              MOV      r4,r0
;;;808      /* could allocate UDP PCB? */
;;;809      if (pcb != NULL) {
00000a  b12c              CBZ      r4,|L5.24|
;;;810        /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
;;;811         * which means checksum is generated over the whole datagram per default
;;;812         * (recommended as default by RFC 3828). */
;;;813        /* initialize PCB to all zeroes */
;;;814        memset(pcb, 0, sizeof(struct udp_pcb));
00000c  2120              MOVS     r1,#0x20
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       __aeabi_memclr4
;;;815        pcb->ttl = UDP_TTL;
000014  20ff              MOVS     r0,#0xff
000016  72e0              STRB     r0,[r4,#0xb]
                  |L5.24|
;;;816      }
;;;817      return pcb;
000018  4620              MOV      r0,r4
;;;818    }
00001a  bd10              POP      {r4,pc}
;;;819    
                          ENDP


                          AREA ||i.udp_recv||, CODE, READONLY, ALIGN=1

                  udp_recv PROC
;;;754    void
;;;755    udp_recv(struct udp_pcb *pcb,
000000  6181              STR      r1,[r0,#0x18]
;;;756             void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
;;;757                           struct ip_addr *addr, u16_t port),
;;;758             void *recv_arg)
;;;759    {
;;;760      /* remember recv() callback and user data */
;;;761      pcb->recv = recv;
;;;762      pcb->recv_arg = recv_arg;
000002  61c2              STR      r2,[r0,#0x1c]
;;;763    }
000004  4770              BX       lr
;;;764    
                          ENDP


                          AREA ||i.udp_remove||, CODE, READONLY, ALIGN=2

                  udp_remove PROC
;;;773    void
;;;774    udp_remove(struct udp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;775    {
000002  4605              MOV      r5,r0
;;;776      struct udp_pcb *pcb2;
;;;777    
;;;778      snmp_delete_udpidx_tree(pcb);
;;;779      /* pcb to be removed is first in list? */
;;;780      if (udp_pcbs == pcb) {
000004  480d              LDR      r0,|L7.60|
000006  6800              LDR      r0,[r0,#0]  ; udp_pcbs
000008  42a8              CMP      r0,r5
00000a  d105              BNE      |L7.24|
;;;781        /* make list start at 2nd pcb */
;;;782        udp_pcbs = udp_pcbs->next;
00000c  480b              LDR      r0,|L7.60|
00000e  6800              LDR      r0,[r0,#0]  ; udp_pcbs
000010  68c0              LDR      r0,[r0,#0xc]
000012  490a              LDR      r1,|L7.60|
000014  6008              STR      r0,[r1,#0]  ; udp_pcbs
000016  e00c              B        |L7.50|
                  |L7.24|
;;;783        /* pcb not 1st in list */
;;;784      } else
;;;785        for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
000018  4808              LDR      r0,|L7.60|
00001a  6804              LDR      r4,[r0,#0]  ; udp_pcbs
00001c  e007              B        |L7.46|
                  |L7.30|
;;;786          /* find pcb in udp_pcbs list */
;;;787          if (pcb2->next != NULL && pcb2->next == pcb) {
00001e  68e0              LDR      r0,[r4,#0xc]
000020  b120              CBZ      r0,|L7.44|
000022  68e0              LDR      r0,[r4,#0xc]
000024  42a8              CMP      r0,r5
000026  d101              BNE      |L7.44|
;;;788            /* remove pcb from list */
;;;789            pcb2->next = pcb->next;
000028  68e8              LDR      r0,[r5,#0xc]
00002a  60e0              STR      r0,[r4,#0xc]
                  |L7.44|
00002c  68e4              LDR      r4,[r4,#0xc]          ;785
                  |L7.46|
00002e  2c00              CMP      r4,#0                 ;785
000030  d1f5              BNE      |L7.30|
                  |L7.50|
;;;790          }
;;;791        }
;;;792      memp_free(MEMP_UDP_PCB, pcb);
000032  4629              MOV      r1,r5
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       memp_free
;;;793    }
00003a  bd70              POP      {r4-r6,pc}
;;;794    
                          ENDP

                  |L7.60|
                          DCD      udp_pcbs

                          AREA ||i.udp_send||, CODE, READONLY, ALIGN=1

                  udp_send PROC
;;;335    err_t
;;;336    udp_send(struct udp_pcb *pcb, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;338      /* send to the packet using remote ip and port stored in the pcb */
;;;339      return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
000006  8aa3              LDRH     r3,[r4,#0x14]
000008  1d22              ADDS     r2,r4,#4
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       udp_sendto
;;;340    }
000012  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP


                          AREA ||i.udp_sendto||, CODE, READONLY, ALIGN=1

                  udp_sendto PROC
;;;359    err_t
;;;360    udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;361      struct ip_addr *dst_ip, u16_t dst_port)
;;;362    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;363      struct netif *netif;
;;;364    
;;;365      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_send\n"));
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;366    
;;;367      /* find the outgoing network interface for this packet */
;;;368    #if LWIP_IGMP
;;;369      netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
;;;370    #else
;;;371      netif = ip_route(dst_ip);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       ip_route
000016  4604              MOV      r4,r0
;;;372    #endif /* LWIP_IGMP */
;;;373    
;;;374      /* no outgoing network interface could be found? */
;;;375      if (netif == NULL) {
000018  b92c              CBNZ     r4,|L9.38|
;;;376        LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;377        UDP_STATS_INC(udp.rterr);
;;;378        return ERR_RTE;
00001e  f06f0003          MVN      r0,#3
                  |L9.34|
;;;379      }
;;;380      return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
;;;381    }
000022  e8bd83f8          POP      {r3-r9,pc}
                  |L9.38|
000026  4643              MOV      r3,r8                 ;380
000028  462a              MOV      r2,r5                 ;380
00002a  4639              MOV      r1,r7                 ;380
00002c  4630              MOV      r0,r6                 ;380
00002e  9400              STR      r4,[sp,#0]            ;380
000030  f7fffffe          BL       udp_sendto_if
000034  e7f5              B        |L9.34|
;;;382    
                          ENDP


                          AREA ||i.udp_sendto_if||, CODE, READONLY, ALIGN=1

                  udp_sendto_if PROC
;;;402    err_t
;;;403    udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;404      struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
;;;405    {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  469b              MOV      r11,r3
00000c  f8dd8040          LDR      r8,[sp,#0x40]
;;;406      struct udp_hdr *udphdr;
;;;407      struct ip_addr *src_ip;
;;;408      err_t err;
;;;409      struct pbuf *q; /* q will be sent down the stack */
;;;410    
;;;411    #if IP_SOF_BROADCAST
;;;412      /* broadcast filter? */
;;;413      if ( ((pcb->so_options & SOF_BROADCAST) == 0) && ip_addr_isbroadcast(dst_ip, netif) ) {
;;;414        LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;415        return ERR_VAL;
;;;416      }
;;;417    #endif /* IP_SOF_BROADCAST */
;;;418    
;;;419      /* if the PCB is not yet bound to a port, bind it here */
;;;420      if (pcb->local_port == 0) {
000010  8a60              LDRH     r0,[r4,#0x12]
000012  b980              CBNZ     r0,|L10.54|
;;;421        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
000014  bf00              NOP      
000016  bf00              NOP      
;;;422        err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
000018  8a62              LDRH     r2,[r4,#0x12]
00001a  4621              MOV      r1,r4
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       udp_bind
000022  4682              MOV      r10,r0
;;;423        if (err != ERR_OK) {
000024  f1ba0f00          CMP      r10,#0
000028  d005              BEQ      |L10.54|
;;;424          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;425          return err;
00002e  4650              MOV      r0,r10
                  |L10.48|
;;;426        }
;;;427      }
;;;428    
;;;429      /* not enough space to add an UDP header to first pbuf in given p chain? */
;;;430      if (pbuf_header(p, UDP_HLEN)) {
;;;431        /* allocate header in a separate new pbuf */
;;;432        q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
;;;433        /* new header pbuf could not be allocated? */
;;;434        if (q == NULL) {
;;;435          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
;;;436          return ERR_MEM;
;;;437        }
;;;438        /* chain header q in front of given pbuf p */
;;;439        pbuf_chain(q, p);
;;;440        /* first pbuf q points to header pbuf */
;;;441        LWIP_DEBUGF(UDP_DEBUG,
;;;442                    ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;443      } else {
;;;444        /* adding space for header within p succeeded */
;;;445        /* first pbuf q equals given pbuf */
;;;446        q = p;
;;;447        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
;;;448      }
;;;449      LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
;;;450                  (q->len >= sizeof(struct udp_hdr)));
;;;451      /* q now represents the packet to be sent */
;;;452      udphdr = q->payload;
;;;453      udphdr->src = htons(pcb->local_port);
;;;454      udphdr->dest = htons(dst_port);
;;;455      /* in UDP, 0 checksum means 'no checksum' */
;;;456      udphdr->chksum = 0x0000; 
;;;457    
;;;458      /* PCB local address is IP_ANY_ADDR? */
;;;459      if (ip_addr_isany(&pcb->local_ip)) {
;;;460        /* use outgoing network interface IP address as source address */
;;;461        src_ip = &(netif->ip_addr);
;;;462      } else {
;;;463        /* check if UDP PCB local IP address is correct
;;;464         * this could be an old address if netif->ip_addr has changed */
;;;465        if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
;;;466          /* local_ip doesn't match, drop the packet */
;;;467          if (q != p) {
;;;468            /* free the header pbuf */
;;;469            pbuf_free(q);
;;;470            q = NULL;
;;;471            /* p is still referenced by the caller, and will live on */
;;;472          }
;;;473          return ERR_VAL;
;;;474        }
;;;475        /* use UDP PCB local IP address as source address */
;;;476        src_ip = &(pcb->local_ip);
;;;477      }
;;;478    
;;;479      LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
;;;480    
;;;481    #if LWIP_UDPLITE
;;;482      /* UDP Lite protocol? */
;;;483      if (pcb->flags & UDP_FLAGS_UDPLITE) {
;;;484        u16_t chklen, chklen_hdr;
;;;485        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
;;;486        /* set UDP message length in UDP header */
;;;487        chklen_hdr = chklen = pcb->chksum_len_tx;
;;;488        if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
;;;489          if (chklen != 0) {
;;;490            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
;;;491          }
;;;492          /* For UDP-Lite, checksum length of 0 means checksum
;;;493             over the complete packet. (See RFC 3828 chap. 3.1)
;;;494             At least the UDP-Lite header must be covered by the
;;;495             checksum, therefore, if chksum_len has an illegal
;;;496             value, we generate the checksum over the complete
;;;497             packet to be safe. */
;;;498          chklen_hdr = 0;
;;;499          chklen = q->tot_len;
;;;500        }
;;;501        udphdr->len = htons(chklen_hdr);
;;;502        /* calculate checksum */
;;;503    #if CHECKSUM_GEN_UDP
;;;504        udphdr->chksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip,
;;;505                                            IP_PROTO_UDPLITE, q->tot_len, chklen);
;;;506        /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;507        if (udphdr->chksum == 0x0000)
;;;508          udphdr->chksum = 0xffff;
;;;509    #endif /* CHECKSUM_CHECK_UDP */
;;;510        /* output to IP */
;;;511        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
;;;512    #if LWIP_NETIF_HWADDRHINT
;;;513        netif->addr_hint = &(pcb->addr_hint);
;;;514    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;515        err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);
;;;516    #if LWIP_NETIF_HWADDRHINT
;;;517        netif->addr_hint = NULL;
;;;518    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;519      } else
;;;520    #endif /* LWIP_UDPLITE */
;;;521      {      /* UDP */
;;;522        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
;;;523        udphdr->len = htons(q->tot_len);
;;;524        /* calculate checksum */
;;;525    #if CHECKSUM_GEN_UDP
;;;526        if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
;;;527          udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
;;;528          /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;529          if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
;;;530        }
;;;531    #endif /* CHECKSUM_CHECK_UDP */
;;;532        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
;;;533        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
;;;534        /* output to IP */
;;;535    #if LWIP_NETIF_HWADDRHINT
;;;536        netif->addr_hint = &(pcb->addr_hint);
;;;537    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;538        err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
;;;539    #if LWIP_NETIF_HWADDRHINT
;;;540        netif->addr_hint = NULL;
;;;541    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;542      }
;;;543      /* TODO: must this be increased even if error occured? */
;;;544      snmp_inc_udpoutdatagrams();
;;;545    
;;;546      /* did we chain a separate header pbuf earlier? */
;;;547      if (q != p) {
;;;548        /* free the header pbuf */
;;;549        pbuf_free(q);
;;;550        q = NULL;
;;;551        /* p is still referenced by the caller, and will live on */
;;;552      }
;;;553    
;;;554      UDP_STATS_INC(udp.xmit);
;;;555      return err;
;;;556    }
000030  b007              ADD      sp,sp,#0x1c
000032  e8bd8ff0          POP      {r4-r11,pc}
                  |L10.54|
000036  2108              MOVS     r1,#8                 ;430
000038  4638              MOV      r0,r7                 ;430
00003a  f7fffffe          BL       pbuf_header
00003e  b188              CBZ      r0,|L10.100|
000040  2200              MOVS     r2,#0                 ;432
000042  2108              MOVS     r1,#8                 ;432
000044  2001              MOVS     r0,#1                 ;432
000046  f7fffffe          BL       pbuf_alloc
00004a  4605              MOV      r5,r0                 ;432
00004c  b925              CBNZ     r5,|L10.88|
00004e  bf00              NOP                            ;435
000050  bf00              NOP                            ;435
000052  f04f30ff          MOV      r0,#0xffffffff        ;436
000056  e7eb              B        |L10.48|
                  |L10.88|
000058  4639              MOV      r1,r7                 ;439
00005a  4628              MOV      r0,r5                 ;439
00005c  f7fffffe          BL       pbuf_chain
000060  bf00              NOP                            ;441
000062  e002              B        |L10.106|
                  |L10.100|
000064  463d              MOV      r5,r7                 ;446
000066  bf00              NOP                            ;447
000068  bf00              NOP                            ;447
                  |L10.106|
00006a  686e              LDR      r6,[r5,#4]            ;452
00006c  8a60              LDRH     r0,[r4,#0x12]         ;453
00006e  f7fffffe          BL       htons
000072  8030              STRH     r0,[r6,#0]            ;453
000074  4658              MOV      r0,r11                ;454
000076  f7fffffe          BL       htons
00007a  8070              STRH     r0,[r6,#2]            ;454
00007c  2000              MOVS     r0,#0                 ;456
00007e  80f0              STRH     r0,[r6,#6]            ;456
000080  b10c              CBZ      r4,|L10.134|
000082  6820              LDR      r0,[r4,#0]            ;459
000084  b910              CBNZ     r0,|L10.140|
                  |L10.134|
000086  f1080904          ADD      r9,r8,#4              ;461
00008a  e00e              B        |L10.170|
                  |L10.140|
00008c  6820              LDR      r0,[r4,#0]            ;465
00008e  f8d81004          LDR      r1,[r8,#4]            ;465
000092  4288              CMP      r0,r1                 ;465
000094  d008              BEQ      |L10.168|
000096  42bd              CMP      r5,r7                 ;467
000098  d003              BEQ      |L10.162|
00009a  4628              MOV      r0,r5                 ;469
00009c  f7fffffe          BL       pbuf_free
0000a0  2500              MOVS     r5,#0                 ;470
                  |L10.162|
0000a2  f06f0008          MVN      r0,#8                 ;473
0000a6  e7c3              B        |L10.48|
                  |L10.168|
0000a8  46a1              MOV      r9,r4                 ;476
                  |L10.170|
0000aa  bf00              NOP                            ;479
0000ac  bf00              NOP                            ;479
0000ae  bf00              NOP                            ;522
0000b0  bf00              NOP                            ;522
0000b2  8928              LDRH     r0,[r5,#8]            ;523
0000b4  f7fffffe          BL       htons
0000b8  80b0              STRH     r0,[r6,#4]            ;523
0000ba  7c20              LDRB     r0,[r4,#0x10]         ;526
0000bc  f0100f01          TST      r0,#1                 ;526
0000c0  d10d              BNE      |L10.222|
0000c2  892b              LDRH     r3,[r5,#8]            ;527
0000c4  9300              STR      r3,[sp,#0]            ;527
0000c6  2311              MOVS     r3,#0x11              ;527
0000c8  4649              MOV      r1,r9                 ;527
0000ca  4628              MOV      r0,r5                 ;527
0000cc  9a05              LDR      r2,[sp,#0x14]         ;527
0000ce  f7fffffe          BL       inet_chksum_pseudo
0000d2  80f0              STRH     r0,[r6,#6]            ;527
0000d4  88f0              LDRH     r0,[r6,#6]            ;529
0000d6  b910              CBNZ     r0,|L10.222|
0000d8  f64f70ff          MOV      r0,#0xffff            ;529
0000dc  80f0              STRH     r0,[r6,#6]            ;529
                  |L10.222|
0000de  bf00              NOP                            ;532
0000e0  bf00              NOP                            ;532
0000e2  bf00              NOP                            ;533
0000e4  bf00              NOP                            ;533
0000e6  2211              MOVS     r2,#0x11              ;538
0000e8  7aa1              LDRB     r1,[r4,#0xa]          ;538
0000ea  e88d0106          STM      sp,{r1,r2,r8}         ;538
0000ee  7ae3              LDRB     r3,[r4,#0xb]          ;538
0000f0  4649              MOV      r1,r9                 ;538
0000f2  4628              MOV      r0,r5                 ;538
0000f4  9a05              LDR      r2,[sp,#0x14]         ;538
0000f6  f7fffffe          BL       ip_output_if
0000fa  4682              MOV      r10,r0                ;538
0000fc  42bd              CMP      r5,r7                 ;547
0000fe  d003              BEQ      |L10.264|
000100  4628              MOV      r0,r5                 ;549
000102  f7fffffe          BL       pbuf_free
000106  2500              MOVS     r5,#0                 ;550
                  |L10.264|
000108  4650              MOV      r0,r10                ;555
00010a  e791              B        |L10.48|
;;;557    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  udp_pcbs
                          DCD      0x00000000
