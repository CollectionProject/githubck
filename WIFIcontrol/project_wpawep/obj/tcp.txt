; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\tcp.o --depend=.\obj\tcp.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\tcp.crf ..\lwIP\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                  tcp_abandon PROC
;;;199    void
;;;200    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;201    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;202      u32_t seqno, ackno;
;;;203      u16_t remote_port, local_port;
;;;204      struct ip_addr remote_ip, local_ip;
;;;205    #if LWIP_CALLBACK_API  
;;;206      void (* errf)(void *arg, err_t err);
;;;207    #endif /* LWIP_CALLBACK_API */
;;;208      void *errf_arg;
;;;209    
;;;210      
;;;211      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;212         are in an active state, call the receive function associated with
;;;213         the PCB with a NULL argument, and send an RST to the remote end. */
;;;214      if (pcb->state == TIME_WAIT) {
000008  7c20              LDRB     r0,[r4,#0x10]
00000a  280a              CMP      r0,#0xa
00000c  d108              BNE      |L1.32|
;;;215        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
00000e  4621              MOV      r1,r4
000010  4823              LDR      r0,|L1.160|
000012  f7fffffe          BL       tcp_pcb_remove
;;;216        memp_free(MEMP_TCP_PCB, pcb);
000016  4621              MOV      r1,r4
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       memp_free
00001e  e03d              B        |L1.156|
                  |L1.32|
;;;217      } else {
;;;218        seqno = pcb->snd_nxt;
000020  6da7              LDR      r7,[r4,#0x58]
;;;219        ackno = pcb->rcv_nxt;
000022  f8d48024          LDR      r8,[r4,#0x24]
;;;220        ip_addr_set(&local_ip, &(pcb->local_ip));
000026  b90c              CBNZ     r4,|L1.44|
000028  2000              MOVS     r0,#0
00002a  e000              B        |L1.46|
                  |L1.44|
00002c  6820              LDR      r0,[r4,#0]
                  |L1.46|
00002e  9002              STR      r0,[sp,#8]
;;;221        ip_addr_set(&remote_ip, &(pcb->remote_ip));
000030  1d20              ADDS     r0,r4,#4
000032  d100              BNE      |L1.54|
000034  e000              B        |L1.56|
                  |L1.54|
000036  6860              LDR      r0,[r4,#4]
                  |L1.56|
000038  9003              STR      r0,[sp,#0xc]
;;;222        local_port = pcb->local_port;
00003a  f8b4a018          LDRH     r10,[r4,#0x18]
;;;223        remote_port = pcb->remote_port;
00003e  f8b49020          LDRH     r9,[r4,#0x20]
;;;224    #if LWIP_CALLBACK_API
;;;225        errf = pcb->errf;
000042  f8d45090          LDR      r5,[r4,#0x90]
;;;226    #endif /* LWIP_CALLBACK_API */
;;;227        errf_arg = pcb->callback_arg;
000046  f8d4b014          LDR      r11,[r4,#0x14]
;;;228        tcp_pcb_remove(&tcp_active_pcbs, pcb);
00004a  4621              MOV      r1,r4
00004c  4815              LDR      r0,|L1.164|
00004e  f7fffffe          BL       tcp_pcb_remove
;;;229        if (pcb->unacked != NULL) {
000052  6fa0              LDR      r0,[r4,#0x78]
000054  b110              CBZ      r0,|L1.92|
;;;230          tcp_segs_free(pcb->unacked);
000056  6fa0              LDR      r0,[r4,#0x78]
000058  f7fffffe          BL       tcp_segs_free
                  |L1.92|
;;;231        }
;;;232        if (pcb->unsent != NULL) {
00005c  6f60              LDR      r0,[r4,#0x74]
00005e  b110              CBZ      r0,|L1.102|
;;;233          tcp_segs_free(pcb->unsent);
000060  6f60              LDR      r0,[r4,#0x74]
000062  f7fffffe          BL       tcp_segs_free
                  |L1.102|
;;;234        }
;;;235    #if TCP_QUEUE_OOSEQ    
;;;236        if (pcb->ooseq != NULL) {
;;;237          tcp_segs_free(pcb->ooseq);
;;;238        }
;;;239    #endif /* TCP_QUEUE_OOSEQ */
;;;240        memp_free(MEMP_TCP_PCB, pcb);
000066  4621              MOV      r1,r4
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       memp_free
;;;241        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
00006e  bf00              NOP      
000070  b11d              CBZ      r5,|L1.122|
000072  f06f0104          MVN      r1,#4
000076  4658              MOV      r0,r11
000078  47a8              BLX      r5
                  |L1.122|
00007a  bf00              NOP      
;;;242        if (reset) {
00007c  b176              CBZ      r6,|L1.156|
;;;243          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
00007e  bf00              NOP      
000080  bf00              NOP      
000082  a009              ADR      r0,|L1.168|
000084  f7fffffe          BL       __2printf
000088  bf00              NOP      
00008a  bf00              NOP      
;;;244          tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
00008c  ab03              ADD      r3,sp,#0xc
00008e  aa02              ADD      r2,sp,#8
000090  4641              MOV      r1,r8
000092  4638              MOV      r0,r7
000094  e9cda900          STRD     r10,r9,[sp,#0]
000098  f7fffffe          BL       tcp_rst
                  |L1.156|
;;;245        }
;;;246      }
;;;247    }
00009c  e8bd9fff          POP      {r0-r12,pc}
;;;248    
                          ENDP

                  |L1.160|
                          DCD      tcp_tw_pcbs
                  |L1.164|
                          DCD      tcp_active_pcbs
                  |L1.168|
0000a8  7463705f          DCB      "tcp_abandon: sending RST\n",0
0000ac  6162616e
0000b0  646f6e3a
0000b4  2073656e
0000b8  64696e67
0000bc  20525354
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;1129   void
;;;1130   tcp_accept(struct tcp_pcb *pcb,
000000  61c1              STR      r1,[r0,#0x1c]
;;;1131        err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
;;;1132   {
;;;1133     pcb->accept = accept;
;;;1134   }
000002  4770              BX       lr
;;;1135   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=1

                  tcp_accept_null PROC
;;;327    static err_t
;;;328    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  4603              MOV      r3,r0
;;;329    {
;;;330      LWIP_UNUSED_ARG(arg);
;;;331      LWIP_UNUSED_ARG(pcb);
;;;332      LWIP_UNUSED_ARG(err);
;;;333    
;;;334      return ERR_ABRT;
000002  f06f0004          MVN      r0,#4
;;;335    }
000006  4770              BX       lr
;;;336    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;983    struct tcp_pcb *
;;;984    tcp_alloc(u8_t prio)
000000  b570              PUSH     {r4-r6,lr}
;;;985    {
000002  4606              MOV      r6,r0
;;;986      struct tcp_pcb *pcb;
;;;987      u32_t iss;
;;;988      
;;;989      pcb = memp_malloc(MEMP_TCP_PCB);
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;990      if (pcb == NULL) {
00000c  b9a4              CBNZ     r4,|L4.56|
;;;991        /* Try killing oldest connection in TIME-WAIT. */
;;;992        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
00000e  bf00              NOP      
000010  bf00              NOP      
000012  a02e              ADR      r0,|L4.204|
000014  f7fffffe          BL       __2printf
000018  bf00              NOP      
00001a  bf00              NOP      
;;;993        tcp_kill_timewait();
00001c  f7fffffe          BL       tcp_kill_timewait
;;;994        /* Try to allocate a tcp_pcb again. */
;;;995        pcb = memp_malloc(MEMP_TCP_PCB);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       memp_malloc
000026  4604              MOV      r4,r0
;;;996        if (pcb == NULL) {
000028  b934              CBNZ     r4,|L4.56|
;;;997          /* Try killing active connections with lower priority than the new one. */
;;;998          tcp_kill_prio(prio);
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       tcp_kill_prio
;;;999          /* Try to allocate a tcp_pcb again. */
;;;1000         pcb = memp_malloc(MEMP_TCP_PCB);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       memp_malloc
000036  4604              MOV      r4,r0
                  |L4.56|
;;;1001       }
;;;1002     }
;;;1003     if (pcb != NULL) {
000038  b3f4              CBZ      r4,|L4.184|
;;;1004       memset(pcb, 0, sizeof(struct tcp_pcb));
00003a  21a0              MOVS     r1,#0xa0
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_memclr4
;;;1005       pcb->prio = TCP_PRIO_NORMAL;
000042  2040              MOVS     r0,#0x40
000044  f1040418          ADD      r4,r4,#0x18
000048  f8040c07          STRB     r0,[r4,#-7]
;;;1006       pcb->snd_buf = TCP_SND_BUF;
00004c  f24050b4          MOV      r0,#0x5b4
000050  f8a40056          STRH     r0,[r4,#0x56]
;;;1007       pcb->snd_queuelen = 0;
000054  f04f0000          MOV      r0,#0
000058  f8a40058          STRH     r0,[r4,#0x58]
;;;1008       pcb->rcv_wnd = TCP_WND;
00005c  f6403068          MOV      r0,#0xb68
000060  8220              STRH     r0,[r4,#0x10]
;;;1009       pcb->rcv_ann_wnd = TCP_WND;
000062  8260              STRH     r0,[r4,#0x12]
;;;1010       pcb->tos = 0;
000064  f04f0000          MOV      r0,#0
000068  f8040c0e          STRB     r0,[r4,#-0xe]
;;;1011       pcb->ttl = TCP_TTL;
00006c  f04f00ff          MOV      r0,#0xff
000070  f8040c0d          STRB     r0,[r4,#-0xd]
;;;1012       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1013          The send MSS is updated when an MSS option is received. */
;;;1014       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
000074  f44f7006          MOV      r0,#0x218
000078  8420              STRH     r0,[r4,#0x20]
;;;1015       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
00007a  f04f0006          MOV      r0,#6
00007e  8620              STRH     r0,[r4,#0x30]
;;;1016       pcb->sa = 0;
000080  f04f0000          MOV      r0,#0
000084  85a0              STRH     r0,[r4,#0x2c]
;;;1017       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
000086  f04f0006          MOV      r0,#6
00008a  85e0              STRH     r0,[r4,#0x2e]
;;;1018       pcb->rtime = -1;
00008c  f04f30ff          MOV      r0,#0xffffffff
000090  83e0              STRH     r0,[r4,#0x1e]
;;;1019       pcb->cwnd = 1;
000092  f04f0001          MOV      r0,#1
000096  8760              STRH     r0,[r4,#0x3a]
;;;1020       iss = tcp_next_iss();
000098  f7fffffe          BL       tcp_next_iss
00009c  4605              MOV      r5,r0
;;;1021       pcb->snd_wl2 = iss;
00009e  64e5              STR      r5,[r4,#0x4c]
;;;1022       pcb->snd_nxt = iss;
0000a0  6425              STR      r5,[r4,#0x40]
;;;1023       pcb->lastack = iss;
0000a2  6365              STR      r5,[r4,#0x34]
;;;1024       pcb->snd_lbb = iss;   
0000a4  6525              STR      r5,[r4,#0x50]
;;;1025       pcb->tmr = tcp_ticks;
0000a6  4816              LDR      r0,|L4.256|
0000a8  6800              LDR      r0,[r0,#0]  ; tcp_ticks
0000aa  61a0              STR      r0,[r4,#0x18]
;;;1026   
;;;1027       pcb->polltmr = 0;
0000ac  2000              MOVS     r0,#0
0000ae  7720              STRB     r0,[r4,#0x1c]
;;;1028   
;;;1029   #if LWIP_CALLBACK_API
;;;1030       pcb->recv = tcp_recv_null;
0000b0  4814              LDR      r0,|L4.260|
0000b2  66e0              STR      r0,[r4,#0x6c]
;;;1031   #endif /* LWIP_CALLBACK_API */  
;;;1032       
;;;1033       /* Init KEEPALIVE timer */
;;;1034       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
0000b4  4814              LDR      r0,|L4.264|
0000b6  e000              B        |L4.186|
                  |L4.184|
0000b8  e005              B        |L4.198|
                  |L4.186|
0000ba  67e0              STR      r0,[r4,#0x7c]
;;;1035       
;;;1036   #if LWIP_TCP_KEEPALIVE
;;;1037       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1038       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1039   #endif /* LWIP_TCP_KEEPALIVE */
;;;1040   
;;;1041       pcb->keep_cnt_sent = 0;
0000bc  2000              MOVS     r0,#0
0000be  f8840085          STRB     r0,[r4,#0x85]
0000c2  f1a40418          SUB      r4,r4,#0x18
                  |L4.198|
;;;1042     }
;;;1043     return pcb;
0000c6  4620              MOV      r0,r4
;;;1044   }
0000c8  bd70              POP      {r4-r6,pc}
;;;1045   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L4.204|
0000cc  7463705f          DCB      "tcp_alloc: killing off oldest TIME-WAIT connection\n",0
0000d0  616c6c6f
0000d4  633a206b
0000d8  696c6c69
0000dc  6e67206f
0000e0  6666206f
0000e4  6c646573
0000e8  74205449
0000ec  4d452d57
0000f0  41495420
0000f4  636f6e6e
0000f8  65637469
0000fc  6f6e0a00
                  |L4.256|
                          DCD      tcp_ticks
                  |L4.260|
                          DCD      tcp_recv_null
                  |L4.264|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1071   void
;;;1072   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  6141              STR      r1,[r0,#0x14]
;;;1073   {  
;;;1074     pcb->callback_arg = arg;
;;;1075   }
000002  4770              BX       lr
;;;1076   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                  tcp_bind PROC
;;;262    err_t
;;;263    tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;264    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;265      struct tcp_pcb *cpcb;
;;;266    
;;;267      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
00000a  bf00              NOP      
00000c  7c38              LDRB     r0,[r7,#0x10]
00000e  b160              CBZ      r0,|L6.42|
000010  bf00              NOP      
000012  a33d              ADR      r3,|L6.264|
000014  f240120b          MOV      r2,#0x10b
000018  a141              ADR      r1,|L6.288|
00001a  a04b              ADR      r0,|L6.328|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
000022  f06f000c          MVN      r0,#0xc
                  |L6.38|
;;;268    
;;;269      if (port == 0) {
;;;270        port = tcp_new_port();
;;;271      }
;;;272      /* Check if the address already is in use. */
;;;273      /* Check the listen pcbs. */
;;;274      for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
;;;275          cpcb != NULL; cpcb = cpcb->next) {
;;;276        if (cpcb->local_port == port) {
;;;277          if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;278              ip_addr_isany(ipaddr) ||
;;;279              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;280            return ERR_USE;
;;;281          }
;;;282        }
;;;283      }
;;;284      /* Check the connected pcbs. */
;;;285      for(cpcb = tcp_active_pcbs;
;;;286          cpcb != NULL; cpcb = cpcb->next) {
;;;287        if (cpcb->local_port == port) {
;;;288          if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;289              ip_addr_isany(ipaddr) ||
;;;290              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;291            return ERR_USE;
;;;292          }
;;;293        }
;;;294      }
;;;295      /* Check the bound, not yet connected pcbs. */
;;;296      for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
;;;297        if (cpcb->local_port == port) {
;;;298          if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;299              ip_addr_isany(ipaddr) ||
;;;300              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;301            return ERR_USE;
;;;302          }
;;;303        }
;;;304      }
;;;305      /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
;;;306       * we have to check the pcbs in TIME-WAIT state, also: */
;;;307      for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
;;;308        if (cpcb->local_port == port) {
;;;309          if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;310            return ERR_USE;
;;;311          }
;;;312        }
;;;313      }
;;;314    
;;;315      if (!ip_addr_isany(ipaddr)) {
;;;316        pcb->local_ip = *ipaddr;
;;;317      }
;;;318      pcb->local_port = port;
;;;319      TCP_REG(&tcp_bound_pcbs, pcb);
;;;320      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;321      return ERR_OK;
;;;322    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L6.42|
00002a  bf00              NOP                            ;267
00002c  b916              CBNZ     r6,|L6.52|
00002e  f7fffffe          BL       tcp_new_port
000032  4606              MOV      r6,r0                 ;270
                  |L6.52|
000034  484e              LDR      r0,|L6.368|
000036  6804              LDR      r4,[r0,#0]            ;274  ; tcp_listen_pcbs
000038  e010              B        |L6.92|
                  |L6.58|
00003a  8b20              LDRH     r0,[r4,#0x18]         ;276
00003c  42b0              CMP      r0,r6                 ;276
00003e  d10c              BNE      |L6.90|
000040  b144              CBZ      r4,|L6.84|
000042  6820              LDR      r0,[r4,#0]            ;277
000044  b130              CBZ      r0,|L6.84|
000046  b12d              CBZ      r5,|L6.84|
000048  6828              LDR      r0,[r5,#0]            ;278
00004a  b118              CBZ      r0,|L6.84|
00004c  6820              LDR      r0,[r4,#0]            ;279
00004e  6829              LDR      r1,[r5,#0]            ;279
000050  4288              CMP      r0,r1                 ;279
000052  d102              BNE      |L6.90|
                  |L6.84|
000054  f06f000a          MVN      r0,#0xa               ;280
000058  e7e5              B        |L6.38|
                  |L6.90|
00005a  68e4              LDR      r4,[r4,#0xc]          ;275
                  |L6.92|
00005c  2c00              CMP      r4,#0                 ;275
00005e  d1ec              BNE      |L6.58|
000060  4844              LDR      r0,|L6.372|
000062  6804              LDR      r4,[r0,#0]            ;285  ; tcp_active_pcbs
000064  e010              B        |L6.136|
                  |L6.102|
000066  8b20              LDRH     r0,[r4,#0x18]         ;287
000068  42b0              CMP      r0,r6                 ;287
00006a  d10c              BNE      |L6.134|
00006c  b144              CBZ      r4,|L6.128|
00006e  6820              LDR      r0,[r4,#0]            ;288
000070  b130              CBZ      r0,|L6.128|
000072  b12d              CBZ      r5,|L6.128|
000074  6828              LDR      r0,[r5,#0]            ;289
000076  b118              CBZ      r0,|L6.128|
000078  6820              LDR      r0,[r4,#0]            ;290
00007a  6829              LDR      r1,[r5,#0]            ;290
00007c  4288              CMP      r0,r1                 ;290
00007e  d102              BNE      |L6.134|
                  |L6.128|
000080  f06f000a          MVN      r0,#0xa               ;291
000084  e7cf              B        |L6.38|
                  |L6.134|
000086  68e4              LDR      r4,[r4,#0xc]          ;286
                  |L6.136|
000088  2c00              CMP      r4,#0                 ;286
00008a  d1ec              BNE      |L6.102|
00008c  483a              LDR      r0,|L6.376|
00008e  6804              LDR      r4,[r0,#0]            ;296  ; tcp_bound_pcbs
000090  e010              B        |L6.180|
                  |L6.146|
000092  8b20              LDRH     r0,[r4,#0x18]         ;297
000094  42b0              CMP      r0,r6                 ;297
000096  d10c              BNE      |L6.178|
000098  b144              CBZ      r4,|L6.172|
00009a  6820              LDR      r0,[r4,#0]            ;298
00009c  b130              CBZ      r0,|L6.172|
00009e  b12d              CBZ      r5,|L6.172|
0000a0  6828              LDR      r0,[r5,#0]            ;299
0000a2  b118              CBZ      r0,|L6.172|
0000a4  6820              LDR      r0,[r4,#0]            ;300
0000a6  6829              LDR      r1,[r5,#0]            ;300
0000a8  4288              CMP      r0,r1                 ;300
0000aa  d102              BNE      |L6.178|
                  |L6.172|
0000ac  f06f000a          MVN      r0,#0xa               ;301
0000b0  e7b9              B        |L6.38|
                  |L6.178|
0000b2  68e4              LDR      r4,[r4,#0xc]          ;296
                  |L6.180|
0000b4  2c00              CMP      r4,#0                 ;296
0000b6  d1ec              BNE      |L6.146|
0000b8  4830              LDR      r0,|L6.380|
0000ba  6804              LDR      r4,[r0,#0]            ;307  ; tcp_tw_pcbs
0000bc  e00a              B        |L6.212|
                  |L6.190|
0000be  8b20              LDRH     r0,[r4,#0x18]         ;308
0000c0  42b0              CMP      r0,r6                 ;308
0000c2  d106              BNE      |L6.210|
0000c4  6820              LDR      r0,[r4,#0]            ;309
0000c6  6829              LDR      r1,[r5,#0]            ;309
0000c8  4288              CMP      r0,r1                 ;309
0000ca  d102              BNE      |L6.210|
0000cc  f06f000a          MVN      r0,#0xa               ;310
0000d0  e7a9              B        |L6.38|
                  |L6.210|
0000d2  68e4              LDR      r4,[r4,#0xc]          ;307
                  |L6.212|
0000d4  2c00              CMP      r4,#0                 ;307
0000d6  d1f2              BNE      |L6.190|
0000d8  b11d              CBZ      r5,|L6.226|
0000da  6828              LDR      r0,[r5,#0]            ;315
0000dc  b108              CBZ      r0,|L6.226|
0000de  6828              LDR      r0,[r5,#0]            ;316
0000e0  6038              STR      r0,[r7,#0]            ;316
                  |L6.226|
0000e2  833e              STRH     r6,[r7,#0x18]         ;318
0000e4  bf00              NOP                            ;319
0000e6  4824              LDR      r0,|L6.376|
0000e8  6800              LDR      r0,[r0,#0]            ;319  ; tcp_bound_pcbs
0000ea  60f8              STR      r0,[r7,#0xc]          ;319
0000ec  4822              LDR      r0,|L6.376|
0000ee  6007              STR      r7,[r0,#0]            ;319  ; tcp_bound_pcbs
0000f0  bf00              NOP                            ;319
0000f2  bf00              NOP                            ;320
0000f4  bf00              NOP                            ;320
0000f6  4631              MOV      r1,r6                 ;320
0000f8  a021              ADR      r0,|L6.384|
0000fa  f7fffffe          BL       __2printf
0000fe  bf00              NOP                            ;320
000100  bf00              NOP                            ;320
000102  2000              MOVS     r0,#0                 ;321
000104  e78f              B        |L6.38|
;;;323    #if LWIP_CALLBACK_API
                          ENDP

000106  0000              DCW      0x0000
                  |L6.264|
000108  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\tcp.c",0
00010c  7749505c
000110  7372635c
000114  636f7265
000118  5c746370
00011c  2e6300  
00011f  00                DCB      0
                  |L6.288|
000120  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
000124  62696e64
000128  3a206361
00012c  6e206f6e
000130  6c792062
000134  696e6420
000138  696e2073
00013c  74617465
000140  20434c4f
000144  53454400
                  |L6.328|
000148  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00014c  7274696f
000150  6e202225
000154  73222066
000158  61696c65
00015c  64206174
000160  206c696e
000164  65202564
000168  20696e20
00016c  25730a00
                  |L6.368|
                          DCD      tcp_listen_pcbs
                  |L6.372|
                          DCD      tcp_active_pcbs
                  |L6.376|
                          DCD      tcp_bound_pcbs
                  |L6.380|
                          DCD      tcp_tw_pcbs
                  |L6.384|
000180  7463705f          DCB      "tcp_bind: bind to port %4d\n",0
000184  62696e64
000188  3a206269
00018c  6e642074
000190  6f20706f
000194  72742025
000198  34640a00

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  tcp_close PROC
;;;111    err_t
;;;112    tcp_close(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;113    {
000002  4604              MOV      r4,r0
;;;114      err_t err;
;;;115    
;;;116    #if TCP_DEBUG
;;;117      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
000004  bf00              NOP      
000006  bf00              NOP      
000008  a049              ADR      r0,|L7.304|
00000a  f7fffffe          BL       __2printf
00000e  bf00              NOP      
000010  bf00              NOP      
;;;118      tcp_debug_print_state(pcb->state);
000012  7c20              LDRB     r0,[r4,#0x10]
000014  f7fffffe          BL       tcp_debug_print_state
;;;119    #endif /* TCP_DEBUG */
;;;120    
;;;121      switch (pcb->state) {
000018  7c20              LDRB     r0,[r4,#0x10]
00001a  2808              CMP      r0,#8
00001c  d27d              BCS      |L7.282|
00001e  e8dff000          TBB      [pc,r0]
000022  044a              DCB      0x04,0x4a
000024  5560697c          DCB      0x55,0x60,0x69,0x7c
000028  7c73              DCB      0x7c,0x73
;;;122    	  case CLOSED:
;;;123    	    /* Closing a pcb in the CLOSED state might seem erroneous,
;;;124    	     * however, it is in this state once allocated and as yet unused
;;;125    	     * and the user needs some way to free it should the need arise.
;;;126    	     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;127    	     * or for a pcb that has been used and then entered the CLOSED state 
;;;128    	     * is erroneous, but this should never happen as the pcb has in those cases
;;;129    	     * been freed, and so any remaining handles are bogus. */
;;;130    	    err = ERR_OK;
00002a  2500              MOVS     r5,#0
;;;131    		tcp_listen_pcbs.listen_pcbs->accepts_pending--;//add by ck
00002c  4846              LDR      r0,|L7.328|
00002e  6800              LDR      r0,[r0,#0]  ; tcp_listen_pcbs
000030  f8900021          LDRB     r0,[r0,#0x21]
000034  1e40              SUBS     r0,r0,#1
000036  4944              LDR      r1,|L7.328|
000038  6809              LDR      r1,[r1,#0]  ; tcp_listen_pcbs
00003a  f8810021          STRB     r0,[r1,#0x21]
;;;132    		LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: tcp_listen_pcbs.listen_pcbs->accepts_pending-- %"U16_F"\n", tcp_listen_pcbs.listen_pcbs->accepts_pending));
00003e  bf00              NOP      
000040  bf00              NOP      
000042  4841              LDR      r0,|L7.328|
000044  6800              LDR      r0,[r0,#0]  ; tcp_listen_pcbs
000046  f8901021          LDRB     r1,[r0,#0x21]
00004a  a040              ADR      r0,|L7.332|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
000052  bf00              NOP      
;;;133    	    TCP_RMV(&tcp_bound_pcbs, pcb);
000054  bf00              NOP      
000056  484d              LDR      r0,|L7.396|
000058  6800              LDR      r0,[r0,#0]  ; tcp_bound_pcbs
00005a  42a0              CMP      r0,r4
00005c  d105              BNE      |L7.106|
00005e  484b              LDR      r0,|L7.396|
000060  6800              LDR      r0,[r0,#0]  ; tcp_bound_pcbs
000062  68c0              LDR      r0,[r0,#0xc]
000064  4949              LDR      r1,|L7.396|
000066  6008              STR      r0,[r1,#0]  ; tcp_bound_pcbs
000068  e01c              B        |L7.164|
                  |L7.106|
00006a  4848              LDR      r0,|L7.396|
00006c  6800              LDR      r0,[r0,#0]  ; tcp_bound_pcbs
00006e  4948              LDR      r1,|L7.400|
000070  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
000072  e012              B        |L7.154|
                  |L7.116|
000074  4846              LDR      r0,|L7.400|
000076  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000078  68c0              LDR      r0,[r0,#0xc]
00007a  b148              CBZ      r0,|L7.144|
00007c  4844              LDR      r0,|L7.400|
00007e  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000080  68c0              LDR      r0,[r0,#0xc]
000082  42a0              CMP      r0,r4
000084  d104              BNE      |L7.144|
000086  4942              LDR      r1,|L7.400|
000088  68e0              LDR      r0,[r4,#0xc]
00008a  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
00008c  60c8              STR      r0,[r1,#0xc]
00008e  e008              B        |L7.162|
                  |L7.144|
000090  483f              LDR      r0,|L7.400|
000092  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000094  68c0              LDR      r0,[r0,#0xc]
000096  493e              LDR      r1,|L7.400|
000098  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L7.154|
00009a  483d              LDR      r0,|L7.400|
00009c  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00009e  2800              CMP      r0,#0
0000a0  d1e8              BNE      |L7.116|
                  |L7.162|
0000a2  bf00              NOP      
                  |L7.164|
0000a4  2000              MOVS     r0,#0
0000a6  60e0              STR      r0,[r4,#0xc]
0000a8  bf00              NOP      
;;;134    	    memp_free(MEMP_TCP_PCB, pcb);
0000aa  4621              MOV      r1,r4
0000ac  2002              MOVS     r0,#2
0000ae  f7fffffe          BL       memp_free
;;;135    	    pcb = NULL;
0000b2  2400              MOVS     r4,#0
;;;136    	    break;
0000b4  e034              B        |L7.288|
;;;137    	  case LISTEN:
;;;138    	    err = ERR_OK;
0000b6  2500              MOVS     r5,#0
;;;139    	    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
0000b8  4621              MOV      r1,r4
0000ba  4823              LDR      r0,|L7.328|
0000bc  f7fffffe          BL       tcp_pcb_remove
;;;140    	    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
0000c0  4621              MOV      r1,r4
0000c2  2003              MOVS     r0,#3
0000c4  f7fffffe          BL       memp_free
;;;141    	    pcb = NULL;
0000c8  2400              MOVS     r4,#0
;;;142    	    break;
0000ca  e029              B        |L7.288|
;;;143    	  case SYN_SENT:
;;;144    	    err = ERR_OK;
0000cc  2500              MOVS     r5,#0
;;;145    	    tcp_pcb_remove(&tcp_active_pcbs, pcb);
0000ce  4621              MOV      r1,r4
0000d0  4830              LDR      r0,|L7.404|
0000d2  f7fffffe          BL       tcp_pcb_remove
;;;146    	    memp_free(MEMP_TCP_PCB, pcb);
0000d6  4621              MOV      r1,r4
0000d8  2002              MOVS     r0,#2
0000da  f7fffffe          BL       memp_free
;;;147    	    pcb = NULL;
0000de  2400              MOVS     r4,#0
;;;148    	    snmp_inc_tcpattemptfails();
;;;149    	    break;
0000e0  e01e              B        |L7.288|
;;;150    	  case SYN_RCVD:
;;;151    	    err = tcp_send_ctrl(pcb, TCP_FIN);
0000e2  2101              MOVS     r1,#1
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       tcp_send_ctrl
0000ea  4605              MOV      r5,r0
;;;152    	    if (err == ERR_OK) {
0000ec  b90d              CBNZ     r5,|L7.242|
;;;153    	      snmp_inc_tcpattemptfails();
;;;154    	      pcb->state = FIN_WAIT_1;
0000ee  2005              MOVS     r0,#5
0000f0  7420              STRB     r0,[r4,#0x10]
                  |L7.242|
;;;155    	    }
;;;156    	    break;
0000f2  e015              B        |L7.288|
;;;157    	  case ESTABLISHED:
;;;158    	    err = tcp_send_ctrl(pcb, TCP_FIN);
0000f4  2101              MOVS     r1,#1
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       tcp_send_ctrl
0000fc  4605              MOV      r5,r0
;;;159    	    if (err == ERR_OK) {
0000fe  b90d              CBNZ     r5,|L7.260|
;;;160    	      snmp_inc_tcpestabresets();
;;;161    	      pcb->state = FIN_WAIT_1;
000100  2005              MOVS     r0,#5
000102  7420              STRB     r0,[r4,#0x10]
                  |L7.260|
;;;162    	    }
;;;163    	    break;
000104  e00c              B        |L7.288|
000106  e008              B        |L7.282|
;;;164    	  case CLOSE_WAIT:
;;;165    	    err = tcp_send_ctrl(pcb, TCP_FIN);
000108  2101              MOVS     r1,#1
00010a  4620              MOV      r0,r4
00010c  f7fffffe          BL       tcp_send_ctrl
000110  4605              MOV      r5,r0
;;;166    	    if (err == ERR_OK) {
000112  b90d              CBNZ     r5,|L7.280|
;;;167    	      snmp_inc_tcpestabresets();
;;;168    	      pcb->state = LAST_ACK;
000114  2009              MOVS     r0,#9
000116  7420              STRB     r0,[r4,#0x10]
                  |L7.280|
;;;169    	    }
;;;170    	    break;
000118  e002              B        |L7.288|
                  |L7.282|
;;;171    	  default:
;;;172    	    /* Has already been closed, do nothing. */
;;;173    	    err = ERR_OK;
00011a  2500              MOVS     r5,#0
;;;174    	    pcb = NULL;
00011c  2400              MOVS     r4,#0
;;;175    	    break;
00011e  bf00              NOP      
                  |L7.288|
000120  bf00              NOP                            ;136
;;;176      }
;;;177    
;;;178      if (pcb != NULL && err == ERR_OK) {
000122  b11c              CBZ      r4,|L7.300|
000124  b915              CBNZ     r5,|L7.300|
;;;179        /* To ensure all data has been sent when tcp_close returns, we have
;;;180           to make sure tcp_output doesn't fail.
;;;181           Since we don't really have to ensure all data has been sent when tcp_close
;;;182           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;183           for the return value of tcp_output for now. */
;;;184        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;185           If SOF_LINGER is set, the data should be sent when tcp_close returns. */
;;;186        tcp_output(pcb);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       tcp_output
                  |L7.300|
;;;187      }
;;;188      return err;
00012c  4628              MOV      r0,r5
;;;189    }
00012e  bd70              POP      {r4-r6,pc}
;;;190    
                          ENDP

                  |L7.304|
000130  7463705f          DCB      "tcp_close: closing in ",0
000134  636c6f73
000138  653a2063
00013c  6c6f7369
000140  6e672069
000144  6e2000  
000147  00                DCB      0
                  |L7.328|
                          DCD      tcp_listen_pcbs
                  |L7.332|
00014c  7463705f          DCB      "tcp_close: tcp_listen_pcbs.listen_pcbs->accepts_pending"
000150  636c6f73
000154  653a2074
000158  63705f6c
00015c  69737465
000160  6e5f7063
000164  62732e6c
000168  69737465
00016c  6e5f7063
000170  62732d3e
000174  61636365
000178  7074735f
00017c  70656e64
000180  696e67  
000183  2d2d2025          DCB      "-- %4d\n",0
000187  34640a00
00018b  00                DCB      0
                  |L7.396|
                          DCD      tcp_bound_pcbs
                  |L7.400|
                          DCD      tcp_tmp_pcb
                  |L7.404|
                          DCD      tcp_active_pcbs

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                  tcp_connect PROC
;;;500    err_t
;;;501    tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;502          err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
;;;503    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;504      err_t ret;
;;;505      u32_t iss;
;;;506    
;;;507      LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
00000c  bf00              NOP      
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  b160              CBZ      r0,|L8.44|
000012  bf00              NOP      
000014  a347              ADR      r3,|L8.308|
000016  f24012fb          MOV      r2,#0x1fb
00001a  a14c              ADR      r1,|L8.332|
00001c  a058              ADR      r0,|L8.384|
00001e  f7fffffe          BL       __2printf
000022  bf00              NOP      
000024  f06f000c          MVN      r0,#0xc
                  |L8.40|
;;;508    
;;;509      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;510      if (ipaddr != NULL) {
;;;511        pcb->remote_ip = *ipaddr;
;;;512      } else {
;;;513        return ERR_VAL;
;;;514      }
;;;515      pcb->remote_port = port;
;;;516      if (pcb->local_port == 0) {
;;;517        pcb->local_port = tcp_new_port();
;;;518      }
;;;519      iss = tcp_next_iss();
;;;520      pcb->rcv_nxt = 0;
;;;521      pcb->snd_nxt = iss;
;;;522      pcb->lastack = iss - 1;
;;;523      pcb->snd_lbb = iss - 1;
;;;524      pcb->rcv_wnd = TCP_WND;
;;;525      pcb->rcv_ann_wnd = TCP_WND;
;;;526      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;527      pcb->snd_wnd = TCP_WND;
;;;528      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;529         The send MSS is updated when an MSS option is received. */
;;;530      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;531    #if TCP_CALCULATE_EFF_SEND_MSS
;;;532      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;533    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;534      pcb->cwnd = 1;
;;;535      pcb->ssthresh = pcb->mss * 10;
;;;536      pcb->state = SYN_SENT;
;;;537    #if LWIP_CALLBACK_API  
;;;538      pcb->connected = connected;
;;;539    #endif /* LWIP_CALLBACK_API */
;;;540      TCP_RMV(&tcp_bound_pcbs, pcb);
;;;541      TCP_REG(&tcp_active_pcbs, pcb);
;;;542    
;;;543      snmp_inc_tcpactiveopens();
;;;544      
;;;545      ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
;;;546    #if LWIP_TCP_TIMESTAMPS
;;;547                        | TF_SEG_OPTS_TS
;;;548    #endif
;;;549                        );
;;;550      if (ret == ERR_OK) { 
;;;551        tcp_output(pcb);
;;;552      }
;;;553      return ret;
;;;554    } 
000028  e8bd87fc          POP      {r2-r10,pc}
                  |L8.44|
00002c  bf00              NOP                            ;507
00002e  bf00              NOP                            ;509
000030  bf00              NOP                            ;509
000032  4639              MOV      r1,r7                 ;509
000034  a05c              ADR      r0,|L8.424|
000036  f7fffffe          BL       __2printf
00003a  bf00              NOP                            ;509
00003c  bf00              NOP                            ;509
00003e  b116              CBZ      r6,|L8.70|
000040  6830              LDR      r0,[r6,#0]            ;511
000042  6060              STR      r0,[r4,#4]            ;511
000044  e002              B        |L8.76|
                  |L8.70|
000046  f06f0008          MVN      r0,#8                 ;513
00004a  e7ed              B        |L8.40|
                  |L8.76|
00004c  8427              STRH     r7,[r4,#0x20]         ;515
00004e  8b20              LDRH     r0,[r4,#0x18]         ;516
000050  b910              CBNZ     r0,|L8.88|
000052  f7fffffe          BL       tcp_new_port
000056  8320              STRH     r0,[r4,#0x18]         ;517
                  |L8.88|
000058  f7fffffe          BL       tcp_next_iss
00005c  4605              MOV      r5,r0                 ;519
00005e  2000              MOVS     r0,#0                 ;520
000060  6260              STR      r0,[r4,#0x24]         ;520
000062  65a5              STR      r5,[r4,#0x58]         ;521
000064  1e68              SUBS     r0,r5,#1              ;522
000066  64e0              STR      r0,[r4,#0x4c]         ;522
000068  66a0              STR      r0,[r4,#0x68]         ;523
00006a  f6403068          MOV      r0,#0xb68             ;524
00006e  8520              STRH     r0,[r4,#0x28]         ;524
000070  8560              STRH     r0,[r4,#0x2a]         ;525
000072  6a60              LDR      r0,[r4,#0x24]         ;526
000074  62e0              STR      r0,[r4,#0x2c]         ;526
000076  f6403068          MOV      r0,#0xb68             ;527
00007a  f8a4005c          STRH     r0,[r4,#0x5c]         ;527
00007e  f44f7006          MOV      r0,#0x218             ;530
000082  8720              STRH     r0,[r4,#0x38]         ;530
000084  8f20              LDRH     r0,[r4,#0x38]         ;532
000086  4631              MOV      r1,r6                 ;532
000088  f7fffffe          BL       tcp_eff_send_mss
00008c  8720              STRH     r0,[r4,#0x38]         ;532
00008e  2001              MOVS     r0,#1                 ;534
000090  f8a40052          STRH     r0,[r4,#0x52]         ;534
000094  8f20              LDRH     r0,[r4,#0x38]         ;535
000096  eb000080          ADD      r0,r0,r0,LSL #2       ;535
00009a  0440              LSLS     r0,r0,#17             ;535
00009c  0c00              LSRS     r0,r0,#16             ;535
00009e  f8a40054          STRH     r0,[r4,#0x54]         ;535
0000a2  2002              MOVS     r0,#2                 ;536
0000a4  7420              STRB     r0,[r4,#0x10]         ;536
0000a6  f8c49088          STR      r9,[r4,#0x88]         ;538
0000aa  bf00              NOP                            ;540
0000ac  4845              LDR      r0,|L8.452|
0000ae  6800              LDR      r0,[r0,#0]            ;540  ; tcp_bound_pcbs
0000b0  42a0              CMP      r0,r4                 ;540
0000b2  d105              BNE      |L8.192|
0000b4  4843              LDR      r0,|L8.452|
0000b6  6800              LDR      r0,[r0,#0]            ;540  ; tcp_bound_pcbs
0000b8  68c0              LDR      r0,[r0,#0xc]          ;540
0000ba  4942              LDR      r1,|L8.452|
0000bc  6008              STR      r0,[r1,#0]            ;540  ; tcp_bound_pcbs
0000be  e01c              B        |L8.250|
                  |L8.192|
0000c0  4840              LDR      r0,|L8.452|
0000c2  6800              LDR      r0,[r0,#0]            ;540  ; tcp_bound_pcbs
0000c4  4940              LDR      r1,|L8.456|
0000c6  6008              STR      r0,[r1,#0]            ;540  ; tcp_tmp_pcb
0000c8  e012              B        |L8.240|
                  |L8.202|
0000ca  483f              LDR      r0,|L8.456|
0000cc  6800              LDR      r0,[r0,#0]            ;540  ; tcp_tmp_pcb
0000ce  68c0              LDR      r0,[r0,#0xc]          ;540
0000d0  b148              CBZ      r0,|L8.230|
0000d2  483d              LDR      r0,|L8.456|
0000d4  6800              LDR      r0,[r0,#0]            ;540  ; tcp_tmp_pcb
0000d6  68c0              LDR      r0,[r0,#0xc]          ;540
0000d8  42a0              CMP      r0,r4                 ;540
0000da  d104              BNE      |L8.230|
0000dc  493a              LDR      r1,|L8.456|
0000de  68e0              LDR      r0,[r4,#0xc]          ;540
0000e0  6809              LDR      r1,[r1,#0]            ;540  ; tcp_tmp_pcb
0000e2  60c8              STR      r0,[r1,#0xc]          ;540
0000e4  e008              B        |L8.248|
                  |L8.230|
0000e6  4838              LDR      r0,|L8.456|
0000e8  6800              LDR      r0,[r0,#0]            ;540  ; tcp_tmp_pcb
0000ea  68c0              LDR      r0,[r0,#0xc]          ;540
0000ec  4936              LDR      r1,|L8.456|
0000ee  6008              STR      r0,[r1,#0]            ;540  ; tcp_tmp_pcb
                  |L8.240|
0000f0  4835              LDR      r0,|L8.456|
0000f2  6800              LDR      r0,[r0,#0]            ;540  ; tcp_tmp_pcb
0000f4  2800              CMP      r0,#0                 ;540
0000f6  d1e8              BNE      |L8.202|
                  |L8.248|
0000f8  bf00              NOP                            ;540
                  |L8.250|
0000fa  2000              MOVS     r0,#0                 ;540
0000fc  60e0              STR      r0,[r4,#0xc]          ;540
0000fe  bf00              NOP                            ;540
000100  bf00              NOP                            ;541
000102  4832              LDR      r0,|L8.460|
000104  6800              LDR      r0,[r0,#0]            ;541  ; tcp_active_pcbs
000106  60e0              STR      r0,[r4,#0xc]          ;541
000108  4830              LDR      r0,|L8.460|
00010a  6004              STR      r4,[r0,#0]            ;541  ; tcp_active_pcbs
00010c  bf00              NOP                            ;541
00010e  2301              MOVS     r3,#1                 ;545
000110  2200              MOVS     r2,#0                 ;545
000112  e9cd2300          STRD     r2,r3,[sp,#0]         ;545
000116  2302              MOVS     r3,#2                 ;545
000118  4611              MOV      r1,r2                 ;545
00011a  4620              MOV      r0,r4                 ;545
00011c  f7fffffe          BL       tcp_enqueue
000120  4680              MOV      r8,r0                 ;545
000122  f1b80f00          CMP      r8,#0                 ;550
000126  d102              BNE      |L8.302|
000128  4620              MOV      r0,r4                 ;551
00012a  f7fffffe          BL       tcp_output
                  |L8.302|
00012e  4640              MOV      r0,r8                 ;553
000130  e77a              B        |L8.40|
;;;555    
                          ENDP

000132  0000              DCW      0x0000
                  |L8.308|
000134  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\tcp.c",0
000138  7749505c
00013c  7372635c
000140  636f7265
000144  5c746370
000148  2e6300  
00014b  00                DCB      0
                  |L8.332|
00014c  7463705f          DCB      "tcp_connect: can only connected from state CLOSED",0
000150  636f6e6e
000154  6563743a
000158  2063616e
00015c  206f6e6c
000160  7920636f
000164  6e6e6563
000168  74656420
00016c  66726f6d
000170  20737461
000174  74652043
000178  4c4f5345
00017c  4400    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L8.384|
000180  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000184  7274696f
000188  6e202225
00018c  73222066
000190  61696c65
000194  64206174
000198  206c696e
00019c  65202564
0001a0  20696e20
0001a4  25730a00
                  |L8.424|
0001a8  7463705f          DCB      "tcp_connect to port %4d\n",0
0001ac  636f6e6e
0001b0  65637420
0001b4  746f2070
0001b8  6f727420
0001bc  2534640a
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L8.452|
                          DCD      tcp_bound_pcbs
                  |L8.456|
                          DCD      tcp_tmp_pcb
                  |L8.460|
                          DCD      tcp_active_pcbs

                          AREA ||i.tcp_debug_print||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_flags
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  tcp_debug_print PROC
;;;1301   void
;;;1302   tcp_debug_print(struct tcp_hdr *tcphdr)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1303   {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
;;;1304     LWIP_DEBUGF(TCP_DEBUG, ("TCP header:\n"));
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  a05c              ADR      r0,|L9.384|
00000e  f7fffffe          BL       __2printf
000012  bf00              NOP      
000014  bf00              NOP      
;;;1305     LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
000016  bf00              NOP      
000018  bf00              NOP      
00001a  a05d              ADR      r0,|L9.400|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
000022  bf00              NOP      
;;;1306     LWIP_DEBUGF(TCP_DEBUG, ("|    %5"U16_F"      |    %5"U16_F"      | (src port, dest port)\n",
000024  bf00              NOP      
000026  bf00              NOP      
000028  8860              LDRH     r0,[r4,#2]
00002a  f7fffffe          BL       ntohs
00002e  4605              MOV      r5,r0
000030  8820              LDRH     r0,[r4,#0]
000032  f7fffffe          BL       ntohs
000036  4606              MOV      r6,r0
000038  462a              MOV      r2,r5
00003a  4601              MOV      r1,r0
00003c  a05d              ADR      r0,|L9.436|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP      
000044  bf00              NOP      
;;;1307            ntohs(tcphdr->src), ntohs(tcphdr->dest)));
;;;1308     LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
000046  bf00              NOP      
000048  bf00              NOP      
00004a  a051              ADR      r0,|L9.400|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
000052  bf00              NOP      
;;;1309     LWIP_DEBUGF(TCP_DEBUG, ("|           %010"U32_F"          | (seq no)\n",
000054  bf00              NOP      
000056  bf00              NOP      
000058  6860              LDR      r0,[r4,#4]
00005a  f7fffffe          BL       ntohl
00005e  4605              MOV      r5,r0
000060  4601              MOV      r1,r0
000062  a062              ADR      r0,|L9.492|
000064  f7fffffe          BL       __2printf
000068  bf00              NOP      
00006a  bf00              NOP      
;;;1310             ntohl(tcphdr->seqno)));
;;;1311     LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
00006c  bf00              NOP      
00006e  bf00              NOP      
000070  a047              ADR      r0,|L9.400|
000072  f7fffffe          BL       __2printf
000076  bf00              NOP      
000078  bf00              NOP      
;;;1312     LWIP_DEBUGF(TCP_DEBUG, ("|           %010"U32_F"          | (ack no)\n",
00007a  bf00              NOP      
00007c  bf00              NOP      
00007e  68a0              LDR      r0,[r4,#8]
000080  f7fffffe          BL       ntohl
000084  4605              MOV      r5,r0
000086  4601              MOV      r1,r0
000088  a063              ADR      r0,|L9.536|
00008a  f7fffffe          BL       __2printf
00008e  bf00              NOP      
000090  bf00              NOP      
;;;1313            ntohl(tcphdr->ackno)));
;;;1314     LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
000092  bf00              NOP      
000094  bf00              NOP      
000096  a03e              ADR      r0,|L9.400|
000098  f7fffffe          BL       __2printf
00009c  bf00              NOP      
00009e  bf00              NOP      
;;;1315     LWIP_DEBUGF(TCP_DEBUG, ("| %2"U16_F" |   |%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"%"U16_F"|     %5"U16_F"     | (hdrlen, flags (",
0000a0  bf00              NOP      
0000a2  bf00              NOP      
0000a4  89e0              LDRH     r0,[r4,#0xe]
0000a6  f7fffffe          BL       ntohs
0000aa  9006              STR      r0,[sp,#0x18]
0000ac  89a0              LDRH     r0,[r4,#0xc]
0000ae  f7fffffe          BL       ntohs
0000b2  f0000501          AND      r5,r0,#1
0000b6  89a0              LDRH     r0,[r4,#0xc]
0000b8  f7fffffe          BL       ntohs
0000bc  f3c00044          UBFX     r0,r0,#1,#5
0000c0  f0000601          AND      r6,r0,#1
0000c4  89a0              LDRH     r0,[r4,#0xc]
0000c6  f7fffffe          BL       ntohs
0000ca  f3c00083          UBFX     r0,r0,#2,#4
0000ce  f0000701          AND      r7,r0,#1
0000d2  89a0              LDRH     r0,[r4,#0xc]
0000d4  f7fffffe          BL       ntohs
0000d8  f3c000c2          UBFX     r0,r0,#3,#3
0000dc  f0000801          AND      r8,r0,#1
0000e0  89a0              LDRH     r0,[r4,#0xc]
0000e2  f7fffffe          BL       ntohs
0000e6  f3c01001          UBFX     r0,r0,#4,#2
0000ea  f0000901          AND      r9,r0,#1
0000ee  89a0              LDRH     r0,[r4,#0xc]
0000f0  f7fffffe          BL       ntohs
0000f4  f3c01a40          UBFX     r10,r0,#5,#1
0000f8  89a0              LDRH     r0,[r4,#0xc]
0000fa  f7fffffe          BL       ntohs
0000fe  ea4f3b20          ASR      r11,r0,#12
000102  9b06              LDR      r3,[sp,#0x18]
000104  e9cd8700          STRD     r8,r7,[sp,#0]
000108  e9cd6502          STRD     r6,r5,[sp,#8]
00010c  9304              STR      r3,[sp,#0x10]
00010e  464b              MOV      r3,r9
000110  4652              MOV      r2,r10
000112  4659              MOV      r1,r11
000114  a04b              ADR      r0,|L9.580|
000116  f7fffffe          BL       __2printf
00011a  bf00              NOP      
00011c  bf00              NOP      
;;;1316          TCPH_HDRLEN(tcphdr),
;;;1317            TCPH_FLAGS(tcphdr) >> 5 & 1,
;;;1318            TCPH_FLAGS(tcphdr) >> 4 & 1,
;;;1319            TCPH_FLAGS(tcphdr) >> 3 & 1,
;;;1320            TCPH_FLAGS(tcphdr) >> 2 & 1,
;;;1321            TCPH_FLAGS(tcphdr) >> 1 & 1,
;;;1322            TCPH_FLAGS(tcphdr) & 1,
;;;1323            ntohs(tcphdr->wnd)));
;;;1324     tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
00011e  89a0              LDRH     r0,[r4,#0xc]
000120  f7fffffe          BL       ntohs
000124  f000053f          AND      r5,r0,#0x3f
000128  4628              MOV      r0,r5
00012a  f7fffffe          BL       tcp_debug_print_flags
;;;1325     LWIP_DEBUGF(TCP_DEBUG, ("), win)\n"));
00012e  bf00              NOP      
000130  bf00              NOP      
000132  a054              ADR      r0,|L9.644|
000134  f7fffffe          BL       __2printf
000138  bf00              NOP      
00013a  bf00              NOP      
;;;1326     LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
00013c  bf00              NOP      
00013e  bf00              NOP      
000140  a013              ADR      r0,|L9.400|
000142  f7fffffe          BL       __2printf
000146  bf00              NOP      
000148  bf00              NOP      
;;;1327     LWIP_DEBUGF(TCP_DEBUG, ("|    0x%04"X16_F"     |     %5"U16_F"     | (chksum, urgp)\n",
00014a  bf00              NOP      
00014c  bf00              NOP      
00014e  8a60              LDRH     r0,[r4,#0x12]
000150  f7fffffe          BL       ntohs
000154  4605              MOV      r5,r0
000156  8a20              LDRH     r0,[r4,#0x10]
000158  f7fffffe          BL       ntohs
00015c  4606              MOV      r6,r0
00015e  462a              MOV      r2,r5
000160  4601              MOV      r1,r0
000162  a04b              ADR      r0,|L9.656|
000164  f7fffffe          BL       __2printf
000168  bf00              NOP      
00016a  bf00              NOP      
;;;1328            ntohs(tcphdr->chksum), ntohs(tcphdr->urgp)));
;;;1329     LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
00016c  bf00              NOP      
00016e  bf00              NOP      
000170  a007              ADR      r0,|L9.400|
000172  f7fffffe          BL       __2printf
000176  bf00              NOP      
000178  bf00              NOP      
;;;1330   }
00017a  b007              ADD      sp,sp,#0x1c
00017c  e8bd8ff0          POP      {r4-r11,pc}
;;;1331   
                          ENDP

                  |L9.384|
000180  54435020          DCB      "TCP header:\n",0
000184  68656164
000188  65723a0a
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L9.400|
000190  2b2d2d2d          DCB      "+-------------------------------+\n",0
000194  2d2d2d2d
000198  2d2d2d2d
00019c  2d2d2d2d
0001a0  2d2d2d2d
0001a4  2d2d2d2d
0001a8  2d2d2d2d
0001ac  2d2d2d2d
0001b0  2b0a00  
0001b3  00                DCB      0
                  |L9.436|
0001b4  7c202020          DCB      "|    %54d      |    %54d      | (src port, dest port)\n"
0001b8  20253534
0001bc  64202020
0001c0  2020207c
0001c4  20202020
0001c8  25353464
0001cc  20202020
0001d0  20207c20
0001d4  28737263
0001d8  20706f72
0001dc  742c2064
0001e0  65737420
0001e4  706f7274
0001e8  290a    
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L9.492|
0001ec  7c202020          DCB      "|           %0108ld          | (seq no)\n",0
0001f0  20202020
0001f4  20202020
0001f8  25303130
0001fc  386c6420
000200  20202020
000204  20202020
000208  207c2028
00020c  73657120
000210  6e6f290a
000214  00      
000215  00                DCB      0
000216  00                DCB      0
000217  00                DCB      0
                  |L9.536|
000218  7c202020          DCB      "|           %0108ld          | (ack no)\n",0
00021c  20202020
000220  20202020
000224  25303130
000228  386c6420
00022c  20202020
000230  20202020
000234  207c2028
000238  61636b20
00023c  6e6f290a
000240  00      
000241  00                DCB      0
000242  00                DCB      0
000243  00                DCB      0
                  |L9.580|
000244  7c202532          DCB      "| %24d |   |%4d%4d%4d%4d%4d%4d|     %54d     | (hdrlen,"
000248  3464207c
00024c  2020207c
000250  25346425
000254  34642534
000258  64253464
00025c  25346425
000260  34647c20
000264  20202020
000268  25353464
00026c  20202020
000270  207c2028
000274  6864726c
000278  656e2c  
00027b  20666c61          DCB      " flags (",0
00027f  67732028
000283  00      
                  |L9.644|
000284  292c2077          DCB      "), win)\n",0
000288  696e290a
00028c  00      
00028d  00                DCB      0
00028e  00                DCB      0
00028f  00                DCB      0
                  |L9.656|
000290  7c202020          DCB      "|    0x%044x     |     %54d     | (chksum, urgp)\n",0
000294  20307825
000298  30343478
00029c  20202020
0002a0  207c2020
0002a4  20202025
0002a8  35346420
0002ac  20202020
0002b0  7c202863
0002b4  686b7375
0002b8  6d2c2075
0002bc  72677029
0002c0  0a00    
0002c2  00                DCB      0
0002c3  00                DCB      0

                          AREA ||i.tcp_debug_print_flags||, CODE, READONLY, ALIGN=2

                  tcp_debug_print_flags PROC
;;;1383   void
;;;1384   tcp_debug_print_flags(u8_t flags)
000000  b510              PUSH     {r4,lr}
;;;1385   {
000002  4604              MOV      r4,r0
;;;1386     if (flags & TCP_FIN) {
000004  f0140f01          TST      r4,#1
000008  d006              BEQ      |L10.24|
;;;1387       LWIP_DEBUGF(TCP_DEBUG, ("FIN "));
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  a029              ADR      r0,|L10.180|
000010  f7fffffe          BL       __2printf
000014  bf00              NOP      
000016  bf00              NOP      
                  |L10.24|
;;;1388     }
;;;1389     if (flags & TCP_SYN) {
000018  f0140f02          TST      r4,#2
00001c  d006              BEQ      |L10.44|
;;;1390       LWIP_DEBUGF(TCP_DEBUG, ("SYN "));
00001e  bf00              NOP      
000020  bf00              NOP      
000022  a026              ADR      r0,|L10.188|
000024  f7fffffe          BL       __2printf
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L10.44|
;;;1391     }
;;;1392     if (flags & TCP_RST) {
00002c  f0140f04          TST      r4,#4
000030  d006              BEQ      |L10.64|
;;;1393       LWIP_DEBUGF(TCP_DEBUG, ("RST "));
000032  bf00              NOP      
000034  bf00              NOP      
000036  a023              ADR      r0,|L10.196|
000038  f7fffffe          BL       __2printf
00003c  bf00              NOP      
00003e  bf00              NOP      
                  |L10.64|
;;;1394     }
;;;1395     if (flags & TCP_PSH) {
000040  f0140f08          TST      r4,#8
000044  d006              BEQ      |L10.84|
;;;1396       LWIP_DEBUGF(TCP_DEBUG, ("PSH "));
000046  bf00              NOP      
000048  bf00              NOP      
00004a  a020              ADR      r0,|L10.204|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
000052  bf00              NOP      
                  |L10.84|
;;;1397     }
;;;1398     if (flags & TCP_ACK) {
000054  f0140f10          TST      r4,#0x10
000058  d006              BEQ      |L10.104|
;;;1399       LWIP_DEBUGF(TCP_DEBUG, ("ACK "));
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  a01d              ADR      r0,|L10.212|
000060  f7fffffe          BL       __2printf
000064  bf00              NOP      
000066  bf00              NOP      
                  |L10.104|
;;;1400     }
;;;1401     if (flags & TCP_URG) {
000068  f0140f20          TST      r4,#0x20
00006c  d006              BEQ      |L10.124|
;;;1402       LWIP_DEBUGF(TCP_DEBUG, ("URG "));
00006e  bf00              NOP      
000070  bf00              NOP      
000072  a01a              ADR      r0,|L10.220|
000074  f7fffffe          BL       __2printf
000078  bf00              NOP      
00007a  bf00              NOP      
                  |L10.124|
;;;1403     }
;;;1404     if (flags & TCP_ECE) {
00007c  f0140f40          TST      r4,#0x40
000080  d006              BEQ      |L10.144|
;;;1405       LWIP_DEBUGF(TCP_DEBUG, ("ECE "));
000082  bf00              NOP      
000084  bf00              NOP      
000086  a017              ADR      r0,|L10.228|
000088  f7fffffe          BL       __2printf
00008c  bf00              NOP      
00008e  bf00              NOP      
                  |L10.144|
;;;1406     }
;;;1407     if (flags & TCP_CWR) {
000090  f0140f80          TST      r4,#0x80
000094  d006              BEQ      |L10.164|
;;;1408       LWIP_DEBUGF(TCP_DEBUG, ("CWR "));
000096  bf00              NOP      
000098  bf00              NOP      
00009a  a014              ADR      r0,|L10.236|
00009c  f7fffffe          BL       __2printf
0000a0  bf00              NOP      
0000a2  bf00              NOP      
                  |L10.164|
;;;1409     }
;;;1410     LWIP_DEBUGF(TCP_DEBUG, ("\n"));
0000a4  bf00              NOP      
0000a6  bf00              NOP      
0000a8  a012              ADR      r0,|L10.244|
0000aa  f7fffffe          BL       __2printf
0000ae  bf00              NOP      
0000b0  bf00              NOP      
;;;1411   }
0000b2  bd10              POP      {r4,pc}
;;;1412   
                          ENDP

                  |L10.180|
0000b4  46494e20          DCB      "FIN ",0
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L10.188|
0000bc  53594e20          DCB      "SYN ",0
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L10.196|
0000c4  52535420          DCB      "RST ",0
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L10.204|
0000cc  50534820          DCB      "PSH ",0
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L10.212|
0000d4  41434b20          DCB      "ACK ",0
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L10.220|
0000dc  55524720          DCB      "URG ",0
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L10.228|
0000e4  45434520          DCB      "ECE ",0
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L10.236|
0000ec  43575220          DCB      "CWR ",0
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L10.244|
0000f4  0a00              DCB      "\n",0
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||i.tcp_debug_print_pcbs||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  tcp_debug_print_pcbs PROC
;;;1416   void
;;;1417   tcp_debug_print_pcbs(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1418   {
;;;1419     struct tcp_pcb *pcb;
;;;1420     LWIP_DEBUGF(TCP_DEBUG, ("Active PCB states:\n"));
000002  bf00              NOP      
000004  bf00              NOP      
000006  a029              ADR      r0,|L11.172|
000008  f7fffffe          BL       __2printf
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;1421     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000010  482b              LDR      r0,|L11.192|
000012  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000014  e00f              B        |L11.54|
                  |L11.22|
;;;1422       LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
000016  bf00              NOP      
000018  bf00              NOP      
00001a  6a63              LDR      r3,[r4,#0x24]
00001c  9300              STR      r3,[sp,#0]
00001e  8c22              LDRH     r2,[r4,#0x20]
000020  8b21              LDRH     r1,[r4,#0x18]
000022  a028              ADR      r0,|L11.196|
000024  6da3              LDR      r3,[r4,#0x58]
000026  f7fffffe          BL       __2printf
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;1423                          pcb->local_port, pcb->remote_port,
;;;1424                          pcb->snd_nxt, pcb->rcv_nxt));
;;;1425       tcp_debug_print_state(pcb->state);
00002e  7c20              LDRB     r0,[r4,#0x10]
000030  f7fffffe          BL       tcp_debug_print_state
000034  68e4              LDR      r4,[r4,#0xc]          ;1421
                  |L11.54|
000036  2c00              CMP      r4,#0                 ;1421
000038  d1ed              BNE      |L11.22|
;;;1426     }    
;;;1427     LWIP_DEBUGF(TCP_DEBUG, ("Listen PCB states:\n"));
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  a030              ADR      r0,|L11.256|
000040  f7fffffe          BL       __2printf
000044  bf00              NOP      
000046  bf00              NOP      
;;;1428     for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
000048  4832              LDR      r0,|L11.276|
00004a  6804              LDR      r4,[r0,#0]  ; tcp_listen_pcbs
00004c  e00f              B        |L11.110|
                  |L11.78|
;;;1429       LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
00004e  bf00              NOP      
000050  bf00              NOP      
000052  6a63              LDR      r3,[r4,#0x24]
000054  9300              STR      r3,[sp,#0]
000056  8c22              LDRH     r2,[r4,#0x20]
000058  8b21              LDRH     r1,[r4,#0x18]
00005a  a01a              ADR      r0,|L11.196|
00005c  6da3              LDR      r3,[r4,#0x58]
00005e  f7fffffe          BL       __2printf
000062  bf00              NOP      
000064  bf00              NOP      
;;;1430                          pcb->local_port, pcb->remote_port,
;;;1431                          pcb->snd_nxt, pcb->rcv_nxt));
;;;1432       tcp_debug_print_state(pcb->state);
000066  7c20              LDRB     r0,[r4,#0x10]
000068  f7fffffe          BL       tcp_debug_print_state
00006c  68e4              LDR      r4,[r4,#0xc]          ;1428
                  |L11.110|
00006e  2c00              CMP      r4,#0                 ;1428
000070  d1ed              BNE      |L11.78|
;;;1433     }    
;;;1434     LWIP_DEBUGF(TCP_DEBUG, ("TIME-WAIT PCB states:\n"));
000072  bf00              NOP      
000074  bf00              NOP      
000076  a028              ADR      r0,|L11.280|
000078  f7fffffe          BL       __2printf
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;1435     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000080  482b              LDR      r0,|L11.304|
000082  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000084  e00f              B        |L11.166|
                  |L11.134|
;;;1436       LWIP_DEBUGF(TCP_DEBUG, ("Local port %"U16_F", foreign port %"U16_F" snd_nxt %"U32_F" rcv_nxt %"U32_F" ",
000086  bf00              NOP      
000088  bf00              NOP      
00008a  6a63              LDR      r3,[r4,#0x24]
00008c  9300              STR      r3,[sp,#0]
00008e  8c22              LDRH     r2,[r4,#0x20]
000090  8b21              LDRH     r1,[r4,#0x18]
000092  a00c              ADR      r0,|L11.196|
000094  6da3              LDR      r3,[r4,#0x58]
000096  f7fffffe          BL       __2printf
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;1437                          pcb->local_port, pcb->remote_port,
;;;1438                          pcb->snd_nxt, pcb->rcv_nxt));
;;;1439       tcp_debug_print_state(pcb->state);
00009e  7c20              LDRB     r0,[r4,#0x10]
0000a0  f7fffffe          BL       tcp_debug_print_state
0000a4  68e4              LDR      r4,[r4,#0xc]          ;1435
                  |L11.166|
0000a6  2c00              CMP      r4,#0                 ;1435
0000a8  d1ed              BNE      |L11.134|
;;;1440     }    
;;;1441   }
0000aa  bd38              POP      {r3-r5,pc}
;;;1442   
                          ENDP

                  |L11.172|
0000ac  41637469          DCB      "Active PCB states:\n",0
0000b0  76652050
0000b4  43422073
0000b8  74617465
0000bc  733a0a00
                  |L11.192|
                          DCD      tcp_active_pcbs
                  |L11.196|
0000c4  4c6f6361          DCB      "Local port %4d, foreign port %4d snd_nxt %8ld rcv_nxt %"
0000c8  6c20706f
0000cc  72742025
0000d0  34642c20
0000d4  666f7265
0000d8  69676e20
0000dc  706f7274
0000e0  20253464
0000e4  20736e64
0000e8  5f6e7874
0000ec  2025386c
0000f0  64207263
0000f4  765f6e78
0000f8  742025  
0000fb  386c6420          DCB      "8ld ",0
0000ff  00      
                  |L11.256|
000100  4c697374          DCB      "Listen PCB states:\n",0
000104  656e2050
000108  43422073
00010c  74617465
000110  733a0a00
                  |L11.276|
                          DCD      tcp_listen_pcbs
                  |L11.280|
000118  54494d45          DCB      "TIME-WAIT PCB states:\n",0
00011c  2d574149
000120  54205043
000124  42207374
000128  61746573
00012c  3a0a00  
00012f  00                DCB      0
                  |L11.304|
                          DCD      tcp_tw_pcbs

                          AREA ||i.tcp_debug_print_state||, CODE, READONLY, ALIGN=2

                  tcp_debug_print_state PROC
;;;1337   void
;;;1338   tcp_debug_print_state(enum tcp_state s)
000000  b510              PUSH     {r4,lr}
;;;1339   {
000002  4604              MOV      r4,r0
;;;1340     LWIP_DEBUGF(TCP_DEBUG, ("State: "));
000004  bf00              NOP      
000006  bf00              NOP      
000008  a034              ADR      r0,|L12.220|
00000a  f7fffffe          BL       __2printf
00000e  bf00              NOP      
000010  bf00              NOP      
;;;1341     switch (s) {
000012  2c0b              CMP      r4,#0xb
000014  d25f              BCS      |L12.214|
000016  e8dff004          TBB      [pc,r4]
00001a  060e              DCB      0x06,0x0e
00001c  161e262e          DCB      0x16,0x1e,0x26,0x2e
000020  363e464e          DCB      0x36,0x3e,0x46,0x4e
000024  5600              DCB      0x56,0x00
;;;1342     case CLOSED:
;;;1343       LWIP_DEBUGF(TCP_DEBUG, ("CLOSED\n"));
000026  bf00              NOP      
000028  bf00              NOP      
00002a  a02e              ADR      r0,|L12.228|
00002c  f7fffffe          BL       __2printf
000030  bf00              NOP      
000032  bf00              NOP      
;;;1344       break;
000034  e04f              B        |L12.214|
;;;1345    case LISTEN:
;;;1346      LWIP_DEBUGF(TCP_DEBUG, ("LISTEN\n"));
000036  bf00              NOP      
000038  bf00              NOP      
00003a  a02c              ADR      r0,|L12.236|
00003c  f7fffffe          BL       __2printf
000040  bf00              NOP      
000042  bf00              NOP      
;;;1347      break;
000044  e047              B        |L12.214|
;;;1348     case SYN_SENT:
;;;1349       LWIP_DEBUGF(TCP_DEBUG, ("SYN_SENT\n"));
000046  bf00              NOP      
000048  bf00              NOP      
00004a  a02a              ADR      r0,|L12.244|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
000052  bf00              NOP      
;;;1350       break;
000054  e03f              B        |L12.214|
;;;1351     case SYN_RCVD:
;;;1352       LWIP_DEBUGF(TCP_DEBUG, ("SYN_RCVD\n"));
000056  bf00              NOP      
000058  bf00              NOP      
00005a  a029              ADR      r0,|L12.256|
00005c  f7fffffe          BL       __2printf
000060  bf00              NOP      
000062  bf00              NOP      
;;;1353       break;
000064  e037              B        |L12.214|
;;;1354     case ESTABLISHED:
;;;1355       LWIP_DEBUGF(TCP_DEBUG, ("ESTABLISHED\n"));
000066  bf00              NOP      
000068  bf00              NOP      
00006a  a028              ADR      r0,|L12.268|
00006c  f7fffffe          BL       __2printf
000070  bf00              NOP      
000072  bf00              NOP      
;;;1356       break;
000074  e02f              B        |L12.214|
;;;1357     case FIN_WAIT_1:
;;;1358       LWIP_DEBUGF(TCP_DEBUG, ("FIN_WAIT_1\n"));
000076  bf00              NOP      
000078  bf00              NOP      
00007a  a028              ADR      r0,|L12.284|
00007c  f7fffffe          BL       __2printf
000080  bf00              NOP      
000082  bf00              NOP      
;;;1359       break;
000084  e027              B        |L12.214|
;;;1360     case FIN_WAIT_2:
;;;1361       LWIP_DEBUGF(TCP_DEBUG, ("FIN_WAIT_2\n"));
000086  bf00              NOP      
000088  bf00              NOP      
00008a  a027              ADR      r0,|L12.296|
00008c  f7fffffe          BL       __2printf
000090  bf00              NOP      
000092  bf00              NOP      
;;;1362       break;
000094  e01f              B        |L12.214|
;;;1363     case CLOSE_WAIT:
;;;1364       LWIP_DEBUGF(TCP_DEBUG, ("CLOSE_WAIT\n"));
000096  bf00              NOP      
000098  bf00              NOP      
00009a  a026              ADR      r0,|L12.308|
00009c  f7fffffe          BL       __2printf
0000a0  bf00              NOP      
0000a2  bf00              NOP      
;;;1365       break;
0000a4  e017              B        |L12.214|
;;;1366     case CLOSING:
;;;1367       LWIP_DEBUGF(TCP_DEBUG, ("CLOSING\n"));
0000a6  bf00              NOP      
0000a8  bf00              NOP      
0000aa  a025              ADR      r0,|L12.320|
0000ac  f7fffffe          BL       __2printf
0000b0  bf00              NOP      
0000b2  bf00              NOP      
;;;1368       break;
0000b4  e00f              B        |L12.214|
;;;1369     case LAST_ACK:
;;;1370       LWIP_DEBUGF(TCP_DEBUG, ("LAST_ACK\n"));
0000b6  bf00              NOP      
0000b8  bf00              NOP      
0000ba  a024              ADR      r0,|L12.332|
0000bc  f7fffffe          BL       __2printf
0000c0  bf00              NOP      
0000c2  bf00              NOP      
;;;1371       break;
0000c4  e007              B        |L12.214|
;;;1372     case TIME_WAIT:
;;;1373       LWIP_DEBUGF(TCP_DEBUG, ("TIME_WAIT\n"));
0000c6  bf00              NOP      
0000c8  bf00              NOP      
0000ca  a023              ADR      r0,|L12.344|
0000cc  f7fffffe          BL       __2printf
0000d0  bf00              NOP      
0000d2  bf00              NOP      
;;;1374      break;
0000d4  bf00              NOP      
                  |L12.214|
0000d6  bf00              NOP                            ;1344
;;;1375     }
;;;1376   }
0000d8  bd10              POP      {r4,pc}
;;;1377   
                          ENDP

0000da  0000              DCW      0x0000
                  |L12.220|
0000dc  53746174          DCB      "State: ",0
0000e0  653a2000
                  |L12.228|
0000e4  434c4f53          DCB      "CLOSED\n",0
0000e8  45440a00
                  |L12.236|
0000ec  4c495354          DCB      "LISTEN\n",0
0000f0  454e0a00
                  |L12.244|
0000f4  53594e5f          DCB      "SYN_SENT\n",0
0000f8  53454e54
0000fc  0a00    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L12.256|
000100  53594e5f          DCB      "SYN_RCVD\n",0
000104  52435644
000108  0a00    
00010a  00                DCB      0
00010b  00                DCB      0
                  |L12.268|
00010c  45535441          DCB      "ESTABLISHED\n",0
000110  424c4953
000114  4845440a
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L12.284|
00011c  46494e5f          DCB      "FIN_WAIT_1\n",0
000120  57414954
000124  5f310a00
                  |L12.296|
000128  46494e5f          DCB      "FIN_WAIT_2\n",0
00012c  57414954
000130  5f320a00
                  |L12.308|
000134  434c4f53          DCB      "CLOSE_WAIT\n",0
000138  455f5741
00013c  49540a00
                  |L12.320|
000140  434c4f53          DCB      "CLOSING\n",0
000144  494e470a
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L12.332|
00014c  4c415354          DCB      "LAST_ACK\n",0
000150  5f41434b
000154  0a00    
000156  00                DCB      0
000157  00                DCB      0
                  |L12.344|
000158  54494d45          DCB      "TIME_WAIT\n",0
00015c  5f574149
000160  540a00  
000163  00                DCB      0

                          AREA ||i.tcp_eff_send_mss||, CODE, READONLY, ALIGN=1

                  tcp_eff_send_mss PROC
;;;1275   u16_t
;;;1276   tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1277   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1278     u16_t mss_s;
;;;1279     struct netif *outif;
;;;1280   
;;;1281     outif = ip_route(addr);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       ip_route
00000e  4604              MOV      r4,r0
;;;1282     if ((outif != NULL) && (outif->mtu != 0)) {
000010  b154              CBZ      r4,|L13.40|
000012  8e20              LDRH     r0,[r4,#0x30]
000014  b140              CBZ      r0,|L13.40|
;;;1283       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
000016  8e20              LDRH     r0,[r4,#0x30]
000018  3828              SUBS     r0,r0,#0x28
00001a  b287              UXTH     r7,r0
;;;1284       /* RFC 1122, chap 4.2.2.6:
;;;1285        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1286        * We correct for TCP options in tcp_enqueue(), and don't support
;;;1287        * IP options
;;;1288        */
;;;1289       sendmss = LWIP_MIN(sendmss, mss_s);
00001c  42bd              CMP      r5,r7
00001e  da01              BGE      |L13.36|
000020  4628              MOV      r0,r5
000022  e000              B        |L13.38|
                  |L13.36|
000024  4638              MOV      r0,r7
                  |L13.38|
000026  b285              UXTH     r5,r0
                  |L13.40|
;;;1290     }
;;;1291     return sendmss;
000028  4628              MOV      r0,r5
;;;1292   }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;1293   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=1

                  tcp_err PROC
;;;1114   void
;;;1115   tcp_err(struct tcp_pcb *pcb,
000000  f8c01090          STR      r1,[r0,#0x90]
;;;1116      void (* errf)(void *arg, err_t err))
;;;1117   {
;;;1118     pcb->errf = errf;
;;;1119   }
000004  4770              BX       lr
;;;1120   
                          ENDP


                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;796    void
;;;797    tcp_fasttmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;798    {
;;;799      struct tcp_pcb *pcb;
;;;800    
;;;801      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000002  4822              LDR      r0,|L15.140|
000004  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000006  e03e              B        |L15.134|
                  |L15.8|
;;;802        /* If there is data which was previously "refused" by upper layer */
;;;803        if (pcb->refused_data != NULL) {
000008  6fe0              LDR      r0,[r4,#0x7c]
00000a  b1f0              CBZ      r0,|L15.74|
;;;804          /* Notify again application with data previously received. */
;;;805          err_t err;
;;;806          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  a01f              ADR      r0,|L15.144|
000012  f7fffffe          BL       __2printf
000016  bf00              NOP      
000018  bf00              NOP      
;;;807          TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
00001a  bf00              NOP      
00001c  f8d40084          LDR      r0,[r4,#0x84]
000020  b140              CBZ      r0,|L15.52|
000022  2300              MOVS     r3,#0
000024  4621              MOV      r1,r4
000026  f8d46084          LDR      r6,[r4,#0x84]
00002a  6fe2              LDR      r2,[r4,#0x7c]
00002c  6960              LDR      r0,[r4,#0x14]
00002e  47b0              BLX      r6
000030  4605              MOV      r5,r0
000032  e005              B        |L15.64|
                  |L15.52|
000034  2500              MOVS     r5,#0
000036  6fe0              LDR      r0,[r4,#0x7c]
000038  b110              CBZ      r0,|L15.64|
00003a  6fe0              LDR      r0,[r4,#0x7c]
00003c  f7fffffe          BL       pbuf_free
                  |L15.64|
000040  bf00              NOP      
;;;808          if (err == ERR_OK) {
000042  b90d              CBNZ     r5,|L15.72|
;;;809            pcb->refused_data = NULL;
000044  2000              MOVS     r0,#0
000046  67e0              STR      r0,[r4,#0x7c]
                  |L15.72|
;;;810          }
;;;811        }
000048  bf00              NOP      
                  |L15.74|
;;;812    
;;;813        /* send delayed ACKs */  
;;;814        if (pcb->flags & TF_ACK_DELAY) {
00004a  f8940022          LDRB     r0,[r4,#0x22]
00004e  f0100f01          TST      r0,#1
000052  d017              BEQ      |L15.132|
;;;815          LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
000054  bf00              NOP      
000056  bf00              NOP      
000058  a016              ADR      r0,|L15.180|
00005a  f7fffffe          BL       __2printf
00005e  bf00              NOP      
000060  bf00              NOP      
;;;816          tcp_ack_now(pcb);
000062  bf00              NOP      
000064  f8940022          LDRB     r0,[r4,#0x22]
000068  f0400002          ORR      r0,r0,#2
00006c  f8840022          STRB     r0,[r4,#0x22]
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       tcp_output
000076  bf00              NOP      
;;;817          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000078  f8940022          LDRB     r0,[r4,#0x22]
00007c  f0200003          BIC      r0,r0,#3
000080  f8840022          STRB     r0,[r4,#0x22]
                  |L15.132|
000084  68e4              LDR      r4,[r4,#0xc]          ;801
                  |L15.134|
000086  2c00              CMP      r4,#0                 ;801
000088  d1be              BNE      |L15.8|
;;;818        }
;;;819      }
;;;820    }
00008a  bd70              POP      {r4-r6,pc}
;;;821    
                          ENDP

                  |L15.140|
                          DCD      tcp_active_pcbs
                  |L15.144|
000090  7463705f          DCB      "tcp_fasttmr: notify kept packet\n",0
000094  66617374
000098  746d723a
00009c  206e6f74
0000a0  69667920
0000a4  6b657074
0000a8  20706163
0000ac  6b65740a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L15.180|
0000b4  7463705f          DCB      "tcp_fasttmr: delayed ACK\n",0
0000b8  66617374
0000bc  746d723a
0000c0  2064656c
0000c4  61796564
0000c8  2041434b
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.tcp_kill_prio||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_p
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  tcp_kill_prio PROC
;;;922    static void
;;;923    tcp_kill_prio(u8_t prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;924    {
000004  4606              MOV      r6,r0
;;;925      struct tcp_pcb *pcb, *inactive;
;;;926      u32_t inactivity;
;;;927      u8_t mprio;
;;;928    
;;;929    
;;;930      mprio = TCP_PRIO_MAX;
000006  f04f087f          MOV      r8,#0x7f
;;;931      
;;;932      /* We kill the oldest active connection that has lower priority than prio. */
;;;933      inactivity = 0;
00000a  2700              MOVS     r7,#0
;;;934      inactive = NULL;
00000c  2500              MOVS     r5,#0
;;;935      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
00000e  4814              LDR      r0,|L16.96|
000010  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000012  e013              B        |L16.60|
                  |L16.20|
;;;936        if (pcb->prio <= prio &&
000014  7c60              LDRB     r0,[r4,#0x11]
000016  42b0              CMP      r0,r6
000018  dc0f              BGT      |L16.58|
;;;937           pcb->prio <= mprio &&
00001a  7c60              LDRB     r0,[r4,#0x11]
00001c  4540              CMP      r0,r8
00001e  dc0c              BGT      |L16.58|
;;;938           (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000020  4910              LDR      r1,|L16.100|
000022  6b20              LDR      r0,[r4,#0x30]
000024  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000026  1a08              SUBS     r0,r1,r0
000028  42b8              CMP      r0,r7
00002a  d306              BCC      |L16.58|
;;;939          inactivity = tcp_ticks - pcb->tmr;
00002c  490d              LDR      r1,|L16.100|
00002e  6b20              LDR      r0,[r4,#0x30]
000030  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000032  1a0f              SUBS     r7,r1,r0
;;;940          inactive = pcb;
000034  4625              MOV      r5,r4
;;;941          mprio = pcb->prio;
000036  f8948011          LDRB     r8,[r4,#0x11]
                  |L16.58|
00003a  68e4              LDR      r4,[r4,#0xc]          ;935
                  |L16.60|
00003c  2c00              CMP      r4,#0                 ;935
00003e  d1e9              BNE      |L16.20|
;;;942        }
;;;943      }
;;;944      if (inactive != NULL) {
000040  b165              CBZ      r5,|L16.92|
;;;945        LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
000042  bf00              NOP      
000044  bf00              NOP      
000046  463a              MOV      r2,r7
000048  4629              MOV      r1,r5
00004a  a007              ADR      r0,|L16.104|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
000052  bf00              NOP      
;;;946               (void *)inactive, inactivity));
;;;947        tcp_abort(inactive);
000054  2101              MOVS     r1,#1
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       tcp_abandon
                  |L16.92|
;;;948      }      
;;;949    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;950    
                          ENDP

                  |L16.96|
                          DCD      tcp_active_pcbs
                  |L16.100|
                          DCD      tcp_ticks
                  |L16.104|
000068  7463705f          DCB      "tcp_kill_prio: killing oldest PCB %p (%8ld)\n",0
00006c  6b696c6c
000070  5f707269
000074  6f3a206b
000078  696c6c69
00007c  6e67206f
000080  6c646573
000084  74205043
000088  42202570
00008c  20282538
000090  6c64290a
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.tcp_kill_timewait||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_p
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  tcp_kill_timewait PROC
;;;955    static void
;;;956    tcp_kill_timewait(void)
000000  b570              PUSH     {r4-r6,lr}
;;;957    {
;;;958      struct tcp_pcb *pcb, *inactive;
;;;959      u32_t inactivity;
;;;960    
;;;961      inactivity = 0;
000002  2600              MOVS     r6,#0
;;;962      inactive = NULL;
000004  2500              MOVS     r5,#0
;;;963      /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;964      for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000006  4810              LDR      r0,|L17.72|
000008  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
00000a  e00b              B        |L17.36|
                  |L17.12|
;;;965        if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
00000c  490f              LDR      r1,|L17.76|
00000e  6b20              LDR      r0,[r4,#0x30]
000010  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000012  1a08              SUBS     r0,r1,r0
000014  42b0              CMP      r0,r6
000016  d304              BCC      |L17.34|
;;;966          inactivity = tcp_ticks - pcb->tmr;
000018  490c              LDR      r1,|L17.76|
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00001e  1a0e              SUBS     r6,r1,r0
;;;967          inactive = pcb;
000020  4625              MOV      r5,r4
                  |L17.34|
000022  68e4              LDR      r4,[r4,#0xc]          ;964
                  |L17.36|
000024  2c00              CMP      r4,#0                 ;964
000026  d1f1              BNE      |L17.12|
;;;968        }
;;;969      }
;;;970      if (inactive != NULL) {
000028  b165              CBZ      r5,|L17.68|
;;;971        LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  4632              MOV      r2,r6
000030  4629              MOV      r1,r5
000032  a007              ADR      r0,|L17.80|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP      
00003a  bf00              NOP      
;;;972               (void *)inactive, inactivity));
;;;973        tcp_abort(inactive);
00003c  2101              MOVS     r1,#1
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       tcp_abandon
                  |L17.68|
;;;974      }      
;;;975    }
000044  bd70              POP      {r4-r6,pc}
;;;976    
                          ENDP

000046  0000              DCW      0x0000
                  |L17.72|
                          DCD      tcp_tw_pcbs
                  |L17.76|
                          DCD      tcp_ticks
                  |L17.80|
000050  7463705f          DCB      "tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%8l"
000054  6b696c6c
000058  5f74696d
00005c  65776169
000060  743a206b
000064  696c6c69
000068  6e67206f
00006c  6c646573
000070  74205449
000074  4d452d57
000078  41495420
00007c  50434220
000080  25702028
000084  25386c  
000087  64290a00          DCB      "d)\n",0
00008b  00                DCB      0

                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_listen_with_backlog PROC
;;;352    struct tcp_pcb *
;;;353    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  b570              PUSH     {r4-r6,lr}
;;;354    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;355      struct tcp_pcb_listen *lpcb;
;;;356    
;;;357      LWIP_UNUSED_ARG(backlog);
;;;358      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
000006  bf00              NOP      
000008  7c28              LDRB     r0,[r5,#0x10]
00000a  b150              CBZ      r0,|L18.34|
00000c  bf00              NOP      
00000e  a337              ADR      r3,|L18.236|
000010  f44f72b3          MOV      r2,#0x166
000014  a13b              ADR      r1,|L18.260|
000016  a044              ADR      r0,|L18.296|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
00001e  2000              MOVS     r0,#0
                  |L18.32|
;;;359    
;;;360      /* already listening? */
;;;361      if (pcb->state == LISTEN) {
;;;362        return pcb;
;;;363      }
;;;364      lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;365      if (lpcb == NULL) {
;;;366        return NULL;
;;;367      }
;;;368      lpcb->callback_arg = pcb->callback_arg;
;;;369      lpcb->local_port = pcb->local_port;
;;;370      lpcb->state = LISTEN;
;;;371      lpcb->so_options = pcb->so_options;
;;;372      lpcb->so_options |= SOF_ACCEPTCONN;
;;;373      lpcb->ttl = pcb->ttl;
;;;374      lpcb->tos = pcb->tos;
;;;375      ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
;;;376      TCP_RMV(&tcp_bound_pcbs, pcb);
;;;377      memp_free(MEMP_TCP_PCB, pcb);
;;;378    #if LWIP_CALLBACK_API
;;;379      lpcb->accept = tcp_accept_null;
;;;380    #endif /* LWIP_CALLBACK_API */
;;;381    #if TCP_LISTEN_BACKLOG
;;;382      lpcb->accepts_pending = 0;
;;;383      lpcb->backlog = (backlog ? backlog : 1);
;;;384    #endif /* TCP_LISTEN_BACKLOG */
;;;385      TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
;;;386      return (struct tcp_pcb *)lpcb;
;;;387    }
000020  bd70              POP      {r4-r6,pc}
                  |L18.34|
000022  bf00              NOP                            ;358
000024  7c28              LDRB     r0,[r5,#0x10]         ;361
000026  2801              CMP      r0,#1                 ;361
000028  d101              BNE      |L18.46|
00002a  4628              MOV      r0,r5                 ;362
00002c  e7f8              B        |L18.32|
                  |L18.46|
00002e  2003              MOVS     r0,#3                 ;364
000030  f7fffffe          BL       memp_malloc
000034  4604              MOV      r4,r0                 ;364
000036  b90c              CBNZ     r4,|L18.60|
000038  2000              MOVS     r0,#0                 ;366
00003a  e7f1              B        |L18.32|
                  |L18.60|
00003c  6968              LDR      r0,[r5,#0x14]         ;368
00003e  6160              STR      r0,[r4,#0x14]         ;368
000040  8b28              LDRH     r0,[r5,#0x18]         ;369
000042  8320              STRH     r0,[r4,#0x18]         ;369
000044  2001              MOVS     r0,#1                 ;370
000046  7420              STRB     r0,[r4,#0x10]         ;370
000048  8928              LDRH     r0,[r5,#8]            ;371
00004a  8120              STRH     r0,[r4,#8]            ;371
00004c  8920              LDRH     r0,[r4,#8]            ;372
00004e  f0400002          ORR      r0,r0,#2              ;372
000052  8120              STRH     r0,[r4,#8]            ;372
000054  7ae8              LDRB     r0,[r5,#0xb]          ;373
000056  72e0              STRB     r0,[r4,#0xb]          ;373
000058  7aa8              LDRB     r0,[r5,#0xa]          ;374
00005a  72a0              STRB     r0,[r4,#0xa]          ;374
00005c  b90d              CBNZ     r5,|L18.98|
00005e  2000              MOVS     r0,#0                 ;375
000060  e000              B        |L18.100|
                  |L18.98|
000062  6828              LDR      r0,[r5,#0]            ;375
                  |L18.100|
000064  6020              STR      r0,[r4,#0]            ;375
000066  bf00              NOP                            ;376
000068  4839              LDR      r0,|L18.336|
00006a  6800              LDR      r0,[r0,#0]            ;376  ; tcp_bound_pcbs
00006c  42a8              CMP      r0,r5                 ;376
00006e  d105              BNE      |L18.124|
000070  4837              LDR      r0,|L18.336|
000072  6800              LDR      r0,[r0,#0]            ;376  ; tcp_bound_pcbs
000074  68c0              LDR      r0,[r0,#0xc]          ;376
000076  4936              LDR      r1,|L18.336|
000078  6008              STR      r0,[r1,#0]            ;376  ; tcp_bound_pcbs
00007a  e01c              B        |L18.182|
                  |L18.124|
00007c  4834              LDR      r0,|L18.336|
00007e  6800              LDR      r0,[r0,#0]            ;376  ; tcp_bound_pcbs
000080  4934              LDR      r1,|L18.340|
000082  6008              STR      r0,[r1,#0]            ;376  ; tcp_tmp_pcb
000084  e012              B        |L18.172|
                  |L18.134|
000086  4833              LDR      r0,|L18.340|
000088  6800              LDR      r0,[r0,#0]            ;376  ; tcp_tmp_pcb
00008a  68c0              LDR      r0,[r0,#0xc]          ;376
00008c  b148              CBZ      r0,|L18.162|
00008e  4831              LDR      r0,|L18.340|
000090  6800              LDR      r0,[r0,#0]            ;376  ; tcp_tmp_pcb
000092  68c0              LDR      r0,[r0,#0xc]          ;376
000094  42a8              CMP      r0,r5                 ;376
000096  d104              BNE      |L18.162|
000098  492e              LDR      r1,|L18.340|
00009a  68e8              LDR      r0,[r5,#0xc]          ;376
00009c  6809              LDR      r1,[r1,#0]            ;376  ; tcp_tmp_pcb
00009e  60c8              STR      r0,[r1,#0xc]          ;376
0000a0  e008              B        |L18.180|
                  |L18.162|
0000a2  482c              LDR      r0,|L18.340|
0000a4  6800              LDR      r0,[r0,#0]            ;376  ; tcp_tmp_pcb
0000a6  68c0              LDR      r0,[r0,#0xc]          ;376
0000a8  492a              LDR      r1,|L18.340|
0000aa  6008              STR      r0,[r1,#0]            ;376  ; tcp_tmp_pcb
                  |L18.172|
0000ac  4829              LDR      r0,|L18.340|
0000ae  6800              LDR      r0,[r0,#0]            ;376  ; tcp_tmp_pcb
0000b0  2800              CMP      r0,#0                 ;376
0000b2  d1e8              BNE      |L18.134|
                  |L18.180|
0000b4  bf00              NOP                            ;376
                  |L18.182|
0000b6  2000              MOVS     r0,#0                 ;376
0000b8  60e8              STR      r0,[r5,#0xc]          ;376
0000ba  bf00              NOP                            ;376
0000bc  4629              MOV      r1,r5                 ;377
0000be  2002              MOVS     r0,#2                 ;377
0000c0  f7fffffe          BL       memp_free
0000c4  4824              LDR      r0,|L18.344|
0000c6  61e0              STR      r0,[r4,#0x1c]         ;379
0000c8  2000              MOVS     r0,#0                 ;382
0000ca  f8840021          STRB     r0,[r4,#0x21]         ;382
0000ce  b10e              CBZ      r6,|L18.212|
0000d0  4630              MOV      r0,r6                 ;383
0000d2  e000              B        |L18.214|
                  |L18.212|
0000d4  2001              MOVS     r0,#1                 ;383
                  |L18.214|
0000d6  f8840020          STRB     r0,[r4,#0x20]         ;383
0000da  bf00              NOP                            ;385
0000dc  481f              LDR      r0,|L18.348|
0000de  6800              LDR      r0,[r0,#0]            ;385  ; tcp_listen_pcbs
0000e0  60e0              STR      r0,[r4,#0xc]          ;385
0000e2  481e              LDR      r0,|L18.348|
0000e4  6004              STR      r4,[r0,#0]            ;385  ; tcp_listen_pcbs
0000e6  bf00              NOP                            ;385
0000e8  4620              MOV      r0,r4                 ;386
0000ea  e799              B        |L18.32|
;;;388    
                          ENDP

                  |L18.236|
0000ec  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\tcp.c",0
0000f0  7749505c
0000f4  7372635c
0000f8  636f7265
0000fc  5c746370
000100  2e6300  
000103  00                DCB      0
                  |L18.260|
000104  7463705f          DCB      "tcp_listen: pcb already connected",0
000108  6c697374
00010c  656e3a20
000110  70636220
000114  616c7265
000118  61647920
00011c  636f6e6e
000120  65637465
000124  6400    
000126  00                DCB      0
000127  00                DCB      0
                  |L18.296|
000128  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00012c  7274696f
000130  6e202225
000134  73222066
000138  61696c65
00013c  64206174
000140  206c696e
000144  65202564
000148  20696e20
00014c  25730a00
                  |L18.336|
                          DCD      tcp_bound_pcbs
                  |L18.340|
                          DCD      tcp_tmp_pcb
                  |L18.344|
                          DCD      tcp_accept_null
                  |L18.348|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1058   struct tcp_pcb *
;;;1059   tcp_new(void)
000000  b510              PUSH     {r4,lr}
;;;1060   {
;;;1061     return tcp_alloc(TCP_PRIO_NORMAL);
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       tcp_alloc
;;;1062   }
000008  bd10              POP      {r4,pc}
;;;1063   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;455    static u16_t
;;;456    tcp_new_port(void)
000000  bf00              NOP      
                  |L20.2|
;;;457    {
;;;458      struct tcp_pcb *pcb;
;;;459    #ifndef TCP_LOCAL_PORT_RANGE_START
;;;460    #define TCP_LOCAL_PORT_RANGE_START 4096
;;;461    #define TCP_LOCAL_PORT_RANGE_END   0x7fff
;;;462    #endif
;;;463      static u16_t port = TCP_LOCAL_PORT_RANGE_START;
;;;464      
;;;465     again:
;;;466      if (++port > TCP_LOCAL_PORT_RANGE_END) {
000002  4819              LDR      r0,|L20.104|
000004  8800              LDRH     r0,[r0,#0]  ; port
000006  1c40              ADDS     r0,r0,#1
000008  b280              UXTH     r0,r0
00000a  4a17              LDR      r2,|L20.104|
00000c  8010              STRH     r0,[r2,#0]
00000e  f5b04f00          CMP      r0,#0x8000
000012  db02              BLT      |L20.26|
;;;467        port = TCP_LOCAL_PORT_RANGE_START;
000014  f44f5080          MOV      r0,#0x1000
000018  8010              STRH     r0,[r2,#0]
                  |L20.26|
;;;468      }
;;;469      
;;;470      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
00001a  4814              LDR      r0,|L20.108|
00001c  6801              LDR      r1,[r0,#0]  ; tcp_active_pcbs
00001e  e006              B        |L20.46|
                  |L20.32|
;;;471        if (pcb->local_port == port) {
000020  8b08              LDRH     r0,[r1,#0x18]
000022  4a11              LDR      r2,|L20.104|
000024  8812              LDRH     r2,[r2,#0]  ; port
000026  4290              CMP      r0,r2
000028  d100              BNE      |L20.44|
;;;472          goto again;
00002a  e7ea              B        |L20.2|
                  |L20.44|
00002c  68c9              LDR      r1,[r1,#0xc]          ;470
                  |L20.46|
00002e  2900              CMP      r1,#0                 ;470
000030  d1f6              BNE      |L20.32|
;;;473        }
;;;474      }
;;;475      for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000032  480f              LDR      r0,|L20.112|
000034  6801              LDR      r1,[r0,#0]  ; tcp_tw_pcbs
000036  e006              B        |L20.70|
                  |L20.56|
;;;476        if (pcb->local_port == port) {
000038  8b08              LDRH     r0,[r1,#0x18]
00003a  4a0b              LDR      r2,|L20.104|
00003c  8812              LDRH     r2,[r2,#0]  ; port
00003e  4290              CMP      r0,r2
000040  d100              BNE      |L20.68|
;;;477          goto again;
000042  e7de              B        |L20.2|
                  |L20.68|
000044  68c9              LDR      r1,[r1,#0xc]          ;475
                  |L20.70|
000046  2900              CMP      r1,#0                 ;475
000048  d1f6              BNE      |L20.56|
;;;478        }
;;;479      }
;;;480      for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
00004a  480a              LDR      r0,|L20.116|
00004c  6801              LDR      r1,[r0,#0]  ; tcp_listen_pcbs
00004e  e006              B        |L20.94|
                  |L20.80|
;;;481        if (pcb->local_port == port) {
000050  8b08              LDRH     r0,[r1,#0x18]
000052  4a05              LDR      r2,|L20.104|
000054  8812              LDRH     r2,[r2,#0]  ; port
000056  4290              CMP      r0,r2
000058  d100              BNE      |L20.92|
;;;482          goto again;
00005a  e7d2              B        |L20.2|
                  |L20.92|
00005c  68c9              LDR      r1,[r1,#0xc]          ;480
                  |L20.94|
00005e  2900              CMP      r1,#0                 ;480
000060  d1f6              BNE      |L20.80|
;;;483        }
;;;484      }
;;;485      return port;
000062  4801              LDR      r0,|L20.104|
000064  8800              LDRH     r0,[r0,#0]  ; port
;;;486    }
000066  4770              BX       lr
;;;487    
                          ENDP

                  |L20.104|
                          DCD      port
                  |L20.108|
                          DCD      tcp_active_pcbs
                  |L20.112|
                          DCD      tcp_tw_pcbs
                  |L20.116|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1260   u32_t
;;;1261   tcp_next_iss(void)
000000  4804              LDR      r0,|L21.20|
;;;1262   {
;;;1263     static u32_t iss = 6510;
;;;1264     
;;;1265     iss += tcp_ticks;       /* XXX */
000002  6800              LDR      r0,[r0,#0]  ; iss
000004  4904              LDR      r1,|L21.24|
000006  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000008  4408              ADD      r0,r0,r1
00000a  4902              LDR      r1,|L21.20|
00000c  6008              STR      r0,[r1,#0]  ; iss
;;;1266     return iss;
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]  ; iss
;;;1267   }
000012  4770              BX       lr
;;;1268   
                          ENDP

                  |L21.20|
                          DCD      iss
                  |L21.24|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  tcp_pcb_purge PROC
;;;1160   void
;;;1161   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1162   {
000002  4604              MOV      r4,r0
;;;1163     if (pcb->state != CLOSED &&
000004  7c20              LDRB     r0,[r4,#0x10]
000006  b3f0              CBZ      r0,|L22.134|
;;;1164        pcb->state != TIME_WAIT &&
000008  7c20              LDRB     r0,[r4,#0x10]
00000a  280a              CMP      r0,#0xa
00000c  d059              BEQ      |L22.194|
;;;1165        pcb->state != LISTEN) {
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  2801              CMP      r0,#1
000012  d056              BEQ      |L22.194|
;;;1166   
;;;1167       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
000014  bf00              NOP      
000016  bf00              NOP      
000018  a02a              ADR      r0,|L22.196|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
000020  bf00              NOP      
;;;1168   
;;;1169   #if TCP_LISTEN_BACKLOG
;;;1170       if (pcb->state == SYN_RCVD) {
000022  7c20              LDRB     r0,[r4,#0x10]
000024  2803              CMP      r0,#3
000026  d121              BNE      |L22.108|
;;;1171         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1172         struct tcp_pcb_listen *lpcb;
;;;1173         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1174         tcp_listen_pcbs.listen_pcbs != NULL);
;;;1175         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
000028  482a              LDR      r0,|L22.212|
00002a  6805              LDR      r5,[r0,#0]  ; tcp_listen_pcbs
00002c  e01a              B        |L22.100|
                  |L22.46|
;;;1176           if ((lpcb->local_port == pcb->local_port) &&
00002e  8b28              LDRH     r0,[r5,#0x18]
000030  8b21              LDRH     r1,[r4,#0x18]
000032  4288              CMP      r0,r1
000034  d115              BNE      |L22.98|
;;;1177               	(ip_addr_isany(&lpcb->local_ip) ||
000036  b12d              CBZ      r5,|L22.68|
000038  6828              LDR      r0,[r5,#0]
00003a  b118              CBZ      r0,|L22.68|
;;;1178                		ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
00003c  6820              LDR      r0,[r4,#0]
00003e  6829              LDR      r1,[r5,#0]
000040  4288              CMP      r0,r1
000042  d10e              BNE      |L22.98|
                  |L22.68|
;;;1179                /* port and address of the listen pcb match the timed-out pcb */
;;;1180                LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1181                			lpcb->accepts_pending > 0);
;;;1182                lpcb->accepts_pending--;
000044  f8950021          LDRB     r0,[r5,#0x21]
000048  1e40              SUBS     r0,r0,#1
00004a  f8850021          STRB     r0,[r5,#0x21]
;;;1183   			 LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: lpcb->accepts_pending-- %"U16_F"\n", lpcb->accepts_pending));
00004e  bf00              NOP      
000050  bf00              NOP      
000052  f8951021          LDRB     r1,[r5,#0x21]
000056  a020              ADR      r0,|L22.216|
000058  f7fffffe          BL       __2printf
00005c  bf00              NOP      
00005e  bf00              NOP      
;;;1184   			 
;;;1185                break;
000060  e002              B        |L22.104|
                  |L22.98|
000062  68ed              LDR      r5,[r5,#0xc]          ;1175
                  |L22.100|
000064  2d00              CMP      r5,#0                 ;1175
000066  d1e2              BNE      |L22.46|
                  |L22.104|
000068  bf00              NOP      
;;;1186             }
;;;1187         }
;;;1188       }
00006a  bf00              NOP      
                  |L22.108|
;;;1189   #endif /* TCP_LISTEN_BACKLOG */
;;;1190   
;;;1191   
;;;1192       if (pcb->refused_data != NULL) {
00006c  6fe0              LDR      r0,[r4,#0x7c]
00006e  b168              CBZ      r0,|L22.140|
;;;1193         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
000070  bf00              NOP      
000072  bf00              NOP      
000074  a023              ADR      r0,|L22.260|
000076  f7fffffe          BL       __2printf
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;1194         pbuf_free(pcb->refused_data);
00007e  6fe0              LDR      r0,[r4,#0x7c]
000080  f7fffffe          BL       pbuf_free
;;;1195         pcb->refused_data = NULL;
000084  e000              B        |L22.136|
                  |L22.134|
000086  e01c              B        |L22.194|
                  |L22.136|
000088  2000              MOVS     r0,#0
00008a  67e0              STR      r0,[r4,#0x7c]
                  |L22.140|
;;;1196       }
;;;1197       if (pcb->unsent != NULL) {
00008c  6f60              LDR      r0,[r4,#0x74]
00008e  b130              CBZ      r0,|L22.158|
;;;1198         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
000090  bf00              NOP      
000092  bf00              NOP      
000094  a026              ADR      r0,|L22.304|
000096  f7fffffe          BL       __2printf
00009a  bf00              NOP      
00009c  bf00              NOP      
                  |L22.158|
;;;1199       }
;;;1200       if (pcb->unacked != NULL) {
00009e  6fa0              LDR      r0,[r4,#0x78]
0000a0  b130              CBZ      r0,|L22.176|
;;;1201         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
0000a2  bf00              NOP      
0000a4  bf00              NOP      
0000a6  a02b              ADR      r0,|L22.340|
0000a8  f7fffffe          BL       __2printf
0000ac  bf00              NOP      
0000ae  bf00              NOP      
                  |L22.176|
;;;1202       }
;;;1203   #if TCP_QUEUE_OOSEQ /* LW */
;;;1204       if (pcb->ooseq != NULL) {
;;;1205         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1206       }
;;;1207   
;;;1208       /* Stop the retransmission timer as it will expect data on unacked
;;;1209          queue if it fires */
;;;1210       pcb->rtime = -1;
;;;1211   
;;;1212       tcp_segs_free(pcb->ooseq);
;;;1213       pcb->ooseq = NULL;
;;;1214   #endif /* TCP_QUEUE_OOSEQ */
;;;1215       tcp_segs_free(pcb->unsent);
0000b0  6f60              LDR      r0,[r4,#0x74]
0000b2  f7fffffe          BL       tcp_segs_free
;;;1216       tcp_segs_free(pcb->unacked);
0000b6  6fa0              LDR      r0,[r4,#0x78]
0000b8  f7fffffe          BL       tcp_segs_free
;;;1217       pcb->unacked = pcb->unsent = NULL;
0000bc  2000              MOVS     r0,#0
0000be  6760              STR      r0,[r4,#0x74]
0000c0  67a0              STR      r0,[r4,#0x78]
                  |L22.194|
;;;1218     }
;;;1219   }
0000c2  bd70              POP      {r4-r6,pc}
;;;1220   
                          ENDP

                  |L22.196|
0000c4  7463705f          DCB      "tcp_pcb_purge\n",0
0000c8  7063625f
0000cc  70757267
0000d0  650a00  
0000d3  00                DCB      0
                  |L22.212|
                          DCD      tcp_listen_pcbs
                  |L22.216|
0000d8  7463705f          DCB      "tcp_pcb_purge: lpcb->accepts_pending-- %4d\n",0
0000dc  7063625f
0000e0  70757267
0000e4  653a206c
0000e8  7063622d
0000ec  3e616363
0000f0  65707473
0000f4  5f70656e
0000f8  64696e67
0000fc  2d2d2025
000100  34640a00
                  |L22.260|
000104  7463705f          DCB      "tcp_pcb_purge: data left on ->refused_data\n",0
000108  7063625f
00010c  70757267
000110  653a2064
000114  61746120
000118  6c656674
00011c  206f6e20
000120  2d3e7265
000124  66757365
000128  645f6461
00012c  74610a00
                  |L22.304|
000130  7463705f          DCB      "tcp_pcb_purge: not all data sent\n",0
000134  7063625f
000138  70757267
00013c  653a206e
000140  6f742061
000144  6c6c2064
000148  61746120
00014c  73656e74
000150  0a00    
000152  00                DCB      0
000153  00                DCB      0
                  |L22.340|
000154  7463705f          DCB      "tcp_pcb_purge: data left on ->unacked\n",0
000158  7063625f
00015c  70757267
000160  653a2064
000164  61746120
000168  6c656674
00016c  206f6e20
000170  2d3e756e
000174  61636b65
000178  640a00  
00017b  00                DCB      0

                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                  tcp_pcb_remove PROC
;;;1227   void
;;;1228   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1229   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1230     TCP_RMV(pcblist, pcb);
000006  bf00              NOP      
000008  6828              LDR      r0,[r5,#0]
00000a  42a0              CMP      r0,r4
00000c  d103              BNE      |L23.22|
00000e  6828              LDR      r0,[r5,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  6028              STR      r0,[r5,#0]
000014  e01b              B        |L23.78|
                  |L23.22|
000016  491c              LDR      r1,|L23.136|
000018  6828              LDR      r0,[r5,#0]
00001a  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
00001c  e012              B        |L23.68|
                  |L23.30|
00001e  481a              LDR      r0,|L23.136|
000020  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000022  68c0              LDR      r0,[r0,#0xc]
000024  b148              CBZ      r0,|L23.58|
000026  4818              LDR      r0,|L23.136|
000028  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  42a0              CMP      r0,r4
00002e  d104              BNE      |L23.58|
000030  4915              LDR      r1,|L23.136|
000032  68e0              LDR      r0,[r4,#0xc]
000034  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
000036  60c8              STR      r0,[r1,#0xc]
000038  e008              B        |L23.76|
                  |L23.58|
00003a  4813              LDR      r0,|L23.136|
00003c  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00003e  68c0              LDR      r0,[r0,#0xc]
000040  4911              LDR      r1,|L23.136|
000042  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L23.68|
000044  4810              LDR      r0,|L23.136|
000046  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000048  2800              CMP      r0,#0
00004a  d1e8              BNE      |L23.30|
                  |L23.76|
00004c  bf00              NOP      
                  |L23.78|
00004e  2000              MOVS     r0,#0
000050  60e0              STR      r0,[r4,#0xc]
000052  bf00              NOP      
;;;1231   
;;;1232     tcp_pcb_purge(pcb);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       tcp_pcb_purge
;;;1233     
;;;1234     /* if there is an outstanding delayed ACKs, send it */
;;;1235     if (pcb->state != TIME_WAIT &&
00005a  7c20              LDRB     r0,[r4,#0x10]
00005c  280a              CMP      r0,#0xa
00005e  d010              BEQ      |L23.130|
;;;1236        pcb->state != LISTEN &&
000060  7c20              LDRB     r0,[r4,#0x10]
000062  2801              CMP      r0,#1
000064  d00d              BEQ      |L23.130|
;;;1237        pcb->flags & TF_ACK_DELAY) {
000066  f8940022          LDRB     r0,[r4,#0x22]
00006a  f0100f01          TST      r0,#1
00006e  d008              BEQ      |L23.130|
;;;1238       pcb->flags |= TF_ACK_NOW;
000070  f8940022          LDRB     r0,[r4,#0x22]
000074  f0400002          ORR      r0,r0,#2
000078  f8840022          STRB     r0,[r4,#0x22]
;;;1239       tcp_output(pcb);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       tcp_output
                  |L23.130|
;;;1240     }
;;;1241   
;;;1242     if (pcb->state != LISTEN) {
;;;1243       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
;;;1244       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
;;;1245   #if TCP_QUEUE_OOSEQ
;;;1246       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
;;;1247   #endif /* TCP_QUEUE_OOSEQ */
;;;1248     }
;;;1249   
;;;1250     pcb->state = CLOSED;
000082  2000              MOVS     r0,#0
000084  7420              STRB     r0,[r4,#0x10]
;;;1251   
;;;1252     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;1253   }
000086  bd70              POP      {r4-r6,pc}
;;;1254   
                          ENDP

                  |L23.136|
                          DCD      tcp_tmp_pcb

                          AREA ||i.tcp_pcbs_sane||, CODE, READONLY, ALIGN=2

                  tcp_pcbs_sane PROC
;;;1446   s16_t
;;;1447   tcp_pcbs_sane(void)
000000  4806              LDR      r0,|L24.28|
;;;1448   {
;;;1449     struct tcp_pcb *pcb;
;;;1450     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000002  6801              LDR      r1,[r0,#0]  ; tcp_active_pcbs
000004  e000              B        |L24.8|
                  |L24.6|
000006  68c9              LDR      r1,[r1,#0xc]
                  |L24.8|
000008  2900              CMP      r1,#0
00000a  d1fc              BNE      |L24.6|
;;;1451       LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != CLOSED", pcb->state != CLOSED);
;;;1452       LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != LISTEN", pcb->state != LISTEN);
;;;1453       LWIP_ASSERT("tcp_pcbs_sane: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
;;;1454     }
;;;1455     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
00000c  4804              LDR      r0,|L24.32|
00000e  6801              LDR      r1,[r0,#0]  ; tcp_tw_pcbs
000010  e000              B        |L24.20|
                  |L24.18|
000012  68c9              LDR      r1,[r1,#0xc]
                  |L24.20|
000014  2900              CMP      r1,#0
000016  d1fc              BNE      |L24.18|
;;;1456       LWIP_ASSERT("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
;;;1457     }
;;;1458     return 1;
000018  2001              MOVS     r0,#1
;;;1459   }
00001a  4770              BX       lr
;;;1460   #endif /* TCP_DEBUG */
                          ENDP

                  |L24.28|
                          DCD      tcp_active_pcbs
                  |L24.32|
                          DCD      tcp_tw_pcbs

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=1

                  tcp_poll PROC
;;;1144   void
;;;1145   tcp_poll(struct tcp_pcb *pcb,
000000  f8c0108c          STR      r1,[r0,#0x8c]
;;;1146      err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
;;;1147   {
;;;1148   #if LWIP_CALLBACK_API
;;;1149     pcb->poll = poll;
;;;1150   #endif /* LWIP_CALLBACK_API */  
;;;1151     pcb->pollinterval = interval;
000004  f8802035          STRB     r2,[r0,#0x35]
;;;1152   }
000008  4770              BX       lr
;;;1153   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=1

                  tcp_recv PROC
;;;1085   void
;;;1086   tcp_recv(struct tcp_pcb *pcb,
000000  f8c01084          STR      r1,[r0,#0x84]
;;;1087      err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
;;;1088   {
;;;1089     pcb->recv = recv;
;;;1090   }
000004  4770              BX       lr
;;;1091   
                          ENDP


                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=1

                  tcp_recv_null PROC
;;;904    static err_t
;;;905    tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;906    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;907      arg = arg;
00000c  bf00              NOP      
;;;908      if (p != NULL) {
00000e  b11c              CBZ      r4,|L27.24|
;;;909        pbuf_free(p);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       pbuf_free
000016  e005              B        |L27.36|
                  |L27.24|
;;;910      } else if (err == ERR_OK) {
000018  b926              CBNZ     r6,|L27.36|
;;;911        return tcp_close(pcb);
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       tcp_close
                  |L27.32|
;;;912      }
;;;913      return ERR_OK;
;;;914    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L27.36|
000024  2000              MOVS     r0,#0                 ;913
000026  e7fb              B        |L27.32|
;;;915    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  tcp_recved PROC
;;;424    void
;;;425    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;426    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;427      int wnd_inflation;
;;;428    
;;;429      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
;;;430                  len <= 0xffff - pcb->rcv_wnd );
;;;431    
;;;432      pcb->rcv_wnd += len;
000006  8d20              LDRH     r0,[r4,#0x28]
000008  4430              ADD      r0,r0,r6
00000a  8520              STRH     r0,[r4,#0x28]
;;;433      if (pcb->rcv_wnd > TCP_WND)
00000c  8d20              LDRH     r0,[r4,#0x28]
00000e  f6403168          MOV      r1,#0xb68
000012  4288              CMP      r0,r1
000014  dd01              BLE      |L28.26|
;;;434        pcb->rcv_wnd = TCP_WND;
000016  4608              MOV      r0,r1
000018  8520              STRH     r0,[r4,#0x28]
                  |L28.26|
;;;435    
;;;436      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       tcp_update_rcv_ann_wnd
000020  4605              MOV      r5,r0
;;;437    
;;;438      /* If the change in the right edge of window is significant (default
;;;439       * watermark is TCP_WND/2), then send an explicit update now.
;;;440       * Otherwise wait for a packet to be sent in the normal course of
;;;441       * events (or more window to be available later) */
;;;442      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
000022  f24020da          MOV      r0,#0x2da
000026  4285              CMP      r5,r0
000028  db0a              BLT      |L28.64|
;;;443        tcp_ack_now(pcb);
00002a  bf00              NOP      
00002c  f8940022          LDRB     r0,[r4,#0x22]
000030  f0400002          ORR      r0,r0,#2
000034  f8840022          STRB     r0,[r4,#0x22]
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       tcp_output
00003e  bf00              NOP      
                  |L28.64|
;;;444    
;;;445      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
000040  bf00              NOP      
000042  bf00              NOP      
000044  8d20              LDRH     r0,[r4,#0x28]
000046  f6403168          MOV      r1,#0xb68
00004a  1a0b              SUBS     r3,r1,r0
00004c  4602              MOV      r2,r0
00004e  4631              MOV      r1,r6
000050  a002              ADR      r0,|L28.92|
000052  f7fffffe          BL       __2printf
000056  bf00              NOP      
000058  bf00              NOP      
;;;446             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;447    }
00005a  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  |L28.92|
00005c  7463705f          DCB      "tcp_recved: recveived %4d bytes, wnd %4d (%4d).\n",0
000060  72656376
000064  65643a20
000068  72656376
00006c  65697665
000070  64202534
000074  64206279
000078  7465732c
00007c  20776e64
000080  20253464
000084  20282534
000088  64292e0a
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;847    u8_t
;;;848    tcp_seg_free(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;849    {
000002  4604              MOV      r4,r0
;;;850      u8_t count = 0;
000004  2500              MOVS     r5,#0
;;;851      
;;;852      if (seg != NULL) {
000006  b15c              CBZ      r4,|L29.32|
;;;853        if (seg->p != NULL) {
000008  6860              LDR      r0,[r4,#4]
00000a  b128              CBZ      r0,|L29.24|
;;;854          count = pbuf_free(seg->p);
00000c  6860              LDR      r0,[r4,#4]
00000e  f7fffffe          BL       pbuf_free
000012  4605              MOV      r5,r0
;;;855    #if TCP_DEBUG
;;;856          seg->p = NULL;
000014  2000              MOVS     r0,#0
000016  6060              STR      r0,[r4,#4]
                  |L29.24|
;;;857    #endif /* TCP_DEBUG */
;;;858        }
;;;859        memp_free(MEMP_TCP_SEG, seg);
000018  4621              MOV      r1,r4
00001a  2004              MOVS     r0,#4
00001c  f7fffffe          BL       memp_free
                  |L29.32|
;;;860      }
;;;861      return count;
000020  4628              MOV      r0,r5
;;;862    }
000022  bd70              POP      {r4-r6,pc}
;;;863    
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;828    u8_t
;;;829    tcp_segs_free(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;830    {
000002  4604              MOV      r4,r0
;;;831      u8_t count = 0;
000004  2500              MOVS     r5,#0
;;;832      struct tcp_seg *next;
;;;833      while (seg != NULL) {
000006  e006              B        |L30.22|
                  |L30.8|
;;;834        next = seg->next;
000008  6826              LDR      r6,[r4,#0]
;;;835        count += tcp_seg_free(seg);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       tcp_seg_free
000010  4428              ADD      r0,r0,r5
000012  b2c5              UXTB     r5,r0
;;;836        seg = next;
000014  4634              MOV      r4,r6
                  |L30.22|
000016  2c00              CMP      r4,#0                 ;833
000018  d1f6              BNE      |L30.8|
;;;837      }
;;;838      return count;
00001a  4628              MOV      r0,r5
;;;839    }
00001c  bd70              POP      {r4-r6,pc}
;;;840    
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=1

                  tcp_sent PROC
;;;1099   void
;;;1100   tcp_sent(struct tcp_pcb *pcb,
000000  f8c01080          STR      r1,[r0,#0x80]
;;;1101      err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
;;;1102   {
;;;1103     pcb->sent = sent;
;;;1104   }
000004  4770              BX       lr
;;;1105   
                          ENDP


                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=1

                  tcp_setprio PROC
;;;870    void
;;;871    tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  7441              STRB     r1,[r0,#0x11]
;;;872    {
;;;873      pcb->prio = prio;
;;;874    }
000002  4770              BX       lr
;;;875    #if TCP_QUEUE_OOSEQ
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  tcp_slowtmr PROC
;;;563    void
;;;564    tcp_slowtmr(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;565    {
;;;566      struct tcp_pcb *pcb, *pcb2, *prev;
;;;567      u16_t eff_wnd;
;;;568      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;569      err_t err;
;;;570    
;;;571      err = ERR_OK;
000004  2000              MOVS     r0,#0
000006  9002              STR      r0,[sp,#8]
;;;572    
;;;573      ++tcp_ticks;
000008  48d7              LDR      r0,|L33.872|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_ticks
00000c  1c40              ADDS     r0,r0,#1
00000e  49d6              LDR      r1,|L33.872|
000010  6008              STR      r0,[r1,#0]  ; tcp_ticks
;;;574    
;;;575      /* Steps through all of the active PCBs. */
;;;576      prev = NULL;
000012  2600              MOVS     r6,#0
;;;577      pcb = tcp_active_pcbs;
000014  48d5              LDR      r0,|L33.876|
000016  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;578      if (pcb == NULL) {
000018  b934              CBNZ     r4,|L33.40|
;;;579        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  a0d4              ADR      r0,|L33.880|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP      
000026  bf00              NOP      
                  |L33.40|
;;;580      }
;;;581      while (pcb != NULL) {
000028  e175              B        |L33.790|
                  |L33.42|
;;;582        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  a0d8              ADR      r0,|L33.912|
000030  f7fffffe          BL       __2printf
000034  bf00              NOP      
000036  bf00              NOP      
;;;583        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
;;;584        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
;;;585        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
;;;586    
;;;587        pcb_remove = 0;
000038  2500              MOVS     r5,#0
;;;588    
;;;589        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
00003a  7c20              LDRB     r0,[r4,#0x10]
00003c  2802              CMP      r0,#2
00003e  d10c              BNE      |L33.90|
000040  f894004a          LDRB     r0,[r4,#0x4a]
000044  2806              CMP      r0,#6
000046  d108              BNE      |L33.90|
;;;590          ++pcb_remove;
000048  1c68              ADDS     r0,r5,#1
00004a  b2c5              UXTB     r5,r0
;;;591          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
00004c  bf00              NOP      
00004e  bf00              NOP      
000050  a0d8              ADR      r0,|L33.948|
000052  f7fffffe          BL       __2printf
000056  bf00              NOP      
000058  e08a              B        |L33.368|
                  |L33.90|
;;;592        }
;;;593        else if (pcb->nrtx == TCP_MAXRTX) {
00005a  f894004a          LDRB     r0,[r4,#0x4a]
00005e  280c              CMP      r0,#0xc
000060  d108              BNE      |L33.116|
;;;594          ++pcb_remove;
000062  1c68              ADDS     r0,r5,#1
000064  b2c5              UXTB     r5,r0
;;;595          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
000066  bf00              NOP      
000068  bf00              NOP      
00006a  a0dc              ADR      r0,|L33.988|
00006c  f7fffffe          BL       __2printf
000070  bf00              NOP      
000072  e07d              B        |L33.368|
                  |L33.116|
;;;596        } else {
;;;597          if (pcb->persist_backoff > 0) {
000074  f894009c          LDRB     r0,[r4,#0x9c]
000078  2800              CMP      r0,#0
00007a  dd1d              BLE      |L33.184|
;;;598            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;599             * instead of using the standard retransmission mechanism. */
;;;600            pcb->persist_cnt++;
00007c  f8540f98          LDR      r0,[r4,#0x98]!
000080  1c40              ADDS     r0,r0,#1
000082  6020              STR      r0,[r4,#0]
;;;601            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
000084  7920              LDRB     r0,[r4,#4]
000086  6821              LDR      r1,[r4,#0]
000088  f1a40498          SUB      r4,r4,#0x98
00008c  f1a00001          SUB      r0,r0,#1
000090  4adc              LDR      r2,|L33.1028|
000092  5c10              LDRB     r0,[r2,r0]
000094  4281              CMP      r1,r0
000096  d36b              BCC      |L33.368|
;;;602              pcb->persist_cnt = 0;
000098  2000              MOVS     r0,#0
00009a  f8c40098          STR      r0,[r4,#0x98]
;;;603              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
00009e  f894009c          LDRB     r0,[r4,#0x9c]
0000a2  2807              CMP      r0,#7
0000a4  d204              BCS      |L33.176|
;;;604                pcb->persist_backoff++;
0000a6  f894009c          LDRB     r0,[r4,#0x9c]
0000aa  1c40              ADDS     r0,r0,#1
0000ac  f884009c          STRB     r0,[r4,#0x9c]
                  |L33.176|
;;;605              }
;;;606              tcp_zero_window_probe(pcb);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       tcp_zero_window_probe
0000b6  e05b              B        |L33.368|
                  |L33.184|
;;;607            }
;;;608          } else {
;;;609            /* Increase the retransmission timer if it is running */
;;;610            if(pcb->rtime >= 0)
0000b8  f9b40036          LDRSH    r0,[r4,#0x36]
0000bc  2800              CMP      r0,#0
0000be  db03              BLT      |L33.200|
;;;611              ++pcb->rtime;
0000c0  8ee0              LDRH     r0,[r4,#0x36]
0000c2  1c40              ADDS     r0,r0,#1
0000c4  b200              SXTH     r0,r0
0000c6  86e0              STRH     r0,[r4,#0x36]
                  |L33.200|
;;;612    
;;;613            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
0000c8  6fa0              LDR      r0,[r4,#0x78]
0000ca  b3e8              CBZ      r0,|L33.328|
0000cc  f9b40036          LDRSH    r0,[r4,#0x36]
0000d0  f9b41048          LDRSH    r1,[r4,#0x48]
0000d4  4288              CMP      r0,r1
0000d6  db4b              BLT      |L33.368|
;;;614              /* Time for a retransmission. */
;;;615              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
0000d8  bf00              NOP      
0000da  bf00              NOP      
0000dc  f9b42048          LDRSH    r2,[r4,#0x48]
0000e0  f9b41036          LDRSH    r1,[r4,#0x36]
0000e4  a0c8              ADR      r0,|L33.1032|
0000e6  f7fffffe          BL       __2printf
0000ea  bf00              NOP      
0000ec  bf00              NOP      
;;;616                                          " pcb->rto %"S16_F"\n",
;;;617                                          pcb->rtime, pcb->rto));
;;;618    
;;;619              /* Double retransmission time-out unless we are trying to
;;;620               * connect to somebody (i.e., we are in SYN_SENT). */
;;;621              if (pcb->state != SYN_SENT) {
0000ee  7c20              LDRB     r0,[r4,#0x10]
0000f0  2802              CMP      r0,#2
0000f2  d00d              BEQ      |L33.272|
;;;622                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
0000f4  f8340f46          LDRH     r0,[r4,#0x46]!
0000f8  f9341c02          LDRSH    r1,[r4,#-2]
0000fc  eb0000e1          ADD      r0,r0,r1,ASR #3
000100  7921              LDRB     r1,[r4,#4]
000102  4acb              LDR      r2,|L33.1072|
000104  5c51              LDRB     r1,[r2,r1]
000106  4088              LSLS     r0,r0,r1
000108  b200              SXTH     r0,r0
00010a  8060              STRH     r0,[r4,#2]
00010c  f1a40446          SUB      r4,r4,#0x46
                  |L33.272|
;;;623              }
;;;624    
;;;625              /* Reset the retransmission timer. */
;;;626              pcb->rtime = 0;
000110  2000              MOVS     r0,#0
000112  86e0              STRH     r0,[r4,#0x36]
;;;627    
;;;628              /* Reduce congestion window and ssthresh. */
;;;629              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
000114  f8b40052          LDRH     r0,[r4,#0x52]
000118  f8b4105c          LDRH     r1,[r4,#0x5c]
00011c  4288              CMP      r0,r1
00011e  da02              BGE      |L33.294|
000120  f8b40052          LDRH     r0,[r4,#0x52]
000124  e001              B        |L33.298|
                  |L33.294|
000126  f8b4005c          LDRH     r0,[r4,#0x5c]
                  |L33.298|
00012a  fa1ff880          UXTH     r8,r0
;;;630              pcb->ssthresh = eff_wnd >> 1;
00012e  ea4f0068          ASR      r0,r8,#1
000132  f8a40054          STRH     r0,[r4,#0x54]
;;;631              if (pcb->ssthresh < pcb->mss) {
000136  f8b40054          LDRH     r0,[r4,#0x54]
00013a  8f21              LDRH     r1,[r4,#0x38]
00013c  4288              CMP      r0,r1
00013e  da06              BGE      |L33.334|
;;;632                pcb->ssthresh = pcb->mss * 2;
000140  8f20              LDRH     r0,[r4,#0x38]
000142  0440              LSLS     r0,r0,#17
000144  0c00              LSRS     r0,r0,#16
000146  e000              B        |L33.330|
                  |L33.328|
000148  e012              B        |L33.368|
                  |L33.330|
00014a  f8a40054          STRH     r0,[r4,#0x54]
                  |L33.334|
;;;633              }
;;;634              pcb->cwnd = pcb->mss;
00014e  8f20              LDRH     r0,[r4,#0x38]
000150  f8a40052          STRH     r0,[r4,#0x52]
;;;635              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
000154  bf00              NOP      
000156  bf00              NOP      
000158  f8b42054          LDRH     r2,[r4,#0x54]
00015c  f8b41052          LDRH     r1,[r4,#0x52]
000160  a0b4              ADR      r0,|L33.1076|
000162  f7fffffe          BL       __2printf
000166  bf00              NOP      
000168  bf00              NOP      
;;;636                                           " ssthresh %"U16_F"\n",
;;;637                                           pcb->cwnd, pcb->ssthresh));
;;;638     
;;;639              /* The following needs to be called AFTER cwnd is set to one
;;;640                 mss - STJ */
;;;641              tcp_rexmit_rto(pcb);
00016a  4620              MOV      r0,r4
00016c  f7fffffe          BL       tcp_rexmit_rto
                  |L33.368|
;;;642            }
;;;643          }
;;;644        }
;;;645        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;646        if (pcb->state == FIN_WAIT_2) {
000170  7c20              LDRB     r0,[r4,#0x10]
000172  2806              CMP      r0,#6
000174  d10e              BNE      |L33.404|
;;;647          if ((u32_t)(tcp_ticks - pcb->tmr) >
000176  497c              LDR      r1,|L33.872|
000178  6b20              LDR      r0,[r4,#0x30]
00017a  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00017c  1a08              SUBS     r0,r1,r0
00017e  2828              CMP      r0,#0x28
000180  d908              BLS      |L33.404|
;;;648              TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;649            ++pcb_remove;
000182  1c68              ADDS     r0,r5,#1
000184  b2c5              UXTB     r5,r0
;;;650            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
000186  bf00              NOP      
000188  bf00              NOP      
00018a  a0b3              ADR      r0,|L33.1112|
00018c  f7fffffe          BL       __2printf
000190  bf00              NOP      
000192  bf00              NOP      
                  |L33.404|
;;;651          }
;;;652        }
;;;653    
;;;654        /* Check if KEEPALIVE should be sent */
;;;655        if((pcb->so_options & SOF_KEEPALIVE) && 
000194  8920              LDRH     r0,[r4,#8]
000196  f0100f08          TST      r0,#8
00019a  d052              BEQ      |L33.578|
;;;656           ((pcb->state == ESTABLISHED) || 
00019c  7c20              LDRB     r0,[r4,#0x10]
00019e  2804              CMP      r0,#4
0001a0  d002              BEQ      |L33.424|
;;;657            (pcb->state == CLOSE_WAIT))) {
0001a2  7c20              LDRB     r0,[r4,#0x10]
0001a4  2807              CMP      r0,#7
0001a6  d14c              BNE      |L33.578|
                  |L33.424|
;;;658    #if LWIP_TCP_KEEPALIVE
;;;659          if((u32_t)(tcp_ticks - pcb->tmr) > 
;;;660             (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
;;;661             / TCP_SLOW_INTERVAL)
;;;662    #else      
;;;663          if((u32_t)(tcp_ticks - pcb->tmr) > 
0001a8  49b7              LDR      r1,|L33.1160|
0001aa  f8d40094          LDR      r0,[r4,#0x94]
0001ae  4408              ADD      r0,r0,r1
0001b0  f44f71fa          MOV      r1,#0x1f4
0001b4  fbb0f1f1          UDIV     r1,r0,r1
0001b8  4a6b              LDR      r2,|L33.872|
0001ba  6b20              LDR      r0,[r4,#0x30]
0001bc  6812              LDR      r2,[r2,#0]  ; tcp_ticks
0001be  1a10              SUBS     r0,r2,r0
0001c0  4281              CMP      r1,r0
0001c2  d223              BCS      |L33.524|
;;;664             (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
;;;665    #endif /* LWIP_TCP_KEEPALIVE */
;;;666          {
;;;667            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
0001c4  bf00              NOP      
0001c6  bf00              NOP      
0001c8  6860              LDR      r0,[r4,#4]
0001ca  f7fffffe          BL       ntohl
0001ce  f00009ff          AND      r9,r0,#0xff
0001d2  6860              LDR      r0,[r4,#4]
0001d4  f7fffffe          BL       ntohl
0001d8  f3c02a07          UBFX     r10,r0,#8,#8
0001dc  6860              LDR      r0,[r4,#4]
0001de  f7fffffe          BL       ntohl
0001e2  f3c04b07          UBFX     r11,r0,#16,#8
0001e6  6860              LDR      r0,[r4,#4]
0001e8  f7fffffe          BL       ntohl
0001ec  0e00              LSRS     r0,r0,#24
0001ee  4653              MOV      r3,r10
0001f0  465a              MOV      r2,r11
0001f2  4601              MOV      r1,r0
0001f4  e9cd9000          STRD     r9,r0,[sp,#0]
0001f8  48a4              LDR      r0,|L33.1164|
0001fa  f7fffffe          BL       __2printf
0001fe  bf00              NOP      
000200  bf00              NOP      
;;;668                                    ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
;;;669                                    ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
;;;670            
;;;671            tcp_abort(pcb);
000202  2101              MOVS     r1,#1
000204  4620              MOV      r0,r4
000206  f7fffffe          BL       tcp_abandon
00020a  e01a              B        |L33.578|
                  |L33.524|
;;;672          }
;;;673    #if LWIP_TCP_KEEPALIVE
;;;674          else if((u32_t)(tcp_ticks - pcb->tmr) > 
;;;675                  (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
;;;676                  / TCP_SLOW_INTERVAL)
;;;677    #else
;;;678          else if((u32_t)(tcp_ticks - pcb->tmr) > 
00020c  f894009d          LDRB     r0,[r4,#0x9d]
000210  f242429f          MOV      r2,#0x249f
000214  4350              MULS     r0,r2,r0
000216  f8d41094          LDR      r1,[r4,#0x94]
00021a  eb0100c0          ADD      r0,r1,r0,LSL #3
00021e  f44f71fa          MOV      r1,#0x1f4
000222  fbb0f0f1          UDIV     r0,r0,r1
000226  4a50              LDR      r2,|L33.872|
000228  6b21              LDR      r1,[r4,#0x30]
00022a  6812              LDR      r2,[r2,#0]  ; tcp_ticks
00022c  1a51              SUBS     r1,r2,r1
00022e  4288              CMP      r0,r1
000230  d207              BCS      |L33.578|
;;;679                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
;;;680                  / TCP_SLOW_INTERVAL)
;;;681    #endif /* LWIP_TCP_KEEPALIVE */
;;;682          {
;;;683            tcp_keepalive(pcb);
000232  4620              MOV      r0,r4
000234  f7fffffe          BL       tcp_keepalive
;;;684            pcb->keep_cnt_sent++;
000238  f894009d          LDRB     r0,[r4,#0x9d]
00023c  1c40              ADDS     r0,r0,#1
00023e  f884009d          STRB     r0,[r4,#0x9d]
                  |L33.578|
;;;685          }
;;;686        }
;;;687    
;;;688        /* If this PCB has queued out of sequence data, but has been
;;;689           inactive for too long, will drop the data (it will eventually
;;;690           be retransmitted). */
;;;691    #if TCP_QUEUE_OOSEQ    
;;;692        if (pcb->ooseq != NULL &&
;;;693            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
;;;694          tcp_segs_free(pcb->ooseq);
;;;695          pcb->ooseq = NULL;
;;;696          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;697        }
;;;698    #endif /* TCP_QUEUE_OOSEQ */
;;;699    
;;;700        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;701        if (pcb->state == SYN_RCVD) {
000242  7c20              LDRB     r0,[r4,#0x10]
000244  2803              CMP      r0,#3
000246  d10e              BNE      |L33.614|
;;;702          if ((u32_t)(tcp_ticks - pcb->tmr) >
000248  4947              LDR      r1,|L33.872|
00024a  6b20              LDR      r0,[r4,#0x30]
00024c  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00024e  1a08              SUBS     r0,r1,r0
000250  2828              CMP      r0,#0x28
000252  d908              BLS      |L33.614|
;;;703              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;704            ++pcb_remove;
000254  1c68              ADDS     r0,r5,#1
000256  b2c5              UXTB     r5,r0
;;;705            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
000258  bf00              NOP      
00025a  bf00              NOP      
00025c  a08c              ADR      r0,|L33.1168|
00025e  f7fffffe          BL       __2printf
000262  bf00              NOP      
000264  bf00              NOP      
                  |L33.614|
;;;706          }
;;;707        }
;;;708    
;;;709        /* Check if this PCB has stayed too long in LAST-ACK */
;;;710        if (pcb->state == LAST_ACK) {
000266  7c20              LDRB     r0,[r4,#0x10]
000268  2809              CMP      r0,#9
00026a  d10e              BNE      |L33.650|
;;;711          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
00026c  493e              LDR      r1,|L33.872|
00026e  6b20              LDR      r0,[r4,#0x30]
000270  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000272  1a08              SUBS     r0,r1,r0
000274  28f0              CMP      r0,#0xf0
000276  d908              BLS      |L33.650|
;;;712            ++pcb_remove;
000278  1c68              ADDS     r0,r5,#1
00027a  b2c5              UXTB     r5,r0
;;;713            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
00027c  bf00              NOP      
00027e  bf00              NOP      
000280  a08f              ADR      r0,|L33.1216|
000282  f7fffffe          BL       __2printf
000286  bf00              NOP      
000288  bf00              NOP      
                  |L33.650|
;;;714          }
;;;715        }
;;;716    
;;;717        /* If the PCB should be removed, do it. */
;;;718        if (pcb_remove) {
00028a  b1dd              CBZ      r5,|L33.708|
;;;719          tcp_pcb_purge(pcb);      
00028c  4620              MOV      r0,r4
00028e  f7fffffe          BL       tcp_pcb_purge
;;;720          /* Remove PCB from tcp_active_pcbs list. */
;;;721          if (prev != NULL) {
000292  b116              CBZ      r6,|L33.666|
;;;722            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
;;;723            prev->next = pcb->next;
000294  68e0              LDR      r0,[r4,#0xc]
000296  60f0              STR      r0,[r6,#0xc]
000298  e002              B        |L33.672|
                  |L33.666|
;;;724          } else {
;;;725            /* This PCB was the first. */
;;;726            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
;;;727            tcp_active_pcbs = pcb->next;
00029a  4934              LDR      r1,|L33.876|
00029c  68e0              LDR      r0,[r4,#0xc]
00029e  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
                  |L33.672|
;;;728          }
;;;729    
;;;730          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
0002a0  bf00              NOP      
0002a2  f8d40090          LDR      r0,[r4,#0x90]
0002a6  b128              CBZ      r0,|L33.692|
0002a8  f06f0104          MVN      r1,#4
0002ac  f8d42090          LDR      r2,[r4,#0x90]
0002b0  6960              LDR      r0,[r4,#0x14]
0002b2  4790              BLX      r2
                  |L33.692|
0002b4  bf00              NOP      
;;;731    
;;;732          pcb2 = pcb->next;
0002b6  68e7              LDR      r7,[r4,#0xc]
;;;733          memp_free(MEMP_TCP_PCB, pcb);
0002b8  4621              MOV      r1,r4
0002ba  2002              MOVS     r0,#2
0002bc  f7fffffe          BL       memp_free
;;;734          pcb = pcb2;
0002c0  463c              MOV      r4,r7
0002c2  e028              B        |L33.790|
                  |L33.708|
;;;735        } else {
;;;736    
;;;737          /* We check if we should poll the connection. */
;;;738          ++pcb->polltmr;
0002c4  f8140f34          LDRB     r0,[r4,#0x34]!
0002c8  1c40              ADDS     r0,r0,#1
0002ca  7020              STRB     r0,[r4,#0]
;;;739          if (pcb->polltmr >= pcb->pollinterval) {
0002cc  7820              LDRB     r0,[r4,#0]
0002ce  7861              LDRB     r1,[r4,#1]
0002d0  f1a40434          SUB      r4,r4,#0x34
0002d4  4288              CMP      r0,r1
0002d6  db1c              BLT      |L33.786|
;;;740            pcb->polltmr = 0;
0002d8  2000              MOVS     r0,#0
0002da  f8840034          STRB     r0,[r4,#0x34]
;;;741            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
0002de  bf00              NOP      
0002e0  bf00              NOP      
0002e2  a083              ADR      r0,|L33.1264|
0002e4  f7fffffe          BL       __2printf
0002e8  bf00              NOP      
0002ea  bf00              NOP      
;;;742            TCP_EVENT_POLL(pcb, err);
0002ec  bf00              NOP      
0002ee  f8d4008c          LDR      r0,[r4,#0x8c]
0002f2  b130              CBZ      r0,|L33.770|
0002f4  4621              MOV      r1,r4
0002f6  f8d4208c          LDR      r2,[r4,#0x8c]
0002fa  6960              LDR      r0,[r4,#0x14]
0002fc  4790              BLX      r2
0002fe  9002              STR      r0,[sp,#8]
000300  e001              B        |L33.774|
                  |L33.770|
000302  2000              MOVS     r0,#0
000304  9002              STR      r0,[sp,#8]
                  |L33.774|
000306  bf00              NOP      
;;;743            if (err == ERR_OK) {
000308  9802              LDR      r0,[sp,#8]
00030a  b910              CBNZ     r0,|L33.786|
;;;744              tcp_output(pcb);
00030c  4620              MOV      r0,r4
00030e  f7fffffe          BL       tcp_output
                  |L33.786|
;;;745            }
;;;746          }
;;;747          
;;;748          prev = pcb;
000312  4626              MOV      r6,r4
;;;749          pcb = pcb->next;
000314  68e4              LDR      r4,[r4,#0xc]
                  |L33.790|
000316  2c00              CMP      r4,#0                 ;581
000318  f47fae87          BNE      |L33.42|
;;;750        }
;;;751      }
;;;752    
;;;753      
;;;754      /* Steps through all of the TIME-WAIT PCBs. */
;;;755      prev = NULL;    
00031c  2600              MOVS     r6,#0
;;;756      pcb = tcp_tw_pcbs;
00031e  487d              LDR      r0,|L33.1300|
000320  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
;;;757      while (pcb != NULL) {
000322  e01c              B        |L33.862|
                  |L33.804|
;;;758        LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
;;;759        pcb_remove = 0;
000324  2500              MOVS     r5,#0
;;;760    
;;;761        /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;762        if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000326  4910              LDR      r1,|L33.872|
000328  6b20              LDR      r0,[r4,#0x30]
00032a  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00032c  1a08              SUBS     r0,r1,r0
00032e  28f0              CMP      r0,#0xf0
000330  d901              BLS      |L33.822|
;;;763          ++pcb_remove;
000332  1c68              ADDS     r0,r5,#1
000334  b2c5              UXTB     r5,r0
                  |L33.822|
;;;764        }
;;;765        
;;;766    
;;;767    
;;;768        /* If the PCB should be removed, do it. */
;;;769        if (pcb_remove) {
000336  b185              CBZ      r5,|L33.858|
;;;770          tcp_pcb_purge(pcb);      
000338  4620              MOV      r0,r4
00033a  f7fffffe          BL       tcp_pcb_purge
;;;771          /* Remove PCB from tcp_tw_pcbs list. */
;;;772          if (prev != NULL) {
00033e  b116              CBZ      r6,|L33.838|
;;;773            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
;;;774            prev->next = pcb->next;
000340  68e0              LDR      r0,[r4,#0xc]
000342  60f0              STR      r0,[r6,#0xc]
000344  e002              B        |L33.844|
                  |L33.838|
;;;775          } else {
;;;776            /* This PCB was the first. */
;;;777            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
;;;778            tcp_tw_pcbs = pcb->next;
000346  4973              LDR      r1,|L33.1300|
000348  68e0              LDR      r0,[r4,#0xc]
00034a  6008              STR      r0,[r1,#0]  ; tcp_tw_pcbs
                  |L33.844|
;;;779          }
;;;780          pcb2 = pcb->next;
00034c  68e7              LDR      r7,[r4,#0xc]
;;;781          memp_free(MEMP_TCP_PCB, pcb);
00034e  4621              MOV      r1,r4
000350  2002              MOVS     r0,#2
000352  f7fffffe          BL       memp_free
;;;782          pcb = pcb2;
000356  463c              MOV      r4,r7
000358  e001              B        |L33.862|
                  |L33.858|
;;;783        } else {
;;;784          prev = pcb;
00035a  4626              MOV      r6,r4
;;;785          pcb = pcb->next;
00035c  68e4              LDR      r4,[r4,#0xc]
                  |L33.862|
00035e  2c00              CMP      r4,#0                 ;757
000360  d1e0              BNE      |L33.804|
;;;786        }
;;;787      }
;;;788    }
000362  e8bd8ffe          POP      {r1-r11,pc}
;;;789    
                          ENDP

000366  0000              DCW      0x0000
                  |L33.872|
                          DCD      tcp_ticks
                  |L33.876|
                          DCD      tcp_active_pcbs
                  |L33.880|
000370  7463705f          DCB      "tcp_slowtmr: no active pcbs\n",0
000374  736c6f77
000378  746d723a
00037c  206e6f20
000380  61637469
000384  76652070
000388  6362730a
00038c  00      
00038d  00                DCB      0
00038e  00                DCB      0
00038f  00                DCB      0
                  |L33.912|
000390  7463705f          DCB      "tcp_slowtmr: processing active pcb\n",0
000394  736c6f77
000398  746d723a
00039c  2070726f
0003a0  63657373
0003a4  696e6720
0003a8  61637469
0003ac  76652070
0003b0  63620a00
                  |L33.948|
0003b4  7463705f          DCB      "tcp_slowtmr: max SYN retries reached\n",0
0003b8  736c6f77
0003bc  746d723a
0003c0  206d6178
0003c4  2053594e
0003c8  20726574
0003cc  72696573
0003d0  20726561
0003d4  63686564
0003d8  0a00    
0003da  00                DCB      0
0003db  00                DCB      0
                  |L33.988|
0003dc  7463705f          DCB      "tcp_slowtmr: max DATA retries reached\n",0
0003e0  736c6f77
0003e4  746d723a
0003e8  206d6178
0003ec  20444154
0003f0  41207265
0003f4  74726965
0003f8  73207265
0003fc  61636865
000400  640a00  
000403  00                DCB      0
                  |L33.1028|
                          DCD      tcp_persist_backoff
                  |L33.1032|
000408  7463705f          DCB      "tcp_slowtmr: rtime %4d pcb->rto %4d\n",0
00040c  736c6f77
000410  746d723a
000414  20727469
000418  6d652025
00041c  34642070
000420  63622d3e
000424  72746f20
000428  2534640a
00042c  00      
00042d  00                DCB      0
00042e  00                DCB      0
00042f  00                DCB      0
                  |L33.1072|
                          DCD      tcp_backoff
                  |L33.1076|
000434  7463705f          DCB      "tcp_slowtmr: cwnd %4d ssthresh %4d\n",0
000438  736c6f77
00043c  746d723a
000440  2063776e
000444  64202534
000448  64207373
00044c  74687265
000450  73682025
000454  34640a00
                  |L33.1112|
000458  7463705f          DCB      "tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n",0
00045c  736c6f77
000460  746d723a
000464  2072656d
000468  6f76696e
00046c  67207063
000470  62207374
000474  75636b20
000478  696e2046
00047c  494e2d57
000480  4149542d
000484  320a00  
000487  00                DCB      0
                  |L33.1160|
                          DCD      0x000a4cb8
                  |L33.1164|
                          DCD      ||.constdata||+0x14
                  |L33.1168|
000490  7463705f          DCB      "tcp_slowtmr: removing pcb stuck in SYN-RCVD\n",0
000494  736c6f77
000498  746d723a
00049c  2072656d
0004a0  6f76696e
0004a4  67207063
0004a8  62207374
0004ac  75636b20
0004b0  696e2053
0004b4  594e2d52
0004b8  4356440a
0004bc  00      
0004bd  00                DCB      0
0004be  00                DCB      0
0004bf  00                DCB      0
                  |L33.1216|
0004c0  7463705f          DCB      "tcp_slowtmr: removing pcb stuck in LAST-ACK\n",0
0004c4  736c6f77
0004c8  746d723a
0004cc  2072656d
0004d0  6f76696e
0004d4  67207063
0004d8  62207374
0004dc  75636b20
0004e0  696e204c
0004e4  4153542d
0004e8  41434b0a
0004ec  00      
0004ed  00                DCB      0
0004ee  00                DCB      0
0004ef  00                DCB      0
                  |L33.1264|
0004f0  7463705f          DCB      "tcp_slowtmr: polling application\n",0
0004f4  736c6f77
0004f8  746d723a
0004fc  20706f6c
000500  6c696e67
000504  20617070
000508  6c696361
00050c  74696f6e
000510  0a00    
000512  00                DCB      0
000513  00                DCB      0
                  |L33.1300|
                          DCD      tcp_tw_pcbs

                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;84     void
;;;85     tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87       /* Call tcp_fasttmr() every 250 ms */
;;;88       tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;89     
;;;90       if (++tcp_timer & 1) {
000006  4806              LDR      r0,|L34.32|
000008  7800              LDRB     r0,[r0,#0]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  b2c0              UXTB     r0,r0
00000e  4904              LDR      r1,|L34.32|
000010  7008              STRB     r0,[r1,#0]
000012  f0100f01          TST      r0,#1
000016  d001              BEQ      |L34.28|
;;;91         /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;92            tcp_tmr() is called. */
;;;93         tcp_slowtmr();
000018  f7fffffe          BL       tcp_slowtmr
                  |L34.28|
;;;94       }
;;;95     }
00001c  bd10              POP      {r4,pc}
;;;96     
                          ENDP

00001e  0000              DCW      0x0000
                  |L34.32|
                          DCD      tcp_timer

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=1

                  tcp_update_rcv_ann_wnd PROC
;;;394     */
;;;395    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  4601              MOV      r1,r0
;;;396    {
;;;397      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000002  8d0b              LDRH     r3,[r1,#0x28]
000004  6a48              LDR      r0,[r1,#0x24]
000006  18c2              ADDS     r2,r0,r3
;;;398    
;;;399      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + pcb->mss)) {
000008  8f0b              LDRH     r3,[r1,#0x38]
00000a  6ac8              LDR      r0,[r1,#0x2c]
00000c  4418              ADD      r0,r0,r3
00000e  1a10              SUBS     r0,r2,r0
000010  d404              BMI      |L35.28|
;;;400        /* we can advertise more window */
;;;401        pcb->rcv_ann_wnd = pcb->rcv_wnd;
000012  8d08              LDRH     r0,[r1,#0x28]
000014  8548              STRH     r0,[r1,#0x2a]
;;;402        return new_right_edge - pcb->rcv_ann_right_edge;
000016  6ac8              LDR      r0,[r1,#0x2c]
000018  1a10              SUBS     r0,r2,r0
                  |L35.26|
;;;403      } else {
;;;404        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;405          /* Can happen due to other end sending out of advertised window,
;;;406           * but within actual available (but not yet advertised) window */
;;;407          pcb->rcv_ann_wnd = 0;
;;;408        } else {
;;;409          /* keep the right edge of window constant */
;;;410          pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;411        }
;;;412        return 0;
;;;413      }
;;;414    }
00001a  4770              BX       lr
                  |L35.28|
00001c  6acb              LDR      r3,[r1,#0x2c]         ;404
00001e  6a48              LDR      r0,[r1,#0x24]         ;404
000020  1ac0              SUBS     r0,r0,r3              ;404
000022  2800              CMP      r0,#0                 ;404
000024  dd02              BLE      |L35.44|
000026  2000              MOVS     r0,#0                 ;407
000028  8548              STRH     r0,[r1,#0x2a]         ;407
00002a  e003              B        |L35.52|
                  |L35.44|
00002c  6a4b              LDR      r3,[r1,#0x24]         ;410
00002e  6ac8              LDR      r0,[r1,#0x2c]         ;410
000030  1ac0              SUBS     r0,r0,r3              ;410
000032  8548              STRH     r0,[r1,#0x2a]         ;410
                  |L35.52|
000034  2000              MOVS     r0,#0                 ;412
000036  e7f0              B        |L35.26|
;;;415    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_backoff
000000  01020304          DCB      0x01,0x02,0x03,0x04
000004  05060707          DCB      0x05,0x06,0x07,0x07
000008  07070707          DCB      0x07,0x07,0x07,0x07
00000c  07                DCB      0x07
                  tcp_persist_backoff
00000d  03060c            DCB      0x03,0x06,0x0c
000010  18306078          DCB      0x18,0x30,0x60,0x78
000014  7463705f          DCB      0x74,0x63,0x70,0x5f
000018  736c6f77          DCB      0x73,0x6c,0x6f,0x77
00001c  746d723a          DCB      0x74,0x6d,0x72,0x3a
000020  204b4545          DCB      0x20,0x4b,0x45,0x45
000024  50414c49          DCB      0x50,0x41,0x4c,0x49
000028  56452074          DCB      0x56,0x45,0x20,0x74
00002c  696d656f          DCB      0x69,0x6d,0x65,0x6f
000030  75742e20          DCB      0x75,0x74,0x2e,0x20
000034  41626f72          DCB      0x41,0x62,0x6f,0x72
000038  74696e67          DCB      0x74,0x69,0x6e,0x67
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  6e656374          DCB      0x6e,0x65,0x63,0x74
000044  696f6e20          DCB      0x69,0x6f,0x6e,0x20
000048  746f2025          DCB      0x74,0x6f,0x20,0x25
00004c  34642e25          DCB      0x34,0x64,0x2e,0x25
000050  34642e25          DCB      0x34,0x64,0x2e,0x25
000054  34642e25          DCB      0x34,0x64,0x2e,0x25
000058  34642e0a          DCB      0x34,0x64,0x2e,0x0a
00005c  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  port
000000  1000              DCW      0x1000
000002  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
                  tcp_timer
000020  00                DCB      0x00
