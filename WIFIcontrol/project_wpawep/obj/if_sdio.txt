; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\if_sdio.o --depend=.\obj\if_sdio.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\if_sdio.crf ..\marvel\driver\src\if_sdio.c]
                          THUMB

                          AREA ||i.if_sdio_card_to_host||, CODE, READONLY, ALIGN=2

                  if_sdio_card_to_host PROC
;;;206    
;;;207    static int if_sdio_card_to_host(struct if_sdio_card *card)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;208    {
000004  4604              MOV      r4,r0
;;;209        int ret;
;;;210        u8 status;
;;;211        u16 size, type, chunk;
;;;212        unsigned long timeout;
;;;213        struct lbs_private	*priv=card->priv;
000006  f8d49004          LDR      r9,[r4,#4]
;;;214        //lbs_deb_enter(LBS_DEB_SDIO);
;;;215        size = if_sdio_read_rx_len(card, &ret);
00000a  a903              ADD      r1,sp,#0xc
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       if_sdio_read_rx_len
000012  4607              MOV      r7,r0
;;;216        if (ret)
000014  9803              LDR      r0,[sp,#0xc]
000016  b100              CBZ      r0,|L1.26|
;;;217            goto out;
000018  e082              B        |L1.288|
                  |L1.26|
;;;218    
;;;219        if (size < 4) {
00001a  2f04              CMP      r7,#4
00001c  da03              BGE      |L1.38|
;;;220            pr_debug("invalid packet size (%d bytes) from firmware\n",
;;;221                     (int)size);
;;;222            ret = -EINVAL;
00001e  f06f0015          MVN      r0,#0x15
000022  9003              STR      r0,[sp,#0xc]
;;;223            goto out;
000024  e07c              B        |L1.288|
                  |L1.38|
;;;224        }
;;;225        timeout = HZ;
000026  f44f707a          MOV      r0,#0x3e8
00002a  9002              STR      r0,[sp,#8]
;;;226        while (1) {
00002c  e018              B        |L1.96|
                  |L1.46|
;;;227            status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
00002e  aa03              ADD      r2,sp,#0xc
000030  2120              MOVS     r1,#0x20
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       sdio_readb
000038  4606              MOV      r6,r0
;;;228            if (ret)
00003a  9803              LDR      r0,[sp,#0xc]
00003c  b100              CBZ      r0,|L1.64|
;;;229                goto out;
00003e  e06f              B        |L1.288|
                  |L1.64|
;;;230            if (status & IF_SDIO_IO_RDY)//正常出口，说明接收的数据包已经准备好，主机可以读取数据包
000040  f0160f08          TST      r6,#8
000044  d000              BEQ      |L1.72|
;;;231                break;
000046  e00c              B        |L1.98|
                  |L1.72|
;;;232            if (time_after(jiffies, &timeout)) {
000048  a902              ADD      r1,sp,#8
00004a  2000              MOVS     r0,#0
00004c  f7fffffe          BL       time_after
000050  b118              CBZ      r0,|L1.90|
;;;233                ret = -ETIMEDOUT;
000052  f06f003b          MVN      r0,#0x3b
000056  9003              STR      r0,[sp,#0xc]
;;;234                goto out;
000058  e062              B        |L1.288|
                  |L1.90|
;;;235            }
;;;236            mdelay(1);
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       mdelay
                  |L1.96|
000060  e7e5              B        |L1.46|
                  |L1.98|
000062  bf00              NOP                            ;231
;;;237        }
;;;238    
;;;239        /*
;;;240    	 * The transfer must be in one transaction or the firmware
;;;241    	 * goes suicidal. There's no way to guarantee that for all
;;;242    	 * controllers, but we can at least try.
;;;243    	 */
;;;244        //最好按size对齐，控制器为其选择一个最优的对齐方式来返回最后应该传输的长度
;;;245        chunk = sdio_align_size(card->func, size);
000064  4639              MOV      r1,r7
000066  6820              LDR      r0,[r4,#0]
000068  f7fffffe          BL       sdio_align_size
00006c  b285              UXTH     r5,r0
;;;246        ret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);//读取数据块
00006e  f1040224          ADD      r2,r4,#0x24
000072  e9cd2500          STRD     r2,r5,[sp,#0]
000076  2300              MOVS     r3,#0
000078  4619              MOV      r1,r3
00007a  68e2              LDR      r2,[r4,#0xc]
00007c  6820              LDR      r0,[r4,#0]
00007e  f7fffffe          BL       sdio_io_rw_ext_helper
000082  9003              STR      r0,[sp,#0xc]
;;;247        //ret=sdio_io_rw_ext_helper(card->func, 0, card->ioport, 0, card->buffer, chunk);
;;;248        if (ret)
000084  9803              LDR      r0,[sp,#0xc]
000086  b100              CBZ      r0,|L1.138|
;;;249            goto out;
000088  e04a              B        |L1.288|
                  |L1.138|
;;;250    
;;;251        chunk = card->buffer[0] | (card->buffer[1] << 8);//这是真正读取到的数据长度，存放在buffer[1]buffer[0]中(小端存储)
00008a  f8941024          LDRB     r1,[r4,#0x24]
00008e  2025              MOVS     r0,#0x25
000090  5d00              LDRB     r0,[r0,r4]
000092  ea412500          ORR      r5,r1,r0,LSL #8
;;;252        type = card->buffer[2] | (card->buffer[3] << 8);//包的类型
000096  2026              MOVS     r0,#0x26
000098  5d01              LDRB     r1,[r0,r4]
00009a  2027              MOVS     r0,#0x27
00009c  5d00              LDRB     r0,[r0,r4]
00009e  ea412800          ORR      r8,r1,r0,LSL #8
;;;253        //debug_data_stream("card->buffer",card->buffer,chunk);
;;;254        lbs_deb_sdio("packet of type %d and size %d bytes\n",
;;;255                     (int)type, (int)chunk);
;;;256        //debug_data_stream("packet",card->buffer,chunk);
;;;257        if (chunk > size) {//错误，收到的数据比包还长?
0000a2  42bd              CMP      r5,r7
0000a4  dd03              BLE      |L1.174|
;;;258            lbs_deb_sdio("packet fragment (%d > %d)\n",
;;;259                         (int)chunk, (int)size);
;;;260            ret = -EINVAL;
0000a6  f06f0015          MVN      r0,#0x15
0000aa  9003              STR      r0,[sp,#0xc]
;;;261            goto out;
0000ac  e038              B        |L1.288|
                  |L1.174|
;;;262        }
;;;263    
;;;264        if (chunk < size) {
;;;265            lbs_deb_sdio("packet fragment (%d < %d)\n",
;;;266                         (int)chunk, (int)size);
;;;267        }
;;;268    
;;;269        switch (type) {
0000ae  f1b80f00          CMP      r8,#0
0000b2  d014              BEQ      |L1.222|
0000b4  f1b80f01          CMP      r8,#1
0000b8  d003              BEQ      |L1.194|
0000ba  f1b80f03          CMP      r8,#3
0000be  d127              BNE      |L1.272|
0000c0  e018              B        |L1.244|
                  |L1.194|
;;;270        case MVMS_CMD:
;;;271            printf("RECV resp CMD... \r\n");
0000c2  a01c              ADR      r0,|L1.308|
0000c4  f7fffffe          BL       __2printf
;;;272            ret = if_sdio_handle_cmd(card, card->buffer + 4, chunk - 4);//命令包处理
0000c8  1f2a              SUBS     r2,r5,#4
0000ca  f1040128          ADD      r1,r4,#0x28
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       if_sdio_handle_cmd
0000d4  9003              STR      r0,[sp,#0xc]
;;;273            if (ret)
0000d6  9803              LDR      r0,[sp,#0xc]
0000d8  b100              CBZ      r0,|L1.220|
;;;274                goto out;
0000da  e021              B        |L1.288|
                  |L1.220|
;;;275            break;
0000dc  e01e              B        |L1.284|
                  |L1.222|
;;;276        case MVMS_DAT:
;;;277            //printf("RECV ETH DATA !!! \r\n");
;;;278            ret = if_sdio_handle_data(card, card->buffer + 4, chunk - 4);//数据报的处理
0000de  1f2a              SUBS     r2,r5,#4
0000e0  f1040128          ADD      r1,r4,#0x28
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       if_sdio_handle_data
0000ea  9003              STR      r0,[sp,#0xc]
;;;279            if (ret)
0000ec  9803              LDR      r0,[sp,#0xc]
0000ee  b100              CBZ      r0,|L1.242|
;;;280                goto out;
0000f0  e016              B        |L1.288|
                  |L1.242|
;;;281            break;
0000f2  e013              B        |L1.284|
                  |L1.244|
;;;282        case MVMS_EVENT:
;;;283            //处理网卡的envent，到底有哪些事件，会唤醒主线程处理
;;;284            //envent会有个kfifo，向里面填充内容后，主线程会读取
;;;285            printf("recv MVMS_EVENT !!!\r\n");
0000f4  a014              ADR      r0,|L1.328|
0000f6  f7fffffe          BL       __2printf
;;;286    #if 1
;;;287            ret = if_sdio_handle_event(card, card->buffer + 4, chunk - 4);
0000fa  1f2a              SUBS     r2,r5,#4
0000fc  f1040128          ADD      r1,r4,#0x28
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       if_sdio_handle_event
000106  9003              STR      r0,[sp,#0xc]
;;;288            if (ret)
000108  9803              LDR      r0,[sp,#0xc]
00010a  b100              CBZ      r0,|L1.270|
;;;289                goto out;
00010c  e008              B        |L1.288|
                  |L1.270|
;;;290            break;
00010e  e005              B        |L1.284|
                  |L1.272|
;;;291    #endif
;;;292        default:
;;;293            /*pr_debug("invalid type (%d) from firmware\n",
;;;294    				(int)type);
;;;295    		ret = -EINVAL;*/
;;;296            priv->connect_status=LBS_DISCONNECTED;
000110  2001              MOVS     r0,#1
000112  f8c901dc          STR      r0,[r9,#0x1dc]
;;;297            ret=0;
000116  2000              MOVS     r0,#0
000118  9003              STR      r0,[sp,#0xc]
;;;298            goto out;
00011a  e001              B        |L1.288|
                  |L1.284|
00011c  bf00              NOP                            ;275
;;;299        }
;;;300    
;;;301        out:
00011e  bf00              NOP      
                  |L1.288|
;;;302        if (ret)
000120  9803              LDR      r0,[sp,#0xc]
000122  b110              CBZ      r0,|L1.298|
;;;303            pr_err("problem fetching packet from firmware\n");
000124  a00e              ADR      r0,|L1.352|
000126  f7fffffe          BL       __2printf
                  |L1.298|
;;;304    
;;;305        pr_debug("ret %d", ret);
;;;306    
;;;307        return ret;
00012a  9803              LDR      r0,[sp,#0xc]
;;;308    }
00012c  b004              ADD      sp,sp,#0x10
00012e  e8bd87f0          POP      {r4-r10,pc}
;;;309    
                          ENDP

000132  0000              DCW      0x0000
                  |L1.308|
000134  52454356          DCB      "RECV resp CMD... \r\n",0
000138  20726573
00013c  7020434d
000140  442e2e2e
000144  200d0a00
                  |L1.328|
000148  72656376          DCB      "recv MVMS_EVENT !!!\r\n",0
00014c  204d564d
000150  535f4556
000154  454e5420
000158  2121210d
00015c  0a00    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L1.352|
000160  70726f62          DCB      "problem fetching packet from firmware\n",0
000164  6c656d20
000168  66657463
00016c  68696e67
000170  20706163
000174  6b657420
000178  66726f6d
00017c  20666972
000180  6d776172
000184  650a00  
000187  00                DCB      0

                          AREA ||i.if_sdio_handle_cmd||, CODE, READONLY, ALIGN=1

                  if_sdio_handle_cmd PROC
;;;112    
;;;113    static int if_sdio_handle_cmd(struct if_sdio_card *card,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;114                                  u8 *buffer, unsigned size)
;;;115    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;116        struct lbs_private *priv = card->priv;
00000a  f8d84004          LDR      r4,[r8,#4]
;;;117        int ret;
;;;118        u8 i;
;;;119    
;;;120        lbs_deb_enter("enter if_sdio_handle_cmd\n");
;;;121    
;;;122        if (size > LBS_CMD_BUFFER_SIZE) {
00000e  f5b56f80          CMP      r5,#0x400
000012  d902              BLS      |L2.26|
;;;123            lbs_deb_sdio("response packet too large (%d bytes)\n",
;;;124                         (int)size);
;;;125            ret = -E2BIG;
000014  f06f0606          MVN      r6,#6
;;;126            goto out;
000018  e014              B        |L2.68|
                  |L2.26|
;;;127        }
;;;128    
;;;129    
;;;130        i = priv->resp_idx = 0;
00001a  2700              MOVS     r7,#0
00001c  f8847495          STRB     r7,[r4,#0x495]
;;;131        priv->resp_len[i] = size;//主线程会读取本字段的值来确定是否有响应要处理
000020  f5046093          ADD      r0,r4,#0x498
000024  f8405027          STR      r5,[r0,r7,LSL #2]
;;;132        memcpy(priv->resp_buf[i], buffer, size);//copy到响应数组中，这里定义了两个priv->resp_buf
000028  eb070247          ADD      r2,r7,r7,LSL #1
00002c  1d01              ADDS     r1,r0,#4
00002e  eb012082          ADD      r0,r1,r2,LSL #10
000032  462a              MOV      r2,r5
000034  4649              MOV      r1,r9
000036  f7fffffe          BL       __aeabi_memcpy
;;;133        lbs_thread(priv);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       lbs_thread
;;;134        ret = 0;
000040  2600              MOVS     r6,#0
;;;135        out:
000042  bf00              NOP      
                  |L2.68|
;;;136        lbs_deb_leave_args("enter if_sdio_handle_cmd(ret=%d)\n", ret);
;;;137        return ret;
000044  4630              MOV      r0,r6
;;;138    }
000046  e8bd87f0          POP      {r4-r10,pc}
;;;139    
                          ENDP


                          AREA ||i.if_sdio_handle_data||, CODE, READONLY, ALIGN=1

                  if_sdio_handle_data PROC
;;;139    
;;;140    static int if_sdio_handle_data(struct if_sdio_card *card,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;141                                   u8 *buffer, unsigned int size)
;;;142    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;143        int ret;
;;;144        lbs_deb_enter("enter if_sdio_handle_data\n");
;;;145        if (size>MRVDRV_ETH_RX_PACKET_BUFFER_SIZE ) {
00000a  f240602a          MOV      r0,#0x62a
00000e  4284              CMP      r4,r0
000010  d902              BLS      |L3.24|
;;;146            lbs_deb_sdio("response packet too large (%d bytes)\n",
;;;147                         (int)size);
;;;148            ret = -E2BIG;
000012  f06f0506          MVN      r5,#6
;;;149            goto out;
000016  e006              B        |L3.38|
                  |L3.24|
;;;150        }
;;;151        lbs_process_rxed_packet(card->priv,(char *)buffer,size);//处理数据包,封装802.3MAC头，并提交给上层协议栈
000018  b2a2              UXTH     r2,r4
00001a  4639              MOV      r1,r7
00001c  6870              LDR      r0,[r6,#4]
00001e  f7fffffe          BL       lbs_process_rxed_packet
;;;152        ret = 0;
000022  2500              MOVS     r5,#0
;;;153        out:
000024  bf00              NOP      
                  |L3.38|
;;;154        lbs_deb_leave_args("leave if_sdio_handle_data(ret=%d)\n", ret);
;;;155        return ret;
000026  4628              MOV      r0,r5
;;;156    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;157    
                          ENDP


                          AREA ||i.if_sdio_handle_event||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  if_sdio_handle_event PROC
;;;161    extern void recv_mac_event(int event);
;;;162    static int if_sdio_handle_event(struct if_sdio_card *card,
000000  b5f8              PUSH     {r3-r7,lr}
;;;163                                    u8 *buffer, unsigned size)
;;;164    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
;;;165        int ret;
;;;166        u32 event;
;;;167    
;;;168        lbs_deb_enter(LBS_DEB_SDIO);
;;;169    
;;;170        if (card->model == IF_SDIO_MODEL_8385) {
000008  68b0              LDR      r0,[r6,#8]
00000a  2804              CMP      r0,#4
00000c  d10b              BNE      |L4.38|
;;;171            event = sdio_readb(card->func, IF_SDIO_EVENT, &ret);
00000e  466a              MOV      r2,sp
000010  f24801fc          MOV      r1,#0x80fc
000014  6830              LDR      r0,[r6,#0]
000016  f7fffffe          BL       sdio_readb
00001a  4604              MOV      r4,r0
;;;172            if (ret)
00001c  9800              LDR      r0,[sp,#0]
00001e  b100              CBZ      r0,|L4.34|
;;;173                goto out;
000020  e01c              B        |L4.92|
                  |L4.34|
;;;174    
;;;175            /* right shift 3 bits to get the event id */
;;;176            event >>= 3;
000022  08e4              LSRS     r4,r4,#3
000024  e00f              B        |L4.70|
                  |L4.38|
;;;177        } else {
;;;178            if (size < 4) {
000026  2f04              CMP      r7,#4
000028  d203              BCS      |L4.50|
;;;179                lbs_deb_sdio("event packet too small (%d bytes)\n",
;;;180                             (int)size);
;;;181                ret = -EINVAL;
00002a  f06f0015          MVN      r0,#0x15
00002e  9000              STR      r0,[sp,#0]
;;;182                goto out;
000030  e014              B        |L4.92|
                  |L4.50|
;;;183            }
;;;184            event = buffer[3] << 24;
000032  78e8              LDRB     r0,[r5,#3]
000034  0604              LSLS     r4,r0,#24
;;;185            event |= buffer[2] << 16;
000036  78a8              LDRB     r0,[r5,#2]
000038  ea444400          ORR      r4,r4,r0,LSL #16
;;;186            event |= buffer[1] << 8;
00003c  7868              LDRB     r0,[r5,#1]
00003e  ea442400          ORR      r4,r4,r0,LSL #8
;;;187            event |= buffer[0] << 0;
000042  7828              LDRB     r0,[r5,#0]
000044  4304              ORRS     r4,r4,r0
                  |L4.70|
;;;188    
;;;189    
;;;190    
;;;191        }
;;;192    
;;;193        printf("RECV EVENT FROM FW  [%d , % d] \r\n",event,event&0xff);
000046  b2e2              UXTB     r2,r4
000048  4621              MOV      r1,r4
00004a  a005              ADR      r0,|L4.96|
00004c  f7fffffe          BL       __2printf
;;;194    
;;;195        recv_mac_event(event);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       recv_mac_event
;;;196        //lbs_queue_event(card->priv, event & 0xFF);
;;;197        ret = 0;
000056  2000              MOVS     r0,#0
000058  9000              STR      r0,[sp,#0]
;;;198    
;;;199        out:
00005a  bf00              NOP      
                  |L4.92|
;;;200        lbs_deb_leave_args(LBS_DEB_SDIO, ret);
;;;201    
;;;202        return ret;
00005c  9800              LDR      r0,[sp,#0]
;;;203    }
00005e  bdf8              POP      {r3-r7,pc}
;;;204    #endif
                          ENDP

                  |L4.96|
000060  52454356          DCB      "RECV EVENT FROM FW  [%d , % d] \r\n",0
000064  20455645
000068  4e542046
00006c  524f4d20
000070  46572020
000074  5b256420
000078  2c202520
00007c  645d200d
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.if_sdio_host_to_card||, CODE, READONLY, ALIGN=1

                  if_sdio_host_to_card PROC
;;;351    
;;;352    static int if_sdio_host_to_card(struct lbs_private *priv,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;353                                    u8 type, u8 *buf, u16 nb)
;;;354    {
000004  f2ad4d0c          SUB      sp,sp,#0x40c
000008  4607              MOV      r7,r0
00000a  4689              MOV      r9,r1
00000c  461d              MOV      r5,r3
;;;355        int ret;
;;;356        struct if_sdio_packet host_tx_pktbuf;
;;;357        struct if_sdio_card *card;
;;;358        struct if_sdio_packet *packet, *cur;
;;;359        u16 size;
;;;360    
;;;361        lbs_deb_cmd_enter_args("enter if_sdio_host_to_card type %d, bytes %d", type);
;;;362    
;;;363        card = priv->card;
00000e  6abe              LDR      r6,[r7,#0x28]
;;;364    
;;;365        if (nb > (65536 - sizeof(struct if_sdio_packet) - 4)) {
000010  f64f30f4          MOV      r0,#0xfbf4
000014  4285              CMP      r5,r0
000016  d902              BLS      |L5.30|
;;;366            ret = -EINVAL;
000018  f06f0a15          MVN      r10,#0x15
;;;367            goto out;
00001c  e040              B        |L5.160|
                  |L5.30|
;;;368        }
;;;369    
;;;370        /*
;;;371    	 * The transfer must be in one transaction or the firmware
;;;372    	 * goes suicidal. There's no way to guarantee that for all
;;;373    	 * controllers, but we can at least try.
;;;374    	 */
;;;375        size = sdio_align_size(card->func, nb + 4);//主机优化对齐
00001e  1d29              ADDS     r1,r5,#4
000020  6830              LDR      r0,[r6,#0]
000022  f7fffffe          BL       sdio_align_size
000026  fa1ffb80          UXTH     r11,r0
;;;376    
;;;377        /*packet = kzalloc(sizeof(struct if_sdio_packet) + size,
;;;378    			GFP_ATOMIC);//分配包空间
;;;379    	if (!packet) {
;;;380    		ret = -ENOMEM;
;;;381    		goto out;
;;;382    	}*/
;;;383        packet=&host_tx_pktbuf;
00002a  ac01              ADD      r4,sp,#4
;;;384        //	memset(packet,0,sizeof(struct if_sdio_packet));
;;;385    
;;;386        packet->next = NULL;
00002c  2000              MOVS     r0,#0
00002e  6020              STR      r0,[r4,#0]
;;;387        packet->nb = size;
000030  f8a4b004          STRH     r11,[r4,#4]
;;;388    
;;;389        /*
;;;390    	 * SDIO specific header.
;;;391    	 */
;;;392        packet->buffer[0] = (nb + 4) & 0xff;
000034  1d28              ADDS     r0,r5,#4
000036  71a0              STRB     r0,[r4,#6]
;;;393        packet->buffer[1] = ((nb + 4) >> 8) & 0xff;
000038  0a00              LSRS     r0,r0,#8
00003a  71e0              STRB     r0,[r4,#7]
;;;394        packet->buffer[2] = type;
00003c  f8849008          STRB     r9,[r4,#8]
;;;395        packet->buffer[3] = 0;//sdio硬件要求的头信息，buffer在这里是个零长数组
000040  2100              MOVS     r1,#0
000042  7261              STRB     r1,[r4,#9]
;;;396    
;;;397        memcpy(packet->buffer + 4, buf, nb);
000044  462a              MOV      r2,r5
000046  f104000a          ADD      r0,r4,#0xa
00004a  f8dd1414          LDR      r1,[sp,#0x414]
00004e  f7fffffe          BL       __aeabi_memcpy
;;;398    
;;;399        //	spin_lock_irqsave(&card->lock, flags);
;;;400    
;;;401        if (!card->packets)
000052  6a30              LDR      r0,[r6,#0x20]
000054  b908              CBNZ     r0,|L5.90|
;;;402            card->packets = packet;
000056  6234              STR      r4,[r6,#0x20]
000058  e00a              B        |L5.112|
                  |L5.90|
;;;403        else {
;;;404            cur = card->packets;
00005a  f8d68020          LDR      r8,[r6,#0x20]
;;;405            while (cur->next)
00005e  e001              B        |L5.100|
                  |L5.96|
;;;406                cur = cur->next;
000060  f8d88000          LDR      r8,[r8,#0]
                  |L5.100|
000064  f8d80000          LDR      r0,[r8,#0]            ;405
000068  2800              CMP      r0,#0                 ;405
00006a  d1f9              BNE      |L5.96|
;;;407            cur->next = packet;//链接到尾部
00006c  f8c84000          STR      r4,[r8,#0]
                  |L5.112|
;;;408        }
;;;409    
;;;410        switch (type) {
000070  f1b90f00          CMP      r9,#0
000074  d007              BEQ      |L5.134|
000076  f1b90f01          CMP      r9,#1
00007a  d109              BNE      |L5.144|
;;;411        case MVMS_CMD:
;;;412            priv->dnld_sent = DNLD_CMD_SENT;//更新状态，以免出现主线程重复提交的问题
00007c  2102              MOVS     r1,#2
00007e  f24100b8          MOV      r0,#0x10b8
000082  55c1              STRB     r1,[r0,r7]
;;;413            break;
000084  e005              B        |L5.146|
                  |L5.134|
;;;414        case MVMS_DAT:
;;;415            priv->dnld_sent = DNLD_DATA_SENT;
000086  2101              MOVS     r1,#1
000088  f24100b8          MOV      r0,#0x10b8
00008c  55c1              STRB     r1,[r0,r7]
;;;416            break;
00008e  e000              B        |L5.146|
                  |L5.144|
000090  bf00              NOP                            ;410
                  |L5.146|
000092  bf00              NOP                            ;413
;;;417        default:
;;;418            lbs_deb_sdio("unknown packet type %d\n", (int)type);
;;;419        }
;;;420        if_sdio_host_to_card_worker(card);
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       if_sdio_host_to_card_worker
;;;421        ret = 0;
00009a  f04f0a00          MOV      r10,#0
;;;422    
;;;423        out:
00009e  bf00              NOP      
                  |L5.160|
;;;424        lbs_deb_cmd_leave_args("leave if_sdio_host_to_card(ret=%d)\n", ret);
;;;425    
;;;426        return ret;
0000a0  4650              MOV      r0,r10
;;;427    }
0000a2  f20d4d1c          ADD      sp,sp,#0x41c
0000a6  e8bd8ff0          POP      {r4-r11,pc}
;;;428    
                          ENDP


                          AREA ||i.if_sdio_host_to_card_worker||, CODE, READONLY, ALIGN=1

                  if_sdio_host_to_card_worker PROC
;;;309    
;;;310    static void if_sdio_host_to_card_worker(struct if_sdio_card *card)
000000  b57f              PUSH     {r0-r6,lr}
;;;311    {
000002  4604              MOV      r4,r0
;;;312        struct if_sdio_packet *packet;
;;;313        unsigned long timeout;
;;;314        u8 status;
;;;315        int ret;
;;;316        lbs_deb_cmd_enter(LBS_DEB_SDIO);
;;;317        while (1) {
000004  e033              B        |L6.110|
                  |L6.6|
;;;318            packet = card->packets;//取出数据包
000006  6a25              LDR      r5,[r4,#0x20]
;;;319            if (packet)
000008  b10d              CBZ      r5,|L6.14|
;;;320                card->packets = packet->next;
00000a  6828              LDR      r0,[r5,#0]
00000c  6220              STR      r0,[r4,#0x20]
                  |L6.14|
;;;321            if (!packet)//正常出口，如果数据包发送完成退出
00000e  b905              CBNZ     r5,|L6.18|
;;;322                break;
000010  e02e              B        |L6.112|
                  |L6.18|
;;;323            timeout = jiffies + HZ;
000012  f44f707a          MOV      r0,#0x3e8
000016  9003              STR      r0,[sp,#0xc]
;;;324            while (1) {
000018  e018              B        |L6.76|
                  |L6.26|
;;;325                status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
00001a  aa02              ADD      r2,sp,#8
00001c  2120              MOVS     r1,#0x20
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       sdio_readb
000024  4606              MOV      r6,r0
;;;326                if (ret)
000026  9802              LDR      r0,[sp,#8]
000028  b100              CBZ      r0,|L6.44|
;;;327                    goto release;
00002a  e020              B        |L6.110|
                  |L6.44|
;;;328                if (status & IF_SDIO_IO_RDY)//读取状态直到IO准备完成，但是有个超时值
00002c  f0160f08          TST      r6,#8
000030  d000              BEQ      |L6.52|
;;;329                    break;
000032  e00c              B        |L6.78|
                  |L6.52|
;;;330                if (time_after(jiffies, &timeout)) {
000034  a903              ADD      r1,sp,#0xc
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       time_after
00003c  b118              CBZ      r0,|L6.70|
;;;331                    ret = -ETIMEDOUT;
00003e  f06f003b          MVN      r0,#0x3b
000042  9002              STR      r0,[sp,#8]
;;;332                    goto release;
000044  e013              B        |L6.110|
                  |L6.70|
;;;333                }
;;;334                mdelay(1);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       mdelay
                  |L6.76|
00004c  e7e5              B        |L6.26|
                  |L6.78|
00004e  bf00              NOP                            ;329
;;;335            }
;;;336            ret = sdio_writesb(card->func, card->ioport,
000050  88ab              LDRH     r3,[r5,#4]
000052  1daa              ADDS     r2,r5,#6
000054  e9cd2300          STRD     r2,r3,[sp,#0]
000058  2300              MOVS     r3,#0
00005a  2101              MOVS     r1,#1
00005c  68e2              LDR      r2,[r4,#0xc]
00005e  6820              LDR      r0,[r4,#0]
000060  f7fffffe          BL       sdio_io_rw_ext_helper
000064  9002              STR      r0,[sp,#8]
;;;337                               packet->buffer, packet->nb);//将数据写入sd卡
;;;338            if (ret)
000066  9802              LDR      r0,[sp,#8]
000068  b100              CBZ      r0,|L6.108|
;;;339                goto release;
00006a  e000              B        |L6.110|
                  |L6.108|
;;;340            release:
00006c  bf00              NOP      
                  |L6.110|
00006e  e7ca              B        |L6.6|
                  |L6.112|
000070  bf00              NOP                            ;322
;;;341            pr_debug("sdio_release_host\n");
;;;342        }
;;;343    
;;;344        lbs_deb_cmd_leave(LBS_DEB_SDIO);
;;;345    }
000072  bd7f              POP      {r0-r6,pc}
;;;346    
                          ENDP


                          AREA ||i.if_sdio_interrupt||, CODE, READONLY, ALIGN=2

                  if_sdio_interrupt PROC
;;;477    
;;;478    void if_sdio_interrupt(struct sdio_func *func)
000000  b5f8              PUSH     {r3-r7,lr}
;;;479    {
000002  4606              MOV      r6,r0
;;;480        int ret;
;;;481        struct if_sdio_card *card;
;;;482        u8 cause;
;;;483    
;;;484        //pr_sdio_interrupt("enter marvel sdio interrupt process!\n");
;;;485        card = sdio_get_drvdata(func);
000004  6874              LDR      r4,[r6,#4]
;;;486    
;;;487        cause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);
000006  466a              MOV      r2,sp
000008  2105              MOVS     r1,#5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       sdio_readb
000010  4605              MOV      r5,r0
;;;488        //读取中断状态，这个是网卡内部的中断状态寄存器,和sdio控制器的中断状态寄存器没有关系
;;;489        if (ret)
000012  9800              LDR      r0,[sp,#0]
000014  b100              CBZ      r0,|L7.24|
;;;490            goto out;
000016  e01d              B        |L7.84|
                  |L7.24|
;;;491    
;;;492        pr_sdio_interrupt("interrupt: 0x%X\n", (unsigned)cause);
;;;493    
;;;494        sdio_writeb(card->func, ~cause, IF_SDIO_H_INT_STATUS, &ret);//请中断挂起标志位
000018  466b              MOV      r3,sp
00001a  2205              MOVS     r2,#5
00001c  43e9              MVNS     r1,r5
00001e  b2c9              UXTB     r1,r1
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       sdio_writeb
;;;495        if (ret)
000026  9800              LDR      r0,[sp,#0]
000028  b100              CBZ      r0,|L7.44|
;;;496            goto out;
00002a  e013              B        |L7.84|
                  |L7.44|
;;;497    
;;;498        /*
;;;499    	 * Ignore the define name, this really means the card has
;;;500    	 * successfully received the command.
;;;501    	 */
;;;502        if (cause & IF_SDIO_H_INT_DNLD)//卡响应命令产生的中断，表明卡正常接收到命令
00002c  f0150f02          TST      r5,#2
000030  d003              BEQ      |L7.58|
;;;503            lbs_host_to_card_done(pgmarvel_priv);
000032  4809              LDR      r0,|L7.88|
000034  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
000036  f7fffffe          BL       lbs_host_to_card_done
                  |L7.58|
;;;504    
;;;505    
;;;506        if (cause & IF_SDIO_H_INT_UPLD) {//卡要求传输数据产生的中断
00003a  f0150f01          TST      r5,#1
00003e  d006              BEQ      |L7.78|
;;;507            ret = if_sdio_card_to_host(card);//读取数据进行相应的处理
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       if_sdio_card_to_host
000046  9000              STR      r0,[sp,#0]
;;;508            //还有个if_sdio_host_to_card与之对应，用来向设备发送数据，他的处理是依靠packet_worker工作队列
;;;509            if (ret)
000048  9800              LDR      r0,[sp,#0]
00004a  b100              CBZ      r0,|L7.78|
;;;510                goto out;
00004c  e002              B        |L7.84|
                  |L7.78|
;;;511        }
;;;512    
;;;513        ret = 0;
00004e  2000              MOVS     r0,#0
000050  9000              STR      r0,[sp,#0]
;;;514    
;;;515        out:
000052  bf00              NOP      
                  |L7.84|
;;;516        //pr_sdio_interrupt("leave sdio interrupt ret %d\n", ret);
;;;517        lbs_deb_cmd_leave("123");
;;;518    }
000054  bdf8              POP      {r3-r7,pc}
;;;519    
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      pgmarvel_priv

                          AREA ||i.if_sdio_probe||, CODE, READONLY, ALIGN=2

                  if_sdio_probe PROC
;;;768    static struct if_sdio_card gmarvel_ifsdio_card;
;;;769    struct lbs_private *if_sdio_probe(struct sdio_func *func,struct sdio_device_id *id)//枚举网卡
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;770    {
000004  4606              MOV      r6,r0
000006  468a              MOV      r10,r1
;;;771        struct kfifo gmarvel_event_fifo={0,0};
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
00000c  9002              STR      r0,[sp,#8]
;;;772        struct if_sdio_card *card;
;;;773        struct lbs_private *priv;
;;;774        int ret=0, i;
00000e  9000              STR      r0,[sp,#0]
;;;775        unsigned int model;
;;;776        u16 scratch;
;;;777        for (i = 0;i < func->card->num_info;i++) {
000010  2700              MOVS     r7,#0
000012  e018              B        |L8.70|
                  |L8.20|
;;;778            pr_debug("card infomation string(%d):%s \n",i,func->card->info[i]);
;;;779            if (strcmp(func->card->info[i],"ID: 04") ==0){//这里指针对本网卡进行这种判读
000014  6831              LDR      r1,[r6,#0]
000016  f8d110cc          LDR      r1,[r1,#0xcc]
00001a  f8510027          LDR      r0,[r1,r7,LSL #2]
00001e  a161              ADR      r1,|L8.420|
000020  f7fffffe          BL       strcmp
000024  b910              CBNZ     r0,|L8.44|
;;;780                model = IF_SDIO_MODEL_8385;
000026  f04f0804          MOV      r8,#4
;;;781                break;
00002a  e011              B        |L8.80|
                  |L8.44|
;;;782            }
;;;783            else if(strcmp(func->card->info[i],"802.11 SDIO ID: 0B") ==0){
00002c  6831              LDR      r1,[r6,#0]
00002e  f8d110cc          LDR      r1,[r1,#0xcc]
000032  f8510027          LDR      r0,[r1,r7,LSL #2]
000036  a15d              ADR      r1,|L8.428|
000038  f7fffffe          BL       strcmp
00003c  b910              CBNZ     r0,|L8.68|
;;;784                model = IF_SDIO_MODEL_8686;
00003e  f04f080b          MOV      r8,#0xb
;;;785                break;
000042  e005              B        |L8.80|
                  |L8.68|
000044  1c7f              ADDS     r7,r7,#1              ;777
                  |L8.70|
000046  6830              LDR      r0,[r6,#0]            ;777
000048  f8d000c8          LDR      r0,[r0,#0xc8]         ;777
00004c  42b8              CMP      r0,r7                 ;777
00004e  d8e1              BHI      |L8.20|
                  |L8.80|
000050  bf00              NOP                            ;781
;;;786            }
;;;787        }
;;;788    
;;;789        if (i == func->card->num_info) {
000052  6830              LDR      r0,[r6,#0]
000054  f8d000c8          LDR      r0,[r0,#0xc8]
000058  42b8              CMP      r0,r7
00005a  d105              BNE      |L8.104|
;;;790            pr_err("unable to identify card model\n");
00005c  a058              ADR      r0,|L8.448|
00005e  f7fffffe          BL       __2printf
;;;791            return (struct lbs_private *)0;
000062  2000              MOVS     r0,#0
                  |L8.100|
;;;792        }
;;;793        card = &gmarvel_ifsdio_card;
;;;794        memset(card,0,sizeof(struct if_sdio_card));
;;;795        card->func = func;
;;;796        card->model = model;
;;;797    
;;;798        switch (card->model) {
;;;799        case IF_SDIO_MODEL_8385:
;;;800            card->scratch_reg = IF_SDIO_SCRATCH_OLD;//sdio wifi给出的一个状态寄存器接口
;;;801            break;
;;;802        case IF_SDIO_MODEL_8686:
;;;803            card->scratch_reg = IF_SDIO_SCRATCH;
;;;804            break;
;;;805        case IF_SDIO_MODEL_8688:
;;;806        default: /* for newer chipsets */
;;;807            card->scratch_reg = IF_SDIO_FW_STATUS;
;;;808            break;
;;;809        }
;;;810        card->helper=&help_firmware;
;;;811        card->firmware=&marvel_firmware;
;;;812    
;;;813        ret = sdio_enable_func(func);//使能sdio设备工作
;;;814        if (ret)
;;;815            goto release;
;;;816    
;;;817        ret = sdio_claim_irq(func, if_sdio_interrupt);//申请SDIO中断，很重要(继续跟进if_sdio_interrupt)
;;;818        if (ret)
;;;819            goto disable;
;;;820    
;;;821        card->ioport = sdio_readb(func, IF_SDIO_IOPORT, &ret);//读写数据包的地址，有点类似以太网卡的dma地址reg10
;;;822        if (ret)
;;;823            goto release_int;
;;;824    
;;;825        card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 1, &ret) << 8;
;;;826        if (ret)
;;;827            goto release_int;
;;;828    
;;;829        card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 2, &ret) << 16;
;;;830        if (ret)
;;;831            goto release_int;
;;;832        sdio_set_drvdata(func, card);
;;;833        pr_debug("class = 0x%X, vendor = 0x%X, "
;;;834                 "device = 0x%X, model = 0x%X, ioport = 0x%X\n",
;;;835                 func->class, func->vendor, func->device,
;;;836                 model, (unsigned)card->ioport);
;;;837    
;;;838        ret = if_sdio_prog_firmware(card);//通过sdio下载固件
;;;839        if (ret)
;;;840            goto reclaim;
;;;841        priv = lbs_add_card(card);//分配net_device结构，并初始化priv的相关软件内容，按装主服务线程
;;;842        if (!priv) {
;;;843            ret = -ENOMEM;
;;;844            goto reclaim;
;;;845        }
;;;846        pgmarvel_priv=priv;
;;;847        card->priv = priv;
;;;848        priv->event_fifo=&gmarvel_event_fifo;
;;;849        priv->card = card;
;;;850        priv->hw_host_to_card = if_sdio_host_to_card;//封装数据包，启动card->packet_worker工作队列向硬件发送数据
;;;851        priv->fw_ready = 1;//标识固件准备好
;;;852        card->rx_unit = 0;
;;;853        /** Enable interrupts now that everything is set up*/
;;;854        /*下面这段是遇到问题的调试代码*/
;;;855        lbs_deb_sdio("read firmware verison!\n");
;;;856        scratch = if_sdio_read_scratch(card, &ret);//读固件版本状态
;;;857        if (ret)
;;;858            goto out;
;;;859        lbs_deb_sdio("firmware status = %#x\n", scratch);
;;;860        if (scratch == IF_SDIO_FIRMWARE_OK)
;;;861            lbs_deb_sdio("firmware already loaded\n");
;;;862        lbs_pr_err("enable interrupt!\n");
;;;863    
;;;864        sdio_writeb(func, 0x0f, IF_SDIO_H_INT_MASK, &ret);//使能网卡芯片sdio中断
;;;865        if (ret)
;;;866            goto reclaim;
;;;867        lbs_deb_sdio("read interrupt mask reg=0x%x\n",sdio_readb(func,IF_SDIO_H_INT_MASK,&ret));
;;;868        ret = lbs_start_card(priv);//注册网络设备，初始化相关参数
;;;869        if (ret)
;;;870            goto err_activate_card;
;;;871    
;;;872        out:
;;;873        pr_debug("probe card return(ret=%d)\n",ret);
;;;874        printk("\r\nWait for scan...\r\n");
;;;875        mdelay(10);
;;;876        if(ret)
;;;877            return (struct lbs_private *)0;
;;;878        else
;;;879            return (struct lbs_private *)(priv);//修改后的程序会返回一个私有变量给main
;;;880    
;;;881        err_activate_card:
;;;882        reclaim:
;;;883        release_int:
;;;884        disable:
;;;885        release:
;;;886        goto out;
;;;887    }
000064  e8bd8ffe          POP      {r1-r11,pc}
                  |L8.104|
000068  4c5d              LDR      r4,|L8.480|
00006a  f2406164          MOV      r1,#0x664             ;794
00006e  4620              MOV      r0,r4                 ;794
000070  f7fffffe          BL       __aeabi_memclr4
000074  6026              STR      r6,[r4,#0]            ;795
000076  f8c48008          STR      r8,[r4,#8]            ;796
00007a  68a0              LDR      r0,[r4,#8]            ;798
00007c  2804              CMP      r0,#4                 ;798
00007e  d004              BEQ      |L8.138|
000080  280b              CMP      r0,#0xb               ;798
000082  d006              BEQ      |L8.146|
000084  2810              CMP      r0,#0x10              ;798
000086  d107              BNE      |L8.152|
000088  e007              B        |L8.154|
                  |L8.138|
00008a  f24800fe          MOV      r0,#0x80fe            ;800
00008e  6120              STR      r0,[r4,#0x10]         ;800
000090  e006              B        |L8.160|
                  |L8.146|
000092  2034              MOVS     r0,#0x34              ;803
000094  6120              STR      r0,[r4,#0x10]         ;803
000096  e003              B        |L8.160|
                  |L8.152|
000098  bf00              NOP                            ;805
                  |L8.154|
00009a  2040              MOVS     r0,#0x40              ;807
00009c  6120              STR      r0,[r4,#0x10]         ;807
00009e  bf00              NOP                            ;808
                  |L8.160|
0000a0  bf00              NOP                            ;801
0000a2  4850              LDR      r0,|L8.484|
0000a4  6160              STR      r0,[r4,#0x14]         ;810
0000a6  4850              LDR      r0,|L8.488|
0000a8  61a0              STR      r0,[r4,#0x18]         ;811
0000aa  4630              MOV      r0,r6                 ;813
0000ac  f7fffffe          BL       sdio_enable_func
0000b0  9000              STR      r0,[sp,#0]            ;813
0000b2  9800              LDR      r0,[sp,#0]            ;814
0000b4  b100              CBZ      r0,|L8.184|
0000b6  e073              B        |L8.416|
                  |L8.184|
0000b8  494c              LDR      r1,|L8.492|
0000ba  4630              MOV      r0,r6                 ;817
0000bc  f7fffffe          BL       sdio_claim_irq
0000c0  9000              STR      r0,[sp,#0]            ;817
0000c2  9800              LDR      r0,[sp,#0]            ;818
0000c4  b100              CBZ      r0,|L8.200|
0000c6  e06a              B        |L8.414|
                  |L8.200|
0000c8  466a              MOV      r2,sp                 ;821
0000ca  2100              MOVS     r1,#0                 ;821
0000cc  4630              MOV      r0,r6                 ;821
0000ce  f7fffffe          BL       sdio_readb
0000d2  60e0              STR      r0,[r4,#0xc]          ;821
0000d4  9800              LDR      r0,[sp,#0]            ;822
0000d6  b100              CBZ      r0,|L8.218|
0000d8  e060              B        |L8.412|
                  |L8.218|
0000da  466a              MOV      r2,sp                 ;825
0000dc  2101              MOVS     r1,#1                 ;825
0000de  4630              MOV      r0,r6                 ;825
0000e0  f7fffffe          BL       sdio_readb
0000e4  68e1              LDR      r1,[r4,#0xc]          ;825
0000e6  ea412000          ORR      r0,r1,r0,LSL #8       ;825
0000ea  60e0              STR      r0,[r4,#0xc]          ;825
0000ec  9800              LDR      r0,[sp,#0]            ;826
0000ee  b100              CBZ      r0,|L8.242|
0000f0  e054              B        |L8.412|
                  |L8.242|
0000f2  466a              MOV      r2,sp                 ;829
0000f4  2102              MOVS     r1,#2                 ;829
0000f6  4630              MOV      r0,r6                 ;829
0000f8  f7fffffe          BL       sdio_readb
0000fc  68e1              LDR      r1,[r4,#0xc]          ;829
0000fe  ea414000          ORR      r0,r1,r0,LSL #16      ;829
000102  60e0              STR      r0,[r4,#0xc]          ;829
000104  9800              LDR      r0,[sp,#0]            ;830
000106  b100              CBZ      r0,|L8.266|
000108  e048              B        |L8.412|
                  |L8.266|
00010a  6074              STR      r4,[r6,#4]            ;832
00010c  4620              MOV      r0,r4                 ;838
00010e  f7fffffe          BL       if_sdio_prog_firmware
000112  9000              STR      r0,[sp,#0]            ;838
000114  9800              LDR      r0,[sp,#0]            ;839
000116  b100              CBZ      r0,|L8.282|
000118  e03f              B        |L8.410|
                  |L8.282|
00011a  4620              MOV      r0,r4                 ;841
00011c  f7fffffe          BL       lbs_add_card
000120  4605              MOV      r5,r0                 ;841
000122  b91d              CBNZ     r5,|L8.300|
000124  f06f000b          MVN      r0,#0xb               ;843
000128  9000              STR      r0,[sp,#0]            ;843
00012a  e036              B        |L8.410|
                  |L8.300|
00012c  4830              LDR      r0,|L8.496|
00012e  6005              STR      r5,[r0,#0]            ;846  ; pgmarvel_priv
000130  6065              STR      r5,[r4,#4]            ;847
000132  a801              ADD      r0,sp,#4              ;848
000134  f8c50094          STR      r0,[r5,#0x94]         ;848
000138  62ac              STR      r4,[r5,#0x28]         ;849
00013a  482e              LDR      r0,|L8.500|
00013c  6568              STR      r0,[r5,#0x54]         ;850
00013e  2001              MOVS     r0,#1                 ;851
000140  f8850494          STRB     r0,[r5,#0x494]        ;851
000144  2000              MOVS     r0,#0                 ;852
000146  7720              STRB     r0,[r4,#0x1c]         ;852
000148  4669              MOV      r1,sp                 ;856
00014a  4620              MOV      r0,r4                 ;856
00014c  f7fffffe          BL       if_sdio_read_scratch
000150  4681              MOV      r9,r0                 ;856
000152  9800              LDR      r0,[sp,#0]            ;857
000154  b100              CBZ      r0,|L8.344|
000156  e013              B        |L8.384|
                  |L8.344|
000158  a027              ADR      r0,|L8.504|
00015a  f7fffffe          BL       __2printf
00015e  466b              MOV      r3,sp                 ;864
000160  2204              MOVS     r2,#4                 ;864
000162  210f              MOVS     r1,#0xf               ;864
000164  4630              MOV      r0,r6                 ;864
000166  f7fffffe          BL       sdio_writeb
00016a  9800              LDR      r0,[sp,#0]            ;865
00016c  b100              CBZ      r0,|L8.368|
00016e  e014              B        |L8.410|
                  |L8.368|
000170  4628              MOV      r0,r5                 ;868
000172  f7fffffe          BL       lbs_start_card
000176  9000              STR      r0,[sp,#0]            ;868
000178  9800              LDR      r0,[sp,#0]            ;869
00017a  b100              CBZ      r0,|L8.382|
00017c  e00c              B        |L8.408|
                  |L8.382|
00017e  bf00              NOP                            ;872
                  |L8.384|
000180  a022              ADR      r0,|L8.524|
000182  f7fffffe          BL       __2printf
000186  200a              MOVS     r0,#0xa               ;875
000188  f7fffffe          BL       mdelay
00018c  9800              LDR      r0,[sp,#0]            ;876
00018e  b108              CBZ      r0,|L8.404|
000190  2000              MOVS     r0,#0                 ;877
000192  e767              B        |L8.100|
                  |L8.404|
000194  4628              MOV      r0,r5                 ;879
000196  e765              B        |L8.100|
                  |L8.408|
000198  bf00              NOP                            ;882
                  |L8.410|
00019a  bf00              NOP                            ;883
                  |L8.412|
00019c  bf00              NOP                            ;884
                  |L8.414|
00019e  bf00              NOP                            ;885
                  |L8.416|
0001a0  e7ee              B        |L8.384|
;;;888    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L8.420|
0001a4  49443a20          DCB      "ID: 04",0
0001a8  303400  
0001ab  00                DCB      0
                  |L8.428|
0001ac  3830322e          DCB      "802.11 SDIO ID: 0B",0
0001b0  31312053
0001b4  44494f20
0001b8  49443a20
0001bc  304200  
0001bf  00                DCB      0
                  |L8.448|
0001c0  756e6162          DCB      "unable to identify card model\n",0
0001c4  6c652074
0001c8  6f206964
0001cc  656e7469
0001d0  66792063
0001d4  61726420
0001d8  6d6f6465
0001dc  6c0a00  
0001df  00                DCB      0
                  |L8.480|
                          DCD      gmarvel_ifsdio_card
                  |L8.484|
                          DCD      help_firmware
                  |L8.488|
                          DCD      marvel_firmware
                  |L8.492|
                          DCD      if_sdio_interrupt
                  |L8.496|
                          DCD      pgmarvel_priv
                  |L8.500|
                          DCD      if_sdio_host_to_card
                  |L8.504|
0001f8  656e6162          DCB      "enable interrupt!\n",0
0001fc  6c652069
000200  6e746572
000204  72757074
000208  210a00  
00020b  00                DCB      0
                  |L8.524|
00020c  0d0a5761          DCB      "\r\nWait for scan...\r\n",0
000210  69742066
000214  6f722073
000218  63616e2e
00021c  2e2e0d0a
000220  00      
000221  00                DCB      0
000222  00                DCB      0
000223  00                DCB      0

                          AREA ||i.if_sdio_prog_firmware||, CODE, READONLY, ALIGN=2

                  if_sdio_prog_firmware PROC
;;;729    
;;;730    static int if_sdio_prog_firmware(struct if_sdio_card *card)
000000  b538              PUSH     {r3-r5,lr}
;;;731    {
000002  4604              MOV      r4,r0
;;;732        int ret;
;;;733        u16 scratch;
;;;734        sdio_sys_wait=0;
000004  2000              MOVS     r0,#0
000006  4918              LDR      r1,|L9.104|
000008  7008              STRB     r0,[r1,#0]
;;;735        scratch = if_sdio_read_scratch(card, &ret);//读固件版本状态
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       if_sdio_read_scratch
000012  4605              MOV      r5,r0
;;;736        if (ret)
000014  9800              LDR      r0,[sp,#0]
000016  b100              CBZ      r0,|L9.26|
;;;737            goto out;
000018  e021              B        |L9.94|
                  |L9.26|
;;;738    
;;;739        lbs_deb_sdio("firmware status = %#x\n", scratch);
;;;740    
;;;741        if (scratch == IF_SDIO_FIRMWARE_OK) {
00001a  f5a5407e          SUB      r0,r5,#0xfe00
00001e  38dc              SUBS     r0,r0,#0xdc
000020  d100              BNE      |L9.36|
;;;742            lbs_deb_sdio("firmware already loaded\n");
;;;743            goto success;
000022  e014              B        |L9.78|
                  |L9.36|
;;;744        }
;;;745    
;;;746        ret = if_sdio_prog_helper(card);//下载bootload
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       if_sdio_prog_helper
00002a  9000              STR      r0,[sp,#0]
;;;747        if (ret){
00002c  9800              LDR      r0,[sp,#0]
00002e  b118              CBZ      r0,|L9.56|
;;;748            pr_err("download help firmware failed!\n");
000030  a00e              ADR      r0,|L9.108|
000032  f7fffffe          BL       __2printf
;;;749            goto out;
000036  e012              B        |L9.94|
                  |L9.56|
;;;750        }
;;;751        ret = if_sdio_prog_real(card);//下载固件
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       if_sdio_prog_real
00003e  9000              STR      r0,[sp,#0]
;;;752        if (ret){
000040  9800              LDR      r0,[sp,#0]
000042  b118              CBZ      r0,|L9.76|
;;;753            pr_err("download marvel firmware failed!\n");
000044  a011              ADR      r0,|L9.140|
000046  f7fffffe          BL       __2printf
;;;754            goto out;
00004a  e008              B        |L9.94|
                  |L9.76|
;;;755        }
;;;756        success:
00004c  bf00              NOP      
                  |L9.78|
;;;757        sdio_set_block_size(card->func, IF_SDIO_BLOCK_SIZE);
00004e  f44f7180          MOV      r1,#0x100
000052  6820              LDR      r0,[r4,#0]
000054  f7fffffe          BL       sdio_set_block_size
;;;758        ret = 0;
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
;;;759    
;;;760        out:
00005c  bf00              NOP      
                  |L9.94|
;;;761        sdio_sys_wait=1;
00005e  2001              MOVS     r0,#1
000060  4901              LDR      r1,|L9.104|
000062  7008              STRB     r0,[r1,#0]
;;;762        return ret;
000064  9800              LDR      r0,[sp,#0]
;;;763    }
000066  bd38              POP      {r3-r5,pc}
;;;764    
                          ENDP

                  |L9.104|
                          DCD      sdio_sys_wait
                  |L9.108|
00006c  646f776e          DCB      "download help firmware failed!\n",0
000070  6c6f6164
000074  2068656c
000078  70206669
00007c  726d7761
000080  72652066
000084  61696c65
000088  64210a00
                  |L9.140|
00008c  646f776e          DCB      "download marvel firmware failed!\n",0
000090  6c6f6164
000094  206d6172
000098  76656c20
00009c  6669726d
0000a0  77617265
0000a4  20666169
0000a8  6c656421
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.if_sdio_prog_helper||, CODE, READONLY, ALIGN=2

                  if_sdio_prog_helper PROC
;;;523    
;;;524    static int if_sdio_prog_helper(struct if_sdio_card *card)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;525    {
000004  b095              SUB      sp,sp,#0x54
000006  4604              MOV      r4,r0
;;;526        int ret;
;;;527        u8 status;
;;;528        u8 tmp_buffer[64];
;;;529        const struct firmware *fw=card->helper;
000008  f8d4a014          LDR      r10,[r4,#0x14]
;;;530        unsigned long timeout;
;;;531        u8 *chunk_buffer=tmp_buffer;
00000c  ad04              ADD      r5,sp,#0x10
;;;532        u32 chunk_size;
;;;533        const u8 *firmware;
;;;534        u32 size;
;;;535    
;;;536        memset(chunk_buffer,0,64);
00000e  2140              MOVS     r1,#0x40
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       __aeabi_memclr
;;;537        ret = sdio_set_block_size(card->func, 32);
000016  2120              MOVS     r1,#0x20
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       sdio_set_block_size
00001e  9014              STR      r0,[sp,#0x50]
;;;538        if (ret)
000020  9814              LDR      r0,[sp,#0x50]
000022  b100              CBZ      r0,|L10.38|
;;;539            goto release;
000024  e082              B        |L10.300|
                  |L10.38|
;;;540        firmware = fw->data;//获取的固件数据
000026  f8da9004          LDR      r9,[r10,#4]
;;;541        size = fw->size;//获取的固件数据长度
00002a  f8da8000          LDR      r8,[r10,#0]
;;;542        while (size) {
00002e  e03e              B        |L10.174|
                  |L10.48|
;;;543            timeout = HZ;
000030  f44f707a          MOV      r0,#0x3e8
000034  9003              STR      r0,[sp,#0xc]
;;;544            while (1) {//读取SDIO状态,直到准备好
000036  e01b              B        |L10.112|
                  |L10.56|
;;;545                status = sdio_readb(card->func,IF_SDIO_STATUS, &ret);
000038  aa14              ADD      r2,sp,#0x50
00003a  2120              MOVS     r1,#0x20
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       sdio_readb
000042  4606              MOV      r6,r0
;;;546                if (ret)
000044  9814              LDR      r0,[sp,#0x50]
000046  b100              CBZ      r0,|L10.74|
;;;547                    goto release;
000048  e070              B        |L10.300|
                  |L10.74|
;;;548                if ((status & IF_SDIO_IO_RDY) &&
00004a  f0160f08          TST      r6,#8
00004e  d003              BEQ      |L10.88|
;;;549                    (status & IF_SDIO_DL_RDY))
000050  f0160f01          TST      r6,#1
000054  d000              BEQ      |L10.88|
;;;550                    break;
000056  e00c              B        |L10.114|
                  |L10.88|
;;;551                if (time_after(jiffies,&timeout)) {
000058  a903              ADD      r1,sp,#0xc
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       time_after
000060  b118              CBZ      r0,|L10.106|
;;;552                    ret = -ETIMEDOUT;
000062  f06f003b          MVN      r0,#0x3b
000066  9014              STR      r0,[sp,#0x50]
;;;553                    goto release;
000068  e060              B        |L10.300|
                  |L10.106|
;;;554                }
;;;555                mdelay(1);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       mdelay
                  |L10.112|
000070  e7e2              B        |L10.56|
                  |L10.114|
000072  bf00              NOP                            ;550
;;;556            }
;;;557    
;;;558            chunk_size = min(size, (size_t)60);
000074  f1b80f3c          CMP      r8,#0x3c
000078  d201              BCS      |L10.126|
00007a  4640              MOV      r0,r8
00007c  e000              B        |L10.128|
                  |L10.126|
00007e  203c              MOVS     r0,#0x3c
                  |L10.128|
000080  4607              MOV      r7,r0
;;;559            *((__le32*)chunk_buffer) = cpu_to_le32(chunk_size);//固件长度占4byte
000082  602f              STR      r7,[r5,#0]
;;;560            memcpy(chunk_buffer + 4, firmware, chunk_size);//固件信息
000084  463a              MOV      r2,r7
000086  4649              MOV      r1,r9
000088  1d28              ADDS     r0,r5,#4
00008a  f7fffffe          BL       __aeabi_memcpy
;;;561    
;;;562            pr_debug("sending %d bytes chunk\n", chunk_size);
;;;563            ret = sdio_writesb(card->func, card->ioport,
00008e  2340              MOVS     r3,#0x40
000090  e9cd5300          STRD     r5,r3,[sp,#0]
000094  2300              MOVS     r3,#0
000096  2101              MOVS     r1,#1
000098  68e2              LDR      r2,[r4,#0xc]
00009a  6820              LDR      r0,[r4,#0]
00009c  f7fffffe          BL       sdio_io_rw_ext_helper
0000a0  9014              STR      r0,[sp,#0x50]
;;;564                               chunk_buffer, 64);
;;;565            if (ret)
0000a2  9814              LDR      r0,[sp,#0x50]
0000a4  b100              CBZ      r0,|L10.168|
;;;566                goto release;
0000a6  e041              B        |L10.300|
                  |L10.168|
;;;567            firmware += chunk_size;
0000a8  44b9              ADD      r9,r9,r7
;;;568            size -= chunk_size;
0000aa  eba80807          SUB      r8,r8,r7
                  |L10.174|
0000ae  f1b80f00          CMP      r8,#0                 ;542
0000b2  d1bd              BNE      |L10.48|
;;;569        }
;;;570        /* an empty block marks the end of the transfer */
;;;571        memset(chunk_buffer, 0, 4);
0000b4  2000              MOVS     r0,#0
0000b6  6028              STR      r0,[r5,#0]
;;;572        ret = sdio_writesb(card->func, card->ioport, chunk_buffer, 64);
0000b8  2340              MOVS     r3,#0x40
0000ba  e9cd5300          STRD     r5,r3,[sp,#0]
0000be  2300              MOVS     r3,#0
0000c0  2101              MOVS     r1,#1
0000c2  68e2              LDR      r2,[r4,#0xc]
0000c4  6820              LDR      r0,[r4,#0]
0000c6  f7fffffe          BL       sdio_io_rw_ext_helper
0000ca  9014              STR      r0,[sp,#0x50]
;;;573        if (ret)
0000cc  9814              LDR      r0,[sp,#0x50]
0000ce  b100              CBZ      r0,|L10.210|
;;;574            goto release;
0000d0  e02c              B        |L10.300|
                  |L10.210|
;;;575    
;;;576        lbs_deb_sdio("waiting for helper to boot...\n");
;;;577    
;;;578        /* wait for the helper to boot by looking at the size register */
;;;579        timeout = jiffies + HZ;
0000d2  f44f707a          MOV      r0,#0x3e8
0000d6  9003              STR      r0,[sp,#0xc]
;;;580        while (1) {
0000d8  e023              B        |L10.290|
                  |L10.218|
;;;581            u16 req_size;
;;;582            req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
0000da  aa14              ADD      r2,sp,#0x50
0000dc  2110              MOVS     r1,#0x10
0000de  6820              LDR      r0,[r4,#0]
0000e0  f7fffffe          BL       sdio_readb
0000e4  4683              MOV      r11,r0
;;;583            if (ret)
0000e6  9814              LDR      r0,[sp,#0x50]
0000e8  b100              CBZ      r0,|L10.236|
;;;584                goto release;
0000ea  e01f              B        |L10.300|
                  |L10.236|
;;;585    
;;;586            req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
0000ec  aa14              ADD      r2,sp,#0x50
0000ee  2111              MOVS     r1,#0x11
0000f0  6820              LDR      r0,[r4,#0]
0000f2  f7fffffe          BL       sdio_readb
0000f6  ea4b2b00          ORR      r11,r11,r0,LSL #8
;;;587            if (ret)
0000fa  9814              LDR      r0,[sp,#0x50]
0000fc  b100              CBZ      r0,|L10.256|
;;;588            {
;;;589                goto release;
0000fe  e015              B        |L10.300|
                  |L10.256|
;;;590            }
;;;591    
;;;592            if (req_size != 0){
000100  f1bb0f00          CMP      r11,#0
000104  d000              BEQ      |L10.264|
;;;593                pr_debug("down help size=%d\n",req_size);
;;;594                break;
000106  e00d              B        |L10.292|
                  |L10.264|
;;;595            }
;;;596    
;;;597            if (time_after(jiffies, &timeout)) {
000108  a903              ADD      r1,sp,#0xc
00010a  2000              MOVS     r0,#0
00010c  f7fffffe          BL       time_after
000110  b118              CBZ      r0,|L10.282|
;;;598                ret = -ETIMEDOUT;
000112  f06f003b          MVN      r0,#0x3b
000116  9014              STR      r0,[sp,#0x50]
;;;599                goto release;
000118  e008              B        |L10.300|
                  |L10.282|
;;;600            }
;;;601    
;;;602            msleep(10);
00011a  200a              MOVS     r0,#0xa
00011c  f7fffffe          BL       mdelay
;;;603        }
000120  bf00              NOP      
                  |L10.290|
000122  e7da              B        |L10.218|
                  |L10.292|
000124  bf00              NOP                            ;594
;;;604    
;;;605        ret = 0;
000126  2000              MOVS     r0,#0
000128  9014              STR      r0,[sp,#0x50]
;;;606        release:
00012a  bf00              NOP      
                  |L10.300|
;;;607        pr_debug("sdio_release_host(card->func)\n");
;;;608        pr_debug("release_firmware(fw)\n");
;;;609        if (ret)
00012c  9814              LDR      r0,[sp,#0x50]
00012e  b110              CBZ      r0,|L10.310|
;;;610            lbs_pr_err("failed to load helper firmware\n");
000130  a003              ADR      r0,|L10.320|
000132  f7fffffe          BL       __2printf
                  |L10.310|
;;;611    
;;;612        lbs_deb_leave_args("leave if_sdio_prog_helper(ret=%d).\n", ret);
;;;613    
;;;614        return ret;
000136  9814              LDR      r0,[sp,#0x50]
;;;615    }
000138  b015              ADD      sp,sp,#0x54
00013a  e8bd8ff0          POP      {r4-r11,pc}
;;;616    
                          ENDP

00013e  0000              DCW      0x0000
                  |L10.320|
000140  6661696c          DCB      "failed to load helper firmware\n",0
000144  65642074
000148  6f206c6f
00014c  61642068
000150  656c7065
000154  72206669
000158  726d7761
00015c  72650a00

                          AREA ||i.if_sdio_prog_real||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  if_sdio_prog_real PROC
;;;617    
;;;618    static int if_sdio_prog_real(struct if_sdio_card *card)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;619    {
000004  f5ad7d05          SUB      sp,sp,#0x214
000008  4604              MOV      r4,r0
;;;620        int ret;
;;;621        u8 status;
;;;622        u8 tmp_buffer[512];
;;;623        const struct firmware *fw=card->firmware;
00000a  f8d4b018          LDR      r11,[r4,#0x18]
;;;624        unsigned long timeout;
;;;625        u8 *chunk_buffer;
;;;626        u32 chunk_size;
;;;627        const u8 *firmware;
;;;628        size_t size, req_size;
;;;629        u16 scratch;
;;;630        chunk_buffer=tmp_buffer;
00000e  a804              ADD      r0,sp,#0x10
000010  9002              STR      r0,[sp,#8]
;;;631        memset(chunk_buffer,0,512);
000012  f44f7100          MOV      r1,#0x200
000016  9802              LDR      r0,[sp,#8]
000018  f7fffffe          BL       __aeabi_memclr
;;;632        ret = sdio_set_block_size(card->func, 32);
00001c  2120              MOVS     r1,#0x20
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       sdio_set_block_size
000024  9084              STR      r0,[sp,#0x210]
;;;633        if (ret)
000026  9884              LDR      r0,[sp,#0x210]
000028  b100              CBZ      r0,|L11.44|
;;;634            goto release;
00002a  e099              B        |L11.352|
                  |L11.44|
;;;635    
;;;636        firmware = fw->data;
00002c  f8db9004          LDR      r9,[r11,#4]
;;;637        size = fw->size;
000030  f8db6000          LDR      r6,[r11,#0]
;;;638    
;;;639        printk("\r\n\r\nFirmware size=%d\r\n\r\n",size);
000034  4631              MOV      r1,r6
000036  a04f              ADR      r0,|L11.372|
000038  f7fffffe          BL       __2printf
;;;640    
;;;641        while (size) {
00003c  e067              B        |L11.270|
                  |L11.62|
;;;642            timeout = jiffies + HZ;
00003e  f44f707a          MOV      r0,#0x3e8
000042  9003              STR      r0,[sp,#0xc]
;;;643            while (1) {
000044  e01b              B        |L11.126|
                  |L11.70|
;;;644                status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
000046  aa84              ADD      r2,sp,#0x210
000048  2120              MOVS     r1,#0x20
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       sdio_readb
000050  4680              MOV      r8,r0
;;;645                if (ret)
000052  9884              LDR      r0,[sp,#0x210]
000054  b100              CBZ      r0,|L11.88|
;;;646                    goto release;
000056  e083              B        |L11.352|
                  |L11.88|
;;;647                if ((status & IF_SDIO_IO_RDY) &&
000058  f0180f08          TST      r8,#8
00005c  d003              BEQ      |L11.102|
;;;648                    (status & IF_SDIO_DL_RDY))
00005e  f0180f01          TST      r8,#1
000062  d000              BEQ      |L11.102|
;;;649                    break;
000064  e00c              B        |L11.128|
                  |L11.102|
;;;650                if (time_after(jiffies, &timeout)) {
000066  a903              ADD      r1,sp,#0xc
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       time_after
00006e  b118              CBZ      r0,|L11.120|
;;;651                    ret = -ETIMEDOUT;
000070  f06f003b          MVN      r0,#0x3b
000074  9084              STR      r0,[sp,#0x210]
;;;652                    goto release;
000076  e073              B        |L11.352|
                  |L11.120|
;;;653                }
;;;654                mdelay(1);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       mdelay
                  |L11.126|
00007e  e7e2              B        |L11.70|
                  |L11.128|
000080  bf00              NOP                            ;649
;;;655            }
;;;656    
;;;657            req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
000082  aa84              ADD      r2,sp,#0x210
000084  2110              MOVS     r1,#0x10
000086  6820              LDR      r0,[r4,#0]
000088  f7fffffe          BL       sdio_readb
00008c  4605              MOV      r5,r0
;;;658            if (ret)
00008e  9884              LDR      r0,[sp,#0x210]
000090  b100              CBZ      r0,|L11.148|
;;;659                goto release;
000092  e065              B        |L11.352|
                  |L11.148|
;;;660    
;;;661            req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
000094  aa84              ADD      r2,sp,#0x210
000096  2111              MOVS     r1,#0x11
000098  6820              LDR      r0,[r4,#0]
00009a  f7fffffe          BL       sdio_readb
00009e  ea452500          ORR      r5,r5,r0,LSL #8
;;;662            if (ret)
0000a2  9884              LDR      r0,[sp,#0x210]
0000a4  b100              CBZ      r0,|L11.168|
;;;663                goto release;
0000a6  e05b              B        |L11.352|
                  |L11.168|
;;;664    
;;;665            pr_debug("firmware wants %d bytes\n", (int)req_size);
;;;666            if (req_size == 0) {
0000a8  b91d              CBNZ     r5,|L11.178|
;;;667                lbs_deb_sdio("firmware helper gave up early\n");
;;;668                ret = -EIO;
0000aa  f06f0004          MVN      r0,#4
0000ae  9084              STR      r0,[sp,#0x210]
;;;669                goto release;
0000b0  e056              B        |L11.352|
                  |L11.178|
;;;670            }
;;;671    
;;;672            if (req_size & 0x01) {
0000b2  f0150f01          TST      r5,#1
0000b6  d003              BEQ      |L11.192|
;;;673                lbs_deb_sdio("firmware helper signalled error\n");
;;;674                ret = -EIO;
0000b8  f06f0004          MVN      r0,#4
0000bc  9084              STR      r0,[sp,#0x210]
;;;675                goto release;
0000be  e04f              B        |L11.352|
                  |L11.192|
;;;676            }
;;;677    
;;;678            if (req_size > size)
0000c0  42b5              CMP      r5,r6
0000c2  d900              BLS      |L11.198|
;;;679                req_size = size;
0000c4  4635              MOV      r5,r6
                  |L11.198|
;;;680    
;;;681            while (req_size) {
0000c6  e020              B        |L11.266|
                  |L11.200|
;;;682                chunk_size = min(req_size, (size_t)512);
0000c8  f5b57f00          CMP      r5,#0x200
0000cc  d201              BCS      |L11.210|
0000ce  4628              MOV      r0,r5
0000d0  e001              B        |L11.214|
                  |L11.210|
0000d2  f44f7000          MOV      r0,#0x200
                  |L11.214|
0000d6  4607              MOV      r7,r0
;;;683    
;;;684                memcpy(chunk_buffer, firmware, chunk_size);
0000d8  463a              MOV      r2,r7
0000da  4649              MOV      r1,r9
0000dc  9802              LDR      r0,[sp,#8]
0000de  f7fffffe          BL       __aeabi_memcpy
;;;685                pr_debug("sending %d bytes (%d bytes) chunk\n",
;;;686                         chunk_size, (chunk_size + 31) / 32 * 32);//必须32字节对齐
;;;687                ret = sdio_writesb(card->func, card->ioport,
0000e2  f107001f          ADD      r0,r7,#0x1f
0000e6  0940              LSRS     r0,r0,#5
0000e8  0143              LSLS     r3,r0,#5
0000ea  9a02              LDR      r2,[sp,#8]
0000ec  e9cd2300          STRD     r2,r3,[sp,#0]
0000f0  2300              MOVS     r3,#0
0000f2  2101              MOVS     r1,#1
0000f4  68e2              LDR      r2,[r4,#0xc]
0000f6  6820              LDR      r0,[r4,#0]
0000f8  f7fffffe          BL       sdio_io_rw_ext_helper
0000fc  9084              STR      r0,[sp,#0x210]
;;;688                                   chunk_buffer, roundup(chunk_size, 32));
;;;689                if (ret)
0000fe  9884              LDR      r0,[sp,#0x210]
000100  b100              CBZ      r0,|L11.260|
;;;690                    goto release;
000102  e02d              B        |L11.352|
                  |L11.260|
;;;691    
;;;692                firmware += chunk_size;
000104  44b9              ADD      r9,r9,r7
;;;693                size -= chunk_size;
000106  1bf6              SUBS     r6,r6,r7
;;;694                req_size -= chunk_size;
000108  1bed              SUBS     r5,r5,r7
                  |L11.266|
00010a  2d00              CMP      r5,#0                 ;681
00010c  d1dc              BNE      |L11.200|
                  |L11.270|
00010e  2e00              CMP      r6,#0                 ;641
000110  d195              BNE      |L11.62|
;;;695            }
;;;696        }
;;;697        ret = 0;
000112  2000              MOVS     r0,#0
000114  9084              STR      r0,[sp,#0x210]
;;;698        lbs_deb_sdio("waiting for firmware to boot...\n");
;;;699        /* wait for the firmware to boot */
;;;700        timeout = jiffies + HZ;
000116  f44f707a          MOV      r0,#0x3e8
00011a  9003              STR      r0,[sp,#0xc]
;;;701        while (1) {
00011c  e01b              B        |L11.342|
                  |L11.286|
;;;702    
;;;703            scratch = if_sdio_read_scratch(card, &ret);
00011e  a984              ADD      r1,sp,#0x210
000120  4620              MOV      r0,r4
000122  f7fffffe          BL       if_sdio_read_scratch
000126  4682              MOV      r10,r0
;;;704            if (ret)
000128  9884              LDR      r0,[sp,#0x210]
00012a  b100              CBZ      r0,|L11.302|
;;;705                goto release;
00012c  e018              B        |L11.352|
                  |L11.302|
;;;706    
;;;707            if (scratch == IF_SDIO_FIRMWARE_OK){
00012e  f5aa407e          SUB      r0,r10,#0xfe00
000132  38dc              SUBS     r0,r0,#0xdc
000134  d103              BNE      |L11.318|
;;;708                printk("program firmware success\n");
000136  a016              ADR      r0,|L11.400|
000138  f7fffffe          BL       __2printf
;;;709                break;
00013c  e00c              B        |L11.344|
                  |L11.318|
;;;710            }
;;;711    
;;;712            if (time_after(jiffies, &timeout)) {
00013e  a903              ADD      r1,sp,#0xc
000140  2000              MOVS     r0,#0
000142  f7fffffe          BL       time_after
000146  b118              CBZ      r0,|L11.336|
;;;713                ret = -ETIMEDOUT;
000148  f06f003b          MVN      r0,#0x3b
00014c  9084              STR      r0,[sp,#0x210]
;;;714                goto release;
00014e  e007              B        |L11.352|
                  |L11.336|
;;;715            }
;;;716    
;;;717            msleep(10);
000150  200a              MOVS     r0,#0xa
000152  f7fffffe          BL       mdelay
                  |L11.342|
000156  e7e2              B        |L11.286|
                  |L11.344|
000158  bf00              NOP                            ;709
;;;718        }
;;;719        ret = 0;
00015a  2000              MOVS     r0,#0
00015c  9084              STR      r0,[sp,#0x210]
;;;720    
;;;721        release:
00015e  bf00              NOP      
                  |L11.352|
;;;722        pr_debug("sdio_release_host(card->func)\n");
;;;723        pr_debug("release_firmware(fw)\n");
;;;724        if (ret)
000160  9884              LDR      r0,[sp,#0x210]
000162  b110              CBZ      r0,|L11.362|
;;;725            lbs_pr_err("failed to load firmware\n");
000164  a011              ADR      r0,|L11.428|
000166  f7fffffe          BL       __2printf
                  |L11.362|
;;;726        lbs_deb_leave_args("leave if_sdio_prog_real(ret=%d)\n", ret);
;;;727        return ret;
00016a  9884              LDR      r0,[sp,#0x210]
;;;728    }
00016c  f50d7d05          ADD      sp,sp,#0x214
000170  e8bd8ff0          POP      {r4-r11,pc}
;;;729    
                          ENDP

                  |L11.372|
000174  0d0a0d0a          DCB      "\r\n\r\nFirmware size=%d\r\n\r\n",0
000178  4669726d
00017c  77617265
000180  2073697a
000184  653d2564
000188  0d0a0d0a
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L11.400|
000190  70726f67          DCB      "program firmware success\n",0
000194  72616d20
000198  6669726d
00019c  77617265
0001a0  20737563
0001a4  63657373
0001a8  0a00    
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L11.428|
0001ac  6661696c          DCB      "failed to load firmware\n",0
0001b0  65642074
0001b4  6f206c6f
0001b8  61642066
0001bc  69726d77
0001c0  6172650a
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0

                          AREA ||i.if_sdio_read_rx_len||, CODE, READONLY, ALIGN=1

                  if_sdio_read_rx_len PROC
;;;83     
;;;84     static u16 if_sdio_read_rx_len(struct if_sdio_card *card, int *err)
000000  b5f8              PUSH     {r3-r7,lr}
;;;85     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;86         int ret;
;;;87         u16 rx_len;
;;;88     
;;;89         switch (card->model) {
000006  68a0              LDR      r0,[r4,#8]
000008  2804              CMP      r0,#4
00000a  d004              BEQ      |L12.22|
00000c  280b              CMP      r0,#0xb
00000e  d003              BEQ      |L12.24|
000010  2810              CMP      r0,#0x10
000012  d107              BNE      |L12.36|
000014  e007              B        |L12.38|
                  |L12.22|
;;;90         case IF_SDIO_MODEL_8385:
;;;91         case IF_SDIO_MODEL_8686:
000016  bf00              NOP      
                  |L12.24|
;;;92             rx_len = if_sdio_read_scratch(card, &ret);//读取scratch reg获取接收数据的长度
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       if_sdio_read_scratch
000020  4605              MOV      r5,r0
;;;93             break;
000022  e010              B        |L12.70|
                  |L12.36|
;;;94         case IF_SDIO_MODEL_8688:
000024  bf00              NOP      
                  |L12.38|
;;;95         default: /* for newer chipsets */
;;;96             rx_len = sdio_readb(card->func, IF_SDIO_RX_LEN, &ret);
000026  466a              MOV      r2,sp
000028  2142              MOVS     r1,#0x42
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       sdio_readb
000030  4605              MOV      r5,r0
;;;97             if (!ret)
000032  9800              LDR      r0,[sp,#0]
000034  b920              CBNZ     r0,|L12.64|
;;;98                 rx_len <<= card->rx_unit;
000036  7f20              LDRB     r0,[r4,#0x1c]
000038  fa05f000          LSL      r0,r5,r0
00003c  b285              UXTH     r5,r0
00003e  e001              B        |L12.68|
                  |L12.64|
;;;99             else
;;;100                rx_len = 0xffff;	/* invalid length */
000040  f64f75ff          MOV      r5,#0xffff
                  |L12.68|
;;;101    
;;;102            break;
000044  bf00              NOP      
                  |L12.70|
000046  bf00              NOP                            ;93
;;;103        }
;;;104    
;;;105        if (err)
000048  b10e              CBZ      r6,|L12.78|
;;;106            *err = ret;
00004a  9800              LDR      r0,[sp,#0]
00004c  6030              STR      r0,[r6,#0]
                  |L12.78|
;;;107    
;;;108        return rx_len;
00004e  4628              MOV      r0,r5
;;;109    }
000050  bdf8              POP      {r3-r7,pc}
;;;110    
                          ENDP


                          AREA ||i.if_sdio_read_scratch||, CODE, READONLY, ALIGN=1

                  if_sdio_read_scratch PROC
;;;63      */
;;;64     static u16 if_sdio_read_scratch(struct if_sdio_card *card, int *err)
000000  b5f8              PUSH     {r3-r7,lr}
;;;65     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;66         int ret;
;;;67         u16 scratch;
;;;68     
;;;69         scratch = sdio_readb(card->func, card->scratch_reg, &ret);
000006  466a              MOV      r2,sp
000008  6921              LDR      r1,[r4,#0x10]
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       sdio_readb
000010  4606              MOV      r6,r0
;;;70         if (!ret)
000012  9800              LDR      r0,[sp,#0]
000014  b938              CBNZ     r0,|L13.38|
;;;71             scratch |= sdio_readb(card->func, card->scratch_reg + 1,
000016  6922              LDR      r2,[r4,#0x10]
000018  1c51              ADDS     r1,r2,#1
00001a  466a              MOV      r2,sp
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       sdio_readb
000022  ea462600          ORR      r6,r6,r0,LSL #8
                  |L13.38|
;;;72                                   &ret) << 8;
;;;73     
;;;74         if (err)
000026  b10d              CBZ      r5,|L13.44|
;;;75             *err = ret;
000028  9800              LDR      r0,[sp,#0]
00002a  6028              STR      r0,[r5,#0]
                  |L13.44|
;;;76     
;;;77         if (ret)
00002c  9800              LDR      r0,[sp,#0]
00002e  b110              CBZ      r0,|L13.54|
;;;78             return 0xffff;
000030  f64f70ff          MOV      r0,#0xffff
                  |L13.52|
;;;79     
;;;80         return scratch;
;;;81     }
000034  bdf8              POP      {r3-r7,pc}
                  |L13.54|
000036  4630              MOV      r0,r6                 ;80
000038  e7fc              B        |L13.52|
;;;82     
                          ENDP


                          AREA ||i.if_sdio_send_data||, CODE, READONLY, ALIGN=1

                  if_sdio_send_data PROC
;;;429    
;;;430    int if_sdio_send_data(struct lbs_private *priv, u8 *buf, u16 nb)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;431    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;432        int ret;
;;;433        unsigned long timeout;
;;;434        u8 status;
;;;435        struct if_sdio_card *card;
;;;436        u16 size;
;;;437        card = priv->card;
00000a  f8d86028          LDR      r6,[r8,#0x28]
;;;438        size = sdio_align_size(card->func, nb + 4);//主机优化对齐
00000e  1d29              ADDS     r1,r5,#4
000010  6830              LDR      r0,[r6,#0]
000012  f7fffffe          BL       sdio_align_size
000016  fa1ff980          UXTH     r9,r0
;;;439        buf[0] = (nb + 4) & 0xff;
00001a  1d28              ADDS     r0,r5,#4
00001c  7020              STRB     r0,[r4,#0]
;;;440        buf[1] = ((nb + 4) >> 8) & 0xff;
00001e  0a00              LSRS     r0,r0,#8
000020  7060              STRB     r0,[r4,#1]
;;;441        buf[2] = MVMS_DAT;
000022  2000              MOVS     r0,#0
000024  70a0              STRB     r0,[r4,#2]
;;;442        buf[3] = 0;//sdio硬件要求的头信息，buffer在这里是个零长数组
000026  70e0              STRB     r0,[r4,#3]
;;;443        timeout = jiffies + HZ;
000028  f44f707a          MOV      r0,#0x3e8
00002c  9002              STR      r0,[sp,#8]
;;;444        while (1) {
00002e  e018              B        |L14.98|
                  |L14.48|
;;;445            status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
000030  aa03              ADD      r2,sp,#0xc
000032  2120              MOVS     r1,#0x20
000034  6830              LDR      r0,[r6,#0]
000036  f7fffffe          BL       sdio_readb
00003a  4607              MOV      r7,r0
;;;446            if (ret)
00003c  9803              LDR      r0,[sp,#0xc]
00003e  b100              CBZ      r0,|L14.66|
;;;447                goto out;
000040  e020              B        |L14.132|
                  |L14.66|
;;;448            if (status & IF_SDIO_IO_RDY)//读取状态直到IO准备完成，但是有个超时值
000042  f0170f08          TST      r7,#8
000046  d000              BEQ      |L14.74|
;;;449                break;
000048  e00c              B        |L14.100|
                  |L14.74|
;;;450            if (time_after(jiffies, &timeout)) {
00004a  a902              ADD      r1,sp,#8
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       time_after
000052  b118              CBZ      r0,|L14.92|
;;;451                ret = -ETIMEDOUT;
000054  f06f003b          MVN      r0,#0x3b
000058  9003              STR      r0,[sp,#0xc]
;;;452                goto out;
00005a  e013              B        |L14.132|
                  |L14.92|
;;;453            }
;;;454            mdelay(1);
00005c  2001              MOVS     r0,#1
00005e  f7fffffe          BL       mdelay
                  |L14.98|
000062  e7e5              B        |L14.48|
                  |L14.100|
000064  bf00              NOP                            ;449
;;;455        }
;;;456        ret = sdio_writesb(card->func, card->ioport,
000066  e9cd4900          STRD     r4,r9,[sp,#0]
00006a  2300              MOVS     r3,#0
00006c  2101              MOVS     r1,#1
00006e  68f2              LDR      r2,[r6,#0xc]
000070  6830              LDR      r0,[r6,#0]
000072  f7fffffe          BL       sdio_io_rw_ext_helper
000076  9003              STR      r0,[sp,#0xc]
;;;457                           buf, size);//将数据写入sd卡
;;;458        if (ret)
000078  9803              LDR      r0,[sp,#0xc]
00007a  b100              CBZ      r0,|L14.126|
;;;459            goto out;
00007c  e002              B        |L14.132|
                  |L14.126|
;;;460        lbs_deb_cmd_leave(LBS_DEB_SDIO);
;;;461        ret = 0;
00007e  2000              MOVS     r0,#0
000080  9003              STR      r0,[sp,#0xc]
;;;462        out:
000082  bf00              NOP      
                  |L14.132|
;;;463        lbs_deb_cmd_leave_args("leave if_sdio_host_to_card(ret=%d)\n", ret);
;;;464        return ret;
000084  9803              LDR      r0,[sp,#0xc]
;;;465    }
000086  b004              ADD      sp,sp,#0x10
000088  e8bd87f0          POP      {r4-r10,pc}
;;;466    
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.pool_sdio_interrupt||, CODE, READONLY, ALIGN=1

                  pool_sdio_interrupt PROC
;;;915    
;;;916    int pool_sdio_interrupt(struct sdio_func *func)
000000  b538              PUSH     {r3-r5,lr}
;;;917    {
000002  4604              MOV      r4,r0
;;;918        int ret;
;;;919        u8 cause;
;;;920        cause=sdio_readb(func, IF_SDIO_H_INT_STATUS, &ret);
000004  466a              MOV      r2,sp
000006  2105              MOVS     r1,#5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       sdio_readb
00000e  4605              MOV      r5,r0
;;;921        if (ret)
000010  9800              LDR      r0,[sp,#0]
000012  b110              CBZ      r0,|L16.26|
;;;922            return -EIO;
000014  f06f0004          MVN      r0,#4
                  |L16.24|
;;;923        return cause;
;;;924    
;;;925    }
000018  bd38              POP      {r3-r5,pc}
                  |L16.26|
00001a  4628              MOV      r0,r5                 ;923
00001c  e7fc              B        |L16.24|
;;;926    
                          ENDP


                          AREA ||i.wireless_card_rx||, CODE, READONLY, ALIGN=2

                  wireless_card_rx PROC
;;;888    
;;;889    u16 wireless_card_rx(u8 *uiprxbuf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;890    {
000004  4680              MOV      r8,r0
;;;891        struct lbs_private *priv=pgmarvel_priv;
000006  4813              LDR      r0,|L17.84|
000008  6805              LDR      r5,[r0,#0]  ; pgmarvel_priv
;;;892        struct if_sdio_card *card=priv->card;
00000a  6aae              LDR      r6,[r5,#0x28]
;;;893        struct eth_packet *rx_pkt=&priv->rx_pkt;
00000c  462c              MOV      r4,r5
;;;894        int ret;
;;;895        memset(rx_pkt,0,sizeof(struct eth_packet ));//清零以判断数据接收正常
00000e  2000              MOVS     r0,#0
000010  6020              STR      r0,[r4,#0]
000012  6060              STR      r0,[r4,#4]
;;;896        ret=pool_sdio_interrupt(card->func);
000014  6830              LDR      r0,[r6,#0]
000016  f7fffffe          BL       pool_sdio_interrupt
00001a  4607              MOV      r7,r0
;;;897        if(ret<0){
00001c  2f00              CMP      r7,#0
00001e  da04              BGE      |L17.42|
;;;898            lbs_pr_err("read interrupt error!\n");
000020  a00d              ADR      r0,|L17.88|
000022  f7fffffe          BL       __2printf
;;;899            try_bug(0);
000026  bf00              NOP      
                  |L17.40|
000028  e7fe              B        |L17.40|
                  |L17.42|
;;;900        }
;;;901        else if(ret&(IF_SDIO_H_INT_UPLD|IF_SDIO_H_INT_DNLD)){//先判断数据
00002a  f0170f03          TST      r7,#3
00002e  d00c              BEQ      |L17.74|
;;;902            if_sdio_interrupt(card->func);
000030  6830              LDR      r0,[r6,#0]
000032  f7fffffe          BL       if_sdio_interrupt
;;;903            if(rx_pkt->len){//接收到数据
000036  8820              LDRH     r0,[r4,#0]
000038  b148              CBZ      r0,|L17.78|
;;;904                debug_data_stream("Wireless data",rx_pkt->data,rx_pkt->len);
00003a  8822              LDRH     r2,[r4,#0]
00003c  a00c              ADR      r0,|L17.112|
00003e  6861              LDR      r1,[r4,#4]
000040  f7fffffe          BL       debug_data_stream
;;;905                //	memcpy((void *)uiprxbuf,(void *)rx_pkt->data,rx_pkt->len);
;;;906                //	memcpy((void *)uip_buf,(void *)rx_pkt->data,rx_pkt->len);
;;;907                return rx_pkt->len;
000044  8820              LDRH     r0,[r4,#0]
                  |L17.70|
;;;908            }
;;;909    
;;;910        }
;;;911        else
;;;912            return 0;
;;;913        return 0;
;;;914    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L17.74|
00004a  2000              MOVS     r0,#0                 ;912
00004c  e7fb              B        |L17.70|
                  |L17.78|
00004e  2000              MOVS     r0,#0                 ;913
000050  e7f9              B        |L17.70|
;;;915    
                          ENDP

000052  0000              DCW      0x0000
                  |L17.84|
                          DCD      pgmarvel_priv
                  |L17.88|
000058  72656164          DCB      "read interrupt error!\n",0
00005c  20696e74
000060  65727275
000064  70742065
000068  72726f72
00006c  210a00  
00006f  00                DCB      0
                  |L17.112|
000070  57697265          DCB      "Wireless data",0
000074  6c657373
000078  20646174
00007c  6100    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.wireless_card_tx||, CODE, READONLY, ALIGN=2

                  wireless_card_tx PROC
;;;930    
;;;931    void wireless_card_tx(u8 *uiptxbuf,u16 len)
000000  b57c              PUSH     {r2-r6,lr}
;;;932    {	
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;933        struct lbs_private *priv=pgmarvel_priv;
000006  4804              LDR      r0,|L18.24|
000008  6805              LDR      r5,[r0,#0]  ; pgmarvel_priv
;;;934        struct eth_packet txpkt;
;;;935        txpkt.len=len;
00000a  f8ad4000          STRH     r4,[sp,#0]
;;;936        lbs_hard_start_xmit(priv,&txpkt);
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       lbs_hard_start_xmit
;;;937    }
000016  bd7c              POP      {r2-r6,pc}
;;;938    
                          ENDP

                  |L18.24|
                          DCD      pgmarvel_priv

                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L19.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L19.32|
                  |L19.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L19.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L19.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L19.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L19.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L19.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L19.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gmarvel_ifsdio_card
                          %        1636

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  help_firmware
                          DCD      0x0000085c
                          DCD      help_firmware_array
                  marvel_firmware
                          DCD      0x000179cc
                          DCD      marvel_firmware_array
