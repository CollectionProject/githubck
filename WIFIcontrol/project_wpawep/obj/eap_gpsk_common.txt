; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eap_gpsk_common.o --depend=.\obj\eap_gpsk_common.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eap_gpsk_common.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_common\eap_gpsk_common.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_gpsk_compute_mic||, CODE, READONLY, ALIGN=2

                  eap_gpsk_compute_mic PROC
;;;396     */
;;;397    int eap_gpsk_compute_mic(const u8 *sk, size_t sk_len, int vendor,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;398    			 int specifier, const u8 *data, size_t len, u8 *mic)
;;;399    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
;;;400    	int ret;
;;;401    
;;;402    	if (vendor != EAP_GPSK_VENDOR_IETF)
000014  b11d              CBZ      r5,|L2.30|
;;;403    		return -1;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L2.26|
;;;404    
;;;405    	switch (specifier) {
;;;406    	case EAP_GPSK_CIPHER_AES:
;;;407    		ret = eap_gpsk_compute_mic_aes(sk, sk_len, data, len, mic);
;;;408    		break;
;;;409    #ifdef EAP_GPSK_SHA256
;;;410    	case EAP_GPSK_CIPHER_SHA256:
;;;411    		hmac_sha256(sk, sk_len, data, len, mic);
;;;412    		ret = 0;
;;;413    		break;
;;;414    #endif /* EAP_GPSK_SHA256 */
;;;415    	default:
;;;416    		wpa_printf(MSG_DEBUG, "EAP-GPSK: Unknown cipher %d:%d used in "
;;;417    			   "MIC computation", vendor, specifier);
;;;418    		ret = -1;
;;;419    		break;
;;;420    	}
;;;421    
;;;422    	return ret;
;;;423    }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.30|
00001e  2e01              CMP      r6,#1                 ;405
000020  d109              BNE      |L2.54|
000022  4653              MOV      r3,r10                ;407
000024  464a              MOV      r2,r9                 ;407
000026  4641              MOV      r1,r8                 ;407
000028  4638              MOV      r0,r7                 ;407
00002a  f8cdb000          STR      r11,[sp,#0]           ;407
00002e  f7fffffe          BL       eap_gpsk_compute_mic_aes
000032  4604              MOV      r4,r0                 ;407
000034  e008              B        |L2.72|
                  |L2.54|
000036  4633              MOV      r3,r6                 ;416
000038  462a              MOV      r2,r5                 ;416
00003a  a105              ADR      r1,|L2.80|
00003c  2000              MOVS     r0,#0                 ;416
00003e  f7fffffe          BL       wpa_printf
000042  f04f34ff          MOV      r4,#0xffffffff        ;418
000046  bf00              NOP                            ;419
                  |L2.72|
000048  bf00              NOP                            ;408
00004a  4620              MOV      r0,r4                 ;422
00004c  e7e5              B        |L2.26|
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
000050  4541502d          DCB      "EAP-GPSK: Unknown cipher %d:%d used in MIC computation",0
000054  4750534b
000058  3a20556e
00005c  6b6e6f77
000060  6e206369
000064  70686572
000068  2025643a
00006c  25642075
000070  73656420
000074  696e204d
000078  49432063
00007c  6f6d7075
000080  74617469
000084  6f6e00  
000087  00                DCB      0

                          AREA ||i.eap_gpsk_compute_mic_aes||, CODE, READONLY, ALIGN=2

                  eap_gpsk_compute_mic_aes PROC
;;;372    
;;;373    static int eap_gpsk_compute_mic_aes(const u8 *sk, size_t sk_len,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;374    				    const u8 *data, size_t len, u8 *mic)
;;;375    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;376    	if (sk_len != 16) {
000010  2c10              CMP      r4,#0x10
000012  d008              BEQ      |L3.38|
;;;377    		wpa_printf(MSG_DEBUG, "EAP-GPSK: Invalid SK length %lu for "
000014  4622              MOV      r2,r4
000016  a107              ADR      r1,|L3.52|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
;;;378    			   "AES-CMAC MIC", (unsigned long) sk_len);
;;;379    		return -1;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L3.34|
;;;380    	}
;;;381    
;;;382    	return omac1_aes_128(sk, data, len, mic);
;;;383    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L3.38|
000026  4643              MOV      r3,r8                 ;382
000028  4632              MOV      r2,r6                 ;382
00002a  4629              MOV      r1,r5                 ;382
00002c  4638              MOV      r0,r7                 ;382
00002e  f7fffffe          BL       omac1_aes_128
000032  e7f6              B        |L3.34|
;;;384    
                          ENDP

                  |L3.52|
000034  4541502d          DCB      "EAP-GPSK: Invalid SK length %lu for AES-CMAC MIC",0
000038  4750534b
00003c  3a20496e
000040  76616c69
000044  6420534b
000048  206c656e
00004c  67746820
000050  256c7520
000054  666f7220
000058  4145532d
00005c  434d4143
000060  204d4943
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.eap_gpsk_derive_keys||, CODE, READONLY, ALIGN=2

                  eap_gpsk_derive_keys PROC
;;;283     */
;;;284    int eap_gpsk_derive_keys(const u8 *psk, size_t psk_len, int vendor,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;285    			 int specifier,
;;;286    			 const u8 *rand_peer, const u8 *rand_server,
;;;287    			 const u8 *id_peer, size_t id_peer_len,
;;;288    			 const u8 *id_server, size_t id_server_len,
;;;289    			 u8 *msk, u8 *emsk, u8 *sk, size_t *sk_len,
;;;290    			 u8 *pk, size_t *pk_len)
;;;291    {
000004  b087              SUB      sp,sp,#0x1c
000006  4682              MOV      r10,r0
000008  469b              MOV      r11,r3
00000a  9f19              LDR      r7,[sp,#0x64]
00000c  9e17              LDR      r6,[sp,#0x5c]
;;;292    	u8 *seed, *pos;
;;;293    	size_t seed_len;
;;;294    	int ret;
;;;295    
;;;296    	wpa_printf(MSG_DEBUG, "EAP-GPSK: Deriving keys (%d:%d)",
00000e  465b              MOV      r3,r11
000010  a132              ADR      r1,|L4.220|
000012  2000              MOVS     r0,#0
000014  9a09              LDR      r2,[sp,#0x24]
000016  f7fffffe          BL       wpa_printf
;;;297    		   vendor, specifier);
;;;298    
;;;299    	if (vendor != EAP_GPSK_VENDOR_IETF)
00001a  9809              LDR      r0,[sp,#0x24]
00001c  b120              CBZ      r0,|L4.40|
;;;300    		return -1;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L4.34|
;;;301    
;;;302    	wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: PSK", psk, psk_len);
;;;303    
;;;304    	/* Seed = RAND_Peer || ID_Peer || RAND_Server || ID_Server */
;;;305    	seed_len = 2 * EAP_GPSK_RAND_LEN + id_server_len + id_peer_len;
;;;306    	seed = os_malloc(seed_len);
;;;307    	if (seed == NULL) {
;;;308    		wpa_printf(MSG_DEBUG, "EAP-GPSK: Failed to allocate memory "
;;;309    			   "for key derivation");
;;;310    		return -1;
;;;311    	}
;;;312    
;;;313    	pos = seed;
;;;314    	os_memcpy(pos, rand_peer, EAP_GPSK_RAND_LEN);
;;;315    	pos += EAP_GPSK_RAND_LEN;
;;;316    	os_memcpy(pos, id_peer, id_peer_len);
;;;317    	pos += id_peer_len;
;;;318    	os_memcpy(pos, rand_server, EAP_GPSK_RAND_LEN);
;;;319    	pos += EAP_GPSK_RAND_LEN;
;;;320    	os_memcpy(pos, id_server, id_server_len);
;;;321    	pos += id_server_len;
;;;322    	wpa_hexdump(MSG_DEBUG, "EAP-GPSK: Seed", seed, seed_len);
;;;323    
;;;324    	switch (specifier) {
;;;325    	case EAP_GPSK_CIPHER_AES:
;;;326    		ret = eap_gpsk_derive_keys_aes(psk, psk_len, seed, seed_len,
;;;327    					       msk, emsk, sk, sk_len,
;;;328    					       pk, pk_len);
;;;329    		break;
;;;330    #ifdef EAP_GPSK_SHA256
;;;331    	case EAP_GPSK_CIPHER_SHA256:
;;;332    		ret = eap_gpsk_derive_keys_sha256(psk, psk_len, seed, seed_len,
;;;333    						  msk, emsk, sk, sk_len);
;;;334    		break;
;;;335    #endif /* EAP_GPSK_SHA256 */
;;;336    	default:
;;;337    		wpa_printf(MSG_DEBUG, "EAP-GPSK: Unknown cipher %d:%d used in "
;;;338    			   "key derivation", vendor, specifier);
;;;339    		ret = -1;
;;;340    		break;
;;;341    	}
;;;342    
;;;343    	os_free(seed);
;;;344    
;;;345    	return ret;
;;;346    }
000022  b00b              ADD      sp,sp,#0x2c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.40|
000028  4652              MOV      r2,r10                ;302
00002a  a134              ADR      r1,|L4.252|
00002c  2000              MOVS     r0,#0                 ;302
00002e  9b08              LDR      r3,[sp,#0x20]         ;302
000030  f7fffffe          BL       wpa_hexdump_key
000034  f1070040          ADD      r0,r7,#0x40           ;305
000038  eb000806          ADD      r8,r0,r6              ;305
00003c  4640              MOV      r0,r8                 ;306
00003e  f7fffffe          BL       os_malloc
000042  4604              MOV      r4,r0                 ;306
000044  b934              CBNZ     r4,|L4.84|
000046  a131              ADR      r1,|L4.268|
000048  2000              MOVS     r0,#0                 ;308
00004a  f7fffffe          BL       wpa_printf
00004e  f04f30ff          MOV      r0,#0xffffffff        ;310
000052  e7e6              B        |L4.34|
                  |L4.84|
000054  4625              MOV      r5,r4                 ;313
000056  2220              MOVS     r2,#0x20              ;314
000058  4628              MOV      r0,r5                 ;314
00005a  9914              LDR      r1,[sp,#0x50]         ;314
00005c  f7fffffe          BL       __aeabi_memcpy
000060  3520              ADDS     r5,r5,#0x20           ;315
000062  4632              MOV      r2,r6                 ;316
000064  4628              MOV      r0,r5                 ;316
000066  9916              LDR      r1,[sp,#0x58]         ;316
000068  f7fffffe          BL       __aeabi_memcpy
00006c  4435              ADD      r5,r5,r6              ;317
00006e  2220              MOVS     r2,#0x20              ;318
000070  4628              MOV      r0,r5                 ;318
000072  9915              LDR      r1,[sp,#0x54]         ;318
000074  f7fffffe          BL       __aeabi_memcpy
000078  3520              ADDS     r5,r5,#0x20           ;319
00007a  463a              MOV      r2,r7                 ;320
00007c  4628              MOV      r0,r5                 ;320
00007e  9918              LDR      r1,[sp,#0x60]         ;320
000080  f7fffffe          BL       __aeabi_memcpy
000084  443d              ADD      r5,r5,r7              ;321
000086  4643              MOV      r3,r8                 ;322
000088  4622              MOV      r2,r4                 ;322
00008a  a12e              ADR      r1,|L4.324|
00008c  2000              MOVS     r0,#0                 ;322
00008e  f7fffffe          BL       wpa_hexdump
000092  f1bb0f01          CMP      r11,#1                ;324
000096  d111              BNE      |L4.188|
000098  a81c              ADD      r0,sp,#0x70           ;326
00009a  c80f              LDM      r0,{r0-r3}            ;326
00009c  e9cd2304          STRD     r2,r3,[sp,#0x10]      ;326
0000a0  e9cd0102          STRD     r0,r1,[sp,#8]         ;326
0000a4  e9dd231a          LDRD     r2,r3,[sp,#0x68]      ;326
0000a8  e9cd2300          STRD     r2,r3,[sp,#0]         ;326
0000ac  4643              MOV      r3,r8                 ;326
0000ae  4622              MOV      r2,r4                 ;326
0000b0  4650              MOV      r0,r10                ;326
0000b2  9908              LDR      r1,[sp,#0x20]         ;326
0000b4  f7fffffe          BL       eap_gpsk_derive_keys_aes
0000b8  4681              MOV      r9,r0                 ;326
0000ba  e008              B        |L4.206|
                  |L4.188|
0000bc  465b              MOV      r3,r11                ;337
0000be  a125              ADR      r1,|L4.340|
0000c0  2000              MOVS     r0,#0                 ;337
0000c2  9a09              LDR      r2,[sp,#0x24]         ;337
0000c4  f7fffffe          BL       wpa_printf
0000c8  f04f39ff          MOV      r9,#0xffffffff        ;339
0000cc  bf00              NOP                            ;340
                  |L4.206|
0000ce  bf00              NOP                            ;329
0000d0  4620              MOV      r0,r4                 ;343
0000d2  f7fffffe          BL       os_free
0000d6  4648              MOV      r0,r9                 ;345
0000d8  e7a3              B        |L4.34|
;;;347    
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
0000dc  4541502d          DCB      "EAP-GPSK: Deriving keys (%d:%d)",0
0000e0  4750534b
0000e4  3a204465
0000e8  72697669
0000ec  6e67206b
0000f0  65797320
0000f4  2825643a
0000f8  25642900
                  |L4.252|
0000fc  4541502d          DCB      "EAP-GPSK: PSK",0
000100  4750534b
000104  3a205053
000108  4b00    
00010a  00                DCB      0
00010b  00                DCB      0
                  |L4.268|
00010c  4541502d          DCB      "EAP-GPSK: Failed to allocate memory for key derivation",0
000110  4750534b
000114  3a204661
000118  696c6564
00011c  20746f20
000120  616c6c6f
000124  63617465
000128  206d656d
00012c  6f727920
000130  666f7220
000134  6b657920
000138  64657269
00013c  76617469
000140  6f6e00  
000143  00                DCB      0
                  |L4.324|
000144  4541502d          DCB      "EAP-GPSK: Seed",0
000148  4750534b
00014c  3a205365
000150  656400  
000153  00                DCB      0
                  |L4.340|
000154  4541502d          DCB      "EAP-GPSK: Unknown cipher %d:%d used in key derivation",0
000158  4750534b
00015c  3a20556e
000160  6b6e6f77
000164  6e206369
000168  70686572
00016c  2025643a
000170  25642075
000174  73656420
000178  696e206b
00017c  65792064
000180  65726976
000184  6174696f
000188  6e00    
00018a  00                DCB      0
00018b  00                DCB      0

                          AREA ||i.eap_gpsk_derive_keys_aes||, CODE, READONLY, ALIGN=1

                  eap_gpsk_derive_keys_aes PROC
;;;193    
;;;194    static int eap_gpsk_derive_keys_aes(const u8 *psk, size_t psk_len,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;195    				    const u8 *seed, size_t seed_len,
;;;196    				    u8 *msk, u8 *emsk, u8 *sk, size_t *sk_len,
;;;197    				    u8 *pk, size_t *pk_len)
;;;198    {
000004  b0b1              SUB      sp,sp,#0xc4
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  e9ddab3e          LDRD     r10,r11,[sp,#0xf8]
000012  f8dd910c          LDR      r9,[sp,#0x10c]
000016  f8dd8104          LDR      r8,[sp,#0x104]
;;;199    #define EAP_GPSK_SK_LEN_AES 16
;;;200    #define EAP_GPSK_PK_LEN_AES 16
;;;201    	u8 kdf_out[EAP_MSK_LEN + EAP_EMSK_LEN + EAP_GPSK_SK_LEN_AES +
;;;202    		   EAP_GPSK_PK_LEN_AES];
;;;203    
;;;204    	/*
;;;205    	 * inputString = RAND_Peer || ID_Peer || RAND_Server || ID_Server
;;;206    	 *            (= seed)
;;;207    	 * KS = 16, PL = psk_len, CSuite_Sel = 0x00000000 0x0001
;;;208    	 * MK = GKDF-16 (PSK[0..15], PL || PSK || CSuite_Sel || inputString)
;;;209    	 * MSK = GKDF-160 (MK, inputString)[0..63]
;;;210    	 * EMSK = GKDF-160 (MK, inputString)[64..127]
;;;211    	 * SK = GKDF-160 (MK, inputString)[128..143]
;;;212    	 * PK = GKDF-160 (MK, inputString)[144..159]
;;;213    	 * zero = 0x00 || 0x00 || ... || 0x00 (16 times)
;;;214    	 * Method-ID = GKDF-16 (zero, "Method ID" || EAP_Method_Type ||
;;;215    	 *                      CSuite_Sel || inputString)
;;;216    	 */
;;;217    
;;;218    	*sk_len = EAP_GPSK_SK_LEN_AES;
00001a  2010              MOVS     r0,#0x10
00001c  f8c80000          STR      r0,[r8,#0]
;;;219    	*pk_len = EAP_GPSK_PK_LEN_AES;
000020  f8c90000          STR      r0,[r9,#0]
;;;220    
;;;221    	return eap_gpsk_derive_keys_helper(EAP_GPSK_CIPHER_AES,
000024  f8d93000          LDR      r3,[r9,#0]
000028  9a42              LDR      r2,[sp,#0x108]
00002a  f8d81000          LDR      r1,[r8,#0]
00002e  9840              LDR      r0,[sp,#0x100]
000030  e88d0ce0          STM      sp,{r5-r7,r10,r11}
000034  e9cd2307          STRD     r2,r3,[sp,#0x1c]
000038  e9cd0105          STRD     r0,r1,[sp,#0x14]
00003c  4623              MOV      r3,r4
00003e  22a0              MOVS     r2,#0xa0
000040  a909              ADD      r1,sp,#0x24
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       eap_gpsk_derive_keys_helper
;;;222    					   kdf_out, sizeof(kdf_out),
;;;223    					   psk, psk_len, seed, seed_len,
;;;224    					   msk, emsk, sk, *sk_len,
;;;225    					   pk, *pk_len);
;;;226    }
000048  b035              ADD      sp,sp,#0xd4
00004a  e8bd8ff0          POP      {r4-r11,pc}
;;;227    
                          ENDP


                          AREA ||i.eap_gpsk_derive_keys_helper||, CODE, READONLY, ALIGN=2

                  eap_gpsk_derive_keys_helper PROC
;;;112    
;;;113    static int eap_gpsk_derive_keys_helper(u32 csuite_specifier,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;114    				       u8 *kdf_out, size_t kdf_out_len,
;;;115    				       const u8 *psk, size_t psk_len,
;;;116    				       const u8 *seed, size_t seed_len,
;;;117    				       u8 *msk, u8 *emsk,
;;;118    				       u8 *sk, size_t sk_len,
;;;119    				       u8 *pk, size_t pk_len)
;;;120    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  469a              MOV      r10,r3
00000c  f8ddb078          LDR      r11,[sp,#0x78]
000010  9d18              LDR      r5,[sp,#0x60]
;;;121    	u8 mk[32], *pos, *data;
;;;122    	size_t data_len, mk_len;
;;;123    	int (*gkdf)(const u8 *_psk, const u8 *_data, size_t _data_len,
;;;124    		    u8 *buf, size_t len);
;;;125    
;;;126    	gkdf = NULL;
000012  2000              MOVS     r0,#0
000014  9001              STR      r0,[sp,#4]
;;;127    	switch (csuite_specifier) {
000016  2f01              CMP      r7,#1
000018  d104              BNE      |L6.36|
;;;128    	case EAP_GPSK_CIPHER_AES:
;;;129    		gkdf = eap_gpsk_gkdf_cmac;
00001a  4850              LDR      r0,|L6.348|
00001c  9001              STR      r0,[sp,#4]
;;;130    		mk_len = 16;
00001e  2010              MOVS     r0,#0x10
000020  9002              STR      r0,[sp,#8]
;;;131    		break;
000022  e004              B        |L6.46|
                  |L6.36|
;;;132    #ifdef EAP_GPSK_SHA256
;;;133    	case EAP_GPSK_CIPHER_SHA256:
;;;134    		gkdf = eap_gpsk_gkdf_sha256;
;;;135    		mk_len = SHA256_MAC_LEN;
;;;136    		break;
;;;137    #endif /* EAP_GPSK_SHA256 */
;;;138    	default:
;;;139    		return -1;
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L6.40|
;;;140    	}
;;;141    
;;;142    	if (psk_len < mk_len)
;;;143    		return -1;
;;;144    
;;;145    	data_len = 2 + psk_len + 6 + seed_len;
;;;146    	data = os_malloc(data_len);
;;;147    	if (data == NULL)
;;;148    		return -1;
;;;149    	pos = data;
;;;150    	WPA_PUT_BE16(pos, psk_len);
;;;151    	pos += 2;
;;;152    	os_memcpy(pos, psk, psk_len);
;;;153    	pos += psk_len;
;;;154    	WPA_PUT_BE32(pos, EAP_GPSK_VENDOR_IETF); /* CSuite/Vendor = IETF */
;;;155    	pos += 4;
;;;156    	WPA_PUT_BE16(pos, csuite_specifier); /* CSuite/Specifier */
;;;157    	pos += 2;
;;;158    	os_memcpy(pos, seed, seed_len); /* inputString */
;;;159    	wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: Data to MK derivation",
;;;160    			data, data_len);
;;;161    
;;;162    	if (gkdf(psk, data, data_len, mk, mk_len) < 0) {
;;;163    		os_free(data);
;;;164    		return -1;
;;;165    	}
;;;166    	os_free(data);
;;;167    	wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: MK", mk, mk_len);
;;;168    
;;;169    	if (gkdf(mk, seed, seed_len, kdf_out, kdf_out_len) < 0)
;;;170    		return -1;
;;;171    
;;;172    	pos = kdf_out;
;;;173    	wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: MSK", pos, EAP_MSK_LEN);
;;;174    	os_memcpy(msk, pos, EAP_MSK_LEN);
;;;175    	pos += EAP_MSK_LEN;
;;;176    
;;;177    	wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: EMSK", pos, EAP_EMSK_LEN);
;;;178    	os_memcpy(emsk, pos, EAP_EMSK_LEN);
;;;179    	pos += EAP_EMSK_LEN;
;;;180    
;;;181    	wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: SK", pos, sk_len);
;;;182    	os_memcpy(sk, pos, sk_len);
;;;183    	pos += sk_len;
;;;184    
;;;185    	if (pk) {
;;;186    		wpa_hexdump_key(MSG_DEBUG, "EAP-GPSK: PK", pos, pk_len);
;;;187    		os_memcpy(pk, pos, pk_len);
;;;188    	}
;;;189    
;;;190    	return 0;
;;;191    }
000028  b00f              ADD      sp,sp,#0x3c
00002a  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.46|
00002e  bf00              NOP                            ;131
000030  9802              LDR      r0,[sp,#8]            ;142
000032  4285              CMP      r5,r0                 ;142
000034  d202              BCS      |L6.60|
000036  f04f30ff          MOV      r0,#0xffffffff        ;143
00003a  e7f5              B        |L6.40|
                  |L6.60|
00003c  f1050008          ADD      r0,r5,#8              ;145
000040  991a              LDR      r1,[sp,#0x68]         ;145
000042  eb000901          ADD      r9,r0,r1              ;145
000046  4648              MOV      r0,r9                 ;146
000048  f7fffffe          BL       os_malloc
00004c  4606              MOV      r6,r0                 ;146
00004e  b916              CBNZ     r6,|L6.86|
000050  f04f30ff          MOV      r0,#0xffffffff        ;148
000054  e7e8              B        |L6.40|
                  |L6.86|
000056  4634              MOV      r4,r6                 ;149
000058  bf00              NOP                            ;150
00005a  0a28              LSRS     r0,r5,#8              ;150
00005c  7020              STRB     r0,[r4,#0]            ;150
00005e  7065              STRB     r5,[r4,#1]            ;150
000060  bf00              NOP                            ;150
000062  1ca4              ADDS     r4,r4,#2              ;151
000064  462a              MOV      r2,r5                 ;152
000066  4651              MOV      r1,r10                ;152
000068  4620              MOV      r0,r4                 ;152
00006a  f7fffffe          BL       __aeabi_memcpy
00006e  442c              ADD      r4,r4,r5              ;153
000070  bf00              NOP                            ;154
000072  2000              MOVS     r0,#0                 ;154
000074  7020              STRB     r0,[r4,#0]            ;154
000076  7060              STRB     r0,[r4,#1]            ;154
000078  70a0              STRB     r0,[r4,#2]            ;154
00007a  70e0              STRB     r0,[r4,#3]            ;154
00007c  bf00              NOP                            ;154
00007e  1d24              ADDS     r4,r4,#4              ;155
000080  bf00              NOP                            ;156
000082  0a38              LSRS     r0,r7,#8              ;156
000084  7020              STRB     r0,[r4,#0]            ;156
000086  7067              STRB     r7,[r4,#1]            ;156
000088  bf00              NOP                            ;156
00008a  1ca4              ADDS     r4,r4,#2              ;157
00008c  4620              MOV      r0,r4                 ;158
00008e  e9dd1219          LDRD     r1,r2,[sp,#0x64]      ;158
000092  f7fffffe          BL       __aeabi_memcpy
000096  464b              MOV      r3,r9                 ;159
000098  4632              MOV      r2,r6                 ;159
00009a  a131              ADR      r1,|L6.352|
00009c  2000              MOVS     r0,#0                 ;159
00009e  f7fffffe          BL       wpa_hexdump_key
0000a2  9b02              LDR      r3,[sp,#8]            ;162
0000a4  9300              STR      r3,[sp,#0]            ;162
0000a6  ab03              ADD      r3,sp,#0xc            ;162
0000a8  464a              MOV      r2,r9                 ;162
0000aa  4631              MOV      r1,r6                 ;162
0000ac  4650              MOV      r0,r10                ;162
0000ae  f8ddc004          LDR      r12,[sp,#4]           ;162
0000b2  47e0              BLX      r12                   ;162
0000b4  2800              CMP      r0,#0                 ;162
0000b6  da05              BGE      |L6.196|
0000b8  4630              MOV      r0,r6                 ;163
0000ba  f7fffffe          BL       os_free
0000be  f04f30ff          MOV      r0,#0xffffffff        ;164
0000c2  e7b1              B        |L6.40|
                  |L6.196|
0000c4  4630              MOV      r0,r6                 ;166
0000c6  f7fffffe          BL       os_free
0000ca  aa03              ADD      r2,sp,#0xc            ;167
0000cc  a12c              ADR      r1,|L6.384|
0000ce  2000              MOVS     r0,#0                 ;167
0000d0  9b02              LDR      r3,[sp,#8]            ;167
0000d2  f7fffffe          BL       wpa_hexdump_key
0000d6  9b0d              LDR      r3,[sp,#0x34]         ;169
0000d8  9300              STR      r3,[sp,#0]            ;169
0000da  4643              MOV      r3,r8                 ;169
0000dc  a803              ADD      r0,sp,#0xc            ;169
0000de  f8ddc004          LDR      r12,[sp,#4]           ;169
0000e2  e9dd1219          LDRD     r1,r2,[sp,#0x64]      ;169
0000e6  47e0              BLX      r12                   ;169
0000e8  2800              CMP      r0,#0                 ;169
0000ea  da02              BGE      |L6.242|
0000ec  f04f30ff          MOV      r0,#0xffffffff        ;170
0000f0  e79a              B        |L6.40|
                  |L6.242|
0000f2  4644              MOV      r4,r8                 ;172
0000f4  2340              MOVS     r3,#0x40              ;173
0000f6  4622              MOV      r2,r4                 ;173
0000f8  a125              ADR      r1,|L6.400|
0000fa  2000              MOVS     r0,#0                 ;173
0000fc  f7fffffe          BL       wpa_hexdump_key
000100  2240              MOVS     r2,#0x40              ;174
000102  4621              MOV      r1,r4                 ;174
000104  981b              LDR      r0,[sp,#0x6c]         ;174
000106  f7fffffe          BL       __aeabi_memcpy
00010a  3440              ADDS     r4,r4,#0x40           ;175
00010c  2340              MOVS     r3,#0x40              ;177
00010e  4622              MOV      r2,r4                 ;177
000110  a123              ADR      r1,|L6.416|
000112  2000              MOVS     r0,#0                 ;177
000114  f7fffffe          BL       wpa_hexdump_key
000118  2240              MOVS     r2,#0x40              ;178
00011a  4621              MOV      r1,r4                 ;178
00011c  981c              LDR      r0,[sp,#0x70]         ;178
00011e  f7fffffe          BL       __aeabi_memcpy
000122  3440              ADDS     r4,r4,#0x40           ;179
000124  465b              MOV      r3,r11                ;181
000126  4622              MOV      r2,r4                 ;181
000128  a121              ADR      r1,|L6.432|
00012a  2000              MOVS     r0,#0                 ;181
00012c  f7fffffe          BL       wpa_hexdump_key
000130  465a              MOV      r2,r11                ;182
000132  4621              MOV      r1,r4                 ;182
000134  981d              LDR      r0,[sp,#0x74]         ;182
000136  f7fffffe          BL       __aeabi_memcpy
00013a  445c              ADD      r4,r4,r11             ;183
00013c  981f              LDR      r0,[sp,#0x7c]         ;185
00013e  b150              CBZ      r0,|L6.342|
000140  4622              MOV      r2,r4                 ;186
000142  a11f              ADR      r1,|L6.448|
000144  2000              MOVS     r0,#0                 ;186
000146  9b20              LDR      r3,[sp,#0x80]         ;186
000148  f7fffffe          BL       wpa_hexdump_key
00014c  4621              MOV      r1,r4                 ;187
00014e  e9dd021f          LDRD     r0,r2,[sp,#0x7c]      ;187
000152  f7fffffe          BL       __aeabi_memcpy
                  |L6.342|
000156  2000              MOVS     r0,#0                 ;190
000158  e766              B        |L6.40|
;;;192    
                          ENDP

00015a  0000              DCW      0x0000
                  |L6.348|
                          DCD      eap_gpsk_gkdf_cmac
                  |L6.352|
000160  4541502d          DCB      "EAP-GPSK: Data to MK derivation",0
000164  4750534b
000168  3a204461
00016c  74612074
000170  6f204d4b
000174  20646572
000178  69766174
00017c  696f6e00
                  |L6.384|
000180  4541502d          DCB      "EAP-GPSK: MK",0
000184  4750534b
000188  3a204d4b
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L6.400|
000190  4541502d          DCB      "EAP-GPSK: MSK",0
000194  4750534b
000198  3a204d53
00019c  4b00    
00019e  00                DCB      0
00019f  00                DCB      0
                  |L6.416|
0001a0  4541502d          DCB      "EAP-GPSK: EMSK",0
0001a4  4750534b
0001a8  3a20454d
0001ac  534b00  
0001af  00                DCB      0
                  |L6.432|
0001b0  4541502d          DCB      "EAP-GPSK: SK",0
0001b4  4750534b
0001b8  3a20534b
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L6.448|
0001c0  4541502d          DCB      "EAP-GPSK: PK",0
0001c4  4750534b
0001c8  3a20504b
0001cc  00      
0001cd  00                DCB      0
0001ce  00                DCB      0
0001cf  00                DCB      0

                          AREA ||i.eap_gpsk_gkdf_cmac||, CODE, READONLY, ALIGN=1

                  eap_gpsk_gkdf_cmac PROC
;;;43     
;;;44     static int eap_gpsk_gkdf_cmac(const u8 *psk /* Y */,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;45     			      const u8 *data /* Z */, size_t data_len,
;;;46     			      u8 *buf, size_t len /* X */)
;;;47     {
000004  b08d              SUB      sp,sp,#0x34
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  f8ddb068          LDR      r11,[sp,#0x68]
;;;48     	u8 *opos;
;;;49     	size_t i, n, hashlen, left, clen;
;;;50     	u8 ibuf[2], hash[16];
;;;51     	const u8 *addr[2];
;;;52     	size_t vlen[2];
;;;53     
;;;54     	hashlen = sizeof(hash);
000010  2510              MOVS     r5,#0x10
;;;55     	/* M_i = MAC_Y (i || Z); (MAC = AES-CMAC-128) */
;;;56     	addr[0] = ibuf;
000012  a80a              ADD      r0,sp,#0x28
000014  9004              STR      r0,[sp,#0x10]
;;;57     	vlen[0] = sizeof(ibuf);
000016  2002              MOVS     r0,#2
000018  9002              STR      r0,[sp,#8]
;;;58     	addr[1] = data;
00001a  f8cd8014          STR      r8,[sp,#0x14]
;;;59     	vlen[1] = data_len;
00001e  f8cd900c          STR      r9,[sp,#0xc]
;;;60     
;;;61     	opos = buf;
000022  f8cda030          STR      r10,[sp,#0x30]
;;;62     	left = len;
000026  465e              MOV      r6,r11
;;;63     	n = (len + hashlen - 1) / hashlen;
000028  eb0b0005          ADD      r0,r11,r5
00002c  1e40              SUBS     r0,r0,#1
00002e  fbb0f0f5          UDIV     r0,r0,r5
000032  900b              STR      r0,[sp,#0x2c]
;;;64     	for (i = 1; i <= n; i++) {
000034  2401              MOVS     r4,#1
000036  e025              B        |L7.132|
                  |L7.56|
;;;65     		WPA_PUT_BE16(ibuf, i);
000038  bf00              NOP      
00003a  0a20              LSRS     r0,r4,#8
00003c  f88d0028          STRB     r0,[sp,#0x28]
000040  b2e0              UXTB     r0,r4
000042  f88d0029          STRB     r0,[sp,#0x29]
000046  bf00              NOP      
;;;66     		if (omac1_aes_128_vector(psk, 2, addr, vlen, hash))
000048  ab06              ADD      r3,sp,#0x18
00004a  9300              STR      r3,[sp,#0]
00004c  ab02              ADD      r3,sp,#8
00004e  aa04              ADD      r2,sp,#0x10
000050  2102              MOVS     r1,#2
000052  980d              LDR      r0,[sp,#0x34]
000054  f7fffffe          BL       omac1_aes_128_vector
000058  b120              CBZ      r0,|L7.100|
;;;67     			return -1;
00005a  f04f30ff          MOV      r0,#0xffffffff
                  |L7.94|
;;;68     		clen = left > hashlen ? hashlen : left;
;;;69     		os_memcpy(opos, hash, clen);
;;;70     		opos += clen;
;;;71     		left -= clen;
;;;72     	}
;;;73     
;;;74     	return 0;
;;;75     }
00005e  b011              ADD      sp,sp,#0x44
000060  e8bd8ff0          POP      {r4-r11,pc}
                  |L7.100|
000064  42ae              CMP      r6,r5                 ;68
000066  d901              BLS      |L7.108|
000068  4628              MOV      r0,r5                 ;68
00006a  e000              B        |L7.110|
                  |L7.108|
00006c  4630              MOV      r0,r6                 ;68
                  |L7.110|
00006e  4607              MOV      r7,r0                 ;68
000070  463a              MOV      r2,r7                 ;69
000072  a906              ADD      r1,sp,#0x18           ;69
000074  980c              LDR      r0,[sp,#0x30]         ;69
000076  f7fffffe          BL       __aeabi_memcpy
00007a  980c              LDR      r0,[sp,#0x30]         ;70
00007c  4438              ADD      r0,r0,r7              ;70
00007e  900c              STR      r0,[sp,#0x30]         ;70
000080  1bf6              SUBS     r6,r6,r7              ;71
000082  1c64              ADDS     r4,r4,#1              ;64
                  |L7.132|
000084  980b              LDR      r0,[sp,#0x2c]         ;64
000086  4284              CMP      r4,r0                 ;64
000088  d9d6              BLS      |L7.56|
00008a  2000              MOVS     r0,#0                 ;74
00008c  e7e7              B        |L7.94|
;;;76     
                          ENDP


                          AREA ||i.eap_gpsk_mic_len||, CODE, READONLY, ALIGN=1

                  eap_gpsk_mic_len PROC
;;;354     */
;;;355    size_t eap_gpsk_mic_len(int vendor, int specifier)
000000  4602              MOV      r2,r0
;;;356    {
;;;357    	if (vendor != EAP_GPSK_VENDOR_IETF)
000002  b10a              CBZ      r2,|L8.8|
;;;358    		return 0;
000004  2000              MOVS     r0,#0
                  |L8.6|
;;;359    
;;;360    	switch (specifier) {
;;;361    	case EAP_GPSK_CIPHER_AES:
;;;362    		return 16;
;;;363    #ifdef EAP_GPSK_SHA256
;;;364    	case EAP_GPSK_CIPHER_SHA256:
;;;365    		return 32;
;;;366    #endif /* EAP_GPSK_SHA256 */
;;;367    	default:
;;;368    		return 0;
;;;369    	}
;;;370    }
000006  4770              BX       lr
                  |L8.8|
000008  2901              CMP      r1,#1                 ;360
00000a  d101              BNE      |L8.16|
00000c  2010              MOVS     r0,#0x10              ;362
00000e  e7fa              B        |L8.6|
                  |L8.16|
000010  2000              MOVS     r0,#0                 ;368
000012  e7f8              B        |L8.6|
;;;371    
                          ENDP


                          AREA ||i.eap_gpsk_supported_ciphersuite||, CODE, READONLY, ALIGN=1

                  eap_gpsk_supported_ciphersuite PROC
;;;29      */
;;;30     int eap_gpsk_supported_ciphersuite(int vendor, int specifier)
000000  4602              MOV      r2,r0
;;;31     {
;;;32     	if (vendor == EAP_GPSK_VENDOR_IETF &&
000002  b91a              CBNZ     r2,|L9.12|
;;;33     	    specifier == EAP_GPSK_CIPHER_AES)
000004  2901              CMP      r1,#1
000006  d101              BNE      |L9.12|
;;;34     		return 1;
000008  2001              MOVS     r0,#1
                  |L9.10|
;;;35     #ifdef EAP_GPSK_SHA256
;;;36     	if (vendor == EAP_GPSK_VENDOR_IETF &&
;;;37     	    specifier == EAP_GPSK_CIPHER_SHA256)
;;;38     		return 1;
;;;39     #endif /* EAP_GPSK_SHA256 */
;;;40     	return 0;
;;;41     }
00000a  4770              BX       lr
                  |L9.12|
00000c  2000              MOVS     r0,#0                 ;40
00000e  e7fc              B        |L9.10|
;;;42     
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L10.30|
00001a  2001              MOVS     r0,#1
                  |L10.28|
;;;495    }
00001c  4770              BX       lr
                  |L10.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L10.28|
;;;496    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L15.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L15.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L15.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L15.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L18.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L18.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L18.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L18.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L24.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       __aeabi_memcpy
                  |L24.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L31.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L31.32|
                  |L31.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L31.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L31.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L31.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L31.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L31.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L31.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L31.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0
