; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eap_tls_common.o --depend=.\obj\eap_tls_common.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eap_tls_common.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer\eap_tls_common.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_peer_method_load||, CODE, READONLY, ALIGN=1

                  eap_peer_method_load PROC
;;;78     
;;;79     static inline int eap_peer_method_load(const char *so)
000000  4601              MOV      r1,r0
;;;80     {
;;;81     	return 0;
000002  2000              MOVS     r0,#0
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.eap_peer_method_unload||, CODE, READONLY, ALIGN=1

                  eap_peer_method_unload PROC
;;;83     
;;;84     static inline int eap_peer_method_unload(struct eap_method *method)
000000  4601              MOV      r1,r0
;;;85     {
;;;86     	return 0;
000002  2000              MOVS     r0,#0
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.eap_peer_select_phase2_methods||, CODE, READONLY, ALIGN=2

                  eap_peer_select_phase2_methods PROC
;;;912     */
;;;913    int eap_peer_select_phase2_methods(struct eap_peer_config *config,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;914    				   const char *prefix,
;;;915    				   struct eap_method_type **types,
;;;916    				   size_t *num_types)
;;;917    {
000004  b083              SUB      sp,sp,#0xc
000006  4680              MOV      r8,r0
;;;918    	char *start, *pos, *buf;
;;;919    	struct eap_method_type *methods = NULL, *_methods;
000008  2600              MOVS     r6,#0
;;;920    	u8 method;
;;;921    	size_t num_methods = 0, prefix_len;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;922    
;;;923    	if (config == NULL || config->phase2 == NULL)
00000e  f1b80f00          CMP      r8,#0
000012  d002              BEQ      |L4.26|
000014  f8d80060          LDR      r0,[r8,#0x60]
000018  b900              CBNZ     r0,|L4.28|
                  |L4.26|
;;;924    		goto get_defaults;
00001a  e068              B        |L4.238|
                  |L4.28|
;;;925    
;;;926    	start = buf = (char*)os_strdup(config->phase2);
00001c  f8d80060          LDR      r0,[r8,#0x60]
000020  f7fffffe          BL       os_strdup
000024  4682              MOV      r10,r0
000026  4605              MOV      r5,r0
;;;927    	if (buf == NULL)
000028  f1ba0f00          CMP      r10,#0
00002c  d104              BNE      |L4.56|
;;;928    		return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L4.50|
;;;929    
;;;930    	prefix_len = os_strlen(prefix);
;;;931    
;;;932    	while (start && *start != '\0') {
;;;933    		int vendor;
;;;934    		pos = os_strstr(start, prefix);
;;;935    		if (pos == NULL)
;;;936    			break;
;;;937    		if (start != pos && *(pos - 1) != ' ') {
;;;938    			start = pos + prefix_len;
;;;939    			continue;
;;;940    		}
;;;941    
;;;942    		start = pos + prefix_len;
;;;943    		pos = os_strchr(start, ' ');
;;;944    		if (pos)
;;;945    			*pos++ = '\0';
;;;946    		method = eap_get_phase2_type(start, &vendor);
;;;947    		if (vendor == EAP_VENDOR_IETF && method == EAP_TYPE_NONE) {
;;;948    			wpa_printf(MSG_ERROR, "TLS: Unsupported Phase2 EAP "
;;;949    				   "method '%s'", start);
;;;950    		} else {
;;;951    			num_methods++;
;;;952    			_methods = os_realloc(methods,
;;;953    					      num_methods * sizeof(*methods));
;;;954    			if (_methods == NULL) {
;;;955    				os_free(methods);
;;;956    				os_free(buf);
;;;957    				return -1;
;;;958    			}
;;;959    			methods = _methods;
;;;960    			methods[num_methods - 1].vendor = vendor;
;;;961    			methods[num_methods - 1].method = method;
;;;962    		}
;;;963    
;;;964    		start = pos;
;;;965    	}
;;;966    
;;;967    	os_free(buf);
;;;968    
;;;969    get_defaults:
;;;970    	if (methods == NULL)
;;;971    		methods = eap_get_phase2_types(config, &num_methods);
;;;972    
;;;973    	if (methods == NULL) {
;;;974    		wpa_printf(MSG_ERROR, "TLS: No Phase2 EAP methods available");
;;;975    		return -1;
;;;976    	}
;;;977    	wpa_hexdump(MSG_DEBUG, "TLS: Phase2 EAP types",
;;;978    		    (u8 *) methods,
;;;979    		    num_methods * sizeof(struct eap_method_type));
;;;980    
;;;981    	*types = methods;
;;;982    	*num_types = num_methods;
;;;983    
;;;984    	return 0;
;;;985    }
000032  b007              ADD      sp,sp,#0x1c
000034  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.56|
000038  9804              LDR      r0,[sp,#0x10]         ;930
00003a  f7fffffe          BL       os_strlen
00003e  4681              MOV      r9,r0                 ;930
000040  e04c              B        |L4.220|
                  |L4.66|
000042  4628              MOV      r0,r5                 ;934
000044  9904              LDR      r1,[sp,#0x10]         ;934
000046  f7fffffe          BL       os_strstr
00004a  4604              MOV      r4,r0                 ;934
00004c  b904              CBNZ     r4,|L4.80|
00004e  e049              B        |L4.228|
                  |L4.80|
000050  42a5              CMP      r5,r4                 ;937
000052  d006              BEQ      |L4.98|
000054  f8140c01          LDRB     r0,[r4,#-1]           ;937
000058  2820              CMP      r0,#0x20              ;937
00005a  d002              BEQ      |L4.98|
00005c  eb040509          ADD      r5,r4,r9              ;938
000060  e03c              B        |L4.220|
                  |L4.98|
000062  eb040509          ADD      r5,r4,r9              ;942
000066  2120              MOVS     r1,#0x20              ;943
000068  4628              MOV      r0,r5                 ;943
00006a  f7fffffe          BL       os_strchr
00006e  4604              MOV      r4,r0                 ;943
000070  b114              CBZ      r4,|L4.120|
000072  2000              MOVS     r0,#0                 ;945
000074  f8040b01          STRB     r0,[r4],#1            ;945
                  |L4.120|
000078  a901              ADD      r1,sp,#4              ;946
00007a  4628              MOV      r0,r5                 ;946
00007c  f7fffffe          BL       eap_get_phase2_type
000080  f0000bff          AND      r11,r0,#0xff          ;946
000084  9801              LDR      r0,[sp,#4]            ;947
000086  b940              CBNZ     r0,|L4.154|
000088  f1bb0f00          CMP      r11,#0                ;947
00008c  d105              BNE      |L4.154|
00008e  462a              MOV      r2,r5                 ;948
000090  a125              ADR      r1,|L4.296|
000092  2000              MOVS     r0,#0                 ;948
000094  f7fffffe          BL       wpa_printf
000098  e01e              B        |L4.216|
                  |L4.154|
00009a  9802              LDR      r0,[sp,#8]            ;951
00009c  1c40              ADDS     r0,r0,#1              ;951
00009e  9002              STR      r0,[sp,#8]            ;951
0000a0  9802              LDR      r0,[sp,#8]            ;952
0000a2  00c1              LSLS     r1,r0,#3              ;952
0000a4  4630              MOV      r0,r6                 ;952
0000a6  f7fffffe          BL       os_realloc
0000aa  4607              MOV      r7,r0                 ;952
0000ac  b947              CBNZ     r7,|L4.192|
0000ae  4630              MOV      r0,r6                 ;955
0000b0  f7fffffe          BL       os_free
0000b4  4650              MOV      r0,r10                ;956
0000b6  f7fffffe          BL       os_free
0000ba  f04f30ff          MOV      r0,#0xffffffff        ;957
0000be  e7b8              B        |L4.50|
                  |L4.192|
0000c0  463e              MOV      r6,r7                 ;959
0000c2  e9dd1001          LDRD     r1,r0,[sp,#4]         ;960
0000c6  1e40              SUBS     r0,r0,#1              ;960
0000c8  f8461030          STR      r1,[r6,r0,LSL #3]     ;960
0000cc  9802              LDR      r0,[sp,#8]            ;961
0000ce  1e40              SUBS     r0,r0,#1              ;961
0000d0  eb0600c0          ADD      r0,r6,r0,LSL #3       ;961
0000d4  f8c0b004          STR      r11,[r0,#4]           ;961
                  |L4.216|
0000d8  4625              MOV      r5,r4                 ;964
0000da  bf00              NOP                            ;939
                  |L4.220|
0000dc  b115              CBZ      r5,|L4.228|
0000de  7828              LDRB     r0,[r5,#0]            ;932
0000e0  2800              CMP      r0,#0                 ;932
0000e2  d1ae              BNE      |L4.66|
                  |L4.228|
0000e4  bf00              NOP                            ;936
0000e6  4650              MOV      r0,r10                ;967
0000e8  f7fffffe          BL       os_free
0000ec  bf00              NOP                            ;969
                  |L4.238|
0000ee  b926              CBNZ     r6,|L4.250|
0000f0  a902              ADD      r1,sp,#8              ;971
0000f2  4640              MOV      r0,r8                 ;971
0000f4  f7fffffe          BL       eap_get_phase2_types
0000f8  4606              MOV      r6,r0                 ;971
                  |L4.250|
0000fa  b936              CBNZ     r6,|L4.266|
0000fc  a114              ADR      r1,|L4.336|
0000fe  2000              MOVS     r0,#0                 ;974
000100  f7fffffe          BL       wpa_printf
000104  f04f30ff          MOV      r0,#0xffffffff        ;975
000108  e793              B        |L4.50|
                  |L4.266|
00010a  9802              LDR      r0,[sp,#8]            ;977
00010c  00c3              LSLS     r3,r0,#3              ;977
00010e  4632              MOV      r2,r6                 ;977
000110  a119              ADR      r1,|L4.376|
000112  2000              MOVS     r0,#0                 ;977
000114  f7fffffe          BL       wpa_hexdump
000118  9805              LDR      r0,[sp,#0x14]         ;981
00011a  6006              STR      r6,[r0,#0]            ;981
00011c  9902              LDR      r1,[sp,#8]            ;982
00011e  9806              LDR      r0,[sp,#0x18]         ;982
000120  6001              STR      r1,[r0,#0]            ;982
000122  2000              MOVS     r0,#0                 ;984
000124  e785              B        |L4.50|
;;;986    
                          ENDP

000126  0000              DCW      0x0000
                  |L4.296|
000128  544c533a          DCB      "TLS: Unsupported Phase2 EAP method '%s'",0
00012c  20556e73
000130  7570706f
000134  72746564
000138  20506861
00013c  73653220
000140  45415020
000144  6d657468
000148  6f642027
00014c  25732700
                  |L4.336|
000150  544c533a          DCB      "TLS: No Phase2 EAP methods available",0
000154  204e6f20
000158  50686173
00015c  65322045
000160  4150206d
000164  6574686f
000168  64732061
00016c  7661696c
000170  61626c65
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L4.376|
000178  544c533a          DCB      "TLS: Phase2 EAP types",0
00017c  20506861
000180  73653220
000184  45415020
000188  74797065
00018c  7300    
00018e  00                DCB      0
00018f  00                DCB      0

                          AREA ||i.eap_peer_tls_build_ack||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_build_ack PROC
;;;657     */
;;;658    struct wpabuf * eap_peer_tls_build_ack(u8 id, EapType eap_type,
000000  b5f8              PUSH     {r3-r7,lr}
;;;659    				       int peap_version)
;;;660    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;661    	struct wpabuf *resp;
;;;662    
;;;663    	resp = eap_msg_alloc(EAP_VENDOR_IETF, eap_type, 1, EAP_CODE_RESPONSE,
000008  2302              MOVS     r3,#2
00000a  2201              MOVS     r2,#1
00000c  4631              MOV      r1,r6
00000e  2000              MOVS     r0,#0
000010  9500              STR      r5,[sp,#0]
000012  f7fffffe          BL       eap_msg_alloc
000016  4607              MOV      r7,r0
;;;664    			     id);
;;;665    	if (resp == NULL)
000018  b90f              CBNZ     r7,|L5.30|
;;;666    		return NULL;
00001a  2000              MOVS     r0,#0
                  |L5.28|
;;;667    	wpa_printf(MSG_DEBUG, "SSL: Building ACK (type=%d id=%d ver=%d)",
;;;668    		   (int) eap_type, id, peap_version);
;;;669    	wpabuf_put_u8(resp, peap_version); /* Flags */
;;;670    	return resp;
;;;671    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L5.30|
00001e  462b              MOV      r3,r5                 ;667
000020  4632              MOV      r2,r6                 ;667
000022  a105              ADR      r1,|L5.56|
000024  2000              MOVS     r0,#0                 ;667
000026  9400              STR      r4,[sp,#0]            ;667
000028  f7fffffe          BL       wpa_printf
00002c  b2e1              UXTB     r1,r4                 ;669
00002e  4638              MOV      r0,r7                 ;669
000030  f7fffffe          BL       wpabuf_put_u8
000034  4638              MOV      r0,r7                 ;670
000036  e7f1              B        |L5.28|
;;;672    
                          ENDP

                  |L5.56|
000038  53534c3a          DCB      "SSL: Building ACK (type=%d id=%d ver=%d)",0
00003c  20427569
000040  6c64696e
000044  67204143
000048  4b202874
00004c  7970653d
000050  25642069
000054  643d2564
000058  20766572
00005c  3d256429
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.eap_peer_tls_data_reassemble||, CODE, READONLY, ALIGN=1

                  eap_peer_tls_data_reassemble PROC
;;;388     */
;;;389    static const struct wpabuf * eap_peer_tls_data_reassemble(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;390    	struct eap_ssl_data *data, const struct wpabuf *in_data,
;;;391    	int *need_more_input)
;;;392    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;393    	*need_more_input = 0;
00000a  2000              MOVS     r0,#0
00000c  6028              STR      r0,[r5,#0]
;;;394    
;;;395    	if (data->tls_in_left > wpabuf_len(in_data) || data->tls_in) {
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_len
000014  6961              LDR      r1,[r4,#0x14]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L6.30|
00001a  6920              LDR      r0,[r4,#0x10]
00001c  b160              CBZ      r0,|L6.56|
                  |L6.30|
;;;396    		/* Message has fragments */
;;;397    		int res = eap_peer_tls_reassemble_fragment(data, in_data);
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       eap_peer_tls_reassemble_fragment
000026  4607              MOV      r7,r0
;;;398    		if (res) {
000028  b12f              CBZ      r7,|L6.54|
;;;399    			if (res == 1)
00002a  2f01              CMP      r7,#1
00002c  d100              BNE      |L6.48|
;;;400    				*need_more_input = 1;
00002e  6028              STR      r0,[r5,#0]
                  |L6.48|
;;;401    			return NULL;
000030  2000              MOVS     r0,#0
                  |L6.50|
;;;402    		}
;;;403    
;;;404    		/* Message is now fully reassembled. */
;;;405    	} else {
;;;406    		/* No fragments in this message, so just make a copy of it. */
;;;407    		data->tls_in_left = 0;
;;;408    		data->tls_in = wpabuf_dup(in_data);
;;;409    		if (data->tls_in == NULL)
;;;410    			return NULL;
;;;411    	}
;;;412    
;;;413    	return data->tls_in;
;;;414    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L6.54|
000036  e009              B        |L6.76|
                  |L6.56|
000038  2000              MOVS     r0,#0                 ;407
00003a  6160              STR      r0,[r4,#0x14]         ;407
00003c  4630              MOV      r0,r6                 ;408
00003e  f7fffffe          BL       wpabuf_dup
000042  6120              STR      r0,[r4,#0x10]         ;408
000044  6920              LDR      r0,[r4,#0x10]         ;409
000046  b908              CBNZ     r0,|L6.76|
000048  2000              MOVS     r0,#0                 ;410
00004a  e7f2              B        |L6.50|
                  |L6.76|
00004c  6920              LDR      r0,[r4,#0x10]         ;413
00004e  e7f0              B        |L6.50|
;;;415    
                          ENDP


                          AREA ||i.eap_peer_tls_decrypt||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_decrypt PROC
;;;846     */
;;;847    int eap_peer_tls_decrypt(struct eap_sm *sm, struct eap_ssl_data *data,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;848    			 const struct wpabuf *in_data,
;;;849    			 struct wpabuf **in_decrypted)
;;;850    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;851    	const struct wpabuf *msg;
;;;852    	int need_more_input;
;;;853    
;;;854    	msg = eap_peer_tls_data_reassemble(data, in_data, &need_more_input);
00000c  466a              MOV      r2,sp
00000e  4639              MOV      r1,r7
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       eap_peer_tls_data_reassemble
000016  4680              MOV      r8,r0
;;;855    	if (msg == NULL)
000018  f1b80f00          CMP      r8,#0
00001c  d107              BNE      |L7.46|
;;;856    		return need_more_input ? 1 : -1;
00001e  9800              LDR      r0,[sp,#0]
000020  b110              CBZ      r0,|L7.40|
000022  2001              MOVS     r0,#1
                  |L7.36|
;;;857    
;;;858    	*in_decrypted = tls_connection_decrypt(sm->ssl_ctx, data->conn, msg);
;;;859    	eap_peer_tls_reset_input(data);
;;;860    	if (*in_decrypted == NULL) {
;;;861    		wpa_printf(MSG_INFO, "SSL: Failed to decrypt Phase 2 data");
;;;862    		return -1;
;;;863    	}
;;;864    	return 0;
;;;865    }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L7.40|
000028  f04f30ff          MOV      r0,#0xffffffff        ;856
00002c  e7fa              B        |L7.36|
                  |L7.46|
00002e  6821              LDR      r1,[r4,#0]            ;858
000030  4642              MOV      r2,r8                 ;858
000032  f8d60098          LDR      r0,[r6,#0x98]         ;858
000036  f7fffffe          BL       tls_connection_decrypt
00003a  6028              STR      r0,[r5,#0]            ;858
00003c  4620              MOV      r0,r4                 ;859
00003e  f7fffffe          BL       eap_peer_tls_reset_input
000042  6828              LDR      r0,[r5,#0]            ;860
000044  b930              CBNZ     r0,|L7.84|
000046  a104              ADR      r1,|L7.88|
000048  2000              MOVS     r0,#0                 ;861
00004a  f7fffffe          BL       wpa_printf
00004e  f04f30ff          MOV      r0,#0xffffffff        ;862
000052  e7e7              B        |L7.36|
                  |L7.84|
000054  2000              MOVS     r0,#0                 ;864
000056  e7e5              B        |L7.36|
;;;866    
                          ENDP

                  |L7.88|
000058  53534c3a          DCB      "SSL: Failed to decrypt Phase 2 data",0
00005c  20466169
000060  6c656420
000064  746f2064
000068  65637279
00006c  70742050
000070  68617365
000074  20322064
000078  61746100

                          AREA ||i.eap_peer_tls_derive_key||, CODE, READONLY, ALIGN=1

                  eap_peer_tls_derive_key PROC
;;;263     */
;;;264    u8 * eap_peer_tls_derive_key(struct eap_sm *sm, struct eap_ssl_data *data,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;265    			     const char *label, size_t len)
;;;266    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4691              MOV      r9,r2
00000c  4698              MOV      r8,r3
;;;267    	struct tls_keys keys;
;;;268    	u8 *rnd = NULL, *out;
00000e  2400              MOVS     r4,#0
;;;269    
;;;270    	out = os_malloc(len);
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       os_malloc
000016  4607              MOV      r7,r0
;;;271    	if (out == NULL)
000018  b91f              CBNZ     r7,|L8.34|
;;;272    		return NULL;
00001a  2000              MOVS     r0,#0
                  |L8.28|
;;;273    
;;;274    	/* First, try to use TLS library function for PRF, if available. */
;;;275    	if (tls_connection_prf(sm->ssl_ctx, data->conn, label, 0, out, len) ==
;;;276    	    0)
;;;277    		return out;
;;;278    
;;;279    	/*
;;;280    	 * TLS library did not support key generation, so get the needed TLS
;;;281    	 * session parameters and use an internal implementation of TLS PRF to
;;;282    	 * derive the key.
;;;283    	 */
;;;284    	if (tls_connection_get_keys(sm->ssl_ctx, data->conn, &keys))
;;;285    		goto fail;
;;;286    
;;;287    	if (keys.client_random == NULL || keys.server_random == NULL ||
;;;288    	    keys.master_key == NULL)
;;;289    		goto fail;
;;;290    
;;;291    	rnd = os_malloc(keys.client_random_len + keys.server_random_len);
;;;292    	if (rnd == NULL)
;;;293    		goto fail;
;;;294    	os_memcpy(rnd, keys.client_random, keys.client_random_len);
;;;295    	os_memcpy(rnd + keys.client_random_len, keys.server_random,
;;;296    		  keys.server_random_len);
;;;297    
;;;298    	if (tls_prf(keys.master_key, keys.master_key_len,
;;;299    		    label, rnd, keys.client_random_len +
;;;300    		    keys.server_random_len, out, len))
;;;301    		goto fail;
;;;302    
;;;303    	os_free(rnd);
;;;304    	return out;
;;;305    
;;;306    fail:
;;;307    	os_free(out);
;;;308    	os_free(rnd);
;;;309    	return NULL;
;;;310    }
00001c  b00b              ADD      sp,sp,#0x2c
00001e  e8bd83f0          POP      {r4-r9,pc}
                  |L8.34|
000022  e9cd7800          STRD     r7,r8,[sp,#0]         ;275
000026  6831              LDR      r1,[r6,#0]            ;275
000028  2300              MOVS     r3,#0                 ;275
00002a  464a              MOV      r2,r9                 ;275
00002c  f8d50098          LDR      r0,[r5,#0x98]         ;275
000030  f7fffffe          BL       tls_connection_prf
000034  b908              CBNZ     r0,|L8.58|
000036  4638              MOV      r0,r7                 ;277
000038  e7f0              B        |L8.28|
                  |L8.58|
00003a  6831              LDR      r1,[r6,#0]            ;284
00003c  aa03              ADD      r2,sp,#0xc            ;284
00003e  f8d50098          LDR      r0,[r5,#0x98]         ;284
000042  f7fffffe          BL       tls_connection_get_keys
000046  b100              CBZ      r0,|L8.74|
000048  e02b              B        |L8.162|
                  |L8.74|
00004a  9805              LDR      r0,[sp,#0x14]         ;287
00004c  b118              CBZ      r0,|L8.86|
00004e  9807              LDR      r0,[sp,#0x1c]         ;287
000050  b108              CBZ      r0,|L8.86|
000052  9803              LDR      r0,[sp,#0xc]          ;288
000054  b900              CBNZ     r0,|L8.88|
                  |L8.86|
000056  e024              B        |L8.162|
                  |L8.88|
000058  9a08              LDR      r2,[sp,#0x20]         ;291
00005a  9906              LDR      r1,[sp,#0x18]         ;291
00005c  1888              ADDS     r0,r1,r2              ;291
00005e  f7fffffe          BL       os_malloc
000062  4604              MOV      r4,r0                 ;291
000064  b904              CBNZ     r4,|L8.104|
000066  e01c              B        |L8.162|
                  |L8.104|
000068  4620              MOV      r0,r4                 ;294
00006a  e9dd1205          LDRD     r1,r2,[sp,#0x14]      ;294
00006e  f7fffffe          BL       os_memcpy
000072  e9dd3106          LDRD     r3,r1,[sp,#0x18]      ;295
000076  1918              ADDS     r0,r3,r4              ;295
000078  9a08              LDR      r2,[sp,#0x20]         ;295
00007a  f7fffffe          BL       os_memcpy
00007e  9908              LDR      r1,[sp,#0x20]         ;298
000080  9806              LDR      r0,[sp,#0x18]         ;298
000082  4401              ADD      r1,r1,r0              ;298
000084  e88d0182          STM      sp,{r1,r7,r8}         ;298
000088  4623              MOV      r3,r4                 ;298
00008a  464a              MOV      r2,r9                 ;298
00008c  e9dd0103          LDRD     r0,r1,[sp,#0xc]       ;298
000090  f7fffffe          BL       tls_prf
000094  b100              CBZ      r0,|L8.152|
000096  e004              B        |L8.162|
                  |L8.152|
000098  4620              MOV      r0,r4                 ;303
00009a  f7fffffe          BL       os_free
00009e  4638              MOV      r0,r7                 ;304
0000a0  e7bc              B        |L8.28|
                  |L8.162|
0000a2  4638              MOV      r0,r7                 ;307
0000a4  f7fffffe          BL       os_free
0000a8  4620              MOV      r0,r4                 ;308
0000aa  f7fffffe          BL       os_free
0000ae  2000              MOVS     r0,#0                 ;309
0000b0  e7b4              B        |L8.28|
;;;311    
                          ENDP


                          AREA ||i.eap_peer_tls_encrypt||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_encrypt PROC
;;;878     */
;;;879    int eap_peer_tls_encrypt(struct eap_sm *sm, struct eap_ssl_data *data,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;880    			 EapType eap_type, int peap_version, u8 id,
;;;881    			 const struct wpabuf *in_data,
;;;882    			 struct wpabuf **out_data)
;;;883    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd5a0d          LDRD     r5,r10,[sp,#0x34]
000010  f8dd9030          LDR      r9,[sp,#0x30]
;;;884    	if (in_data) {
000014  b1dd              CBZ      r5,|L9.78|
;;;885    		eap_peer_tls_reset_output(data);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       eap_peer_tls_reset_output
;;;886    		data->tls_out = tls_connection_encrypt(sm->ssl_ctx, data->conn,
00001c  6821              LDR      r1,[r4,#0]
00001e  462a              MOV      r2,r5
000020  f8d60098          LDR      r0,[r6,#0x98]
000024  f7fffffe          BL       tls_connection_encrypt
000028  6060              STR      r0,[r4,#4]
;;;887    						       in_data);
;;;888    		if (data->tls_out == NULL) {
00002a  6860              LDR      r0,[r4,#4]
00002c  b978              CBNZ     r0,|L9.78|
;;;889    			wpa_printf(MSG_INFO, "SSL: Failed to encrypt Phase 2 "
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       wpabuf_len
000034  4683              MOV      r11,r0
000036  4602              MOV      r2,r0
000038  a10a              ADR      r1,|L9.100|
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       wpa_printf
;;;890    				   "data (in_len=%lu)",
;;;891    				   (unsigned long) wpabuf_len(in_data));
;;;892    			eap_peer_tls_reset_output(data);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       eap_peer_tls_reset_output
;;;893    			return -1;
000046  f04f30ff          MOV      r0,#0xffffffff
                  |L9.74|
;;;894    		}
;;;895    	}
;;;896    
;;;897    	return eap_tls_process_output(data, eap_type, peap_version, id, 0,
;;;898    				      out_data);
;;;899    }
00004a  e8bd9ffc          POP      {r2-r12,pc}
                  |L9.78|
00004e  2200              MOVS     r2,#0                 ;897
000050  464b              MOV      r3,r9                 ;897
000052  e9cd2a00          STRD     r2,r10,[sp,#0]        ;897
000056  4642              MOV      r2,r8                 ;897
000058  4639              MOV      r1,r7                 ;897
00005a  4620              MOV      r0,r4                 ;897
00005c  f7fffffe          BL       eap_tls_process_output
000060  e7f3              B        |L9.74|
;;;900    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
000064  53534c3a          DCB      "SSL: Failed to encrypt Phase 2 data (in_len=%lu)",0
000068  20466169
00006c  6c656420
000070  746f2065
000074  6e637279
000078  70742050
00007c  68617365
000080  20322064
000084  61746120
000088  28696e5f
00008c  6c656e3d
000090  256c7529
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.eap_peer_tls_phase2_nak||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_phase2_nak PROC
;;;995     */
;;;996    int eap_peer_tls_phase2_nak(struct eap_method_type *types, size_t num_types,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;997    			    struct eap_hdr *hdr, struct wpabuf **resp)
;;;998    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;999    	u8 *pos = (u8 *) (hdr + 1);
00000c  f1080904          ADD      r9,r8,#4
;;;1000   	size_t i;
;;;1001   
;;;1002   	/* TODO: add support for expanded Nak */
;;;1003   	wpa_printf(MSG_DEBUG, "TLS: Phase 2 Request: Nak type=%d", *pos);
000010  f8992000          LDRB     r2,[r9,#0]
000014  a119              ADR      r1,|L10.124|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       wpa_printf
;;;1004   	wpa_hexdump(MSG_DEBUG, "TLS: Allowed Phase2 EAP types",
00001c  00fb              LSLS     r3,r7,#3
00001e  462a              MOV      r2,r5
000020  a11f              ADR      r1,|L10.160|
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       wpa_hexdump
;;;1005   		    (u8 *) types, num_types * sizeof(struct eap_method_type));
;;;1006   	*resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_NAK, num_types,
000028  f8983001          LDRB     r3,[r8,#1]
00002c  9300              STR      r3,[sp,#0]
00002e  2302              MOVS     r3,#2
000030  463a              MOV      r2,r7
000032  2103              MOVS     r1,#3
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       eap_msg_alloc
00003a  6030              STR      r0,[r6,#0]
;;;1007   			      EAP_CODE_RESPONSE, hdr->identifier);
;;;1008   	if (*resp == NULL)
00003c  6830              LDR      r0,[r6,#0]
00003e  b918              CBNZ     r0,|L10.72|
;;;1009   		return -1;
000040  f04f30ff          MOV      r0,#0xffffffff
                  |L10.68|
;;;1010   
;;;1011   	for (i = 0; i < num_types; i++) {
;;;1012   		if (types[i].vendor == EAP_VENDOR_IETF &&
;;;1013   		    types[i].method < 256)
;;;1014   			wpabuf_put_u8(*resp, types[i].method);
;;;1015   	}
;;;1016   
;;;1017   	eap_update_len(*resp);
;;;1018   
;;;1019   	return 0;
;;;1020   }
000044  e8bd83f8          POP      {r3-r9,pc}
                  |L10.72|
000048  2400              MOVS     r4,#0                 ;1011
00004a  e00f              B        |L10.108|
                  |L10.76|
00004c  f8550034          LDR      r0,[r5,r4,LSL #3]     ;1012
000050  b958              CBNZ     r0,|L10.106|
000052  eb0500c4          ADD      r0,r5,r4,LSL #3       ;1013
000056  6840              LDR      r0,[r0,#4]            ;1013
000058  28ff              CMP      r0,#0xff              ;1013
00005a  d806              BHI      |L10.106|
00005c  eb0502c4          ADD      r2,r5,r4,LSL #3       ;1014
000060  6852              LDR      r2,[r2,#4]            ;1014
000062  b2d1              UXTB     r1,r2                 ;1014
000064  6830              LDR      r0,[r6,#0]            ;1014
000066  f7fffffe          BL       wpabuf_put_u8
                  |L10.106|
00006a  1c64              ADDS     r4,r4,#1              ;1011
                  |L10.108|
00006c  42bc              CMP      r4,r7                 ;1011
00006e  d3ed              BCC      |L10.76|
000070  6830              LDR      r0,[r6,#0]            ;1017
000072  f7fffffe          BL       eap_update_len
000076  2000              MOVS     r0,#0                 ;1019
000078  e7e4              B        |L10.68|
                          ENDP

00007a  0000              DCW      0x0000
                  |L10.124|
00007c  544c533a          DCB      "TLS: Phase 2 Request: Nak type=%d",0
000080  20506861
000084  73652032
000088  20526571
00008c  75657374
000090  3a204e61
000094  6b207479
000098  70653d25
00009c  6400    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L10.160|
0000a0  544c533a          DCB      "TLS: Allowed Phase2 EAP types",0
0000a4  20416c6c
0000a8  6f776564
0000ac  20506861
0000b0  73653220
0000b4  45415020
0000b8  74797065
0000bc  7300    
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.eap_peer_tls_process_helper||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_process_helper PROC
;;;578     */
;;;579    int eap_peer_tls_process_helper(struct eap_sm *sm, struct eap_ssl_data *data,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;580    				EapType eap_type, int peap_version,
;;;581    				u8 id, const u8 *in_data, size_t in_len,
;;;582    				struct wpabuf **out_data)
;;;583    {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  f8ddb040          LDR      r11,[sp,#0x40]
000012  e9dd8912          LDRD     r8,r9,[sp,#0x48]
;;;584    	int ret = 0;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;585    
;;;586    	*out_data = NULL;
00001a  f8c90000          STR      r0,[r9,#0]
;;;587    
;;;588    	if (data->tls_out && wpabuf_len(data->tls_out) > 0 && in_len > 0) {
00001e  6860              LDR      r0,[r4,#4]
000020  b178              CBZ      r0,|L11.66|
000022  6860              LDR      r0,[r4,#4]
000024  f7fffffe          BL       wpabuf_len
000028  b158              CBZ      r0,|L11.66|
00002a  f1b80f00          CMP      r8,#0
00002e  d008              BEQ      |L11.66|
;;;589    		wpa_printf(MSG_DEBUG, "SSL: Received non-ACK when output "
000030  4926              LDR      r1,|L11.204|
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       wpa_printf
;;;590    			   "fragments are waiting to be sent out");
;;;591    		return -1;
000038  f04f30ff          MOV      r0,#0xffffffff
                  |L11.60|
;;;592    	}
;;;593    
;;;594    	if (data->tls_out == NULL || wpabuf_len(data->tls_out) == 0) {
;;;595    		/*
;;;596    		 * No more data to send out - expect to receive more data from
;;;597    		 * the AS.
;;;598    		 */
;;;599    		int res = eap_tls_process_input(sm, data, in_data, in_len,
;;;600    						out_data);
;;;601    		if (res) {
;;;602    			/*
;;;603    			 * Input processing failed (res = -1) or more data is
;;;604    			 * needed (res = 1).
;;;605    			 */
;;;606    			return res;
;;;607    		}
;;;608    
;;;609    		/*
;;;610    		 * The incoming message has been reassembled and processed. The
;;;611    		 * response was allocated into data->tls_out buffer.
;;;612    		 */
;;;613    	}
;;;614    
;;;615    	if (data->tls_out == NULL) {
;;;616    		/*
;;;617    		 * No outgoing fragments remaining from the previous message
;;;618    		 * and no new message generated. This indicates an error in TLS
;;;619    		 * processing.
;;;620    		 */
;;;621    		eap_peer_tls_reset_output(data);
;;;622    		return -1;
;;;623    	}
;;;624    
;;;625    	if (tls_connection_get_failed(sm->ssl_ctx, data->conn)) {
;;;626    		/* TLS processing has failed - return error */
;;;627    		wpa_printf(MSG_DEBUG, "SSL: Failed - tls_out available to "
;;;628    			   "report error");
;;;629    		ret = -1;
;;;630    		/* TODO: clean pin if engine used? */
;;;631    	}
;;;632    
;;;633    	if (data->tls_out == NULL || wpabuf_len(data->tls_out) == 0) {
;;;634    		/*
;;;635    		 * TLS negotiation should now be complete since all other cases
;;;636    		 * needing more data should have been caught above based on
;;;637    		 * the TLS Message Length field.
;;;638    		 */
;;;639    		wpa_printf(MSG_DEBUG, "SSL: No data to be sent out");
;;;640    		wpabuf_free(data->tls_out);
;;;641    		data->tls_out = NULL;
;;;642    		return 1;
;;;643    	}
;;;644    
;;;645    	/* Send the pending message (in fragments, if needed). */
;;;646    	return eap_tls_process_output(data, eap_type, peap_version, id, ret,
;;;647    				      out_data);
;;;648    }
00003c  b007              ADD      sp,sp,#0x1c
00003e  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.66|
000042  6860              LDR      r0,[r4,#4]            ;594
000044  b118              CBZ      r0,|L11.78|
000046  6860              LDR      r0,[r4,#4]            ;594
000048  f7fffffe          BL       wpabuf_len
00004c  b970              CBNZ     r0,|L11.108|
                  |L11.78|
00004e  4643              MOV      r3,r8                 ;599
000050  f8cd9000          STR      r9,[sp,#0]            ;599
000054  4621              MOV      r1,r4                 ;599
000056  4628              MOV      r0,r5                 ;599
000058  9a11              LDR      r2,[sp,#0x44]         ;599
00005a  f7fffffe          BL       eap_tls_process_input
00005e  4682              MOV      r10,r0                ;599
000060  f1ba0f00          CMP      r10,#0                ;601
000064  d001              BEQ      |L11.106|
000066  4650              MOV      r0,r10                ;606
000068  e7e8              B        |L11.60|
                  |L11.106|
00006a  bf00              NOP                            ;613
                  |L11.108|
00006c  6860              LDR      r0,[r4,#4]            ;615
00006e  b928              CBNZ     r0,|L11.124|
000070  4620              MOV      r0,r4                 ;621
000072  f7fffffe          BL       eap_peer_tls_reset_output
000076  f04f30ff          MOV      r0,#0xffffffff        ;622
00007a  e7df              B        |L11.60|
                  |L11.124|
00007c  6821              LDR      r1,[r4,#0]            ;625
00007e  f8d50098          LDR      r0,[r5,#0x98]         ;625
000082  f7fffffe          BL       tls_connection_get_failed
000086  b130              CBZ      r0,|L11.150|
000088  a111              ADR      r1,|L11.208|
00008a  2000              MOVS     r0,#0                 ;627
00008c  f7fffffe          BL       wpa_printf
000090  f04f30ff          MOV      r0,#0xffffffff        ;629
000094  9002              STR      r0,[sp,#8]            ;629
                  |L11.150|
000096  6860              LDR      r0,[r4,#4]            ;633
000098  b118              CBZ      r0,|L11.162|
00009a  6860              LDR      r0,[r4,#4]            ;633
00009c  f7fffffe          BL       wpabuf_len
0000a0  b950              CBNZ     r0,|L11.184|
                  |L11.162|
0000a2  a117              ADR      r1,|L11.256|
0000a4  2000              MOVS     r0,#0                 ;639
0000a6  f7fffffe          BL       wpa_printf
0000aa  6860              LDR      r0,[r4,#4]            ;640
0000ac  f7fffffe          BL       wpabuf_free
0000b0  2000              MOVS     r0,#0                 ;641
0000b2  6060              STR      r0,[r4,#4]            ;641
0000b4  2001              MOVS     r0,#1                 ;642
0000b6  e7c1              B        |L11.60|
                  |L11.184|
0000b8  9a02              LDR      r2,[sp,#8]            ;646
0000ba  465b              MOV      r3,r11                ;646
0000bc  e9cd2900          STRD     r2,r9,[sp,#0]         ;646
0000c0  463a              MOV      r2,r7                 ;646
0000c2  4631              MOV      r1,r6                 ;646
0000c4  4620              MOV      r0,r4                 ;646
0000c6  f7fffffe          BL       eap_tls_process_output
0000ca  e7b7              B        |L11.60|
;;;649    
                          ENDP

                  |L11.204|
                          DCD      ||.constdata||+0xb0
                  |L11.208|
0000d0  53534c3a          DCB      "SSL: Failed - tls_out available to report error",0
0000d4  20466169
0000d8  6c656420
0000dc  2d20746c
0000e0  735f6f75
0000e4  74206176
0000e8  61696c61
0000ec  626c6520
0000f0  746f2072
0000f4  65706f72
0000f8  74206572
0000fc  726f7200
                  |L11.256|
000100  53534c3a          DCB      "SSL: No data to be sent out",0
000104  204e6f20
000108  64617461
00010c  20746f20
000110  62652073
000114  656e7420
000118  6f757400

                          AREA ||i.eap_peer_tls_process_init||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_process_init PROC
;;;738     */
;;;739    const u8 * eap_peer_tls_process_init(struct eap_sm *sm,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;740    				     struct eap_ssl_data *data,
;;;741    				     EapType eap_type,
;;;742    				     struct eap_method_ret *ret,
;;;743    				     const struct wpabuf *reqData,
;;;744    				     size_t *len, u8 *flags)
;;;745    {
000004  b083              SUB      sp,sp,#0xc
000006  4681              MOV      r9,r0
000008  460e              MOV      r6,r1
00000a  4692              MOV      r10,r2
00000c  461d              MOV      r5,r3
00000e  f8ddb040          LDR      r11,[sp,#0x40]
000012  9f12              LDR      r7,[sp,#0x48]
;;;746    	const u8 *pos;
;;;747    	size_t left;
;;;748    	unsigned int tls_msg_len;
;;;749    
;;;750    	if (tls_get_errors(sm->ssl_ctx)) {
000014  f8d90098          LDR      r0,[r9,#0x98]
000018  f7fffffe          BL       tls_get_errors
00001c  b148              CBZ      r0,|L12.50|
;;;751    		wpa_printf(MSG_INFO, "SSL: TLS errors detected");
00001e  a13a              ADR      r1,|L12.264|
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       wpa_printf
;;;752    		ret->ignore = TRUE;
000026  2001              MOVS     r0,#1
000028  6028              STR      r0,[r5,#0]
;;;753    		return NULL;
00002a  2000              MOVS     r0,#0
                  |L12.44|
;;;754    	}
;;;755    
;;;756    	pos = eap_hdr_validate(EAP_VENDOR_IETF, eap_type, reqData, &left);
;;;757    	if (pos == NULL) {
;;;758    		ret->ignore = TRUE;
;;;759    		return NULL;
;;;760    	}
;;;761    	if (left == 0) {
;;;762    		wpa_printf(MSG_DEBUG, "SSL: Invalid TLS message: no Flags "
;;;763    			   "octet included");
;;;764    		if (!sm->workaround) {
;;;765    			ret->ignore = TRUE;
;;;766    			return NULL;
;;;767    		}
;;;768    
;;;769    		wpa_printf(MSG_DEBUG, "SSL: Workaround - assume no Flags "
;;;770    			   "indicates ACK frame");
;;;771    		*flags = 0;
;;;772    	} else {
;;;773    		*flags = *pos++;
;;;774    		left--;
;;;775    	}
;;;776    	wpa_printf(MSG_DEBUG, "SSL: Received packet(len=%lu) - "
;;;777    		   "Flags 0x%02x", (unsigned long) wpabuf_len(reqData),
;;;778    		   *flags);
;;;779    	if (*flags & EAP_TLS_FLAGS_LENGTH_INCLUDED) {
;;;780    		if (left < 4) {
;;;781    			wpa_printf(MSG_INFO, "SSL: Short frame with TLS "
;;;782    				   "length");
;;;783    			ret->ignore = TRUE;
;;;784    			return NULL;
;;;785    		}
;;;786    		tls_msg_len = WPA_GET_BE32(pos);
;;;787    		wpa_printf(MSG_DEBUG, "SSL: TLS Message Length: %d",
;;;788    			   tls_msg_len);
;;;789    		if (data->tls_in_left == 0) {
;;;790    			data->tls_in_total = tls_msg_len;
;;;791    			data->tls_in_left = tls_msg_len;
;;;792    			wpabuf_free(data->tls_in);
;;;793    			data->tls_in = NULL;
;;;794    		}
;;;795    		pos += 4;
;;;796    		left -= 4;
;;;797    	}
;;;798    
;;;799    	ret->ignore = FALSE;
;;;800    	ret->methodState = METHOD_MAY_CONT;
;;;801    	ret->decision = DECISION_FAIL;
;;;802    	ret->allowNotifications = TRUE;
;;;803    
;;;804    	*len = left;
;;;805    	return pos;
;;;806    }
00002c  b007              ADD      sp,sp,#0x1c
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.50|
000032  ab02              ADD      r3,sp,#8              ;756
000034  465a              MOV      r2,r11                ;756
000036  4651              MOV      r1,r10                ;756
000038  2000              MOVS     r0,#0                 ;756
00003a  f7fffffe          BL       eap_hdr_validate
00003e  4604              MOV      r4,r0                 ;756
000040  b91c              CBNZ     r4,|L12.74|
000042  2001              MOVS     r0,#1                 ;758
000044  6028              STR      r0,[r5,#0]            ;758
000046  2000              MOVS     r0,#0                 ;759
000048  e7f0              B        |L12.44|
                  |L12.74|
00004a  9802              LDR      r0,[sp,#8]            ;761
00004c  b988              CBNZ     r0,|L12.114|
00004e  a135              ADR      r1,|L12.292|
000050  2000              MOVS     r0,#0                 ;762
000052  f7fffffe          BL       wpa_printf
000056  f8d9009c          LDR      r0,[r9,#0x9c]         ;764
00005a  b918              CBNZ     r0,|L12.100|
00005c  2001              MOVS     r0,#1                 ;765
00005e  6028              STR      r0,[r5,#0]            ;765
000060  2000              MOVS     r0,#0                 ;766
000062  e7e3              B        |L12.44|
                  |L12.100|
000064  a13c              ADR      r1,|L12.344|
000066  2000              MOVS     r0,#0                 ;769
000068  f7fffffe          BL       wpa_printf
00006c  2000              MOVS     r0,#0                 ;771
00006e  7038              STRB     r0,[r7,#0]            ;771
000070  e005              B        |L12.126|
                  |L12.114|
000072  f8140b01          LDRB     r0,[r4],#1            ;773
000076  7038              STRB     r0,[r7,#0]            ;773
000078  9802              LDR      r0,[sp,#8]            ;774
00007a  1e40              SUBS     r0,r0,#1              ;774
00007c  9002              STR      r0,[sp,#8]            ;774
                  |L12.126|
00007e  4658              MOV      r0,r11                ;776
000080  f7fffffe          BL       wpabuf_len
000084  9001              STR      r0,[sp,#4]            ;776
000086  783b              LDRB     r3,[r7,#0]            ;776
000088  4602              MOV      r2,r0                 ;776
00008a  a141              ADR      r1,|L12.400|
00008c  2000              MOVS     r0,#0                 ;776
00008e  f7fffffe          BL       wpa_printf
000092  7838              LDRB     r0,[r7,#0]            ;779
000094  f0100f80          TST      r0,#0x80              ;779
000098  d029              BEQ      |L12.238|
00009a  9802              LDR      r0,[sp,#8]            ;780
00009c  2804              CMP      r0,#4                 ;780
00009e  d207              BCS      |L12.176|
0000a0  a147              ADR      r1,|L12.448|
0000a2  2000              MOVS     r0,#0                 ;781
0000a4  f7fffffe          BL       wpa_printf
0000a8  2001              MOVS     r0,#1                 ;783
0000aa  6028              STR      r0,[r5,#0]            ;783
0000ac  2000              MOVS     r0,#0                 ;784
0000ae  e7bd              B        |L12.44|
                  |L12.176|
0000b0  7820              LDRB     r0,[r4,#0]            ;786
0000b2  0600              LSLS     r0,r0,#24             ;786
0000b4  7861              LDRB     r1,[r4,#1]            ;786
0000b6  ea404001          ORR      r0,r0,r1,LSL #16      ;786
0000ba  78a1              LDRB     r1,[r4,#2]            ;786
0000bc  ea402001          ORR      r0,r0,r1,LSL #8       ;786
0000c0  78e1              LDRB     r1,[r4,#3]            ;786
0000c2  ea400801          ORR      r8,r0,r1              ;786
0000c6  4642              MOV      r2,r8                 ;787
0000c8  a146              ADR      r1,|L12.484|
0000ca  2000              MOVS     r0,#0                 ;787
0000cc  f7fffffe          BL       wpa_printf
0000d0  6970              LDR      r0,[r6,#0x14]         ;789
0000d2  b940              CBNZ     r0,|L12.230|
0000d4  f8c68018          STR      r8,[r6,#0x18]         ;790
0000d8  f8c68014          STR      r8,[r6,#0x14]         ;791
0000dc  6930              LDR      r0,[r6,#0x10]         ;792
0000de  f7fffffe          BL       wpabuf_free
0000e2  2000              MOVS     r0,#0                 ;793
0000e4  6130              STR      r0,[r6,#0x10]         ;793
                  |L12.230|
0000e6  1d24              ADDS     r4,r4,#4              ;795
0000e8  9802              LDR      r0,[sp,#8]            ;796
0000ea  1f00              SUBS     r0,r0,#4              ;796
0000ec  9002              STR      r0,[sp,#8]            ;796
                  |L12.238|
0000ee  2000              MOVS     r0,#0                 ;799
0000f0  6028              STR      r0,[r5,#0]            ;799
0000f2  2003              MOVS     r0,#3                 ;800
0000f4  7128              STRB     r0,[r5,#4]            ;800
0000f6  2000              MOVS     r0,#0                 ;801
0000f8  7168              STRB     r0,[r5,#5]            ;801
0000fa  2001              MOVS     r0,#1                 ;802
0000fc  60a8              STR      r0,[r5,#8]            ;802
0000fe  9902              LDR      r1,[sp,#8]            ;804
000100  9811              LDR      r0,[sp,#0x44]         ;804
000102  6001              STR      r1,[r0,#0]            ;804
000104  4620              MOV      r0,r4                 ;805
000106  e791              B        |L12.44|
;;;807    
                          ENDP

                  |L12.264|
000108  53534c3a          DCB      "SSL: TLS errors detected",0
00010c  20544c53
000110  20657272
000114  6f727320
000118  64657465
00011c  63746564
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L12.292|
000124  53534c3a          DCB      "SSL: Invalid TLS message: no Flags octet included",0
000128  20496e76
00012c  616c6964
000130  20544c53
000134  206d6573
000138  73616765
00013c  3a206e6f
000140  20466c61
000144  6773206f
000148  63746574
00014c  20696e63
000150  6c756465
000154  6400    
000156  00                DCB      0
000157  00                DCB      0
                  |L12.344|
000158  53534c3a          DCB      "SSL: Workaround - assume no Flags indicates ACK frame",0
00015c  20576f72
000160  6b61726f
000164  756e6420
000168  2d206173
00016c  73756d65
000170  206e6f20
000174  466c6167
000178  7320696e
00017c  64696361
000180  74657320
000184  41434b20
000188  6672616d
00018c  6500    
00018e  00                DCB      0
00018f  00                DCB      0
                  |L12.400|
000190  53534c3a          DCB      "SSL: Received packet(len=%lu) - Flags 0x%02x",0
000194  20526563
000198  65697665
00019c  64207061
0001a0  636b6574
0001a4  286c656e
0001a8  3d256c75
0001ac  29202d20
0001b0  466c6167
0001b4  73203078
0001b8  25303278
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L12.448|
0001c0  53534c3a          DCB      "SSL: Short frame with TLS length",0
0001c4  2053686f
0001c8  72742066
0001cc  72616d65
0001d0  20776974
0001d4  6820544c
0001d8  53206c65
0001dc  6e677468
0001e0  00      
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L12.484|
0001e4  53534c3a          DCB      "SSL: TLS Message Length: %d",0
0001e8  20544c53
0001ec  204d6573
0001f0  73616765
0001f4  204c656e
0001f8  6774683a
0001fc  20256400

                          AREA ||i.eap_peer_tls_reassemble_fragment||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_reassemble_fragment PROC
;;;319     */
;;;320    static int eap_peer_tls_reassemble_fragment(struct eap_ssl_data *data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;321    					    const struct wpabuf *in_data)
;;;322    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;323    	size_t tls_in_len, in_len;
;;;324    
;;;325    	tls_in_len = data->tls_in ? wpabuf_len(data->tls_in) : 0;
000006  6920              LDR      r0,[r4,#0x10]
000008  b118              CBZ      r0,|L13.18|
00000a  6920              LDR      r0,[r4,#0x10]
00000c  f7fffffe          BL       wpabuf_len
000010  e000              B        |L13.20|
                  |L13.18|
000012  2000              MOVS     r0,#0
                  |L13.20|
000014  4607              MOV      r7,r0
;;;326    	in_len = in_data ? wpabuf_len(in_data) : 0;
000016  b11e              CBZ      r6,|L13.32|
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       wpabuf_len
00001e  e000              B        |L13.34|
                  |L13.32|
000020  2000              MOVS     r0,#0
                  |L13.34|
000022  4605              MOV      r5,r0
;;;327    
;;;328    	if (tls_in_len + in_len == 0) {
000024  1978              ADDS     r0,r7,r5
000026  d10b              BNE      |L13.64|
;;;329    		/* No message data received?! */
;;;330    		wpa_printf(MSG_WARNING, "SSL: Invalid reassembly state: "
000028  9500              STR      r5,[sp,#0]
00002a  463b              MOV      r3,r7
00002c  4923              LDR      r1,|L13.188|
00002e  6962              LDR      r2,[r4,#0x14]
000030  f7fffffe          BL       wpa_printf
;;;331    			   "tls_in_left=%lu tls_in_len=%lu in_len=%lu",
;;;332    			   (unsigned long) data->tls_in_left,
;;;333    			   (unsigned long) tls_in_len,
;;;334    			   (unsigned long) in_len);
;;;335    		eap_peer_tls_reset_input(data);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       eap_peer_tls_reset_input
;;;336    		return -1;
00003a  f04f30ff          MOV      r0,#0xffffffff
                  |L13.62|
;;;337    	}
;;;338    
;;;339    	if (tls_in_len + in_len > 65536) {
;;;340    		/*
;;;341    		 * Limit length to avoid rogue servers from causing large
;;;342    		 * memory allocations.
;;;343    		 */
;;;344    		wpa_printf(MSG_INFO, "SSL: Too long TLS fragment (size over "
;;;345    			   "64 kB)");
;;;346    		eap_peer_tls_reset_input(data);
;;;347    		return -1;
;;;348    	}
;;;349    
;;;350    	if (in_len > data->tls_in_left) {
;;;351    		/* Sender is doing something odd - reject message */
;;;352    		wpa_printf(MSG_INFO, "SSL: more data than TLS message length "
;;;353    			   "indicated");
;;;354    		eap_peer_tls_reset_input(data);
;;;355    		return -1;
;;;356    	}
;;;357    
;;;358    	if (wpabuf_resize(&data->tls_in, in_len) < 0) {
;;;359    		wpa_printf(MSG_INFO, "SSL: Could not allocate memory for TLS "
;;;360    			   "data");
;;;361    		eap_peer_tls_reset_input(data);
;;;362    		return -1;
;;;363    	}
;;;364    	wpabuf_put_buf(data->tls_in, in_data);
;;;365    	data->tls_in_left -= in_len;
;;;366    
;;;367    	if (data->tls_in_left > 0) {
;;;368    		wpa_printf(MSG_DEBUG, "SSL: Need %lu bytes more input "
;;;369    			   "data", (unsigned long) data->tls_in_left);
;;;370    		return 1;
;;;371    	}
;;;372    
;;;373    	return 0;
;;;374    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L13.64|
000040  1978              ADDS     r0,r7,r5              ;339
000042  f5b03f80          CMP      r0,#0x10000           ;339
000046  d909              BLS      |L13.92|
000048  a11d              ADR      r1,|L13.192|
00004a  2000              MOVS     r0,#0                 ;344
00004c  f7fffffe          BL       wpa_printf
000050  4620              MOV      r0,r4                 ;346
000052  f7fffffe          BL       eap_peer_tls_reset_input
000056  f04f30ff          MOV      r0,#0xffffffff        ;347
00005a  e7f0              B        |L13.62|
                  |L13.92|
00005c  6960              LDR      r0,[r4,#0x14]         ;350
00005e  42a8              CMP      r0,r5                 ;350
000060  d209              BCS      |L13.118|
000062  a123              ADR      r1,|L13.240|
000064  2000              MOVS     r0,#0                 ;352
000066  f7fffffe          BL       wpa_printf
00006a  4620              MOV      r0,r4                 ;354
00006c  f7fffffe          BL       eap_peer_tls_reset_input
000070  f04f30ff          MOV      r0,#0xffffffff        ;355
000074  e7e3              B        |L13.62|
                  |L13.118|
000076  4629              MOV      r1,r5                 ;358
000078  f1040010          ADD      r0,r4,#0x10           ;358
00007c  f7fffffe          BL       wpabuf_resize
000080  2800              CMP      r0,#0                 ;358
000082  da09              BGE      |L13.152|
000084  a127              ADR      r1,|L13.292|
000086  2000              MOVS     r0,#0                 ;359
000088  f7fffffe          BL       wpa_printf
00008c  4620              MOV      r0,r4                 ;361
00008e  f7fffffe          BL       eap_peer_tls_reset_input
000092  f04f30ff          MOV      r0,#0xffffffff        ;362
000096  e7d2              B        |L13.62|
                  |L13.152|
000098  4631              MOV      r1,r6                 ;364
00009a  6920              LDR      r0,[r4,#0x10]         ;364
00009c  f7fffffe          BL       wpabuf_put_buf
0000a0  6960              LDR      r0,[r4,#0x14]         ;365
0000a2  1b40              SUBS     r0,r0,r5              ;365
0000a4  6160              STR      r0,[r4,#0x14]         ;365
0000a6  6960              LDR      r0,[r4,#0x14]         ;367
0000a8  b130              CBZ      r0,|L13.184|
0000aa  a129              ADR      r1,|L13.336|
0000ac  2000              MOVS     r0,#0                 ;368
0000ae  6962              LDR      r2,[r4,#0x14]         ;368
0000b0  f7fffffe          BL       wpa_printf
0000b4  2001              MOVS     r0,#1                 ;370
0000b6  e7c2              B        |L13.62|
                  |L13.184|
0000b8  2000              MOVS     r0,#0                 ;373
0000ba  e7c0              B        |L13.62|
;;;375    
                          ENDP

                  |L13.188|
                          DCD      ||.constdata||+0x14
                  |L13.192|
0000c0  53534c3a          DCB      "SSL: Too long TLS fragment (size over 64 kB)",0
0000c4  20546f6f
0000c8  206c6f6e
0000cc  6720544c
0000d0  53206672
0000d4  61676d65
0000d8  6e742028
0000dc  73697a65
0000e0  206f7665
0000e4  72203634
0000e8  206b4229
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L13.240|
0000f0  53534c3a          DCB      "SSL: more data than TLS message length indicated",0
0000f4  206d6f72
0000f8  65206461
0000fc  74612074
000100  68616e20
000104  544c5320
000108  6d657373
00010c  61676520
000110  6c656e67
000114  74682069
000118  6e646963
00011c  61746564
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L13.292|
000124  53534c3a          DCB      "SSL: Could not allocate memory for TLS data",0
000128  20436f75
00012c  6c64206e
000130  6f742061
000134  6c6c6f63
000138  61746520
00013c  6d656d6f
000140  72792066
000144  6f722054
000148  4c532064
00014c  61746100
                  |L13.336|
000150  53534c3a          DCB      "SSL: Need %lu bytes more input data",0
000154  204e6565
000158  6420256c
00015c  75206279
000160  74657320
000164  6d6f7265
000168  20696e70
00016c  75742064
000170  61746100

                          AREA ||i.eap_peer_tls_reauth_init||, CODE, READONLY, ALIGN=1

                  eap_peer_tls_reauth_init PROC
;;;679     */
;;;680    int eap_peer_tls_reauth_init(struct eap_sm *sm, struct eap_ssl_data *data)
000000  b570              PUSH     {r4-r6,lr}
;;;681    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;682    	eap_peer_tls_reset_input(data);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       eap_peer_tls_reset_input
;;;683    	eap_peer_tls_reset_output(data);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       eap_peer_tls_reset_output
;;;684    	return tls_connection_shutdown(sm->ssl_ctx, data->conn);
000012  6821              LDR      r1,[r4,#0]
000014  f8d50098          LDR      r0,[r5,#0x98]
000018  f7fffffe          BL       tls_connection_shutdown
;;;685    }
00001c  bd70              POP      {r4-r6,pc}
;;;686    
                          ENDP


                          AREA ||i.eap_peer_tls_reset_input||, CODE, READONLY, ALIGN=1

                  eap_peer_tls_reset_input PROC
;;;815     */
;;;816    void eap_peer_tls_reset_input(struct eap_ssl_data *data)
000000  b510              PUSH     {r4,lr}
;;;817    {
000002  4604              MOV      r4,r0
;;;818    	data->tls_in_left = data->tls_in_total = 0;
000004  2000              MOVS     r0,#0
000006  61a0              STR      r0,[r4,#0x18]
000008  6160              STR      r0,[r4,#0x14]
;;;819    	wpabuf_free(data->tls_in);
00000a  6920              LDR      r0,[r4,#0x10]
00000c  f7fffffe          BL       wpabuf_free
;;;820    	data->tls_in = NULL;
000010  2000              MOVS     r0,#0
000012  6120              STR      r0,[r4,#0x10]
;;;821    }
000014  bd10              POP      {r4,pc}
;;;822    
                          ENDP


                          AREA ||i.eap_peer_tls_reset_output||, CODE, READONLY, ALIGN=1

                  eap_peer_tls_reset_output PROC
;;;830     */
;;;831    void eap_peer_tls_reset_output(struct eap_ssl_data *data)
000000  b510              PUSH     {r4,lr}
;;;832    {
000002  4604              MOV      r4,r0
;;;833    	data->tls_out_pos = 0;
000004  2000              MOVS     r0,#0
000006  60a0              STR      r0,[r4,#8]
;;;834    	wpabuf_free(data->tls_out);
000008  6860              LDR      r0,[r4,#4]
00000a  f7fffffe          BL       wpabuf_free
;;;835    	data->tls_out = NULL;
00000e  2000              MOVS     r0,#0
000010  6060              STR      r0,[r4,#4]
;;;836    }
000012  bd10              POP      {r4,pc}
;;;837    
                          ENDP


                          AREA ||i.eap_peer_tls_ssl_deinit||, CODE, READONLY, ALIGN=1

                  eap_peer_tls_ssl_deinit PROC
;;;241     */
;;;242    void eap_peer_tls_ssl_deinit(struct eap_sm *sm, struct eap_ssl_data *data)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;244    	tls_connection_deinit(sm->ssl_ctx, data->conn);
000006  6821              LDR      r1,[r4,#0]
000008  f8d50098          LDR      r0,[r5,#0x98]
00000c  f7fffffe          BL       tls_connection_deinit
;;;245    	eap_peer_tls_reset_input(data);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       eap_peer_tls_reset_input
;;;246    	eap_peer_tls_reset_output(data);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       eap_peer_tls_reset_output
;;;247    }
00001c  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP


                          AREA ||i.eap_peer_tls_ssl_init||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_ssl_init PROC
;;;196     */
;;;197    int eap_peer_tls_ssl_init(struct eap_sm *sm, struct eap_ssl_data *data,
000000  b570              PUSH     {r4-r6,lr}
;;;198    			  struct eap_peer_config *config)
;;;199    {
000002  b09a              SUB      sp,sp,#0x68
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;200    	struct tls_connection_params params;
;;;201    
;;;202    	if (config == NULL)
00000a  b91d              CBNZ     r5,|L18.20|
;;;203    		return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L18.16|
;;;204    
;;;205    	data->eap = sm;
;;;206    	data->phase2 = sm->init_phase2;
;;;207    	if (eap_tls_params_from_conf(sm, data, &params, config, data->phase2) <
;;;208    	    0)
;;;209    		return -1;
;;;210    
;;;211    	if (eap_tls_init_connection(sm, data, config, &params) < 0)
;;;212    		return -1;
;;;213    
;;;214    	data->tls_out_limit = config->fragment_size;
;;;215    	if (data->phase2) {
;;;216    		/* Limit the fragment size in the inner TLS authentication
;;;217    		 * since the outer authentication with EAP-PEAP does not yet
;;;218    		 * support fragmentation */
;;;219    		if (data->tls_out_limit > 100)
;;;220    			data->tls_out_limit -= 100;
;;;221    	}
;;;222    
;;;223    	if (config->phase1 &&
;;;224    	    os_strstr(config->phase1, "include_tls_length=1")) {
;;;225    		wpa_printf(MSG_DEBUG, "TLS: Include TLS Message Length in "
;;;226    			   "unfragmented packets");
;;;227    		data->include_tls_length = 1;
;;;228    	}
;;;229    
;;;230    	return 0;
;;;231    }
000010  b01a              ADD      sp,sp,#0x68
000012  bd70              POP      {r4-r6,pc}
                  |L18.20|
000014  62a6              STR      r6,[r4,#0x28]         ;205
000016  6df0              LDR      r0,[r6,#0x5c]         ;206
000018  61e0              STR      r0,[r4,#0x1c]         ;206
00001a  69e3              LDR      r3,[r4,#0x1c]         ;207
00001c  9300              STR      r3,[sp,#0]            ;207
00001e  462b              MOV      r3,r5                 ;207
000020  aa02              ADD      r2,sp,#8              ;207
000022  4621              MOV      r1,r4                 ;207
000024  4630              MOV      r0,r6                 ;207
000026  f7fffffe          BL       eap_tls_params_from_conf
00002a  2800              CMP      r0,#0                 ;207
00002c  da02              BGE      |L18.52|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;209
000032  e7ed              B        |L18.16|
                  |L18.52|
000034  ab02              ADD      r3,sp,#8              ;211
000036  462a              MOV      r2,r5                 ;211
000038  4621              MOV      r1,r4                 ;211
00003a  4630              MOV      r0,r6                 ;211
00003c  f7fffffe          BL       eap_tls_init_connection
000040  2800              CMP      r0,#0                 ;211
000042  da02              BGE      |L18.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;212
000048  e7e2              B        |L18.16|
                  |L18.74|
00004a  f8d500cc          LDR      r0,[r5,#0xcc]         ;214
00004e  60e0              STR      r0,[r4,#0xc]          ;214
000050  69e0              LDR      r0,[r4,#0x1c]         ;215
000052  b128              CBZ      r0,|L18.96|
000054  68e0              LDR      r0,[r4,#0xc]          ;219
000056  2864              CMP      r0,#0x64              ;219
000058  d902              BLS      |L18.96|
00005a  68e0              LDR      r0,[r4,#0xc]          ;220
00005c  3864              SUBS     r0,r0,#0x64           ;220
00005e  60e0              STR      r0,[r4,#0xc]          ;220
                  |L18.96|
000060  6de8              LDR      r0,[r5,#0x5c]         ;223
000062  b150              CBZ      r0,|L18.122|
000064  a106              ADR      r1,|L18.128|
000066  6de8              LDR      r0,[r5,#0x5c]         ;224
000068  f7fffffe          BL       os_strstr
00006c  b128              CBZ      r0,|L18.122|
00006e  a10a              ADR      r1,|L18.152|
000070  2000              MOVS     r0,#0                 ;225
000072  f7fffffe          BL       wpa_printf
000076  2001              MOVS     r0,#1                 ;227
000078  6220              STR      r0,[r4,#0x20]         ;227
                  |L18.122|
00007a  2000              MOVS     r0,#0                 ;230
00007c  e7c8              B        |L18.16|
;;;232    
                          ENDP

00007e  0000              DCW      0x0000
                  |L18.128|
000080  696e636c          DCB      "include_tls_length=1",0
000084  7564655f
000088  746c735f
00008c  6c656e67
000090  74683d31
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L18.152|
000098  544c533a          DCB      "TLS: Include TLS Message Length in unfragmented packets"
00009c  20496e63
0000a0  6c756465
0000a4  20544c53
0000a8  204d6573
0000ac  73616765
0000b0  204c656e
0000b4  67746820
0000b8  696e2075
0000bc  6e667261
0000c0  676d656e
0000c4  74656420
0000c8  7061636b
0000cc  657473  
0000cf  00                DCB      0

                          AREA ||i.eap_peer_tls_status||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_status PROC
;;;696     */
;;;697    int eap_peer_tls_status(struct eap_sm *sm, struct eap_ssl_data *data,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;698    			char *buf, size_t buflen, int verbose)
;;;699    {
000004  b0a0              SUB      sp,sp,#0x80
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  461e              MOV      r6,r3
00000e  f8dda0a0          LDR      r10,[sp,#0xa0]
;;;700    	char name[128];
;;;701    	int len = 0, ret;
000012  2400              MOVS     r4,#0
;;;702    
;;;703    	if (tls_get_cipher(sm->ssl_ctx, data->conn, name, sizeof(name)) == 0) {
000014  f8d81000          LDR      r1,[r8,#0]
000018  2380              MOVS     r3,#0x80
00001a  466a              MOV      r2,sp
00001c  f8d70098          LDR      r0,[r7,#0x98]
000020  f7fffffe          BL       tls_get_cipher
000024  b988              CBNZ     r0,|L19.74|
;;;704    		ret = os_snprintf(buf + len, buflen - len,
000026  1b31              SUBS     r1,r6,r4
000028  eb090004          ADD      r0,r9,r4
00002c  466b              MOV      r3,sp
00002e  a208              ADR      r2,|L19.80|
000030  f7fffffe          BL       os_snprintf
000034  4605              MOV      r5,r0
;;;705    				  "EAP TLS cipher=%s\n", name);
;;;706    		if (ret < 0 || (size_t) ret >= buflen - len)
000036  2d00              CMP      r5,#0
000038  db02              BLT      |L19.64|
00003a  1b30              SUBS     r0,r6,r4
00003c  42a8              CMP      r0,r5
00003e  d803              BHI      |L19.72|
                  |L19.64|
;;;707    			return len;
000040  4620              MOV      r0,r4
                  |L19.66|
;;;708    		len += ret;
;;;709    	}
;;;710    
;;;711    	return len;
;;;712    }
000042  b020              ADD      sp,sp,#0x80
000044  e8bd87f0          POP      {r4-r10,pc}
                  |L19.72|
000048  442c              ADD      r4,r4,r5              ;708
                  |L19.74|
00004a  4620              MOV      r0,r4                 ;711
00004c  e7f9              B        |L19.66|
;;;713    
                          ENDP

00004e  0000              DCW      0x0000
                  |L19.80|
000050  45415020          DCB      "EAP TLS cipher=%s\n",0
000054  544c5320
000058  63697068
00005c  65723d25
000060  730a00  
000063  00                DCB      0

                          AREA ||i.eap_tls_check_blob||, CODE, READONLY, ALIGN=2

                  eap_tls_check_blob PROC
;;;24     
;;;25     static int eap_tls_check_blob(struct eap_sm *sm, const char **name,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;26     			      const u8 **data, size_t *data_len)
;;;27     {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;28     	const struct wpa_config_blob *blob;
;;;29     
;;;30     	if (*name == NULL || os_strncmp(*name, "blob://", 7) != 0)
00000c  6820              LDR      r0,[r4,#0]
00000e  b128              CBZ      r0,|L20.28|
000010  2207              MOVS     r2,#7
000012  a110              ADR      r1,|L20.84|
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       os_strncmp
00001a  b110              CBZ      r0,|L20.34|
                  |L20.28|
;;;31     		return 0;
00001c  2000              MOVS     r0,#0
                  |L20.30|
;;;32     
;;;33     	blob = eap_get_config_blob(sm, *name + 7);
;;;34     	if (blob == NULL) {
;;;35     		wpa_printf(MSG_ERROR, "%s: Named configuration blob '%s' not "
;;;36     			   "found", __func__, *name + 7);
;;;37     		return -1;
;;;38     	}
;;;39     
;;;40     	*name = NULL;
;;;41     	*data = blob->data;
;;;42     	*data_len = blob->len;
;;;43     
;;;44     	return 0;
;;;45     }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L20.34|
000022  6820              LDR      r0,[r4,#0]            ;33
000024  1dc1              ADDS     r1,r0,#7              ;33
000026  4640              MOV      r0,r8                 ;33
000028  f7fffffe          BL       eap_get_config_blob
00002c  4605              MOV      r5,r0                 ;33
00002e  b94d              CBNZ     r5,|L20.68|
000030  6820              LDR      r0,[r4,#0]            ;35
000032  1dc3              ADDS     r3,r0,#7              ;35
000034  4a09              LDR      r2,|L20.92|
000036  a10a              ADR      r1,|L20.96|
000038  2000              MOVS     r0,#0                 ;35
00003a  f7fffffe          BL       wpa_printf
00003e  f04f30ff          MOV      r0,#0xffffffff        ;37
000042  e7ec              B        |L20.30|
                  |L20.68|
000044  2000              MOVS     r0,#0                 ;40
000046  6020              STR      r0,[r4,#0]            ;40
000048  6868              LDR      r0,[r5,#4]            ;41
00004a  6030              STR      r0,[r6,#0]            ;41
00004c  68a8              LDR      r0,[r5,#8]            ;42
00004e  6038              STR      r0,[r7,#0]            ;42
000050  2000              MOVS     r0,#0                 ;44
000052  e7e4              B        |L20.30|
;;;46     
                          ENDP

                  |L20.84|
000054  626c6f62          DCB      "blob://",0
000058  3a2f2f00
                  |L20.92|
                          DCD      __func__
                  |L20.96|
000060  25733a20          DCB      "%s: Named configuration blob '%s' not found",0
000064  4e616d65
000068  6420636f
00006c  6e666967
000070  75726174
000074  696f6e20
000078  626c6f62
00007c  20272573
000080  27206e6f
000084  7420666f
000088  756e6400

                          AREA ||i.eap_tls_init_connection||, CODE, READONLY, ALIGN=2

                  eap_tls_init_connection PROC
;;;138    
;;;139    static int eap_tls_init_connection(struct eap_sm *sm,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;140    				   struct eap_ssl_data *data,
;;;141    				   struct eap_peer_config *config,
;;;142    				   struct tls_connection_params *params)
;;;143    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;144    	int res;
;;;145    
;;;146    	data->conn = tls_connection_init(sm->ssl_ctx);
00000c  f8d50098          LDR      r0,[r5,#0x98]
000010  f7fffffe          BL       tls_connection_init
000014  6020              STR      r0,[r4,#0]
;;;147    	if (data->conn == NULL) {
000016  6820              LDR      r0,[r4,#0]
000018  b938              CBNZ     r0,|L21.42|
;;;148    		wpa_printf(MSG_INFO, "SSL: Failed to initialize new TLS "
00001a  a11f              ADR      r1,|L21.152|
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       wpa_printf
;;;149    			   "connection");
;;;150    		return -1;
000022  f04f30ff          MOV      r0,#0xffffffff
                  |L21.38|
;;;151    	}
;;;152    
;;;153    	res = tls_connection_set_params(sm->ssl_ctx, data->conn, params);
;;;154    	if (res == TLS_SET_PARAMS_ENGINE_PRV_INIT_FAILED) {
;;;155    		/*
;;;156    		 * At this point with the pkcs11 engine the PIN might be wrong.
;;;157    		 * We reset the PIN in the configuration to be sure to not use
;;;158    		 * it again and the calling function must request a new one.
;;;159    		 */
;;;160    		os_free(config->pin);
;;;161    		config->pin = NULL;
;;;162    	} else if (res == TLS_SET_PARAMS_ENGINE_PRV_VERIFY_FAILED) {
;;;163    		wpa_printf(MSG_INFO, "TLS: Failed to load private key");
;;;164    		/*
;;;165    		 * We do not know exactly but maybe the PIN was wrong,
;;;166    		 * so ask for a new one.
;;;167    		 */
;;;168    		os_free(config->pin);
;;;169    		config->pin = NULL;
;;;170    		eap_sm_request_pin(sm);
;;;171    		sm->ignore = TRUE;
;;;172    		tls_connection_deinit(sm->ssl_ctx, data->conn);
;;;173    		data->conn = NULL;
;;;174    		return -1;
;;;175    	} else if (res) {
;;;176    		wpa_printf(MSG_INFO, "TLS: Failed to set TLS connection "
;;;177    			   "parameters");
;;;178    		tls_connection_deinit(sm->ssl_ctx, data->conn);
;;;179    		data->conn = NULL;
;;;180    		return -1;
;;;181    	}
;;;182    
;;;183    	return 0;
;;;184    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L21.42|
00002a  6821              LDR      r1,[r4,#0]            ;153
00002c  4642              MOV      r2,r8                 ;153
00002e  f8d50098          LDR      r0,[r5,#0x98]         ;153
000032  f7fffffe          BL       tls_connection_set_params
000036  4607              MOV      r7,r0                 ;153
000038  1cb8              ADDS     r0,r7,#2              ;154
00003a  d105              BNE      |L21.72|
00003c  6eb0              LDR      r0,[r6,#0x68]         ;160
00003e  f7fffffe          BL       os_free
000042  2000              MOVS     r0,#0                 ;161
000044  66b0              STR      r0,[r6,#0x68]         ;161
000046  e025              B        |L21.148|
                  |L21.72|
000048  1cf8              ADDS     r0,r7,#3              ;162
00004a  d115              BNE      |L21.120|
00004c  a11e              ADR      r1,|L21.200|
00004e  f7fffffe          BL       wpa_printf
000052  6eb0              LDR      r0,[r6,#0x68]         ;168
000054  f7fffffe          BL       os_free
000058  2000              MOVS     r0,#0                 ;169
00005a  66b0              STR      r0,[r6,#0x68]         ;169
00005c  4628              MOV      r0,r5                 ;170
00005e  f7fffffe          BL       eap_sm_request_pin
000062  2001              MOVS     r0,#1                 ;171
000064  62e8              STR      r0,[r5,#0x2c]         ;171
000066  6821              LDR      r1,[r4,#0]            ;172
000068  f8d50098          LDR      r0,[r5,#0x98]         ;172
00006c  f7fffffe          BL       tls_connection_deinit
000070  2000              MOVS     r0,#0                 ;173
000072  6020              STR      r0,[r4,#0]            ;173
000074  1e40              SUBS     r0,r0,#1              ;174
000076  e7d6              B        |L21.38|
                  |L21.120|
000078  b167              CBZ      r7,|L21.148|
00007a  a11b              ADR      r1,|L21.232|
00007c  2000              MOVS     r0,#0                 ;176
00007e  f7fffffe          BL       wpa_printf
000082  6821              LDR      r1,[r4,#0]            ;178
000084  f8d50098          LDR      r0,[r5,#0x98]         ;178
000088  f7fffffe          BL       tls_connection_deinit
00008c  2000              MOVS     r0,#0                 ;179
00008e  6020              STR      r0,[r4,#0]            ;179
000090  1e40              SUBS     r0,r0,#1              ;180
000092  e7c8              B        |L21.38|
                  |L21.148|
000094  2000              MOVS     r0,#0                 ;183
000096  e7c6              B        |L21.38|
;;;185    
                          ENDP

                  |L21.152|
000098  53534c3a          DCB      "SSL: Failed to initialize new TLS connection",0
00009c  20466169
0000a0  6c656420
0000a4  746f2069
0000a8  6e697469
0000ac  616c697a
0000b0  65206e65
0000b4  7720544c
0000b8  5320636f
0000bc  6e6e6563
0000c0  74696f6e
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L21.200|
0000c8  544c533a          DCB      "TLS: Failed to load private key",0
0000cc  20466169
0000d0  6c656420
0000d4  746f206c
0000d8  6f616420
0000dc  70726976
0000e0  61746520
0000e4  6b657900
                  |L21.232|
0000e8  544c533a          DCB      "TLS: Failed to set TLS connection parameters",0
0000ec  20466169
0000f0  6c656420
0000f4  746f2073
0000f8  65742054
0000fc  4c532063
000100  6f6e6e65
000104  6374696f
000108  6e207061
00010c  72616d65
000110  74657273
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0

                          AREA ||i.eap_tls_params_flags||, CODE, READONLY, ALIGN=2

                  eap_tls_params_flags PROC
;;;47     
;;;48     static void eap_tls_params_flags(struct tls_connection_params *params,
000000  b570              PUSH     {r4-r6,lr}
;;;49     				 const char *txt)
;;;50     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;51     	if (txt == NULL)
000006  b905              CBNZ     r5,|L22.10|
                  |L22.8|
;;;52     		return;
;;;53     	if (os_strstr(txt, "tls_allow_md5=1"))
;;;54     		params->flags |= TLS_CONN_ALLOW_SIGN_RSA_MD5;
;;;55     	if (os_strstr(txt, "tls_disable_time_checks=1"))
;;;56     		params->flags |= TLS_CONN_DISABLE_TIME_CHECKS;
;;;57     }
000008  bd70              POP      {r4-r6,pc}
                  |L22.10|
00000a  a10a              ADR      r1,|L22.52|
00000c  4628              MOV      r0,r5                 ;53
00000e  f7fffffe          BL       os_strstr
000012  b118              CBZ      r0,|L22.28|
000014  6de0              LDR      r0,[r4,#0x5c]         ;54
000016  f0400001          ORR      r0,r0,#1              ;54
00001a  65e0              STR      r0,[r4,#0x5c]         ;54
                  |L22.28|
00001c  a109              ADR      r1,|L22.68|
00001e  4628              MOV      r0,r5                 ;55
000020  f7fffffe          BL       os_strstr
000024  b118              CBZ      r0,|L22.46|
000026  6de0              LDR      r0,[r4,#0x5c]         ;56
000028  f0400002          ORR      r0,r0,#2              ;56
00002c  65e0              STR      r0,[r4,#0x5c]         ;56
                  |L22.46|
00002e  bf00              NOP      
000030  e7ea              B        |L22.8|
;;;58     
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
000034  746c735f          DCB      "tls_allow_md5=1",0
000038  616c6c6f
00003c  775f6d64
000040  353d3100
                  |L22.68|
000044  746c735f          DCB      "tls_disable_time_checks=1",0
000048  64697361
00004c  626c655f
000050  74696d65
000054  5f636865
000058  636b733d
00005c  3100    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.eap_tls_params_from_conf||, CODE, READONLY, ALIGN=2

                  eap_tls_params_from_conf PROC
;;;101    
;;;102    static int eap_tls_params_from_conf(struct eap_sm *sm,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;103    				    struct eap_ssl_data *data,
;;;104    				    struct tls_connection_params *params,
;;;105    				    struct eap_peer_config *config, int phase2)
;;;106    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;107    	os_memset(params, 0, sizeof(*params));
000010  2260              MOVS     r2,#0x60
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       os_memset
;;;108    	if (phase2) {
00001a  f1b80f00          CMP      r8,#0
00001e  d008              BEQ      |L23.50|
;;;109    		wpa_printf(MSG_DEBUG, "TLS: using phase2 config options");
000020  a11e              ADR      r1,|L23.156|
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       wpa_printf
;;;110    		eap_tls_params_from_conf2(params, config);
000028  4631              MOV      r1,r6
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       eap_tls_params_from_conf2
000030  e007              B        |L23.66|
                  |L23.50|
;;;111    	} else {
;;;112    		wpa_printf(MSG_DEBUG, "TLS: using phase1 config options");
000032  a123              ADR      r1,|L23.192|
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       wpa_printf
;;;113    		eap_tls_params_from_conf1(params, config);
00003a  4631              MOV      r1,r6
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       eap_tls_params_from_conf1
                  |L23.66|
;;;114    	}
;;;115    	params->tls_ia = data->tls_ia;
000042  6a68              LDR      r0,[r5,#0x24]
000044  6420              STR      r0,[r4,#0x40]
;;;116    
;;;117    	/*
;;;118    	 * Use blob data, if available. Otherwise, leave reference to external
;;;119    	 * file as-is.
;;;120    	 */
;;;121    	if (eap_tls_check_blob(sm, &params->ca_cert, &params->ca_cert_blob,
000046  f1040308          ADD      r3,r4,#8
00004a  1d22              ADDS     r2,r4,#4
00004c  4621              MOV      r1,r4
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       eap_tls_check_blob
000054  b9b8              CBNZ     r0,|L23.134|
;;;122    			       &params->ca_cert_blob_len) ||
;;;123    	    eap_tls_check_blob(sm, &params->client_cert,
000056  f1040320          ADD      r3,r4,#0x20
00005a  1f1a              SUBS     r2,r3,#4
00005c  1f11              SUBS     r1,r2,#4
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       eap_tls_check_blob
000064  b978              CBNZ     r0,|L23.134|
;;;124    			       &params->client_cert_blob,
;;;125    			       &params->client_cert_blob_len) ||
;;;126    	    eap_tls_check_blob(sm, &params->private_key,
000066  f104032c          ADD      r3,r4,#0x2c
00006a  1f1a              SUBS     r2,r3,#4
00006c  1f11              SUBS     r1,r2,#4
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       eap_tls_check_blob
000074  b938              CBNZ     r0,|L23.134|
;;;127    			       &params->private_key_blob,
;;;128    			       &params->private_key_blob_len) ||
;;;129    	    eap_tls_check_blob(sm, &params->dh_file, &params->dh_blob,
000076  f104033c          ADD      r3,r4,#0x3c
00007a  1f1a              SUBS     r2,r3,#4
00007c  1f11              SUBS     r1,r2,#4
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       eap_tls_check_blob
000084  b138              CBZ      r0,|L23.150|
                  |L23.134|
;;;130    			       &params->dh_blob_len)) {
;;;131    		wpa_printf(MSG_INFO, "SSL: Failed to get configuration blobs");
000086  a117              ADR      r1,|L23.228|
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       wpa_printf
;;;132    		return -1;
00008e  f04f30ff          MOV      r0,#0xffffffff
                  |L23.146|
;;;133    	}
;;;134    
;;;135    	return 0;
;;;136    }
000092  e8bd81f0          POP      {r4-r8,pc}
                  |L23.150|
000096  2000              MOVS     r0,#0                 ;135
000098  e7fb              B        |L23.146|
;;;137    
                          ENDP

00009a  0000              DCW      0x0000
                  |L23.156|
00009c  544c533a          DCB      "TLS: using phase2 config options",0
0000a0  20757369
0000a4  6e672070
0000a8  68617365
0000ac  3220636f
0000b0  6e666967
0000b4  206f7074
0000b8  696f6e73
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L23.192|
0000c0  544c533a          DCB      "TLS: using phase1 config options",0
0000c4  20757369
0000c8  6e672070
0000cc  68617365
0000d0  3120636f
0000d4  6e666967
0000d8  206f7074
0000dc  696f6e73
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L23.228|
0000e4  53534c3a          DCB      "SSL: Failed to get configuration blobs",0
0000e8  20466169
0000ec  6c656420
0000f0  746f2067
0000f4  65742063
0000f8  6f6e6669
0000fc  67757261
000100  74696f6e
000104  20626c6f
000108  627300  
00010b  00                DCB      0

                          AREA ||i.eap_tls_params_from_conf1||, CODE, READONLY, ALIGN=1

                  eap_tls_params_from_conf1 PROC
;;;59     
;;;60     static void eap_tls_params_from_conf1(struct tls_connection_params *params,
000000  b570              PUSH     {r4-r6,lr}
;;;61     				      struct eap_peer_config *config)
;;;62     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;63     	params->ca_cert = (char *) config->ca_cert;
000006  f8540f18          LDR      r0,[r4,#0x18]!
00000a  6028              STR      r0,[r5,#0]
;;;64     	params->ca_path = (char *) config->ca_path;
00000c  6860              LDR      r0,[r4,#4]
00000e  60e8              STR      r0,[r5,#0xc]
;;;65     	params->client_cert = (char *) config->client_cert;
000010  68a0              LDR      r0,[r4,#8]
000012  61a8              STR      r0,[r5,#0x18]
;;;66     	params->private_key = (char *) config->private_key;
000014  68e0              LDR      r0,[r4,#0xc]
000016  6268              STR      r0,[r5,#0x24]
;;;67     	params->private_key_passwd = (char *) config->private_key_passwd;
000018  6920              LDR      r0,[r4,#0x10]
00001a  6328              STR      r0,[r5,#0x30]
;;;68     	params->dh_file = (char *) config->dh_file;
00001c  6960              LDR      r0,[r4,#0x14]
00001e  6368              STR      r0,[r5,#0x34]
;;;69     	params->subject_match = (char *) config->subject_match;
000020  69a0              LDR      r0,[r4,#0x18]
000022  6128              STR      r0,[r5,#0x10]
;;;70     	params->altsubject_match = (char *) config->altsubject_match;
000024  69e0              LDR      r0,[r4,#0x1c]
000026  6168              STR      r0,[r5,#0x14]
;;;71     	params->engine = config->engine;
000028  6d60              LDR      r0,[r4,#0x54]
00002a  6468              STR      r0,[r5,#0x44]
;;;72     	params->engine_id = config->engine_id;
00002c  6da0              LDR      r0,[r4,#0x58]
00002e  64a8              STR      r0,[r5,#0x48]
;;;73     	params->pin = config->pin;
000030  6d20              LDR      r0,[r4,#0x50]
000032  64e8              STR      r0,[r5,#0x4c]
;;;74     	params->key_id = config->key_id;
000034  6ea0              LDR      r0,[r4,#0x68]
000036  6528              STR      r0,[r5,#0x50]
;;;75     	params->cert_id = config->cert_id;
000038  6ee0              LDR      r0,[r4,#0x6c]
00003a  6568              STR      r0,[r5,#0x54]
;;;76     	params->ca_cert_id = config->ca_cert_id;
00003c  6f20              LDR      r0,[r4,#0x70]
00003e  65a8              STR      r0,[r5,#0x58]
;;;77     	eap_tls_params_flags(params, config->phase1);
000040  6c61              LDR      r1,[r4,#0x44]
000042  f1a40418          SUB      r4,r4,#0x18
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       eap_tls_params_flags
;;;78     }
00004c  bd70              POP      {r4-r6,pc}
;;;79     
                          ENDP


                          AREA ||i.eap_tls_params_from_conf2||, CODE, READONLY, ALIGN=1

                  eap_tls_params_from_conf2 PROC
;;;80     
;;;81     static void eap_tls_params_from_conf2(struct tls_connection_params *params,
000000  b570              PUSH     {r4-r6,lr}
;;;82     				      struct eap_peer_config *config)
;;;83     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;84     	params->ca_cert = (char *) config->ca_cert2;
000006  f8540f38          LDR      r0,[r4,#0x38]!
00000a  6028              STR      r0,[r5,#0]
;;;85     	params->ca_path = (char *) config->ca_path2;
00000c  6860              LDR      r0,[r4,#4]
00000e  60e8              STR      r0,[r5,#0xc]
;;;86     	params->client_cert = (char *) config->client_cert2;
000010  68a0              LDR      r0,[r4,#8]
000012  61a8              STR      r0,[r5,#0x18]
;;;87     	params->private_key = (char *) config->private_key2;
000014  68e0              LDR      r0,[r4,#0xc]
000016  6268              STR      r0,[r5,#0x24]
;;;88     	params->private_key_passwd = (char *) config->private_key2_passwd;
000018  6920              LDR      r0,[r4,#0x10]
00001a  6328              STR      r0,[r5,#0x30]
;;;89     	params->dh_file = (char *) config->dh_file2;
00001c  6960              LDR      r0,[r4,#0x14]
00001e  6368              STR      r0,[r5,#0x34]
;;;90     	params->subject_match = (char *) config->subject_match2;
000020  69a0              LDR      r0,[r4,#0x18]
000022  6128              STR      r0,[r5,#0x10]
;;;91     	params->altsubject_match = (char *) config->altsubject_match2;
000024  69e0              LDR      r0,[r4,#0x1c]
000026  6168              STR      r0,[r5,#0x14]
;;;92     	params->engine = config->engine2;
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  6468              STR      r0,[r5,#0x44]
;;;93     	params->engine_id = config->engine2_id;
00002c  6c60              LDR      r0,[r4,#0x44]
00002e  64a8              STR      r0,[r5,#0x48]
;;;94     	params->pin = config->pin2;
000030  6c20              LDR      r0,[r4,#0x40]
000032  64e8              STR      r0,[r5,#0x4c]
;;;95     	params->key_id = config->key2_id;
000034  6d60              LDR      r0,[r4,#0x54]
000036  6528              STR      r0,[r5,#0x50]
;;;96     	params->cert_id = config->cert2_id;
000038  6da0              LDR      r0,[r4,#0x58]
00003a  6568              STR      r0,[r5,#0x54]
;;;97     	params->ca_cert_id = config->ca_cert2_id;
00003c  6de0              LDR      r0,[r4,#0x5c]
00003e  65a8              STR      r0,[r5,#0x58]
;;;98     	eap_tls_params_flags(params, config->phase2);
000040  6aa1              LDR      r1,[r4,#0x28]
000042  f1a40438          SUB      r4,r4,#0x38
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       eap_tls_params_flags
;;;99     }
00004c  bd70              POP      {r4-r6,pc}
;;;100    
                          ENDP


                          AREA ||i.eap_tls_process_input||, CODE, READONLY, ALIGN=2

                  eap_tls_process_input PROC
;;;426     */
;;;427    static int eap_tls_process_input(struct eap_sm *sm, struct eap_ssl_data *data,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;428    				 const u8 *in_data, size_t in_len,
;;;429    				 struct wpabuf **out_data)
;;;430    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
00000e  f8dd9030          LDR      r9,[sp,#0x30]
;;;431    	const struct wpabuf *msg;
;;;432    	int need_more_input;
;;;433    	struct wpabuf *appl_data;
;;;434    	struct wpabuf buf;
;;;435    
;;;436    	wpabuf_set(&buf, in_data, in_len);
000012  463a              MOV      r2,r7
000014  4631              MOV      r1,r6
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       wpabuf_set
;;;437    	msg = eap_peer_tls_data_reassemble(data, &buf, &need_more_input);
00001c  aa04              ADD      r2,sp,#0x10
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       eap_peer_tls_data_reassemble
000026  4680              MOV      r8,r0
;;;438    	if (msg == NULL)
000028  f1b80f00          CMP      r8,#0
00002c  d108              BNE      |L26.64|
;;;439    		return need_more_input ? 1 : -1;
00002e  9804              LDR      r0,[sp,#0x10]
000030  b118              CBZ      r0,|L26.58|
000032  2001              MOVS     r0,#1
                  |L26.52|
;;;440    
;;;441    	/* Full TLS message reassembled - continue handshake processing */
;;;442    	if (data->tls_out) {
;;;443    		/* This should not happen.. */
;;;444    		wpa_printf(MSG_INFO, "SSL: eap_tls_process_input - pending "
;;;445    			   "tls_out data even though tls_out_len = 0");
;;;446    		wpabuf_free(data->tls_out);
;;;447    		WPA_ASSERT(data->tls_out == NULL);
;;;448    	}
;;;449    	appl_data = NULL;
;;;450    	data->tls_out = tls_connection_handshake(sm->ssl_ctx, data->conn,
;;;451    						 msg, &appl_data);
;;;452    
;;;453    	eap_peer_tls_reset_input(data);
;;;454    
;;;455    	if (appl_data &&
;;;456    	    tls_connection_established(sm->ssl_ctx, data->conn) &&
;;;457    	    !tls_connection_get_failed(sm->ssl_ctx, data->conn)) {
;;;458    		wpa_hexdump_buf_key(MSG_MSGDUMP, "SSL: Application data",
;;;459    				    appl_data);
;;;460    		*out_data = appl_data;
;;;461    		return 2;
;;;462    	}
;;;463    
;;;464    	wpabuf_free(appl_data);
;;;465    
;;;466    	return 0;
;;;467    }
000034  b005              ADD      sp,sp,#0x14
000036  e8bd83f0          POP      {r4-r9,pc}
                  |L26.58|
00003a  f04f30ff          MOV      r0,#0xffffffff        ;439
00003e  e7f9              B        |L26.52|
                  |L26.64|
000040  6860              LDR      r0,[r4,#4]            ;442
000042  b140              CBZ      r0,|L26.86|
000044  4919              LDR      r1,|L26.172|
000046  2000              MOVS     r0,#0                 ;444
000048  f7fffffe          BL       wpa_printf
00004c  6860              LDR      r0,[r4,#4]            ;446
00004e  f7fffffe          BL       wpabuf_free
000052  bf00              NOP                            ;447
000054  bf00              NOP                            ;447
                  |L26.86|
000056  2000              MOVS     r0,#0                 ;449
000058  9003              STR      r0,[sp,#0xc]          ;449
00005a  6821              LDR      r1,[r4,#0]            ;450
00005c  ab03              ADD      r3,sp,#0xc            ;450
00005e  4642              MOV      r2,r8                 ;450
000060  f8d50098          LDR      r0,[r5,#0x98]         ;450
000064  f7fffffe          BL       tls_connection_handshake
000068  6060              STR      r0,[r4,#4]            ;450
00006a  4620              MOV      r0,r4                 ;453
00006c  f7fffffe          BL       eap_peer_tls_reset_input
000070  9803              LDR      r0,[sp,#0xc]          ;455
000072  b1a8              CBZ      r0,|L26.160|
000074  6821              LDR      r1,[r4,#0]            ;456
000076  f8d50098          LDR      r0,[r5,#0x98]         ;456
00007a  f7fffffe          BL       tls_connection_established
00007e  b178              CBZ      r0,|L26.160|
000080  6821              LDR      r1,[r4,#0]            ;457
000082  f8d50098          LDR      r0,[r5,#0x98]         ;457
000086  f7fffffe          BL       tls_connection_get_failed
00008a  b948              CBNZ     r0,|L26.160|
00008c  a108              ADR      r1,|L26.176|
00008e  2000              MOVS     r0,#0                 ;458
000090  9a03              LDR      r2,[sp,#0xc]          ;458
000092  f7fffffe          BL       wpa_hexdump_buf_key
000096  9803              LDR      r0,[sp,#0xc]          ;460
000098  f8c90000          STR      r0,[r9,#0]            ;460
00009c  2002              MOVS     r0,#2                 ;461
00009e  e7c9              B        |L26.52|
                  |L26.160|
0000a0  9803              LDR      r0,[sp,#0xc]          ;464
0000a2  f7fffffe          BL       wpabuf_free
0000a6  2000              MOVS     r0,#0                 ;466
0000a8  e7c4              B        |L26.52|
;;;468    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L26.172|
                          DCD      ||.constdata||+0x60
                  |L26.176|
0000b0  53534c3a          DCB      "SSL: Application data",0
0000b4  20417070
0000b8  6c696361
0000bc  74696f6e
0000c0  20646174
0000c4  6100    
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.eap_tls_process_output||, CODE, READONLY, ALIGN=2

                  eap_tls_process_output PROC
;;;479     */
;;;480    static int eap_tls_process_output(struct eap_ssl_data *data, EapType eap_type,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;481    				  int peap_version, u8 id, int ret,
;;;482    				  struct wpabuf **out_data)
;;;483    {
000004  b081              SUB      sp,sp,#4
000006  4604              MOV      r4,r0
000008  468b              MOV      r11,r1
00000a  4692              MOV      r10,r2
00000c  9e0f              LDR      r6,[sp,#0x3c]
;;;484    	size_t len;
;;;485    	u8 *flags;
;;;486    	int more_fragments, length_included;
;;;487    
;;;488    	if (data->tls_out == NULL)
00000e  6860              LDR      r0,[r4,#4]
000010  b920              CBNZ     r0,|L27.28|
;;;489    		return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L27.22|
;;;490    	len = wpabuf_len(data->tls_out) - data->tls_out_pos;
;;;491    	wpa_printf(MSG_DEBUG, "SSL: %lu bytes left to be sent out (of total "
;;;492    		   "%lu bytes)",
;;;493    		   (unsigned long) len,
;;;494    		   (unsigned long) wpabuf_len(data->tls_out));
;;;495    
;;;496    	/*
;;;497    	 * Limit outgoing message to the configured maximum size. Fragment
;;;498    	 * message if needed.
;;;499    	 */
;;;500    	if (len > data->tls_out_limit) {
;;;501    		more_fragments = 1;
;;;502    		len = data->tls_out_limit;
;;;503    		wpa_printf(MSG_DEBUG, "SSL: sending %lu bytes, more fragments "
;;;504    			   "will follow", (unsigned long) len);
;;;505    	} else
;;;506    		more_fragments = 0;
;;;507    
;;;508    	length_included = data->tls_out_pos == 0 &&
;;;509    		(wpabuf_len(data->tls_out) > data->tls_out_limit ||
;;;510    		 data->include_tls_length);
;;;511    	if (!length_included &&
;;;512    	    eap_type == EAP_TYPE_PEAP && peap_version == 0 &&
;;;513    	    !tls_connection_established(data->eap->ssl_ctx, data->conn)) {
;;;514    		/*
;;;515    		 * Windows Server 2008 NPS really wants to have the TLS Message
;;;516    		 * length included in phase 0 even for unfragmented frames or
;;;517    		 * it will get very confused with Compound MAC calculation and
;;;518    		 * Outer TLVs.
;;;519    		 */
;;;520    		length_included = 1;
;;;521    	}
;;;522    
;;;523    	*out_data = eap_msg_alloc(EAP_VENDOR_IETF, eap_type,
;;;524    				  1 + length_included * 4 + len,
;;;525    				  EAP_CODE_RESPONSE, id);
;;;526    	if (*out_data == NULL)
;;;527    		return -1;
;;;528    
;;;529    	flags = wpabuf_put(*out_data, 1);
;;;530    	*flags = peap_version;
;;;531    	if (more_fragments)
;;;532    		*flags |= EAP_TLS_FLAGS_MORE_FRAGMENTS;
;;;533    	if (length_included) {
;;;534    		*flags |= EAP_TLS_FLAGS_LENGTH_INCLUDED;
;;;535    		wpabuf_put_be32(*out_data, wpabuf_len(data->tls_out));
;;;536    	}
;;;537    
;;;538    	wpabuf_put_data(*out_data,
;;;539    			wpabuf_head_u8(data->tls_out) + data->tls_out_pos,
;;;540    			len);
;;;541    	data->tls_out_pos += len;
;;;542    
;;;543    	if (!more_fragments)
;;;544    		eap_peer_tls_reset_output(data);
;;;545    
;;;546    	return ret;
;;;547    }
000016  b005              ADD      sp,sp,#0x14
000018  e8bd8ff0          POP      {r4-r11,pc}
                  |L27.28|
00001c  6860              LDR      r0,[r4,#4]            ;490
00001e  f7fffffe          BL       wpabuf_len
000022  68a1              LDR      r1,[r4,#8]            ;490
000024  1a47              SUBS     r7,r0,r1              ;490
000026  6860              LDR      r0,[r4,#4]            ;491
000028  f7fffffe          BL       wpabuf_len
00002c  4603              MOV      r3,r0                 ;491
00002e  463a              MOV      r2,r7                 ;491
000030  a13b              ADR      r1,|L27.288|
000032  9000              STR      r0,[sp,#0]            ;491
000034  2000              MOVS     r0,#0                 ;491
000036  f7fffffe          BL       wpa_printf
00003a  68e0              LDR      r0,[r4,#0xc]          ;500
00003c  42b8              CMP      r0,r7                 ;500
00003e  d208              BCS      |L27.82|
000040  f04f0801          MOV      r8,#1                 ;501
000044  68e7              LDR      r7,[r4,#0xc]          ;502
000046  463a              MOV      r2,r7                 ;503
000048  a143              ADR      r1,|L27.344|
00004a  2000              MOVS     r0,#0                 ;503
00004c  f7fffffe          BL       wpa_printf
000050  e001              B        |L27.86|
                  |L27.82|
000052  f04f0800          MOV      r8,#0                 ;506
                  |L27.86|
000056  68a0              LDR      r0,[r4,#8]            ;508
000058  b948              CBNZ     r0,|L27.110|
00005a  6860              LDR      r0,[r4,#4]            ;509
00005c  f7fffffe          BL       wpabuf_len
000060  68e1              LDR      r1,[r4,#0xc]          ;509
000062  4288              CMP      r0,r1                 ;509
000064  d801              BHI      |L27.106|
000066  6a20              LDR      r0,[r4,#0x20]         ;510
000068  b108              CBZ      r0,|L27.110|
                  |L27.106|
00006a  2001              MOVS     r0,#1                 ;510
00006c  e000              B        |L27.112|
                  |L27.110|
00006e  2000              MOVS     r0,#0                 ;510
                  |L27.112|
000070  4681              MOV      r9,r0                 ;510
000072  f1b90f00          CMP      r9,#0                 ;511
000076  d10e              BNE      |L27.150|
000078  f1bb0f19          CMP      r11,#0x19             ;512
00007c  d10b              BNE      |L27.150|
00007e  f1ba0f00          CMP      r10,#0                ;512
000082  d108              BNE      |L27.150|
000084  6aa2              LDR      r2,[r4,#0x28]         ;513
000086  6821              LDR      r1,[r4,#0]            ;513
000088  f8d20098          LDR      r0,[r2,#0x98]         ;513
00008c  f7fffffe          BL       tls_connection_established
000090  b908              CBNZ     r0,|L27.150|
000092  f04f0901          MOV      r9,#1                 ;520
                  |L27.150|
000096  9b04              LDR      r3,[sp,#0x10]         ;523
000098  2001              MOVS     r0,#1                 ;523
00009a  eb000089          ADD      r0,r0,r9,LSL #2       ;523
00009e  19c2              ADDS     r2,r0,r7              ;523
0000a0  9300              STR      r3,[sp,#0]            ;523
0000a2  2302              MOVS     r3,#2                 ;523
0000a4  4659              MOV      r1,r11                ;523
0000a6  2000              MOVS     r0,#0                 ;523
0000a8  f7fffffe          BL       eap_msg_alloc
0000ac  6030              STR      r0,[r6,#0]            ;523
0000ae  6830              LDR      r0,[r6,#0]            ;526
0000b0  b910              CBNZ     r0,|L27.184|
0000b2  f04f30ff          MOV      r0,#0xffffffff        ;527
0000b6  e7ae              B        |L27.22|
                  |L27.184|
0000b8  2101              MOVS     r1,#1                 ;529
0000ba  6830              LDR      r0,[r6,#0]            ;529
0000bc  f7fffffe          BL       wpabuf_put
0000c0  4605              MOV      r5,r0                 ;529
0000c2  f885a000          STRB     r10,[r5,#0]           ;530
0000c6  f1b80f00          CMP      r8,#0                 ;531
0000ca  d003              BEQ      |L27.212|
0000cc  7828              LDRB     r0,[r5,#0]            ;532
0000ce  f0400040          ORR      r0,r0,#0x40           ;532
0000d2  7028              STRB     r0,[r5,#0]            ;532
                  |L27.212|
0000d4  f1b90f00          CMP      r9,#0                 ;533
0000d8  d00b              BEQ      |L27.242|
0000da  7828              LDRB     r0,[r5,#0]            ;534
0000dc  f0400080          ORR      r0,r0,#0x80           ;534
0000e0  7028              STRB     r0,[r5,#0]            ;534
0000e2  6860              LDR      r0,[r4,#4]            ;535
0000e4  f7fffffe          BL       wpabuf_len
0000e8  9000              STR      r0,[sp,#0]            ;535
0000ea  6830              LDR      r0,[r6,#0]            ;535
0000ec  9900              LDR      r1,[sp,#0]            ;535
0000ee  f7fffffe          BL       wpabuf_put_be32
                  |L27.242|
0000f2  6860              LDR      r0,[r4,#4]            ;538
0000f4  f7fffffe          BL       wpabuf_head_u8
0000f8  68a1              LDR      r1,[r4,#8]            ;538
0000fa  4408              ADD      r0,r0,r1              ;538
0000fc  9000              STR      r0,[sp,#0]            ;538
0000fe  463a              MOV      r2,r7                 ;538
000100  6830              LDR      r0,[r6,#0]            ;538
000102  9900              LDR      r1,[sp,#0]            ;538
000104  f7fffffe          BL       wpabuf_put_data
000108  68a0              LDR      r0,[r4,#8]            ;541
00010a  4438              ADD      r0,r0,r7              ;541
00010c  60a0              STR      r0,[r4,#8]            ;541
00010e  f1b80f00          CMP      r8,#0                 ;543
000112  d102              BNE      |L27.282|
000114  4620              MOV      r0,r4                 ;544
000116  f7fffffe          BL       eap_peer_tls_reset_output
                  |L27.282|
00011a  980e              LDR      r0,[sp,#0x38]         ;546
00011c  e77b              B        |L27.22|
;;;548    
                          ENDP

00011e  0000              DCW      0x0000
                  |L27.288|
000120  53534c3a          DCB      "SSL: %lu bytes left to be sent out (of total %lu bytes)"
000124  20256c75
000128  20627974
00012c  6573206c
000130  65667420
000134  746f2062
000138  65207365
00013c  6e74206f
000140  75742028
000144  6f662074
000148  6f74616c
00014c  20256c75
000150  20627974
000154  657329  
000157  00                DCB      0
                  |L27.344|
000158  53534c3a          DCB      "SSL: sending %lu bytes, more fragments will follow",0
00015c  2073656e
000160  64696e67
000164  20256c75
000168  20627974
00016c  65732c20
000170  6d6f7265
000174  20667261
000178  676d656e
00017c  74732077
000180  696c6c20
000184  666f6c6c
000188  6f7700  
00018b  00                DCB      0

                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L28.30|
00001a  2001              MOVS     r0,#1
                  |L28.28|
;;;495    }
00001c  4770              BX       lr
                  |L28.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L28.28|
;;;496    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpa_key_mgmt_ft||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_ft PROC
;;;65     
;;;66     static inline int wpa_key_mgmt_ft(int akm)
000000  4601              MOV      r1,r0
;;;67     {
;;;68     	return akm == WPA_KEY_MGMT_FT_PSK ||
000002  2940              CMP      r1,#0x40
000004  d001              BEQ      |L33.10|
;;;69     		akm == WPA_KEY_MGMT_FT_IEEE8021X;
000006  2920              CMP      r1,#0x20
000008  d101              BNE      |L33.14|
                  |L33.10|
00000a  2001              MOVS     r0,#1                 ;68
                  |L33.12|
;;;70     }
00000c  4770              BX       lr
                  |L33.14|
00000e  2000              MOVS     r0,#0                 ;68
000010  e7fc              B        |L33.12|
;;;71     
                          ENDP


                          AREA ||i.wpa_key_mgmt_sha256||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_sha256 PROC
;;;71     
;;;72     static inline int wpa_key_mgmt_sha256(int akm)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return akm == WPA_KEY_MGMT_PSK_SHA256 ||
000002  f5b17f80          CMP      r1,#0x100
000006  d001              BEQ      |L34.12|
;;;75     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
000008  2980              CMP      r1,#0x80
00000a  d101              BNE      |L34.16|
                  |L34.12|
00000c  2001              MOVS     r0,#1                 ;74
                  |L34.14|
;;;76     }
00000e  4770              BX       lr
                  |L34.16|
000010  2000              MOVS     r0,#0                 ;74
000012  e7fc              B        |L34.14|
;;;77     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_ieee8021x||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_ieee8021x PROC
;;;51     
;;;52     static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return akm == WPA_KEY_MGMT_IEEE8021X ||
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L35.14|
;;;55     		akm == WPA_KEY_MGMT_FT_IEEE8021X ||
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L35.14|
;;;56     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
00000a  2980              CMP      r1,#0x80
00000c  d101              BNE      |L35.18|
                  |L35.14|
00000e  2001              MOVS     r0,#1                 ;54
                  |L35.16|
;;;57     }
000010  4770              BX       lr
                  |L35.18|
000012  2000              MOVS     r0,#0                 ;54
000014  e7fc              B        |L35.16|
;;;58     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_psk||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_psk PROC
;;;58     
;;;59     static inline int wpa_key_mgmt_wpa_psk(int akm)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     	return akm == WPA_KEY_MGMT_PSK ||
000002  2902              CMP      r1,#2
000004  d004              BEQ      |L36.16|
;;;62     		akm == WPA_KEY_MGMT_FT_PSK ||
000006  2940              CMP      r1,#0x40
000008  d002              BEQ      |L36.16|
;;;63     		akm == WPA_KEY_MGMT_PSK_SHA256;
00000a  f5b17f80          CMP      r1,#0x100
00000e  d101              BNE      |L36.20|
                  |L36.16|
000010  2001              MOVS     r0,#1                 ;61
                  |L36.18|
;;;64     }
000012  4770              BX       lr
                  |L36.20|
000014  2000              MOVS     r0,#0                 ;61
000016  e7fc              B        |L36.18|
;;;65     
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L37.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L37.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L37.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L37.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L40.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L40.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L40.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L40.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L46.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L46.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __func__
000000  6561705f          DCB      0x65,0x61,0x70,0x5f
000004  746c735f          DCB      0x74,0x6c,0x73,0x5f
000008  63686563          DCB      0x63,0x68,0x65,0x63
00000c  6b5f626c          DCB      0x6b,0x5f,0x62,0x6c
000010  6f620000          DCB      0x6f,0x62,0x00,0x00
000014  53534c3a          DCB      0x53,0x53,0x4c,0x3a
000018  20496e76          DCB      0x20,0x49,0x6e,0x76
00001c  616c6964          DCB      0x61,0x6c,0x69,0x64
000020  20726561          DCB      0x20,0x72,0x65,0x61
000024  7373656d          DCB      0x73,0x73,0x65,0x6d
000028  626c7920          DCB      0x62,0x6c,0x79,0x20
00002c  73746174          DCB      0x73,0x74,0x61,0x74
000030  653a2074          DCB      0x65,0x3a,0x20,0x74
000034  6c735f69          DCB      0x6c,0x73,0x5f,0x69
000038  6e5f6c65          DCB      0x6e,0x5f,0x6c,0x65
00003c  66743d25          DCB      0x66,0x74,0x3d,0x25
000040  6c752074          DCB      0x6c,0x75,0x20,0x74
000044  6c735f69          DCB      0x6c,0x73,0x5f,0x69
000048  6e5f6c65          DCB      0x6e,0x5f,0x6c,0x65
00004c  6e3d256c          DCB      0x6e,0x3d,0x25,0x6c
000050  7520696e          DCB      0x75,0x20,0x69,0x6e
000054  5f6c656e          DCB      0x5f,0x6c,0x65,0x6e
000058  3d256c75          DCB      0x3d,0x25,0x6c,0x75
00005c  00000000          DCB      0x00,0x00,0x00,0x00
000060  53534c3a          DCB      0x53,0x53,0x4c,0x3a
000064  20656170          DCB      0x20,0x65,0x61,0x70
000068  5f746c73          DCB      0x5f,0x74,0x6c,0x73
00006c  5f70726f          DCB      0x5f,0x70,0x72,0x6f
000070  63657373          DCB      0x63,0x65,0x73,0x73
000074  5f696e70          DCB      0x5f,0x69,0x6e,0x70
000078  7574202d          DCB      0x75,0x74,0x20,0x2d
00007c  2070656e          DCB      0x20,0x70,0x65,0x6e
000080  64696e67          DCB      0x64,0x69,0x6e,0x67
000084  20746c73          DCB      0x20,0x74,0x6c,0x73
000088  5f6f7574          DCB      0x5f,0x6f,0x75,0x74
00008c  20646174          DCB      0x20,0x64,0x61,0x74
000090  61206576          DCB      0x61,0x20,0x65,0x76
000094  656e2074          DCB      0x65,0x6e,0x20,0x74
000098  686f7567          DCB      0x68,0x6f,0x75,0x67
00009c  6820746c          DCB      0x68,0x20,0x74,0x6c
0000a0  735f6f75          DCB      0x73,0x5f,0x6f,0x75
0000a4  745f6c65          DCB      0x74,0x5f,0x6c,0x65
0000a8  6e203d20          DCB      0x6e,0x20,0x3d,0x20
0000ac  30000000          DCB      0x30,0x00,0x00,0x00
0000b0  53534c3a          DCB      0x53,0x53,0x4c,0x3a
0000b4  20526563          DCB      0x20,0x52,0x65,0x63
0000b8  65697665          DCB      0x65,0x69,0x76,0x65
0000bc  64206e6f          DCB      0x64,0x20,0x6e,0x6f
0000c0  6e2d4143          DCB      0x6e,0x2d,0x41,0x43
0000c4  4b207768          DCB      0x4b,0x20,0x77,0x68
0000c8  656e206f          DCB      0x65,0x6e,0x20,0x6f
0000cc  75747075          DCB      0x75,0x74,0x70,0x75
0000d0  74206672          DCB      0x74,0x20,0x66,0x72
0000d4  61676d65          DCB      0x61,0x67,0x6d,0x65
0000d8  6e747320          DCB      0x6e,0x74,0x73,0x20
0000dc  61726520          DCB      0x61,0x72,0x65,0x20
0000e0  77616974          DCB      0x77,0x61,0x69,0x74
0000e4  696e6720          DCB      0x69,0x6e,0x67,0x20
0000e8  746f2062          DCB      0x74,0x6f,0x20,0x62
0000ec  65207365          DCB      0x65,0x20,0x73,0x65
0000f0  6e74206f          DCB      0x6e,0x74,0x20,0x6f
0000f4  757400            DCB      0x75,0x74,0x00
