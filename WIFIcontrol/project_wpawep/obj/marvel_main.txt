; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\marvel_main.o --depend=.\obj\marvel_main.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\marvel_main.crf ..\marvel\driver\src\marvel_main.c]
                          THUMB

                          AREA ||i.INIT_LIST_HEAD||, CODE, READONLY, ALIGN=1

                  INIT_LIST_HEAD PROC
;;;33     
;;;34     static __inline void INIT_LIST_HEAD(struct list_head *list)
000000  6000              STR      r0,[r0,#0]
;;;35     {
;;;36     	list->next = list;
;;;37     	list->prev = list;
000002  6040              STR      r0,[r0,#4]
;;;38     }
000004  4770              BX       lr
;;;39     
                          ENDP


                          AREA ||i.__list_add||, CODE, READONLY, ALIGN=1

                  __list_add PROC
;;;46     #ifndef CONFIG_DEBUG_LIST
;;;47     static __inline void __list_add(struct list_head *new,
000000  6050              STR      r0,[r2,#4]
;;;48     			      struct list_head *prev,
;;;49     			      struct list_head *next)
;;;50     {
;;;51     	next->prev = new;
;;;52     	new->next = next;
000002  6002              STR      r2,[r0,#0]
;;;53     	new->prev = prev;
000004  6041              STR      r1,[r0,#4]
;;;54     	prev->next = new;
000006  6008              STR      r0,[r1,#0]
;;;55     }
000008  4770              BX       lr
;;;56     #else
                          ENDP


                          AREA ||i.lbs_add_card||, CODE, READONLY, ALIGN=2

                  lbs_add_card PROC
;;;648    static struct lbs_private gmarvell_priv;
;;;649    struct lbs_private *lbs_add_card(void *card)
000000  b570              PUSH     {r4-r6,lr}
;;;650    {
000002  4605              MOV      r5,r0
;;;651    	struct lbs_private *priv =&gmarvell_priv;
000004  4c14              LDR      r4,|L3.88|
;;;652    	lbs_deb_enter("enter lbs_add_card!\n");
;;;653    
;;;654    	memset(priv,0,sizeof(struct lbs_private));
000006  f2411168          MOV      r1,#0x1168
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;655    	//哪里记住这个priv是个bug
;;;656    	 if (lbs_init_adapter(priv)) {//初始化lbs_private中的信息，它是管理网卡控制器的主要数据结构
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       lbs_init_adapter
000016  b118              CBZ      r0,|L3.32|
;;;657    		lbs_pr_err("failed to initialize adapter structure.\n");
000018  a010              ADR      r0,|L3.92|
00001a  f7fffffe          BL       __2printf
;;;658    		goto err_init_adapter;
00001e  e017              B        |L3.80|
                  |L3.32|
;;;659    	} 
;;;660    	priv->card = card;//if_sdio_card
000020  62a5              STR      r5,[r4,#0x28]
;;;661    	priv->mesh_open = 0;
000022  2100              MOVS     r1,#0
000024  f241009c          MOV      r0,#0x109c
000028  5101              STR      r1,[r0,r4]
;;;662    	priv->infra_open = 0;
00002a  f24100a4          MOV      r0,#0x10a4
00002e  5101              STR      r1,[r0,r4]
;;;663    	sprintf((char *)priv->mesh_ssid,"mesh");
000030  a115              ADR      r1,|L3.136|
000032  f24100bc          MOV      r0,#0x10bc
000036  4420              ADD      r0,r0,r4
000038  f7fffffe          BL       __2sprintf
;;;664    	priv->mesh_ssid_len = 4;
00003c  2104              MOVS     r1,#4
00003e  f24100dd          MOV      r0,#0x10dd
000042  5501              STRB     r1,[r0,r4]
;;;665    
;;;666    	priv->wol_criteria = 0xffffffff;
000044  1f48              SUBS     r0,r1,#5
000046  6620              STR      r0,[r4,#0x60]
;;;667    	priv->wol_gpio = 0xff;
000048  20ff              MOVS     r0,#0xff
00004a  f8840064          STRB     r0,[r4,#0x64]
;;;668    
;;;669    	goto done;
00004e  e000              B        |L3.82|
                  |L3.80|
;;;670    
;;;671    err_init_adapter:
;;;672    done:
000050  bf00              NOP      
                  |L3.82|
;;;673    	lbs_deb_leave_args("leave lbs_add_card",0);
;;;674    	return priv;
000052  4620              MOV      r0,r4
;;;675    }
000054  bd70              POP      {r4-r6,pc}
;;;676    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      gmarvell_priv
                  |L3.92|
00005c  6661696c          DCB      "failed to initialize adapter structure.\n",0
000060  65642074
000064  6f20696e
000068  69746961
00006c  6c697a65
000070  20616461
000074  70746572
000078  20737472
00007c  75637475
000080  72652e0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L3.136|
000088  6d657368          DCB      "mesh",0
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.lbs_fw_index_to_data_rate||, CODE, READONLY, ALIGN=2

                  lbs_fw_index_to_data_rate PROC
;;;148    
;;;149    u32 lbs_fw_index_to_data_rate(u8 idx)
000000  4601              MOV      r1,r0
;;;150    {
;;;151    	if (idx >= sizeof(fw_data_rates))
000002  290e              CMP      r1,#0xe
000004  d300              BCC      |L4.8|
;;;152    		idx = 0;
000006  2100              MOVS     r1,#0
                  |L4.8|
;;;153    	return fw_data_rates[idx];
000008  4801              LDR      r0,|L4.16|
00000a  5c40              LDRB     r0,[r0,r1]
;;;154    }
00000c  4770              BX       lr
;;;155    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      fw_data_rates

                          AREA ||i.lbs_get_region_cfp_table||, CODE, READONLY, ALIGN=2

                  lbs_get_region_cfp_table PROC
;;;740     */
;;;741    struct chan_freq_power *lbs_get_region_cfp_table(u8 region, int *cfp_no)
000000  b530              PUSH     {r4,r5,lr}
;;;742    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;743    	int i, end;
;;;744    
;;;745    	lbs_deb_enter(LBS_DEB_MAIN);
;;;746    
;;;747    	end = ARRAY_SIZE(region_cfp_table);
000006  2406              MOVS     r4,#6
;;;748    
;;;749    	for (i = 0; i < end ; i++) {
000008  2100              MOVS     r1,#0
00000a  e013              B        |L5.52|
                  |L5.12|
;;;750    		lbs_pr_debug("region_cfp_table[i].region=%d\n",
;;;751    			region_cfp_table[i].region);
;;;752    		if (region_cfp_table[i].region == region) {
00000c  eb010041          ADD      r0,r1,r1,LSL #1
000010  4d0a              LDR      r5,|L5.60|
000012  f8150020          LDRB     r0,[r5,r0,LSL #2]
000016  4290              CMP      r0,r2
000018  d10b              BNE      |L5.50|
;;;753    			*cfp_no = region_cfp_table[i].cfp_no_BG;//返回区域对应的channel、frequency、power的数目
00001a  eb010041          ADD      r0,r1,r1,LSL #1
00001e  eb050080          ADD      r0,r5,r0,LSL #2
000022  6880              LDR      r0,[r0,#8]
000024  6018              STR      r0,[r3,#0]
;;;754    			lbs_deb_leave(LBS_DEB_MAIN);
;;;755    			return region_cfp_table[i].cfp_BG;//返回获取到的cfp表地址
000026  eb010041          ADD      r0,r1,r1,LSL #1
00002a  eb050080          ADD      r0,r5,r0,LSL #2
00002e  6840              LDR      r0,[r0,#4]
                  |L5.48|
;;;756    		}
;;;757    	}
;;;758    
;;;759    	lbs_deb_leave_args(LBS_DEB_MAIN, "ret NULL");
;;;760    	return NULL;
;;;761    }
000030  bd30              POP      {r4,r5,pc}
                  |L5.50|
000032  1c49              ADDS     r1,r1,#1              ;749
                  |L5.52|
000034  42a1              CMP      r1,r4                 ;749
000036  dbe9              BLT      |L5.12|
000038  2000              MOVS     r0,#0                 ;760
00003a  e7f9              B        |L5.48|
;;;762    
                          ENDP

                  |L5.60|
                          DCD      region_cfp_table

                          AREA ||i.lbs_host_to_card_done||, CODE, READONLY, ALIGN=1

                  lbs_host_to_card_done PROC
;;;177    
;;;178    void lbs_host_to_card_done(struct lbs_private *priv)
000000  b510              PUSH     {r4,lr}
;;;179    {
000002  4604              MOV      r4,r0
;;;180    //	unsigned long flags;
;;;181    
;;;182    	 lbs_deb_cmd_enter("enter lbs_host_to_card_done\n");
;;;183    
;;;184    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;185    
;;;186    	priv->dnld_sent = DNLD_RES_RECEIVED;
000004  2100              MOVS     r1,#0
000006  f24100b8          MOV      r0,#0x10b8
00000a  5501              STRB     r1,[r0,r4]
;;;187    
;;;188    	/* Wake main thread if commands are pending */
;;;189    	 if (!priv->cur_cmd || priv->tx_pending_len > 0)//当前命令执行完成，或者有数据要发送，唤醒主线程处理
00000c  6fe0              LDR      r0,[r4,#0x7c]
00000e  b110              CBZ      r0,|L6.22|
000010  6f20              LDR      r0,[r4,#0x70]
000012  2800              CMP      r0,#0
000014  dd02              BLE      |L6.28|
                  |L6.22|
;;;190    		//wake_up_interruptible(&priv->waitq);
;;;191    		lbs_thread(priv);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       lbs_thread
                  |L6.28|
;;;192    
;;;193    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;194    	 lbs_deb_cmd_leave("leave lbs_host_to_card_done\n");
;;;195    }
00001c  bd10              POP      {r4,pc}
;;;196    
                          ENDP


                          AREA ||i.lbs_init_adapter||, CODE, READONLY, ALIGN=2

                  lbs_init_adapter PROC
;;;197    
;;;198    static int lbs_init_adapter(struct lbs_private *priv)//主要是初始化网卡的一些软件信息
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;199    {
000004  4604              MOV      r4,r0
;;;200    	size_t bufsize;
;;;201    	int i, ret = 0;
000006  f04f0900          MOV      r9,#0
;;;202    	static u8 gnet_bss_desc[MAX_NETWORK_COUNT * sizeof(struct bss_descriptor)];
;;;203    
;;;204    	lbs_deb_enter("enter lbs_init_adapter\n");
;;;205    	/* Allocate buffer to store the BSSID list */
;;;206    	bufsize = MAX_NETWORK_COUNT * sizeof(struct bss_descriptor);
00000a  f44f58ba          MOV      r8,#0x1740
;;;207    	//分配一个服务集描述符的空间，用来存放这个BSS的一些基本信息
;;;208    	/*priv->networks = kzalloc(bufsize, GFP_KERNEL);
;;;209    	if (!priv->networks) {
;;;210    		lbs_pr_err("Out of memory allocating beacons\n");
;;;211    		ret = -1;
;;;212    		goto out;
;;;213    	}*/
;;;214    	priv->networks=(struct bss_descriptor *)gnet_bss_desc;
00000e  4832              LDR      r0,|L7.216|
000010  f8c400fc          STR      r0,[r4,#0xfc]
;;;215    	memset(priv->networks,0,bufsize);
000014  4641              MOV      r1,r8
000016  f8d400fc          LDR      r0,[r4,#0xfc]
00001a  f7fffffe          BL       __aeabi_memclr4
;;;216    
;;;217    	/* Initialize scan result lists */
;;;218    	INIT_LIST_HEAD(&priv->network_free_list);//初始化扫描相关的链表
00001e  f10400f4          ADD      r0,r4,#0xf4
000022  f7fffffe          BL       INIT_LIST_HEAD
;;;219    	INIT_LIST_HEAD(&priv->network_list);
000026  f10400ec          ADD      r0,r4,#0xec
00002a  f7fffffe          BL       INIT_LIST_HEAD
;;;220    	for (i = 0; i < MAX_NETWORK_COUNT; i++) {//当前未用的所有bss_descriptor链入到空闲链表
00002e  2500              MOVS     r5,#0
000030  e010              B        |L7.84|
                  |L7.50|
;;;221    		list_add_tail(&priv->networks[i].list,
000032  ebc51145          RSB      r1,r5,r5,LSL #5
000036  f8d400fc          LDR      r0,[r4,#0xfc]
00003a  eb001001          ADD      r0,r0,r1,LSL #4
00003e  f50077f4          ADD      r7,r0,#0x1e8
000042  f10406f4          ADD      r6,r4,#0xf4
000046  4632              MOV      r2,r6
000048  4638              MOV      r0,r7
00004a  6871              LDR      r1,[r6,#4]
00004c  f7fffffe          BL       __list_add
000050  bf00              NOP      
000052  1c6d              ADDS     r5,r5,#1              ;220
                  |L7.84|
000054  2d0c              CMP      r5,#0xc               ;220
000056  dbec              BLT      |L7.50|
;;;222    			      &priv->network_free_list);
;;;223    	}
;;;224    
;;;225    	memset(priv->current_addr, 0xff, ETH_ALEN);//当前物理地址软件初始化为0xff
000058  22ff              MOVS     r2,#0xff
00005a  2106              MOVS     r1,#6
00005c  f5047085          ADD      r0,r4,#0x10a
000060  f7fffffe          BL       __aeabi_memset
;;;226    
;;;227    	priv->connect_status = LBS_DISCONNECTED;//未连接
000064  2001              MOVS     r0,#1
000066  f8c401dc          STR      r0,[r4,#0x1dc]
;;;228    	priv->mesh_connect_status = LBS_DISCONNECTED;//mesh网络未连接
00006a  f8c401e0          STR      r0,[r4,#0x1e0]
;;;229    	priv->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;//认证模式，开放型认证
00006e  2101              MOVS     r1,#1
000070  f2402003          MOV      r0,#0x203
000074  5501              STRB     r1,[r0,r4]
;;;230    	priv->mode = IW_MODE_INFRA;//基础网络
000076  2002              MOVS     r0,#2
000078  f88400e9          STRB     r0,[r4,#0xe9]
;;;231    	priv->curbssparams.channel = DEFAULT_AD_HOC_CHANNEL;//实际上就是效果最好的信道，信道6
00007c  2106              MOVS     r1,#6
00007e  f88410d9          STRB     r1,[r4,#0xd9]
;;;232    	priv->mac_control = CMD_ACT_MAC_RX_ON | CMD_ACT_MAC_TX_ON;//接收发送使能
000082  2003              MOVS     r0,#3
000084  f8a401da          STRH     r0,[r4,#0x1da]
;;;233    	priv->radio_on = 1;
000088  2001              MOVS     r0,#1
00008a  f8840316          STRB     r0,[r4,#0x316]
;;;234    	priv->enablehwauto = 1;
00008e  f8a401d4          STRH     r0,[r4,#0x1d4]
;;;235    	priv->capability = WLAN_CAPABILITY_SHORT_PREAMBLE;
000092  2020              MOVS     r0,#0x20
000094  f8a40108          STRH     r0,[r4,#0x108]
;;;236    	priv->psmode = LBS802_11POWERMODECAM;
000098  2000              MOVS     r0,#0
00009a  f8a401ee          STRH     r0,[r4,#0x1ee]
;;;237    	priv->psstate = PS_STATE_FULL_POWER;
00009e  f8c401f0          STR      r0,[r4,#0x1f0]
;;;238    	//以上都是初始化适配器的一些软件参数
;;;239    	//mutex_init(&priv->lock);
;;;240    
;;;241    	/*setup_timer(&priv->command_timer, command_timer_fn,//安装一个命令处理的定时器
;;;242    		(unsigned long)priv);*/
;;;243    
;;;244    	INIT_LIST_HEAD(&priv->cmdfreeq);
0000a2  f1040084          ADD      r0,r4,#0x84
0000a6  f7fffffe          BL       INIT_LIST_HEAD
;;;245    	INIT_LIST_HEAD(&priv->cmdpendingq);
0000aa  f104008c          ADD      r0,r4,#0x8c
0000ae  f7fffffe          BL       INIT_LIST_HEAD
;;;246    
;;;247    	/*spin_lock_init(&priv->driver_lock);
;;;248    	init_waitqueue_head(&priv->cmd_pending);//初始化一个等待队列处理命令*/
;;;249    
;;;250    	/* Allocate the command buffers */
;;;251    	if (lbs_allocate_cmd_buffer(priv)) {//分配并初始化命令控制块struct cmd_ctrl_node是命令存放的主要结构
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       lbs_allocate_cmd_buffer
0000b8  b128              CBZ      r0,|L7.198|
;;;252    		lbs_pr_err("Out of memory allocating command buffers\n");
0000ba  a008              ADR      r0,|L7.220|
0000bc  f7fffffe          BL       __2printf
;;;253    		ret = -ENOMEM;
0000c0  f06f090b          MVN      r9,#0xb
;;;254    		goto out;
0000c4  e005              B        |L7.210|
                  |L7.198|
;;;255    	}
;;;256    	priv->resp_idx = 0;
0000c6  2000              MOVS     r0,#0
0000c8  f8840495          STRB     r0,[r4,#0x495]
;;;257    	priv->resp_len[0] = 0;//硬件返回的命令响应
0000cc  f8c40498          STR      r0,[r4,#0x498]
;;;258    
;;;259    	/* Create the event FIFO */
;;;260    	/*priv->event_fifo = kfifo_alloc(sizeof(u32) * 16, GFP_KERNEL, NULL);//硬件的event，比如热插拔等事件
;;;261    	if (IS_ERR(priv->event_fifo)) {
;;;262    		lbs_pr_err("Out of memory allocating event FIFO buffer\n");
;;;263    		ret = -ENOMEM;
;;;264    		goto out;
;;;265    	}*/
;;;266    
;;;267    out:
0000d0  bf00              NOP      
                  |L7.210|
;;;268    	lbs_deb_leave_args("leave lbs_init_adapter(ret=%d)\n", ret);
;;;269    
;;;270    	return ret;
0000d2  4648              MOV      r0,r9
;;;271    }
0000d4  e8bd87f0          POP      {r4-r10,pc}
;;;272    
                          ENDP

                  |L7.216|
                          DCD      gnet_bss_desc
                  |L7.220|
0000dc  4f757420          DCB      "Out of memory allocating command buffers\n",0
0000e0  6f66206d
0000e4  656d6f72
0000e8  7920616c
0000ec  6c6f6361
0000f0  74696e67
0000f4  20636f6d
0000f8  6d616e64
0000fc  20627566
000100  66657273
000104  0a00    
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.lbs_notify_command_response||, CODE, READONLY, ALIGN=1

                  lbs_notify_command_response PROC
;;;157    
;;;158    void lbs_notify_command_response(struct lbs_private *priv, u8 resp_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;159    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;160    	//lbs_deb_enter(LBS_DEB_THREAD);
;;;161    
;;;162    	if (priv->psstate == PS_STATE_SLEEP)
000006  f8d401f0          LDR      r0,[r4,#0x1f0]
00000a  2803              CMP      r0,#3
00000c  d102              BNE      |L8.20|
;;;163    		priv->psstate = PS_STATE_AWAKE;
00000e  2001              MOVS     r0,#1
000010  f8c401f0          STR      r0,[r4,#0x1f0]
                  |L8.20|
;;;164    
;;;165    	/* Swap buffers by flipping the response index */
;;;166    	//BUG_ON(resp_idx > 1);
;;;167    	priv->resp_idx = resp_idx;
000014  f8845495          STRB     r5,[r4,#0x495]
;;;168    
;;;169    	lbs_thread(priv);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       lbs_thread
;;;170    
;;;171    	//lbs_deb_leave(LBS_DEB_THREAD);
;;;172    }
00001e  bd70              POP      {r4-r6,pc}
;;;173    
                          ENDP


                          AREA ||i.lbs_process_event||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  lbs_process_event PROC
;;;273    
;;;274    int lbs_process_event(struct lbs_private *priv, u32 event)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;276    	int ret = 0;
000006  2600              MOVS     r6,#0
;;;277    	lbs_deb_enter(LBS_DEB_CMD);
;;;278    
;;;279    	switch (event) {
000008  1ee8              SUBS     r0,r5,#3
00000a  281b              CMP      r0,#0x1b
00000c  d26d              BCS      |L9.234|
00000e  e8dff000          TBB      [pc,r0]
000012  1a0e              DCB      0x1a,0x0e
000014  6c4c5012          DCB      0x6c,0x4c,0x50,0x12
000018  16301e6c          DCB      0x16,0x30,0x1e,0x6c
00001c  48446c6c          DCB      0x48,0x44,0x6c,0x6c
000020  542c6c6c          DCB      0x54,0x2c,0x6c,0x6c
000024  6c6c6c6c          DCB      0x6c,0x6c,0x6c,0x6c
000028  585c6064          DCB      0x58,0x5c,0x60,0x64
00002c  6800              DCB      0x68,0x00
;;;280    	case MACREG_INT_CODE_LINK_SENSED:
;;;281    		printk("EVENT: link sensed\n");//掉线
00002e  a033              ADR      r0,|L9.252|
000030  f7fffffe          BL       __2printf
;;;282    		break;
000034  e05e              B        |L9.244|
;;;283    
;;;284    	case MACREG_INT_CODE_DEAUTHENTICATED:
;;;285    		printk("EVENT: deauthenticated\n");
000036  a036              ADR      r0,|L9.272|
000038  f7fffffe          BL       __2printf
;;;286    		//lbs_mac_event_disconnected(priv);
;;;287    		break;
00003c  e05a              B        |L9.244|
;;;288    
;;;289    	case MACREG_INT_CODE_DISASSOCIATED:
;;;290    		printk("EVENT: disassociated\n");
00003e  a03a              ADR      r0,|L9.296|
000040  f7fffffe          BL       __2printf
;;;291    		//lbs_mac_event_disconnected(priv);
;;;292    		break;
000044  e056              B        |L9.244|
;;;293    
;;;294    	case MACREG_INT_CODE_LINK_LOST_NO_SCAN:
;;;295    		printk("EVENT: link lost\n");
000046  a03e              ADR      r0,|L9.320|
000048  f7fffffe          BL       __2printf
;;;296    		//lbs_mac_event_disconnected(priv);
;;;297    		break;
00004c  e052              B        |L9.244|
;;;298    
;;;299    	case MACREG_INT_CODE_PS_SLEEP:
;;;300    		printk("EVENT: ps sleep\n");
00004e  a041              ADR      r0,|L9.340|
000050  f7fffffe          BL       __2printf
;;;301    
;;;302    		/* handle unexpected PS SLEEP event */
;;;303    		if (priv->psstate == PS_STATE_FULL_POWER) {
000054  f8d401f0          LDR      r0,[r4,#0x1f0]
000058  b918              CBNZ     r0,|L9.98|
;;;304    			printk("EVENT: in FULL POWER mode, ignoreing PS_SLEEP\n");
00005a  a043              ADR      r0,|L9.360|
00005c  f7fffffe          BL       __2printf
;;;305    			break;
000060  e048              B        |L9.244|
                  |L9.98|
;;;306    		}
;;;307    		priv->psstate = PS_STATE_PRE_SLEEP;
000062  2002              MOVS     r0,#2
000064  f8c401f0          STR      r0,[r4,#0x1f0]
;;;308    
;;;309    		//lbs_ps_confirm_sleep(priv);
;;;310    
;;;311    		break;
000068  e044              B        |L9.244|
;;;312    
;;;313    	case MACREG_INT_CODE_HOST_AWAKE:
;;;314    		printk("EVENT: host awake\n");
00006a  a04b              ADR      r0,|L9.408|
00006c  f7fffffe          BL       __2printf
;;;315    		//lbs_send_confirmwake(priv);
;;;316    		break;
000070  e040              B        |L9.244|
;;;317    
;;;318    	case MACREG_INT_CODE_PS_AWAKE:
;;;319    		printk("EVENT: ps awake\n");
000072  a04e              ADR      r0,|L9.428|
000074  f7fffffe          BL       __2printf
;;;320    		/* handle unexpected PS AWAKE event */
;;;321    		if (priv->psstate == PS_STATE_FULL_POWER) {
000078  f8d401f0          LDR      r0,[r4,#0x1f0]
00007c  b918              CBNZ     r0,|L9.134|
;;;322    			printk(
00007e  a050              ADR      r0,|L9.448|
000080  f7fffffe          BL       __2printf
;;;323    			       "EVENT: In FULL POWER mode - ignore PS AWAKE\n");
;;;324    			break;
000084  e036              B        |L9.244|
                  |L9.134|
;;;325    		}
;;;326    
;;;327    		priv->psstate = PS_STATE_AWAKE;
000086  2001              MOVS     r0,#1
000088  f8c401f0          STR      r0,[r4,#0x1f0]
;;;328    
;;;329    		if (priv->needtowakeup) {
00008c  f89401f4          LDRB     r0,[r4,#0x1f4]
000090  b110              CBZ      r0,|L9.152|
;;;330    			/*
;;;331    			 * wait for the command processing to finish
;;;332    			 * before resuming sending
;;;333    			 * priv->needtowakeup will be set to FALSE
;;;334    			 * in lbs_ps_wakeup()
;;;335    			 */
;;;336    			printk("waking up ...\n");
000092  a057              ADR      r0,|L9.496|
000094  f7fffffe          BL       __2printf
                  |L9.152|
;;;337    			//lbs_ps_wakeup(priv, 0);
;;;338    		}
;;;339    		break;
000098  e02c              B        |L9.244|
;;;340    
;;;341    	case MACREG_INT_CODE_MIC_ERR_UNICAST:
;;;342    		printk("EVENT: UNICAST MIC ERROR\n");
00009a  a059              ADR      r0,|L9.512|
00009c  f7fffffe          BL       __2printf
;;;343    		//handle_mic_failureevent(priv, MACREG_INT_CODE_MIC_ERR_UNICAST);
;;;344    		break;
0000a0  e028              B        |L9.244|
;;;345    
;;;346    	case MACREG_INT_CODE_MIC_ERR_MULTICAST:
;;;347    		printk("EVENT: MULTICAST MIC ERROR\n");
0000a2  a05e              ADR      r0,|L9.540|
0000a4  f7fffffe          BL       __2printf
;;;348    		//handle_mic_failureevent(priv, MACREG_INT_CODE_MIC_ERR_MULTICAST);
;;;349    		break;
0000a8  e024              B        |L9.244|
;;;350    
;;;351    	case MACREG_INT_CODE_MIB_CHANGED:
;;;352    		printk("EVENT: MIB CHANGED\n");
0000aa  a063              ADR      r0,|L9.568|
0000ac  f7fffffe          BL       __2printf
;;;353    		break;
0000b0  e020              B        |L9.244|
;;;354    	case MACREG_INT_CODE_INIT_DONE:
;;;355    		printk("EVENT: INIT DONE\n");
0000b2  a066              ADR      r0,|L9.588|
0000b4  f7fffffe          BL       __2printf
;;;356    		break;
0000b8  e01c              B        |L9.244|
;;;357    	case MACREG_INT_CODE_ADHOC_BCN_LOST:
;;;358    		printk("EVENT: ADHOC beacon lost\n");
0000ba  a069              ADR      r0,|L9.608|
0000bc  f7fffffe          BL       __2printf
;;;359    		break;
0000c0  e018              B        |L9.244|
;;;360    	case MACREG_INT_CODE_RSSI_LOW:
;;;361    		printk("EVENT: rssi low\n");
0000c2  a06e              ADR      r0,|L9.636|
0000c4  f7fffffe          BL       __2printf
;;;362    		break;
0000c8  e014              B        |L9.244|
;;;363    	case MACREG_INT_CODE_SNR_LOW:
;;;364    		printk("EVENT: snr low\n");
0000ca  a071              ADR      r0,|L9.656|
0000cc  f7fffffe          BL       __2printf
;;;365    		break;
0000d0  e010              B        |L9.244|
;;;366    	case MACREG_INT_CODE_MAX_FAIL:
;;;367    		printk("EVENT: max fail\n");
0000d2  a073              ADR      r0,|L9.672|
0000d4  f7fffffe          BL       __2printf
;;;368    		break;
0000d8  e00c              B        |L9.244|
;;;369    	case MACREG_INT_CODE_RSSI_HIGH:
;;;370    		printk("EVENT: rssi high\n");
0000da  a076              ADR      r0,|L9.692|
0000dc  f7fffffe          BL       __2printf
;;;371    		break;
0000e0  e008              B        |L9.244|
;;;372    	case MACREG_INT_CODE_SNR_HIGH:
;;;373    		printk("EVENT: snr high\n");
0000e2  a079              ADR      r0,|L9.712|
0000e4  f7fffffe          BL       __2printf
;;;374    		break;
0000e8  e004              B        |L9.244|
                  |L9.234|
;;;375    #ifdef MASK_DEBUG
;;;376    	case MACREG_INT_CODE_MESH_AUTO_STARTED:
;;;377    		/* Ignore spurious autostart events if autostart is disabled */
;;;378    		if (!priv->mesh_autostart_enabled) {
;;;379    			lbs_pr_info("EVENT: MESH_AUTO_STARTED (ignoring)\n");
;;;380    			break;
;;;381    		}
;;;382    		lbs_pr_info("EVENT: MESH_AUTO_STARTED\n");
;;;383    		priv->mesh_connect_status = LBS_CONNECTED;
;;;384    		if (priv->mesh_open) {
;;;385    			netif_carrier_on(priv->mesh_dev);
;;;386    			if (!priv->tx_pending_len)
;;;387    				netif_wake_queue(priv->mesh_dev);
;;;388    		}
;;;389    		priv->mode = IW_MODE_ADHOC;
;;;390    		schedule_work(&priv->sync_channel);
;;;391    		break;
;;;392    #endif
;;;393    	default:
;;;394    		printk("EVENT: unknown event id %d\n", event);
0000ea  4629              MOV      r1,r5
0000ec  a07b              ADR      r0,|L9.732|
0000ee  f7fffffe          BL       __2printf
;;;395    		break;
0000f2  bf00              NOP      
                  |L9.244|
0000f4  bf00              NOP                            ;282
;;;396    	}
;;;397    
;;;398    	lbs_deb_leave_args(LBS_DEB_CMD, ret);
;;;399    	return ret;
0000f6  4630              MOV      r0,r6
;;;400    }
0000f8  bd70              POP      {r4-r6,pc}
;;;401    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L9.252|
0000fc  4556454e          DCB      "EVENT: link sensed\n",0
000100  543a206c
000104  696e6b20
000108  73656e73
00010c  65640a00
                  |L9.272|
000110  4556454e          DCB      "EVENT: deauthenticated\n",0
000114  543a2064
000118  65617574
00011c  68656e74
000120  69636174
000124  65640a00
                  |L9.296|
000128  4556454e          DCB      "EVENT: disassociated\n",0
00012c  543a2064
000130  69736173
000134  736f6369
000138  61746564
00013c  0a00    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L9.320|
000140  4556454e          DCB      "EVENT: link lost\n",0
000144  543a206c
000148  696e6b20
00014c  6c6f7374
000150  0a00    
000152  00                DCB      0
000153  00                DCB      0
                  |L9.340|
000154  4556454e          DCB      "EVENT: ps sleep\n",0
000158  543a2070
00015c  7320736c
000160  6565700a
000164  00      
000165  00                DCB      0
000166  00                DCB      0
000167  00                DCB      0
                  |L9.360|
000168  4556454e          DCB      "EVENT: in FULL POWER mode, ignoreing PS_SLEEP\n",0
00016c  543a2069
000170  6e204655
000174  4c4c2050
000178  4f574552
00017c  206d6f64
000180  652c2069
000184  676e6f72
000188  65696e67
00018c  2050535f
000190  534c4545
000194  500a00  
000197  00                DCB      0
                  |L9.408|
000198  4556454e          DCB      "EVENT: host awake\n",0
00019c  543a2068
0001a0  6f737420
0001a4  6177616b
0001a8  650a00  
0001ab  00                DCB      0
                  |L9.428|
0001ac  4556454e          DCB      "EVENT: ps awake\n",0
0001b0  543a2070
0001b4  73206177
0001b8  616b650a
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L9.448|
0001c0  4556454e          DCB      "EVENT: In FULL POWER mode - ignore PS AWAKE\n",0
0001c4  543a2049
0001c8  6e204655
0001cc  4c4c2050
0001d0  4f574552
0001d4  206d6f64
0001d8  65202d20
0001dc  69676e6f
0001e0  72652050
0001e4  53204157
0001e8  414b450a
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L9.496|
0001f0  77616b69          DCB      "waking up ...\n",0
0001f4  6e672075
0001f8  70202e2e
0001fc  2e0a00  
0001ff  00                DCB      0
                  |L9.512|
000200  4556454e          DCB      "EVENT: UNICAST MIC ERROR\n",0
000204  543a2055
000208  4e494341
00020c  5354204d
000210  49432045
000214  52524f52
000218  0a00    
00021a  00                DCB      0
00021b  00                DCB      0
                  |L9.540|
00021c  4556454e          DCB      "EVENT: MULTICAST MIC ERROR\n",0
000220  543a204d
000224  554c5449
000228  43415354
00022c  204d4943
000230  20455252
000234  4f520a00
                  |L9.568|
000238  4556454e          DCB      "EVENT: MIB CHANGED\n",0
00023c  543a204d
000240  49422043
000244  48414e47
000248  45440a00
                  |L9.588|
00024c  4556454e          DCB      "EVENT: INIT DONE\n",0
000250  543a2049
000254  4e495420
000258  444f4e45
00025c  0a00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L9.608|
000260  4556454e          DCB      "EVENT: ADHOC beacon lost\n",0
000264  543a2041
000268  44484f43
00026c  20626561
000270  636f6e20
000274  6c6f7374
000278  0a00    
00027a  00                DCB      0
00027b  00                DCB      0
                  |L9.636|
00027c  4556454e          DCB      "EVENT: rssi low\n",0
000280  543a2072
000284  73736920
000288  6c6f770a
00028c  00      
00028d  00                DCB      0
00028e  00                DCB      0
00028f  00                DCB      0
                  |L9.656|
000290  4556454e          DCB      "EVENT: snr low\n",0
000294  543a2073
000298  6e72206c
00029c  6f770a00
                  |L9.672|
0002a0  4556454e          DCB      "EVENT: max fail\n",0
0002a4  543a206d
0002a8  61782066
0002ac  61696c0a
0002b0  00      
0002b1  00                DCB      0
0002b2  00                DCB      0
0002b3  00                DCB      0
                  |L9.692|
0002b4  4556454e          DCB      "EVENT: rssi high\n",0
0002b8  543a2072
0002bc  73736920
0002c0  68696768
0002c4  0a00    
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L9.712|
0002c8  4556454e          DCB      "EVENT: snr high\n",0
0002cc  543a2073
0002d0  6e722068
0002d4  6967680a
0002d8  00      
0002d9  00                DCB      0
0002da  00                DCB      0
0002db  00                DCB      0
                  |L9.732|
0002dc  4556454e          DCB      "EVENT: unknown event id %d\n",0
0002e0  543a2075
0002e4  6e6b6e6f
0002e8  776e2065
0002ec  76656e74
0002f0  20696420
0002f4  25640a00

                          AREA ||i.lbs_queue_event||, CODE, READONLY, ALIGN=1

                  lbs_queue_event PROC
;;;796    
;;;797    void lbs_queue_event(struct lbs_private *priv, u32 event)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;798    {
000002  4604              MOV      r4,r0
;;;799    //	unsigned long flags;
;;;800    	lbs_deb_enter(LBS_DEB_THREAD);
;;;801    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;802    
;;;803    	if (priv->psstate == PS_STATE_SLEEP)
000004  f8d401f0          LDR      r0,[r4,#0x1f0]
000008  2803              CMP      r0,#3
00000a  d102              BNE      |L10.18|
;;;804    		priv->psstate = PS_STATE_AWAKE;
00000c  2001              MOVS     r0,#1
00000e  f8c401f0          STR      r0,[r4,#0x1f0]
                  |L10.18|
;;;805    
;;;806    	__kfifo_put(priv->event_fifo, (unsigned char *)&event, sizeof(u32));
000012  bf00              NOP      
000014  f89d0004          LDRB     r0,[sp,#4]
000018  f8d41094          LDR      r1,[r4,#0x94]
00001c  6048              STR      r0,[r1,#4]
00001e  2001              MOVS     r0,#1
000020  f8d41094          LDR      r1,[r4,#0x94]
000024  7008              STRB     r0,[r1,#0]
000026  bf00              NOP      
;;;807    	//wake_up_interruptible(&priv->waitq);
;;;808    	lbs_thread(priv);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       lbs_thread
;;;809    
;;;810    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;811    	lbs_deb_leave(LBS_DEB_THREAD);
;;;812    }
00002e  bd1c              POP      {r2-r4,pc}
;;;813    
                          ENDP


                          AREA ||i.lbs_set_regiontable||, CODE, READONLY, ALIGN=1

                  lbs_set_regiontable PROC
;;;764    
;;;765    int lbs_set_regiontable(struct lbs_private *priv, u8 region, u8 band)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;766    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;767    	int ret = 0;
00000a  f04f0900          MOV      r9,#0
;;;768    	int i = 0;
00000e  2500              MOVS     r5,#0
;;;769    
;;;770    	struct chan_freq_power *cfp;
;;;771    	int cfp_no;
;;;772    
;;;773    	lbs_deb_enter(LBS_DEB_MAIN);
;;;774    
;;;775    	memset(priv->region_channel, 0, sizeof(priv->region_channel));
000010  f5047040          ADD      r0,r4,#0x300
000014  2100              MOVS     r1,#0
000016  6181              STR      r1,[r0,#0x18]
000018  61c1              STR      r1,[r0,#0x1c]
00001a  6201              STR      r1,[r0,#0x20]
00001c  6241              STR      r1,[r0,#0x24]
;;;776    
;;;777    	cfp = lbs_get_region_cfp_table(region, &cfp_no);//获取区域的802.11b/g的信道、频率和功率对应表
00001e  4669              MOV      r1,sp
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       lbs_get_region_cfp_table
000026  4680              MOV      r8,r0
;;;778    	if (cfp != NULL) {
000028  f1b80f00          CMP      r8,#0
00002c  d00d              BEQ      |L11.74|
;;;779    		priv->region_channel[i].nrcfp = cfp_no;
00002e  9800              LDR      r0,[sp,#0]
000030  b2c1              UXTB     r1,r0
000032  f5047046          ADD      r0,r4,#0x318
000036  eb0000c5          ADD      r0,r0,r5,LSL #3
00003a  70c1              STRB     r1,[r0,#3]
;;;780    		priv->region_channel[i].CFP = cfp;
00003c  f5047046          ADD      r0,r4,#0x318
000040  eb0000c5          ADD      r0,r0,r5,LSL #3
000044  f8c08004          STR      r8,[r0,#4]
000048  e002              B        |L11.80|
                  |L11.74|
;;;781    	} else {
;;;782    		lbs_pr_debug("wrong region code %#x in band B/G\n",
;;;783    		       region);
;;;784    		ret = -1;
00004a  f04f39ff          MOV      r9,#0xffffffff
;;;785    		goto out;
00004e  e00e              B        |L11.110|
                  |L11.80|
;;;786    	}
;;;787    	priv->region_channel[i].valid = 1;
000050  2101              MOVS     r1,#1
000052  f5047046          ADD      r0,r4,#0x318
000056  f8001035          STRB     r1,[r0,r5,LSL #3]
;;;788    	priv->region_channel[i].region = region;
00005a  eb0000c5          ADD      r0,r0,r5,LSL #3
00005e  7046              STRB     r6,[r0,#1]
;;;789    	priv->region_channel[i].band = band;
000060  f5047046          ADD      r0,r4,#0x318
000064  eb0000c5          ADD      r0,r0,r5,LSL #3
000068  7087              STRB     r7,[r0,#2]
;;;790    	i++;
00006a  1c6d              ADDS     r5,r5,#1
;;;791    out:
00006c  bf00              NOP      
                  |L11.110|
;;;792    	lbs_deb_leave_args(LBS_DEB_MAIN, ret);
;;;793    	return ret;
00006e  4648              MOV      r0,r9
;;;794    }
000070  e8bd83f8          POP      {r3-r9,pc}
;;;795    
                          ENDP


                          AREA ||i.lbs_setup_firmware||, CODE, READONLY, ALIGN=1

                  lbs_setup_firmware PROC
;;;685     */
;;;686    static int lbs_setup_firmware(struct lbs_private *priv)
000000  b53e              PUSH     {r1-r5,lr}
;;;687    {
000002  4604              MOV      r4,r0
;;;688    	int ret = -1;
000004  f04f35ff          MOV      r5,#0xffffffff
;;;689    	 s16 curlevel = 0, minlevel = 0, maxlevel = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
00000c  9001              STR      r0,[sp,#4]
00000e  9000              STR      r0,[sp,#0]
;;;690    
;;;691    	 lbs_deb_enter("enter lbs_setup_firmware\n");
;;;692    
;;;693    	/* Read MAC address from firmware */
;;;694    	memset(priv->current_addr, 0xff, ETH_ALEN);
000010  22ff              MOVS     r2,#0xff
000012  2106              MOVS     r1,#6
000014  f5047085          ADD      r0,r4,#0x10a
000018  f7fffffe          BL       __aeabi_memset
;;;695    	ret = lbs_update_hw_spec(priv);//根据固件的情况更新MAC地址、区域信道等细节信息填充到priv中
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       lbs_update_hw_spec
000022  4605              MOV      r5,r0
;;;696    	if (ret)
000024  b105              CBZ      r5,|L12.40|
;;;697    		goto done;
000026  e017              B        |L12.88|
                  |L12.40|
;;;698    	/* Read power levels if available */
;;;699    	ret = lbs_get_tx_power(priv, &curlevel, &minlevel, &maxlevel);//获取当前功率、最小功率和最大功率
000028  466b              MOV      r3,sp
00002a  aa01              ADD      r2,sp,#4
00002c  a902              ADD      r1,sp,#8
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       lbs_get_tx_power
000034  4605              MOV      r5,r0
;;;700    	if (ret == 0) {
000036  b95d              CBNZ     r5,|L12.80|
;;;701    		priv->txpower_cur = curlevel;
000038  f9bd0008          LDRSH    r0,[sp,#8]
00003c  f8a401e6          STRH     r0,[r4,#0x1e6]
;;;702    		priv->txpower_min = minlevel;
000040  f9bd0004          LDRSH    r0,[sp,#4]
000044  f8a401e8          STRH     r0,[r4,#0x1e8]
;;;703    		priv->txpower_max = maxlevel;
000048  f9bd0000          LDRSH    r0,[sp,#0]
00004c  f8a401ea          STRH     r0,[r4,#0x1ea]
                  |L12.80|
;;;704    	}
;;;705    
;;;706    	lbs_set_mac_control(priv);	  
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       lbs_set_mac_control
;;;707    done:
000056  bf00              NOP      
                  |L12.88|
;;;708    	lbs_deb_leave_args("leave lbs_setup_firmware(ret=%d)\n", ret);
;;;709    
;;;710    	return ret;
000058  4628              MOV      r0,r5
;;;711    }
00005a  bd3e              POP      {r1-r5,pc}
;;;712    
                          ENDP


                          AREA ||i.lbs_start_card||, CODE, READONLY, ALIGN=1

                  lbs_start_card PROC
;;;712    
;;;713    int lbs_start_card(struct lbs_private *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;714    {
000002  4605              MOV      r5,r0
;;;715    	int ret = -1;
000004  f04f34ff          MOV      r4,#0xffffffff
;;;716    	 lbs_deb_enter("enter lbs_start_card\n");
;;;717    	ret = lbs_setup_firmware(priv);//读取和设置相关的固件参数
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       lbs_setup_firmware
00000e  4604              MOV      r4,r0
;;;718    	if (ret)
000010  b104              CBZ      r4,|L13.20|
;;;719    		goto done;
000012  e006              B        |L13.34|
                  |L13.20|
;;;720    	lbs_init_11d(priv);//不是能802.11d
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       lbs_init_11d
;;;721    	lbs_update_channel(priv);//获取当前信道编号记录在priv->curbssparams.channel中
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       lbs_update_channel
;;;722    done:
000020  bf00              NOP      
                  |L13.34|
;;;723    	lbs_pr_info("Marvell WLAN 802.11 adapter\n");
;;;724    	lbs_deb_leave_args("leave lbs_start_card(ret=%d)\n", ret);
;;;725    
;;;726    	return ret;
000022  4620              MOV      r0,r4
;;;727    }
000024  bd70              POP      {r4-r6,pc}
;;;728    
                          ENDP


                          AREA ||i.lbs_thread||, CODE, READONLY, ALIGN=1

                  lbs_thread PROC
;;;423     */
;;;424     int lbs_thread(struct lbs_private *priv)//主线程，处理所有固件生成的envent、接收和发送数据以及执行网卡命令
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;425    {
000004  4604              MOV      r4,r0
;;;426    //	struct net_device *dev = data;
;;;427    //	struct lbs_private *priv = dev->ml_priv;
;;;428    	//wait_queue_t wait;
;;;429    	int shouldsleep;
;;;430    	u8 resp_idx;
;;;431    
;;;432    	//lbs_deb_enter(LBS_DEB_THREAD);
;;;433    
;;;434    	//init_waitqueue_entry(&wait, current);
;;;435    	do{
000006  bf00              NOP      
;;;436    		
;;;437    
;;;438    		/*lbs_deb_thread("1: currenttxskb %p, dnld_sent %d\n",
;;;439    				priv->currenttxskb, priv->dnld_sent);	 */
;;;440    
;;;441    		/*add_wait_queue(&priv->waitq, &wait);//将线程加入到等待队列，直到调用schedule()线程进入睡眠
;;;442    		set_current_state(TASK_INTERRUPTIBLE);
;;;443    		spin_lock_irq(&priv->driver_lock);
;;;444    
;;;445    		if (kthread_should_stop())//终止
;;;446    			shouldsleep = 0;	*/
;;;447    		if (priv->surpriseremoved)
000008  f89401ec          LDRB     r0,[r4,#0x1ec]
00000c  b108              CBZ      r0,|L14.18|
;;;448    			shouldsleep = 1;	/* We need to wait until we're _told_ to die */
00000e  2501              MOVS     r5,#1
000010  e02e              B        |L14.112|
                  |L14.18|
;;;449    		else if (priv->psstate == PS_STATE_SLEEP)
000012  f8d401f0          LDR      r0,[r4,#0x1f0]
000016  2803              CMP      r0,#3
000018  d101              BNE      |L14.30|
;;;450    			shouldsleep = 1;	/* Sleep mode. Nothing we can do till it wakes */
00001a  2501              MOVS     r5,#1
00001c  e028              B        |L14.112|
                  |L14.30|
;;;451    		else if (priv->cmd_timed_out)
00001e  f8d400ac          LDR      r0,[r4,#0xac]
000022  b108              CBZ      r0,|L14.40|
;;;452    			shouldsleep = 0;	/* Command timed out. Recover */
000024  2500              MOVS     r5,#0
000026  e023              B        |L14.112|
                  |L14.40|
;;;453    		else if (!priv->fw_ready)
000028  f8940494          LDRB     r0,[r4,#0x494]
00002c  b908              CBNZ     r0,|L14.50|
;;;454    			shouldsleep = 1;	/* Firmware not ready. We're waiting for it */
00002e  2501              MOVS     r5,#1
000030  e01e              B        |L14.112|
                  |L14.50|
;;;455    		else if (priv->dnld_sent)
000032  f24100b8          MOV      r0,#0x10b8
000036  5d00              LDRB     r0,[r0,r4]
000038  b108              CBZ      r0,|L14.62|
;;;456    			shouldsleep = 1;	/* Something is en route to the device already */
00003a  2501              MOVS     r5,#1
00003c  e018              B        |L14.112|
                  |L14.62|
;;;457    		//else if (priv->tx_pending_len > 0)//有数据需要发送
;;;458    		//	shouldsleep = 0;	/* We've a packet to send */
;;;459    		else if (priv->resp_len[priv->resp_idx])//响应，主要还是用于处理802.11管理
00003e  f8941495          LDRB     r1,[r4,#0x495]
000042  f5046093          ADD      r0,r4,#0x498
000046  f8500021          LDR      r0,[r0,r1,LSL #2]
00004a  b108              CBZ      r0,|L14.80|
;;;460    			shouldsleep = 0;	/* We have a command response */
00004c  2500              MOVS     r5,#0
00004e  e00f              B        |L14.112|
                  |L14.80|
;;;461    		else if (priv->cur_cmd)//当前还有命令在处理
000050  6fe0              LDR      r0,[r4,#0x7c]
000052  b108              CBZ      r0,|L14.88|
;;;462    			shouldsleep = 1;	/* Can't send a command; one already running */
000054  2501              MOVS     r5,#1
000056  e00b              B        |L14.112|
                  |L14.88|
;;;463    		else if (!list_empty(&priv->cmdpendingq))//命令挂起链表有命令链入，需要处理
000058  f104008c          ADD      r0,r4,#0x8c
00005c  6801              LDR      r1,[r0,#0]
00005e  4281              CMP      r1,r0
000060  d101              BNE      |L14.102|
000062  2101              MOVS     r1,#1
000064  e000              B        |L14.104|
                  |L14.102|
000066  2100              MOVS     r1,#0
                  |L14.104|
000068  b909              CBNZ     r1,|L14.110|
;;;464    			shouldsleep = 0;	/* We have a command to send */
00006a  2500              MOVS     r5,#0
00006c  e000              B        |L14.112|
                  |L14.110|
;;;465    		/*  else if (__kfifo_len(priv->event_fifo))
;;;466    			shouldsleep = 0;	*/ /* We have an event to process */
;;;467    		else
;;;468    			shouldsleep = 1;	/* No command */
00006e  2501              MOVS     r5,#1
                  |L14.112|
;;;469    
;;;470    		if (shouldsleep) {
000070  b105              CBZ      r5,|L14.116|
;;;471    			/*lbs_deb_thread("sleeping, connect_status %d, "
;;;472    				"psmode %d, psstate %d\n",
;;;473    				priv->connect_status,
;;;474    				priv->psmode, priv->psstate);*/
;;;475    			//spin_unlock_irq(&priv->driver_lock);
;;;476    			//schedule();
;;;477    			break;
000072  e076              B        |L14.354|
                  |L14.116|
;;;478    		} 
;;;479    		/*else
;;;480    			spin_unlock_irq(&priv->driver_lock);*/
;;;481    
;;;482    	/*	lbs_deb_thread("2: currenttxskb %p, dnld_send %d\n",
;;;483    			       priv->currenttxskb, priv->dnld_sent);*/
;;;484    
;;;485    		/*set_current_state(TASK_RUNNING);
;;;486    		remove_wait_queue(&priv->waitq, &wait);*/
;;;487    
;;;488    		/*lbs_deb_thread("3: currenttxskb %p, dnld_sent %d\n",
;;;489    			       priv->currenttxskb, priv->dnld_sent);
;;;490    
;;;491    		if (kthread_should_stop()) {
;;;492    			lbs_deb_thread("break from main thread\n");
;;;493    			break;
;;;494    		}*/
;;;495    
;;;496    		if (priv->surpriseremoved) {
000074  f89401ec          LDRB     r0,[r4,#0x1ec]
000078  b100              CBZ      r0,|L14.124|
;;;497    			lbs_deb_thread("adapter removed; waiting to die...\n");
;;;498    			continue;
00007a  e071              B        |L14.352|
                  |L14.124|
;;;499    		}
;;;500    
;;;501    		/*lbs_deb_thread("4: currenttxskb %p, dnld_sent %d\n",
;;;502    		       priv->currenttxskb, priv->dnld_sent);*/
;;;503    
;;;504    		/* Process any pending command response */
;;;505    		//spin_lock_irq(&priv->driver_lock);
;;;506    		resp_idx = priv->resp_idx;
00007c  f8946495          LDRB     r6,[r4,#0x495]
;;;507    		if (priv->resp_len[resp_idx]) {//处理网卡响应
000080  f5046093          ADD      r0,r4,#0x498
000084  f8500026          LDR      r0,[r0,r6,LSL #2]
000088  b180              CBZ      r0,|L14.172|
;;;508    		//	spin_unlock_irq(&priv->driver_lock);
;;;509    			lbs_process_command_response(priv,
00008a  f5046093          ADD      r0,r4,#0x498
00008e  f8502026          LDR      r2,[r0,r6,LSL #2]
000092  eb060346          ADD      r3,r6,r6,LSL #1
000096  1d00              ADDS     r0,r0,#4
000098  eb002183          ADD      r1,r0,r3,LSL #10
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       lbs_process_command_response
;;;510    				priv->resp_buf[resp_idx],
;;;511    				priv->resp_len[resp_idx]);
;;;512    			//spin_lock_irq(&priv->driver_lock);
;;;513    			priv->resp_len[resp_idx] = 0;//完成清0
0000a2  2100              MOVS     r1,#0
0000a4  f5046093          ADD      r0,r4,#0x498
0000a8  f8401026          STR      r1,[r0,r6,LSL #2]
                  |L14.172|
;;;514    		}
;;;515    		//spin_unlock_irq(&priv->driver_lock);
;;;516    
;;;517    		/* command timeout stuff */
;;;518    		if (priv->cmd_timed_out && priv->cur_cmd) {//命令超时
0000ac  f8d400ac          LDR      r0,[r4,#0xac]
0000b0  b320              CBZ      r0,|L14.252|
0000b2  6fe0              LDR      r0,[r4,#0x7c]
0000b4  b310              CBZ      r0,|L14.252|
;;;519    			struct cmd_ctrl_node *cmdnode = priv->cur_cmd;
0000b6  f8d4807c          LDR      r8,[r4,#0x7c]
;;;520    
;;;521    			if (++priv->nr_retries > 0) {
0000ba  f8d400a8          LDR      r0,[r4,#0xa8]
0000be  1c40              ADDS     r0,r0,#1
0000c0  f8c400a8          STR      r0,[r4,#0xa8]
0000c4  2800              CMP      r0,#0
0000c6  dd09              BLE      |L14.220|
;;;522    				lbs_pr_info("Excessive timeouts submitting "
;;;523    					"command 0x%04x\n",
;;;524    					le16_to_cpu(cmdnode->cmdbuf->command));
;;;525    				lbs_complete_command(priv, cmdnode, -ETIMEDOUT);//超过重试次数直接挂掉
0000c8  f06f023b          MVN      r2,#0x3b
0000cc  4641              MOV      r1,r8
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       lbs_complete_command
;;;526    				priv->nr_retries = 0;
0000d4  2000              MOVS     r0,#0
0000d6  f8c400a8          STR      r0,[r4,#0xa8]
0000da  e00e              B        |L14.250|
                  |L14.220|
;;;527    				/*if (priv->reset_card)
;;;528    					priv->reset_card(priv);*/
;;;529    			} else {
;;;530    				priv->cur_cmd = NULL;
0000dc  2000              MOVS     r0,#0
0000de  67e0              STR      r0,[r4,#0x7c]
;;;531    				priv->dnld_sent = DNLD_RES_RECEIVED;
0000e0  2100              MOVS     r1,#0
0000e2  f24100b8          MOV      r0,#0x10b8
0000e6  5501              STRB     r1,[r0,r4]
;;;532    				lbs_pr_info("requeueing command 0x%04x due "
;;;533    					"to timeout (#%d)\n",
;;;534    					le16_to_cpu(cmdnode->cmdbuf->command),
;;;535    					priv->nr_retries);
;;;536    
;;;537    				/* Stick it back at the _top_ of the pending queue
;;;538    				   for immediate resubmission */
;;;539    				list_add(&cmdnode->list, &priv->cmdpendingq);//重新链入处理
0000e8  f104078c          ADD      r7,r4,#0x8c
0000ec  4639              MOV      r1,r7
0000ee  4640              MOV      r0,r8
0000f0  683a              LDR      r2,[r7,#0]
0000f2  f7fffffe          BL       __list_add
0000f6  bf00              NOP      
0000f8  bf00              NOP      
                  |L14.250|
;;;540    			}
;;;541    		}
0000fa  bf00              NOP      
                  |L14.252|
;;;542    		priv->cmd_timed_out = 0;
0000fc  2000              MOVS     r0,#0
0000fe  f8c400ac          STR      r0,[r4,#0xac]
;;;543    
;;;544    		/* Process hardware events, e.g. card removed, link lost */
;;;545    		//spin_lock_irq(&priv->driver_lock);
;;;546    	 /*	while (__kfifo_len(priv->event_fifo)) {//之前提到的envent，包括掉线，热插拔等事件的处理
;;;547    				u32 event;
;;;548    			__kfifo_get(priv->event_fifo,(unsigned char *)&event,sizeof(event));
;;;549    			//spin_unlock_irq(&priv->driver_lock);
;;;550    			lbs_process_event(priv, event);//处理envent事件
;;;551    			//spin_lock_irq(&priv->driver_lock);
;;;552    		} */
;;;553    		//spin_unlock_irq(&priv->driver_lock);
;;;554    
;;;555    		if (!priv->fw_ready)
000102  f8940494          LDRB     r0,[r4,#0x494]
000106  b900              CBNZ     r0,|L14.266|
;;;556    			continue;
000108  e02a              B        |L14.352|
                  |L14.266|
;;;557    
;;;558    		/* Check if we need to confirm Sleep Request received previously */
;;;559    		if (priv->psstate == PS_STATE_PRE_SLEEP &&
00010a  f8d401f0          LDR      r0,[r4,#0x1f0]
00010e  2802              CMP      r0,#2
000110  d113              BNE      |L14.314|
;;;560    		    !priv->dnld_sent && !priv->cur_cmd) {
000112  f24100b8          MOV      r0,#0x10b8
000116  5d00              LDRB     r0,[r0,r4]
000118  b978              CBNZ     r0,|L14.314|
00011a  6fe0              LDR      r0,[r4,#0x7c]
00011c  b968              CBNZ     r0,|L14.314|
;;;561    			if (priv->connect_status == LBS_CONNECTED) {
00011e  f8d401dc          LDR      r0,[r4,#0x1dc]
000122  b938              CBNZ     r0,|L14.308|
;;;562    				/*lbs_deb_thread("pre-sleep, currenttxskb %p, "
;;;563    					"dnld_sent %d, cur_cmd %p\n",
;;;564    					priv->currenttxskb, priv->dnld_sent,
;;;565    					priv->cur_cmd);*/
;;;566    
;;;567    				//lbs_ps_confirm_sleep(priv);
;;;568    				lbs_pr_alert("ignore PS_SleepConfirm in "
;;;569    					"non-connected state\n");
;;;570    				while(1){
000124  e004              B        |L14.304|
                  |L14.294|
;;;571    					if(priv->psstate != PS_STATE_PRE_SLEEP)//bug
000126  f8d401f0          LDR      r0,[r4,#0x1f0]
00012a  2802              CMP      r0,#2
00012c  d000              BEQ      |L14.304|
;;;572    						break;
00012e  e000              B        |L14.306|
                  |L14.304|
000130  e7f9              B        |L14.294|
                  |L14.306|
000132  e002              B        |L14.314|
                  |L14.308|
;;;573    					}
;;;574    			} else {
;;;575    				/* workaround for firmware sending
;;;576    				 * deauth/linkloss event immediately
;;;577    				 * after sleep request; remove this
;;;578    				 * after firmware fixes it
;;;579    				 */
;;;580    				priv->psstate = PS_STATE_AWAKE;
000134  2001              MOVS     r0,#1
000136  f8c401f0          STR      r0,[r4,#0x1f0]
                  |L14.314|
;;;581    				lbs_pr_alert("ignore PS_SleepConfirm in "
;;;582    					"non-connected state\n");
;;;583    			}
;;;584    		}
;;;585    
;;;586    		/* The PS state is changed during processing of Sleep Request
;;;587    		 * event above
;;;588    		 */
;;;589    		if ((priv->psstate == PS_STATE_SLEEP) ||
00013a  f8d401f0          LDR      r0,[r4,#0x1f0]
00013e  2803              CMP      r0,#3
000140  d003              BEQ      |L14.330|
;;;590    		    (priv->psstate == PS_STATE_PRE_SLEEP))
000142  f8d401f0          LDR      r0,[r4,#0x1f0]
000146  2802              CMP      r0,#2
000148  d100              BNE      |L14.332|
                  |L14.330|
;;;591    			continue;
00014a  e009              B        |L14.352|
                  |L14.332|
;;;592    
;;;593    		/* Execute the next command */
;;;594    		if (!priv->dnld_sent && !priv->cur_cmd)//执行下一个命令
00014c  f24100b8          MOV      r0,#0x10b8
000150  5d00              LDRB     r0,[r0,r4]
000152  b920              CBNZ     r0,|L14.350|
000154  6fe0              LDR      r0,[r4,#0x7c]
000156  b910              CBNZ     r0,|L14.350|
;;;595    			lbs_execute_next_command(priv);//会调用硬件相关的函数将命令写入芯片
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       lbs_execute_next_command
                  |L14.350|
00015e  bf00              NOP                            ;498
                  |L14.352|
;;;596    
;;;597    		/* Wake-up command waiters which can't sleep in
;;;598    		 * lbs_prepare_and_send_command
;;;599    		 */
;;;600    		/*if (!list_empty(&priv->cmdpendingq))
;;;601    			wake_up_all(&priv->cmd_pending);*/
;;;602    
;;;603    #ifdef MASK_DEBUG
;;;604    
;;;605    		//spin_lock_irq(&priv->driver_lock);
;;;606    		if (!priv->dnld_sent && priv->tx_pending_len > 0) {//发送数据处理
;;;607    			//这里就是调用if_sdio_host_to_card这个函数来处理向设备发送数据	
;;;608    			int ret = priv->hw_host_to_card(priv, MVMS_DAT,
;;;609    							priv->tx_pending_buf,
;;;610    							priv->tx_pending_len);
;;;611    			if (ret) {
;;;612    				lbs_deb_tx("host_to_card failed %d\n", ret);
;;;613    				priv->dnld_sent = DNLD_RES_RECEIVED;
;;;614    			}
;;;615    			priv->tx_pending_len = 0;
;;;616    			/*if (!priv->currenttxskb) {
;;;617    				//We can wake the queues immediately if we aren't
;;;618    				 // waiting for TX feedback 
;;;619    				if (priv->connect_status == LBS_CONNECTED)
;;;620    					netif_wake_queue(priv->dev);
;;;621    				if (priv->mesh_dev &&
;;;622    				    priv->mesh_connect_status == LBS_CONNECTED)
;;;623    					netif_wake_queue(priv->mesh_dev);
;;;624    			}*/
;;;625    		}
;;;626    #endif
;;;627    		//spin_unlock_irq(&priv->driver_lock);
;;;628    	}while(0);
000160  bf00              NOP      
                  |L14.354|
000162  bf00              NOP                            ;477
;;;629    
;;;630    	//del_timer(&priv->command_timer);
;;;631    	//wake_up_all(&priv->cmd_pending);
;;;632    
;;;633    	//lbs_deb_leave("leave main thread!\n");
;;;634    
;;;635    	return 0;
000164  2000              MOVS     r0,#0
;;;636    }
000166  e8bd81f0          POP      {r4-r8,pc}
;;;637    
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L16.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L16.32|
                  |L16.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L16.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L16.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L16.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L16.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L16.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L16.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L16.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gnet_bss_desc
                          %        5952
                  gmarvell_priv
                          %        4456

                          AREA ||.data||, DATA, ALIGN=2

                  channel_freq_power_US_BG
000000  0001              DCW      0x0001
000002  0000              DCB      0x00,0x00
                          DCD      0x0000096c
000008  0014              DCW      0x0014
00000a  0000              DCB      0x00,0x00
00000c  0002              DCW      0x0002
00000e  0000              DCB      0x00,0x00
                          DCD      0x00000971
000014  0014              DCW      0x0014
000016  0000              DCB      0x00,0x00
000018  0003              DCW      0x0003
00001a  0000              DCB      0x00,0x00
                          DCD      0x00000976
000020  0014              DCW      0x0014
000022  0000              DCB      0x00,0x00
000024  0004              DCW      0x0004
000026  0000              DCB      0x00,0x00
                          DCD      0x0000097b
00002c  0014              DCW      0x0014
00002e  0000              DCB      0x00,0x00
000030  0005              DCW      0x0005
000032  0000              DCB      0x00,0x00
                          DCD      0x00000980
000038  0014              DCW      0x0014
00003a  0000              DCB      0x00,0x00
00003c  0006              DCW      0x0006
00003e  0000              DCB      0x00,0x00
                          DCD      0x00000985
000044  0014              DCW      0x0014
000046  0000              DCB      0x00,0x00
000048  0007              DCW      0x0007
00004a  0000              DCB      0x00,0x00
                          DCD      0x0000098a
000050  0014              DCW      0x0014
000052  0000              DCB      0x00,0x00
000054  0008              DCW      0x0008
000056  0000              DCB      0x00,0x00
                          DCD      0x0000098f
00005c  0014              DCW      0x0014
00005e  0000              DCB      0x00,0x00
000060  0009              DCW      0x0009
000062  0000              DCB      0x00,0x00
                          DCD      0x00000994
000068  0014              DCW      0x0014
00006a  0000              DCB      0x00,0x00
00006c  000a              DCW      0x000a
00006e  0000              DCB      0x00,0x00
                          DCD      0x00000999
000074  0014              DCW      0x0014
000076  0000              DCB      0x00,0x00
000078  000b              DCW      0x000b
00007a  0000              DCB      0x00,0x00
                          DCD      0x0000099e
000080  0014              DCW      0x0014
000082  0000              DCB      0x00,0x00
                  channel_freq_power_EU_BG
000084  0001              DCW      0x0001
000086  0000              DCB      0x00,0x00
                          DCD      0x0000096c
00008c  0014              DCW      0x0014
00008e  0000              DCB      0x00,0x00
000090  0002              DCW      0x0002
000092  0000              DCB      0x00,0x00
                          DCD      0x00000971
000098  0014              DCW      0x0014
00009a  0000              DCB      0x00,0x00
00009c  0003              DCW      0x0003
00009e  0000              DCB      0x00,0x00
                          DCD      0x00000976
0000a4  0014              DCW      0x0014
0000a6  0000              DCB      0x00,0x00
0000a8  0004              DCW      0x0004
0000aa  0000              DCB      0x00,0x00
                          DCD      0x0000097b
0000b0  0014              DCW      0x0014
0000b2  0000              DCB      0x00,0x00
0000b4  0005              DCW      0x0005
0000b6  0000              DCB      0x00,0x00
                          DCD      0x00000980
0000bc  0014              DCW      0x0014
0000be  0000              DCB      0x00,0x00
0000c0  0006              DCW      0x0006
0000c2  0000              DCB      0x00,0x00
                          DCD      0x00000985
0000c8  0014              DCW      0x0014
0000ca  0000              DCB      0x00,0x00
0000cc  0007              DCW      0x0007
0000ce  0000              DCB      0x00,0x00
                          DCD      0x0000098a
0000d4  0014              DCW      0x0014
0000d6  0000              DCB      0x00,0x00
0000d8  0008              DCW      0x0008
0000da  0000              DCB      0x00,0x00
                          DCD      0x0000098f
0000e0  0014              DCW      0x0014
0000e2  0000              DCB      0x00,0x00
0000e4  0009              DCW      0x0009
0000e6  0000              DCB      0x00,0x00
                          DCD      0x00000994
0000ec  0014              DCW      0x0014
0000ee  0000              DCB      0x00,0x00
0000f0  000a              DCW      0x000a
0000f2  0000              DCB      0x00,0x00
                          DCD      0x00000999
0000f8  0014              DCW      0x0014
0000fa  0000              DCB      0x00,0x00
0000fc  000b              DCW      0x000b
0000fe  0000              DCB      0x00,0x00
                          DCD      0x0000099e
000104  0014              DCW      0x0014
000106  0000              DCB      0x00,0x00
000108  000c              DCW      0x000c
00010a  0000              DCB      0x00,0x00
                          DCD      0x000009a3
000110  0014              DCW      0x0014
000112  0000              DCB      0x00,0x00
000114  000d              DCW      0x000d
000116  0000              DCB      0x00,0x00
                          DCD      0x000009a8
00011c  0014              DCW      0x0014
00011e  0000              DCB      0x00,0x00
                  channel_freq_power_SPN_BG
000120  000a              DCW      0x000a
000122  0000              DCB      0x00,0x00
                          DCD      0x00000999
000128  0014              DCW      0x0014
00012a  0000              DCB      0x00,0x00
00012c  000b              DCW      0x000b
00012e  0000              DCB      0x00,0x00
                          DCD      0x0000099e
000134  0014              DCW      0x0014
000136  0000              DCB      0x00,0x00
                  channel_freq_power_FR_BG
000138  000a              DCW      0x000a
00013a  0000              DCB      0x00,0x00
                          DCD      0x00000999
000140  0014              DCW      0x0014
000142  0000              DCB      0x00,0x00
000144  000b              DCW      0x000b
000146  0000              DCB      0x00,0x00
                          DCD      0x0000099e
00014c  0014              DCW      0x0014
00014e  0000              DCB      0x00,0x00
000150  000c              DCW      0x000c
000152  0000              DCB      0x00,0x00
                          DCD      0x000009a3
000158  0014              DCW      0x0014
00015a  0000              DCB      0x00,0x00
00015c  000d              DCW      0x000d
00015e  0000              DCB      0x00,0x00
                          DCD      0x000009a8
000164  0014              DCW      0x0014
000166  0000              DCB      0x00,0x00
                  channel_freq_power_JPN_BG
000168  0001              DCW      0x0001
00016a  0000              DCB      0x00,0x00
                          DCD      0x0000096c
000170  0010              DCW      0x0010
000172  0000              DCB      0x00,0x00
000174  0002              DCW      0x0002
000176  0000              DCB      0x00,0x00
                          DCD      0x00000971
00017c  0010              DCW      0x0010
00017e  0000              DCB      0x00,0x00
000180  0003              DCW      0x0003
000182  0000              DCB      0x00,0x00
                          DCD      0x00000976
000188  0010              DCW      0x0010
00018a  0000              DCB      0x00,0x00
00018c  0004              DCW      0x0004
00018e  0000              DCB      0x00,0x00
                          DCD      0x0000097b
000194  0010              DCW      0x0010
000196  0000              DCB      0x00,0x00
000198  0005              DCW      0x0005
00019a  0000              DCB      0x00,0x00
                          DCD      0x00000980
0001a0  0010              DCW      0x0010
0001a2  0000              DCB      0x00,0x00
0001a4  0006              DCW      0x0006
0001a6  0000              DCB      0x00,0x00
                          DCD      0x00000985
0001ac  0010              DCW      0x0010
0001ae  0000              DCB      0x00,0x00
0001b0  0007              DCW      0x0007
0001b2  0000              DCB      0x00,0x00
                          DCD      0x0000098a
0001b8  0010              DCW      0x0010
0001ba  0000              DCB      0x00,0x00
0001bc  0008              DCW      0x0008
0001be  0000              DCB      0x00,0x00
                          DCD      0x0000098f
0001c4  0010              DCW      0x0010
0001c6  0000              DCB      0x00,0x00
0001c8  0009              DCW      0x0009
0001ca  0000              DCB      0x00,0x00
                          DCD      0x00000994
0001d0  0010              DCW      0x0010
0001d2  0000              DCB      0x00,0x00
0001d4  000a              DCW      0x000a
0001d6  0000              DCB      0x00,0x00
                          DCD      0x00000999
0001dc  0010              DCW      0x0010
0001de  0000              DCB      0x00,0x00
0001e0  000b              DCW      0x000b
0001e2  0000              DCB      0x00,0x00
                          DCD      0x0000099e
0001e8  0010              DCW      0x0010
0001ea  0000              DCB      0x00,0x00
0001ec  000c              DCW      0x000c
0001ee  0000              DCB      0x00,0x00
                          DCD      0x000009a3
0001f4  0010              DCW      0x0010
0001f6  0000              DCB      0x00,0x00
0001f8  000d              DCW      0x000d
0001fa  0000              DCB      0x00,0x00
                          DCD      0x000009a8
000200  0010              DCW      0x0010
000202  0000              DCB      0x00,0x00
000204  000e              DCW      0x000e
000206  0000              DCB      0x00,0x00
                          DCD      0x000009b4
00020c  0010              DCW      0x0010
00020e  0000              DCB      0x00,0x00
                  region_cfp_table
000210  10000000          DCB      0x10,0x00,0x00,0x00
                          DCD      channel_freq_power_US_BG
                          DCD      0x0000000b
00021c  20000000          DCB      0x20,0x00,0x00,0x00
                          DCD      channel_freq_power_US_BG
                          DCD      0x0000000b
000228  30000000          DCB      0x30,0x00,0x00,0x00
                          DCD      channel_freq_power_EU_BG
                          DCD      0x0000000d
000234  31000000          DCB      0x31,0x00,0x00,0x00
                          DCD      channel_freq_power_SPN_BG
                          DCD      0x00000002
000240  32000000          DCB      0x32,0x00,0x00,0x00
                          DCD      channel_freq_power_FR_BG
                          DCD      0x00000004
00024c  40000000          DCB      0x40,0x00,0x00,0x00
                          DCD      channel_freq_power_JPN_BG
                          DCD      0x0000000e
                  lbs_region_code_to_index
000258  00100020          DCW      0x0010,0x0020
00025c  00300031          DCW      0x0030,0x0031
000260  00320040          DCW      0x0032,0x0040
                  lbs_bg_rates
000264  02040b16          DCB      0x02,0x04,0x0b,0x16
000268  0c121824          DCB      0x0c,0x12,0x18,0x24
00026c  3048606c          DCB      0x30,0x48,0x60,0x6c
000270  0000              DCB      0x00,0x00
                  fw_data_rates
000272  0204              DCB      0x02,0x04
000274  0b16000c          DCB      0x0b,0x16,0x00,0x0c
000278  12182430          DCB      0x12,0x18,0x24,0x30
00027c  48606c00          DCB      0x48,0x60,0x6c,0x00
