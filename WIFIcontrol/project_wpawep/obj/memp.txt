; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\memp.o --depend=.\obj\memp.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\memp.crf ..\lwIP\src\core\memp.c]
                          THUMB

                          AREA ||i.memp_free||, CODE, READONLY, ALIGN=2

                  memp_free PROC
;;;351    void
;;;352    memp_free(memp_t type, void *mem)
000000  b901              CBNZ     r1,|L1.4|
                  |L1.2|
;;;353    {
;;;354      struct memp *memp;
;;;355      SYS_ARCH_DECL_PROTECT(old_level);
;;;356    
;;;357      if (mem == NULL) {
;;;358        return;
;;;359      }
;;;360      LWIP_ASSERT("memp_free: mem properly aligned",
;;;361                    ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);
;;;362    
;;;363      memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
;;;364    
;;;365      SYS_ARCH_PROTECT(old_level);
;;;366    #if MEMP_OVERFLOW_CHECK
;;;367    #if MEMP_OVERFLOW_CHECK >= 2
;;;368      memp_overflow_check_all();
;;;369    #else
;;;370      memp_overflow_check_element(memp, memp_sizes[type]);
;;;371    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;372    #endif /* MEMP_OVERFLOW_CHECK */
;;;373    
;;;374      MEMP_STATS_DEC(used, type); 
;;;375      
;;;376      memp->next = memp_tab[type]; 
;;;377      memp_tab[type] = memp;
;;;378    
;;;379    #if MEMP_SANITY_CHECK
;;;380      LWIP_ASSERT("memp sanity", memp_sanity());
;;;381    #endif /* MEMP_SANITY_CHECK */
;;;382    
;;;383      SYS_ARCH_UNPROTECT(old_level);
;;;384    }
000002  4770              BX       lr
                  |L1.4|
000004  460a              MOV      r2,r1                 ;363
000006  4b04              LDR      r3,|L1.24|
000008  f8533020          LDR      r3,[r3,r0,LSL #2]     ;376
00000c  6013              STR      r3,[r2,#0]            ;376
00000e  4b02              LDR      r3,|L1.24|
000010  f8432020          STR      r2,[r3,r0,LSL #2]     ;377
000014  bf00              NOP      
000016  e7f4              B        |L1.2|
;;;385    
                          ENDP

                  |L1.24|
                          DCD      memp_tab

                          AREA ||i.memp_init||, CODE, READONLY, ALIGN=2

                  memp_init PROC
;;;259    void
;;;260    memp_init(void)
000000  b510              PUSH     {r4,lr}
;;;261    {
;;;262      struct memp *memp;
;;;263      u16_t i, j;
;;;264    
;;;265      for (i = 0; i < MEMP_MAX; ++i) {
000002  2000              MOVS     r0,#0
000004  e001              B        |L2.10|
                  |L2.6|
000006  1c43              ADDS     r3,r0,#1
000008  b298              UXTH     r0,r3
                  |L2.10|
00000a  2809              CMP      r0,#9
00000c  dbfb              BLT      |L2.6|
;;;266        MEMP_STATS_AVAIL(used, i, 0);
;;;267        MEMP_STATS_AVAIL(max, i, 0);
;;;268        MEMP_STATS_AVAIL(err, i, 0);
;;;269        MEMP_STATS_AVAIL(avail, i, memp_num[i]);
;;;270      }
;;;271    
;;;272      memp = LWIP_MEM_ALIGN(memp_memory);
00000e  4b11              LDR      r3,|L2.84|
000010  f0230103          BIC      r1,r3,#3
;;;273      /* for every pool: */
;;;274      for (i = 0; i < MEMP_MAX; ++i) {
000014  2000              MOVS     r0,#0
000016  e019              B        |L2.76|
                  |L2.24|
;;;275        memp_tab[i] = NULL;
000018  2300              MOVS     r3,#0
00001a  4c0f              LDR      r4,|L2.88|
00001c  f8443020          STR      r3,[r4,r0,LSL #2]
;;;276        /* create a linked list of memp elements */
;;;277        for (j = 0; j < memp_num[i]; ++j) {
000020  2200              MOVS     r2,#0
000022  e00c              B        |L2.62|
                  |L2.36|
;;;278          memp->next = memp_tab[i];
000024  4b0c              LDR      r3,|L2.88|
000026  f8533020          LDR      r3,[r3,r0,LSL #2]
00002a  600b              STR      r3,[r1,#0]
;;;279          memp_tab[i] = memp;
00002c  4b0a              LDR      r3,|L2.88|
00002e  f8431020          STR      r1,[r3,r0,LSL #2]
;;;280          memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
000032  4b0a              LDR      r3,|L2.92|
000034  f8333010          LDRH     r3,[r3,r0,LSL #1]
000038  4419              ADD      r1,r1,r3
00003a  1c53              ADDS     r3,r2,#1              ;277
00003c  b29a              UXTH     r2,r3                 ;277
                  |L2.62|
00003e  4b08              LDR      r3,|L2.96|
000040  f8333010          LDRH     r3,[r3,r0,LSL #1]     ;277
000044  4293              CMP      r3,r2                 ;277
000046  dced              BGT      |L2.36|
000048  1c43              ADDS     r3,r0,#1              ;274
00004a  b298              UXTH     r0,r3                 ;274
                  |L2.76|
00004c  2809              CMP      r0,#9                 ;274
00004e  dbe3              BLT      |L2.24|
;;;281    #if MEMP_OVERFLOW_CHECK
;;;282            + MEMP_SANITY_REGION_AFTER_ALIGNED
;;;283    #endif
;;;284          );
;;;285        }
;;;286      }
;;;287    #if MEMP_OVERFLOW_CHECK
;;;288      memp_overflow_init();
;;;289      /* check everything a first time to see if it worked */
;;;290      memp_overflow_check_all();
;;;291    #endif /* MEMP_OVERFLOW_CHECK */
;;;292    }
000050  bd10              POP      {r4,pc}
;;;293    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      memp_memory+0x3
                  |L2.88|
                          DCD      memp_tab
                  |L2.92|
                          DCD      memp_sizes
                  |L2.96|
                          DCD      memp_num

                          AREA ||i.memp_malloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  memp_malloc PROC
;;;306    #if !MEMP_OVERFLOW_CHECK
;;;307    memp_malloc(memp_t type)
000000  b570              PUSH     {r4-r6,lr}
;;;308    #else
;;;309    memp_malloc_fn(memp_t type, const char* file, const int line)
;;;310    #endif
;;;311    {
000002  4605              MOV      r5,r0
;;;312      struct memp *memp;
;;;313      SYS_ARCH_DECL_PROTECT(old_level);
;;;314     
;;;315      LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
000004  bf00              NOP      
000006  2d09              CMP      r5,#9
000008  db0a              BLT      |L3.32|
00000a  bf00              NOP      
00000c  a30b              ADR      r3,|L3.60|
00000e  f240123b          MOV      r2,#0x13b
000012  a110              ADR      r1,|L3.84|
000014  a017              ADR      r0,|L3.116|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
00001c  2000              MOVS     r0,#0
                  |L3.30|
;;;316    
;;;317      SYS_ARCH_PROTECT(old_level);
;;;318    #if MEMP_OVERFLOW_CHECK >= 2
;;;319      memp_overflow_check_all();
;;;320    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;321    
;;;322      memp = memp_tab[type];
;;;323      
;;;324      if (memp != NULL) {
;;;325        memp_tab[type] = memp->next;
;;;326    #if MEMP_OVERFLOW_CHECK
;;;327        memp->next = NULL;
;;;328        memp->file = file;
;;;329        memp->line = line;
;;;330    #endif /* MEMP_OVERFLOW_CHECK */
;;;331        MEMP_STATS_INC_USED(used, type);
;;;332        LWIP_ASSERT("memp_malloc: memp properly aligned",
;;;333                    ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
;;;334        memp = (struct memp*)((u8_t*)memp + MEMP_SIZE);
;;;335      } else {
;;;336        LWIP_DEBUGF(MEMP_DEBUG | 2, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
;;;337        MEMP_STATS_INC(err, type);
;;;338      }
;;;339    
;;;340      SYS_ARCH_UNPROTECT(old_level);
;;;341    
;;;342      return memp;
;;;343    }
00001e  bd70              POP      {r4-r6,pc}
                  |L3.32|
000020  bf00              NOP                            ;315
000022  481e              LDR      r0,|L3.156|
000024  f8504025          LDR      r4,[r0,r5,LSL #2]     ;322
000028  b124              CBZ      r4,|L3.52|
00002a  491c              LDR      r1,|L3.156|
00002c  6820              LDR      r0,[r4,#0]            ;325
00002e  f8410025          STR      r0,[r1,r5,LSL #2]     ;325
000032  e001              B        |L3.56|
                  |L3.52|
000034  bf00              NOP                            ;336
000036  bf00              NOP                            ;336
                  |L3.56|
000038  4620              MOV      r0,r4                 ;342
00003a  e7f0              B        |L3.30|
;;;344    
                          ENDP

                  |L3.60|
00003c  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\memp.c",0
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c6d656d
000050  702e6300
                  |L3.84|
000054  6d656d70          DCB      "memp_malloc: type < MEMP_MAX",0
000058  5f6d616c
00005c  6c6f633a
000060  20747970
000064  65203c20
000068  4d454d50
00006c  5f4d4158
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L3.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730a00
                  |L3.156|
                          DCD      memp_tab

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  memp_tab
                          %        36
                  memp_memory
                          %        10763

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  memp_sizes
000000  001c0020          DCW      0x001c,0x0020
000004  00a00024          DCW      0x00a0,0x0024
000008  00140020          DCW      0x0014,0x0020
00000c  00080010          DCW      0x0008,0x0010
000010  0620              DCW      0x0620
                  memp_num
000012  0004              DCW      0x0004
000014  0006000a          DCW      0x0006,0x000a
000018  0006000c          DCW      0x0006,0x000c
00001c  0005001e          DCW      0x0005,0x001e
000020  000a0005          DCW      0x000a,0x0005

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  5241575f          DCB      "RAW_PCB",0
000004  50434200
000008  5544505f          DCB      "UDP_PCB",0
00000c  50434200
000010  5443505f          DCB      "TCP_PCB",0
000014  50434200
000018  5443505f          DCB      "TCP_PCB_LISTEN",0
00001c  5043425f
000020  4c495354
000024  454e00  
000027  5443505f          DCB      "TCP_SEG",0
00002b  53454700
00002f  52454153          DCB      "REASSDATA",0
000033  53444154
000037  4100    
000039  4152505f          DCB      "ARP_QUEUE",0
00003d  51554555
000041  4500    
000043  50425546          DCB      "PBUF_REF/ROM",0
000047  5f524546
00004b  2f524f4d
00004f  00      
000050  50425546          DCB      "PBUF_POOL",0
000054  5f504f4f
000058  4c00    

                          AREA ||.data||, DATA, ALIGN=2

                  memp_desc
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x18
                          DCD      ||.conststring||+0x27
                          DCD      ||.conststring||+0x2f
                          DCD      ||.conststring||+0x39
                          DCD      ||.conststring||+0x43
                          DCD      ||.conststring||+0x50
