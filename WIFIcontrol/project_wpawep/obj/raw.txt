; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\raw.o --depend=.\obj\raw.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\raw.crf ..\lwIP\src\core\raw.c]
                          THUMB

                          AREA ||i.raw_bind||, CODE, READONLY, ALIGN=1

                  raw_bind PROC
;;;141    err_t
;;;142    raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
000000  4602              MOV      r2,r0
;;;143    {
;;;144      ip_addr_set(&pcb->local_ip, ipaddr);
000002  b909              CBNZ     r1,|L1.8|
000004  2000              MOVS     r0,#0
000006  e000              B        |L1.10|
                  |L1.8|
000008  6808              LDR      r0,[r1,#0]
                  |L1.10|
00000a  6010              STR      r0,[r2,#0]
;;;145      return ERR_OK;
00000c  2000              MOVS     r0,#0
;;;146    }
00000e  4770              BX       lr
;;;147    
                          ENDP


                          AREA ||i.raw_connect||, CODE, READONLY, ALIGN=1

                  raw_connect PROC
;;;161    err_t
;;;162    raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
000000  4602              MOV      r2,r0
;;;163    {
;;;164      ip_addr_set(&pcb->remote_ip, ipaddr);
000002  b909              CBNZ     r1,|L2.8|
000004  2000              MOVS     r0,#0
000006  e000              B        |L2.10|
                  |L2.8|
000008  6808              LDR      r0,[r1,#0]
                  |L2.10|
00000a  6050              STR      r0,[r2,#4]
;;;165      return ERR_OK;
00000c  2000              MOVS     r0,#0
;;;166    }
00000e  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.raw_input||, CODE, READONLY, ALIGN=2

                  raw_input PROC
;;;77     u8_t
;;;78     raw_input(struct pbuf *p, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;79     {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
;;;80       struct raw_pcb *pcb, *prev;
;;;81       struct ip_hdr *iphdr;
;;;82       s16_t proto;
;;;83       u8_t eaten = 0;
000008  f04f0800          MOV      r8,#0
;;;84     
;;;85       LWIP_UNUSED_ARG(inp);
;;;86     
;;;87       iphdr = p->payload;
00000c  686f              LDR      r7,[r5,#4]
;;;88       proto = IPH_PROTO(iphdr);
00000e  8938              LDRH     r0,[r7,#8]
000010  f7fffffe          BL       ntohs
000014  f00009ff          AND      r9,r0,#0xff
;;;89     
;;;90       prev = NULL;
000018  2600              MOVS     r6,#0
;;;91       pcb = raw_pcbs;
00001a  4812              LDR      r0,|L3.100|
00001c  6804              LDR      r4,[r0,#0]  ; raw_pcbs
;;;92       /* loop through all raw pcbs until the packet is eaten by one */
;;;93       /* this allows multiple pcbs to match against the packet by design */
;;;94       while ((eaten == 0) && (pcb != NULL)) {
00001e  e019              B        |L3.84|
                  |L3.32|
;;;95         if (pcb->protocol == proto) {
000020  7c20              LDRB     r0,[r4,#0x10]
000022  4548              CMP      r0,r9
000024  d114              BNE      |L3.80|
;;;96     #if IP_SOF_BROADCAST_RECV
;;;97           /* broadcast filter? */
;;;98           if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
;;;99     #endif /* IP_SOF_BROADCAST_RECV */
;;;100          {
;;;101            /* receive callback function available? */
;;;102            if (pcb->recv != NULL) {
000026  6960              LDR      r0,[r4,#0x14]
000028  b190              CBZ      r0,|L3.80|
;;;103              /* the receive callback function did not eat the packet? */
;;;104              if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
00002a  f107030c          ADD      r3,r7,#0xc
00002e  462a              MOV      r2,r5
000030  4621              MOV      r1,r4
000032  e9d4c005          LDRD     r12,r0,[r4,#0x14]
000036  47e0              BLX      r12
000038  b150              CBZ      r0,|L3.80|
;;;105                /* receive function ate the packet */
;;;106                p = NULL;
00003a  2500              MOVS     r5,#0
;;;107                eaten = 1;
00003c  f04f0801          MOV      r8,#1
;;;108                if (prev != NULL) {
000040  b136              CBZ      r6,|L3.80|
;;;109                /* move the pcb to the front of raw_pcbs so that is
;;;110                   found faster next time */
;;;111                  prev->next = pcb->next;
000042  68e0              LDR      r0,[r4,#0xc]
000044  60f0              STR      r0,[r6,#0xc]
;;;112                  pcb->next = raw_pcbs;
000046  4807              LDR      r0,|L3.100|
000048  6800              LDR      r0,[r0,#0]  ; raw_pcbs
00004a  60e0              STR      r0,[r4,#0xc]
;;;113                  raw_pcbs = pcb;
00004c  4805              LDR      r0,|L3.100|
00004e  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L3.80|
;;;114                }
;;;115              }
;;;116            }
;;;117            /* no receive callback function was set for this raw PCB */
;;;118          }
;;;119          /* drop the packet */
;;;120        }
;;;121        prev = pcb;
000050  4626              MOV      r6,r4
;;;122        pcb = pcb->next;
000052  68e4              LDR      r4,[r4,#0xc]
                  |L3.84|
000054  f1b80f00          CMP      r8,#0                 ;94
000058  d101              BNE      |L3.94|
00005a  2c00              CMP      r4,#0                 ;94
00005c  d1e0              BNE      |L3.32|
                  |L3.94|
;;;123      }
;;;124      return eaten;
00005e  4640              MOV      r0,r8
;;;125    }
000060  e8bd87f0          POP      {r4-r10,pc}
;;;126    
                          ENDP

                  |L3.100|
                          DCD      raw_pcbs

                          AREA ||i.raw_new||, CODE, READONLY, ALIGN=2

                  raw_new PROC
;;;334    struct raw_pcb *
;;;335    raw_new(u8_t proto) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;336      struct raw_pcb *pcb;
;;;337    
;;;338      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));
000004  bf00              NOP      
000006  bf00              NOP      
;;;339    
;;;340      pcb = memp_malloc(MEMP_RAW_PCB);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       memp_malloc
00000e  4604              MOV      r4,r0
;;;341      /* could allocate RAW PCB? */
;;;342      if (pcb != NULL) {
000010  b15c              CBZ      r4,|L4.42|
;;;343        /* initialize PCB to all zeroes */
;;;344        memset(pcb, 0, sizeof(struct raw_pcb));
000012  211c              MOVS     r1,#0x1c
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       __aeabi_memclr4
;;;345        pcb->protocol = proto;
00001a  7425              STRB     r5,[r4,#0x10]
;;;346        pcb->ttl = RAW_TTL;
00001c  20ff              MOVS     r0,#0xff
00001e  72e0              STRB     r0,[r4,#0xb]
;;;347        pcb->next = raw_pcbs;
000020  4803              LDR      r0,|L4.48|
000022  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000024  60e0              STR      r0,[r4,#0xc]
;;;348        raw_pcbs = pcb;
000026  4802              LDR      r0,|L4.48|
000028  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L4.42|
;;;349      }
;;;350      return pcb;
00002a  4620              MOV      r0,r4
;;;351    }
00002c  bd70              POP      {r4-r6,pc}
;;;352    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      raw_pcbs

                          AREA ||i.raw_recv||, CODE, READONLY, ALIGN=1

                  raw_recv PROC
;;;182    void
;;;183    raw_recv(struct raw_pcb *pcb,
000000  6141              STR      r1,[r0,#0x14]
;;;184             u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
;;;185                          struct ip_addr *addr),
;;;186             void *recv_arg)
;;;187    {
;;;188      /* remember recv() callback and user data */
;;;189      pcb->recv = recv;
;;;190      pcb->recv_arg = recv_arg;
000002  6182              STR      r2,[r0,#0x18]
;;;191    }
000004  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i.raw_remove||, CODE, READONLY, ALIGN=2

                  raw_remove PROC
;;;303    void
;;;304    raw_remove(struct raw_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;305    {
000002  4605              MOV      r5,r0
;;;306      struct raw_pcb *pcb2;
;;;307      /* pcb to be removed is first in list? */
;;;308      if (raw_pcbs == pcb) {
000004  480d              LDR      r0,|L6.60|
000006  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000008  42a8              CMP      r0,r5
00000a  d105              BNE      |L6.24|
;;;309        /* make list start at 2nd pcb */
;;;310        raw_pcbs = raw_pcbs->next;
00000c  480b              LDR      r0,|L6.60|
00000e  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000010  68c0              LDR      r0,[r0,#0xc]
000012  490a              LDR      r1,|L6.60|
000014  6008              STR      r0,[r1,#0]  ; raw_pcbs
000016  e00c              B        |L6.50|
                  |L6.24|
;;;311        /* pcb not 1st in list */
;;;312      } else {
;;;313        for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
000018  4808              LDR      r0,|L6.60|
00001a  6804              LDR      r4,[r0,#0]  ; raw_pcbs
00001c  e007              B        |L6.46|
                  |L6.30|
;;;314          /* find pcb in raw_pcbs list */
;;;315          if (pcb2->next != NULL && pcb2->next == pcb) {
00001e  68e0              LDR      r0,[r4,#0xc]
000020  b120              CBZ      r0,|L6.44|
000022  68e0              LDR      r0,[r4,#0xc]
000024  42a8              CMP      r0,r5
000026  d101              BNE      |L6.44|
;;;316            /* remove pcb from list */
;;;317            pcb2->next = pcb->next;
000028  68e8              LDR      r0,[r5,#0xc]
00002a  60e0              STR      r0,[r4,#0xc]
                  |L6.44|
00002c  68e4              LDR      r4,[r4,#0xc]          ;313
                  |L6.46|
00002e  2c00              CMP      r4,#0                 ;313
000030  d1f5              BNE      |L6.30|
                  |L6.50|
;;;318          }
;;;319        }
;;;320      }
;;;321      memp_free(MEMP_RAW_PCB, pcb);
000032  4629              MOV      r1,r5
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       memp_free
;;;322    }
00003a  bd70              POP      {r4-r6,pc}
;;;323    
                          ENDP

                  |L6.60|
                          DCD      raw_pcbs

                          AREA ||i.raw_send||, CODE, READONLY, ALIGN=1

                  raw_send PROC
;;;289    err_t
;;;290    raw_send(struct raw_pcb *pcb, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;292      return raw_sendto(pcb, p, &pcb->remote_ip);
000006  1d22              ADDS     r2,r4,#4
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       raw_sendto
;;;293    }
000010  bd70              POP      {r4-r6,pc}
;;;294    
                          ENDP


                          AREA ||i.raw_sendto||, CODE, READONLY, ALIGN=1

                  raw_sendto PROC
;;;205    err_t
;;;206    raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;207    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
;;;208      err_t err;
;;;209      struct netif *netif;
;;;210      struct ip_addr *src_ip;
;;;211      struct pbuf *q; /* q will be sent down the stack */
;;;212      
;;;213      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;214      
;;;215      /* not enough space to add an IP header to first pbuf in given p chain? */
;;;216      if (pbuf_header(p, IP_HLEN)) {
00000e  2114              MOVS     r1,#0x14
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       pbuf_header
000016  b190              CBZ      r0,|L8.62|
;;;217        /* allocate header in new pbuf */
;;;218        q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       pbuf_alloc
000022  4605              MOV      r5,r0
;;;219        /* new header pbuf could not be allocated? */
;;;220        if (q == NULL) {
000024  b92d              CBNZ     r5,|L8.50|
;;;221          LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
000026  bf00              NOP      
000028  bf00              NOP      
;;;222          return ERR_MEM;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L8.46|
;;;223        }
;;;224        /* chain header q in front of given pbuf p */
;;;225        pbuf_chain(q, p);
;;;226        /* { first pbuf q points to header pbuf } */
;;;227        LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;228      }  else {
;;;229        /* first pbuf q equals given pbuf */
;;;230        q = p;
;;;231        if(pbuf_header(q, -IP_HLEN)) {
;;;232          LWIP_ASSERT("Can't restore header we just removed!", 0);
;;;233          return ERR_MEM;
;;;234        }
;;;235      }
;;;236    
;;;237      if ((netif = ip_route(ipaddr)) == NULL) {
;;;238        LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
;;;239        /* free any temporary header pbuf allocated by pbuf_header() */
;;;240        if (q != p) {
;;;241          pbuf_free(q);
;;;242        }
;;;243        return ERR_RTE;
;;;244      }
;;;245    
;;;246    #if IP_SOF_BROADCAST
;;;247      /* broadcast filter? */
;;;248      if ( ((pcb->so_options & SOF_BROADCAST) == 0) && ip_addr_isbroadcast(ipaddr, netif) ) {
;;;249        LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;250        /* free any temporary header pbuf allocated by pbuf_header() */
;;;251        if (q != p) {
;;;252          pbuf_free(q);
;;;253        }
;;;254        return ERR_VAL;
;;;255      }
;;;256    #endif /* IP_SOF_BROADCAST */
;;;257    
;;;258      if (ip_addr_isany(&pcb->local_ip)) {
;;;259        /* use outgoing network interface IP address as source address */
;;;260        src_ip = &(netif->ip_addr);
;;;261      } else {
;;;262        /* use RAW PCB local IP address as source address */
;;;263        src_ip = &(pcb->local_ip);
;;;264      }
;;;265    
;;;266    #if LWIP_NETIF_HWADDRHINT
;;;267      netif->addr_hint = &(pcb->addr_hint);
;;;268    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;269      err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
;;;270    #if LWIP_NETIF_HWADDRHINT
;;;271      netif->addr_hint = NULL;
;;;272    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;273    
;;;274      /* did we chain a header earlier? */
;;;275      if (q != p) {
;;;276        /* free the header */
;;;277        pbuf_free(q);
;;;278      }
;;;279      return err;
;;;280    }
00002e  e8bd8ffe          POP      {r1-r11,pc}
                  |L8.50|
000032  4631              MOV      r1,r6                 ;225
000034  4628              MOV      r0,r5                 ;225
000036  f7fffffe          BL       pbuf_chain
00003a  bf00              NOP                            ;227
00003c  e009              B        |L8.82|
                  |L8.62|
00003e  4635              MOV      r5,r6                 ;230
000040  f06f0113          MVN      r1,#0x13              ;231
000044  4628              MOV      r0,r5                 ;231
000046  f7fffffe          BL       pbuf_header
00004a  b110              CBZ      r0,|L8.82|
00004c  f04f30ff          MOV      r0,#0xffffffff        ;233
000050  e7ed              B        |L8.46|
                  |L8.82|
000052  4648              MOV      r0,r9                 ;237
000054  f7fffffe          BL       ip_route
000058  0007              MOVS     r7,r0                 ;237
00005a  d109              BNE      |L8.112|
00005c  bf00              NOP                            ;238
00005e  bf00              NOP                            ;238
000060  42b5              CMP      r5,r6                 ;240
000062  d002              BEQ      |L8.106|
000064  4628              MOV      r0,r5                 ;241
000066  f7fffffe          BL       pbuf_free
                  |L8.106|
00006a  f06f0003          MVN      r0,#3                 ;243
00006e  e7de              B        |L8.46|
                  |L8.112|
000070  b10c              CBZ      r4,|L8.118|
000072  6820              LDR      r0,[r4,#0]            ;258
000074  b910              CBNZ     r0,|L8.124|
                  |L8.118|
000076  f1070804          ADD      r8,r7,#4              ;260
00007a  e000              B        |L8.126|
                  |L8.124|
00007c  46a0              MOV      r8,r4                 ;263
                  |L8.126|
00007e  7c22              LDRB     r2,[r4,#0x10]         ;269
000080  7aa1              LDRB     r1,[r4,#0xa]          ;269
000082  e88d0086          STM      sp,{r1,r2,r7}         ;269
000086  7ae3              LDRB     r3,[r4,#0xb]          ;269
000088  464a              MOV      r2,r9                 ;269
00008a  4641              MOV      r1,r8                 ;269
00008c  4628              MOV      r0,r5                 ;269
00008e  f7fffffe          BL       ip_output_if
000092  4682              MOV      r10,r0                ;269
000094  42b5              CMP      r5,r6                 ;275
000096  d002              BEQ      |L8.158|
000098  4628              MOV      r0,r5                 ;277
00009a  f7fffffe          BL       pbuf_free
                  |L8.158|
00009e  4650              MOV      r0,r10                ;279
0000a0  e7c5              B        |L8.46|
;;;281    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  raw_pcbs
                          DCD      0x00000000
