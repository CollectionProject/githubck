; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\mem.o --depend=.\obj\mem.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\mem.crf ..\lwIP\src\core\mem.c]
                          THUMB

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=1

                  mem_calloc PROC
;;;627     */
;;;628    void *mem_calloc(mem_size_t count, mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;629    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;630      void *p;
;;;631    
;;;632      /* allocate 'count' objects of size 'size' */
;;;633      p = mem_malloc(count * size);
000006  fb04f105          MUL      r1,r4,r5
00000a  b288              UXTH     r0,r1
00000c  f7fffffe          BL       mem_malloc
000010  4606              MOV      r6,r0
;;;634      if (p) {
000012  b126              CBZ      r6,|L1.30|
;;;635        /* zero the memory */
;;;636        memset(p, 0, count * size);
000014  fb04f105          MUL      r1,r4,r5
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       __aeabi_memclr
                  |L1.30|
;;;637      }
;;;638      return p;
00001e  4630              MOV      r0,r6
;;;639    }
000020  bd70              POP      {r4-r6,pc}
;;;640    
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                  mem_free PROC
;;;304    void
;;;305    mem_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;306    {
000002  4604              MOV      r4,r0
;;;307      struct mem *mem;
;;;308      LWIP_MEM_FREE_DECL_PROTECT();
;;;309    
;;;310      if (rmem == NULL) {
000004  b914              CBNZ     r4,|L2.12|
;;;311        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
000006  bf00              NOP      
000008  bf00              NOP      
                  |L2.10|
;;;312        return;
;;;313      }
;;;314      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;315    
;;;316      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;317        (u8_t *)rmem < (u8_t *)ram_end);
;;;318    
;;;319      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;320        SYS_ARCH_DECL_PROTECT(lev);
;;;321        LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
;;;322        /* protect mem stats from concurrent access */
;;;323        SYS_ARCH_PROTECT(lev);
;;;324        MEM_STATS_INC(illegal);
;;;325        SYS_ARCH_UNPROTECT(lev);
;;;326        return;
;;;327      }
;;;328      /* protect the heap from concurrent access */
;;;329      LWIP_MEM_FREE_PROTECT();
;;;330      /* Get the corresponding struct mem ... */
;;;331      mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;332      /* ... which has to be in a used state ... */
;;;333      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;334      /* ... and is now unused. */
;;;335      mem->used = 0;
;;;336    
;;;337      if (mem < lfree) {
;;;338        /* the newly freed struct is now the lowest */
;;;339        lfree = mem;
;;;340      }
;;;341    
;;;342      MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));
;;;343    
;;;344      /* finally, see if prev or next are free also */
;;;345      plug_holes(mem);
;;;346    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;347      mem_free_count = 1;
;;;348    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;349      LWIP_MEM_FREE_UNPROTECT();
;;;350    }
00000a  bd70              POP      {r4-r6,pc}
                  |L2.12|
00000c  480c              LDR      r0,|L2.64|
00000e  6800              LDR      r0,[r0,#0]            ;319  ; ram
000010  4284              CMP      r4,r0                 ;319
000012  d303              BCC      |L2.28|
000014  480b              LDR      r0,|L2.68|
000016  6800              LDR      r0,[r0,#0]            ;319  ; ram_end
000018  4284              CMP      r4,r0                 ;319
00001a  d302              BCC      |L2.34|
                  |L2.28|
00001c  bf00              NOP                            ;321
00001e  bf00              NOP                            ;321
000020  e7f3              B        |L2.10|
                  |L2.34|
000022  f1a40508          SUB      r5,r4,#8              ;331
000026  2000              MOVS     r0,#0                 ;335
000028  7128              STRB     r0,[r5,#4]            ;335
00002a  4807              LDR      r0,|L2.72|
00002c  6800              LDR      r0,[r0,#0]            ;337  ; lfree
00002e  4285              CMP      r5,r0                 ;337
000030  d201              BCS      |L2.54|
000032  4805              LDR      r0,|L2.72|
000034  6005              STR      r5,[r0,#0]            ;339  ; lfree
                  |L2.54|
000036  4628              MOV      r0,r5                 ;345
000038  f7fffffe          BL       plug_holes
00003c  bf00              NOP      
00003e  e7e4              B        |L2.10|
;;;351    
                          ENDP

                  |L2.64|
                          DCD      ||ram||
                  |L2.68|
                          DCD      ram_end
                  |L2.72|
                          DCD      lfree

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;267    void
;;;268    mem_init(void)
000000  f44f717a          MOV      r1,#0x3e8
;;;269    {
;;;270      struct mem *mem;
;;;271      RAM_DUG;
000004  4a13              LDR      r2,|L3.84|
000006  6011              STR      r1,[r2,#0]  ; wpa_debug_level
;;;272    
;;;273      LWIP_ASSERT("Sanity check alignment",
;;;274        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;275    
;;;276      /* align the heap */
;;;277      ram = LWIP_MEM_ALIGN(ram_heap);
000008  4913              LDR      r1,|L3.88|
00000a  f0210103          BIC      r1,r1,#3
00000e  4a13              LDR      r2,|L3.92|
000010  6011              STR      r1,[r2,#0]  ; ram
;;;278      /* initialize the start of the heap */
;;;279      mem = (struct mem *)ram;
000012  4611              MOV      r1,r2
000014  6808              LDR      r0,[r1,#0]  ; ram
;;;280      mem->next = MEM_SIZE_ALIGNED;
000016  f44f5180          MOV      r1,#0x1000
00001a  8001              STRH     r1,[r0,#0]
;;;281      mem->prev = 0;
00001c  2100              MOVS     r1,#0
00001e  8041              STRH     r1,[r0,#2]
;;;282      mem->used = 0;
000020  7101              STRB     r1,[r0,#4]
;;;283      /* initialize the end of the heap */
;;;284      ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
000022  4611              MOV      r1,r2
000024  6809              LDR      r1,[r1,#0]  ; ram
000026  f5015180          ADD      r1,r1,#0x1000
00002a  4a0d              LDR      r2,|L3.96|
00002c  6011              STR      r1,[r2,#0]  ; ram_end
;;;285      ram_end->used = 1;
00002e  2101              MOVS     r1,#1
000030  6812              LDR      r2,[r2,#0]  ; ram_end
000032  7111              STRB     r1,[r2,#4]
;;;286      ram_end->next = MEM_SIZE_ALIGNED;
000034  0309              LSLS     r1,r1,#12
000036  4a0a              LDR      r2,|L3.96|
000038  6812              LDR      r2,[r2,#0]  ; ram_end
00003a  8011              STRH     r1,[r2,#0]
;;;287      ram_end->prev = MEM_SIZE_ALIGNED;
00003c  4a08              LDR      r2,|L3.96|
00003e  6812              LDR      r2,[r2,#0]  ; ram_end
000040  8051              STRH     r1,[r2,#2]
;;;288    
;;;289    
;;;290      mem_sem = sys_sem_new(1);
000042  2101              MOVS     r1,#1
000044  4a07              LDR      r2,|L3.100|
000046  7011              STRB     r1,[r2,#0]
;;;291    
;;;292      /* initialize the lowest-free pointer to the start of the heap */
;;;293      lfree = (struct mem *)ram;
000048  4904              LDR      r1,|L3.92|
00004a  6809              LDR      r1,[r1,#0]  ; ram
00004c  4a06              LDR      r2,|L3.104|
00004e  6011              STR      r1,[r2,#0]  ; lfree
;;;294    
;;;295      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;296    }
000050  4770              BX       lr
;;;297    
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
                          DCD      wpa_debug_level
                  |L3.88|
                          DCD      ram_heap+0x3
                  |L3.92|
                          DCD      ||ram||
                  |L3.96|
                          DCD      ram_end
                  |L3.100|
                          DCD      mem_sem
                  |L3.104|
                          DCD      lfree

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                  mem_malloc PROC
;;;489    void *
;;;490    mem_malloc(mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;491    {
000002  4602              MOV      r2,r0
;;;492      mem_size_t ptr, ptr2;
;;;493      struct mem *mem, *mem2;
;;;494    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;495      u8_t local_mem_free_count = 0;
;;;496    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;497      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;498    
;;;499      if (size == 0) {
000004  b90a              CBNZ     r2,|L4.10|
;;;500        return NULL;
000006  2000              MOVS     r0,#0
                  |L4.8|
;;;501      }
;;;502    
;;;503      /* Expand the size of the allocated memory region so that we can
;;;504         adjust for alignment. */
;;;505      size = LWIP_MEM_ALIGN_SIZE(size);
;;;506    
;;;507      if(size < MIN_SIZE_ALIGNED) {
;;;508        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;509        size = MIN_SIZE_ALIGNED;
;;;510      }
;;;511    
;;;512      if (size > MEM_SIZE_ALIGNED) {
;;;513        return NULL;
;;;514      }
;;;515    
;;;516      /* protect the heap from concurrent access */
;;;517      sys_arch_sem_wait(mem_sem, 0);
;;;518      LWIP_MEM_ALLOC_PROTECT();
;;;519    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;520      /* run as long as a mem_free disturbed mem_malloc */
;;;521      do {
;;;522        local_mem_free_count = 0;
;;;523    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;524    
;;;525        /* Scan through the heap searching for a free block that is big enough,
;;;526         * beginning with the lowest free block.
;;;527         */
;;;528        for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
;;;529             ptr = ((struct mem *)&ram[ptr])->next) {
;;;530          mem = (struct mem *)&ram[ptr];
;;;531    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;532          mem_free_count = 0;
;;;533          LWIP_MEM_ALLOC_UNPROTECT();
;;;534          /* allow mem_free to run */
;;;535          LWIP_MEM_ALLOC_PROTECT();
;;;536          if (mem_free_count != 0) {
;;;537            local_mem_free_count = mem_free_count;
;;;538          }
;;;539          mem_free_count = 0;
;;;540    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;541    
;;;542          if ((!mem->used) &&
;;;543              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;544            /* mem is not used and at least perfect fit is possible:
;;;545             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;546    
;;;547            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;548              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;549               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;550               * -> split large block, create empty remainder,
;;;551               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;552               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;553               * struct mem would fit in but no data between mem2 and mem2->next
;;;554               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;555               *       region that couldn't hold data, but when mem->next gets freed,
;;;556               *       the 2 regions would be combined, resulting in more free memory
;;;557               */
;;;558              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;559              /* create mem2 struct */
;;;560              mem2 = (struct mem *)&ram[ptr2];
;;;561              mem2->used = 0;
;;;562              mem2->next = mem->next;
;;;563              mem2->prev = ptr;
;;;564              /* and insert it between mem and mem->next */
;;;565              mem->next = ptr2;
;;;566              mem->used = 1;
;;;567    
;;;568              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;569                ((struct mem *)&ram[mem2->next])->prev = ptr2;
;;;570              }
;;;571              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;572            } else {
;;;573              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;574               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;575               * take care of this).
;;;576               * -> near fit or excact fit: do not split, no mem2 creation
;;;577               * also can't move mem->next directly behind mem, since mem->next
;;;578               * will always be used at this point!
;;;579               */
;;;580              mem->used = 1;
;;;581              MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
;;;582            }
;;;583    
;;;584            if (mem == lfree) {
;;;585              /* Find next free block after mem and update lowest free pointer */
;;;586              while (lfree->used && lfree != ram_end) {
;;;587                LWIP_MEM_ALLOC_UNPROTECT();
;;;588                /* prevent high interrupt latency... */
;;;589                LWIP_MEM_ALLOC_PROTECT();
;;;590                lfree = (struct mem *)&ram[lfree->next];
;;;591              }
;;;592              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;593            }
;;;594            LWIP_MEM_ALLOC_UNPROTECT();
;;;595            sys_sem_signal(mem_sem);
;;;596            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;597             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;598            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;599             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;600            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;601              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;602    
;;;603            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;604          }
;;;605        }
;;;606    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;607        /* if we got interrupted by a mem_free, try again */
;;;608      } while(local_mem_free_count != 0);
;;;609    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;610      LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;611      MEM_STATS_INC(err);
;;;612      LWIP_MEM_ALLOC_UNPROTECT();
;;;613      sys_sem_signal(mem_sem);
;;;614      return NULL;
;;;615    }
000008  bd70              POP      {r4-r6,pc}
                  |L4.10|
00000a  1cd0              ADDS     r0,r2,#3              ;505
00000c  f0200003          BIC      r0,r0,#3              ;505
000010  b282              UXTH     r2,r0                 ;505
000012  2a0c              CMP      r2,#0xc               ;507
000014  da00              BGE      |L4.24|
000016  220c              MOVS     r2,#0xc               ;509
                  |L4.24|
000018  f5b25f80          CMP      r2,#0x1000            ;512
00001c  dd01              BLE      |L4.34|
00001e  2000              MOVS     r0,#0                 ;513
000020  e7f2              B        |L4.8|
                  |L4.34|
000022  482e              LDR      r0,|L4.220|
000024  6800              LDR      r0,[r0,#0]            ;528  ; lfree
000026  4e2e              LDR      r6,|L4.224|
000028  6836              LDR      r6,[r6,#0]            ;528  ; ram
00002a  1b80              SUBS     r0,r0,r6              ;528
00002c  b283              UXTH     r3,r0                 ;528
00002e  e04c              B        |L4.202|
                  |L4.48|
000030  482b              LDR      r0,|L4.224|
000032  6800              LDR      r0,[r0,#0]            ;530  ; ram
000034  18c1              ADDS     r1,r0,r3              ;530
000036  7908              LDRB     r0,[r1,#4]            ;542
000038  bbf0              CBNZ     r0,|L4.184|
00003a  880e              LDRH     r6,[r1,#0]            ;543
00003c  f1030008          ADD      r0,r3,#8              ;543
000040  1a30              SUBS     r0,r6,r0              ;543
000042  4290              CMP      r0,r2                 ;543
000044  d33e              BCC      |L4.196|
000046  880e              LDRH     r6,[r1,#0]            ;547
000048  f1030008          ADD      r0,r3,#8              ;547
00004c  1a36              SUBS     r6,r6,r0              ;547
00004e  f1020014          ADD      r0,r2,#0x14           ;547
000052  4286              CMP      r6,r0                 ;547
000054  d318              BCC      |L4.136|
000056  f1030008          ADD      r0,r3,#8              ;558
00005a  4410              ADD      r0,r0,r2              ;558
00005c  b285              UXTH     r5,r0                 ;558
00005e  4820              LDR      r0,|L4.224|
000060  6800              LDR      r0,[r0,#0]            ;560  ; ram
000062  1944              ADDS     r4,r0,r5              ;560
000064  2000              MOVS     r0,#0                 ;561
000066  7120              STRB     r0,[r4,#4]            ;561
000068  8808              LDRH     r0,[r1,#0]            ;562
00006a  8020              STRH     r0,[r4,#0]            ;562
00006c  8063              STRH     r3,[r4,#2]            ;563
00006e  800d              STRH     r5,[r1,#0]            ;565
000070  2001              MOVS     r0,#1                 ;566
000072  7108              STRB     r0,[r1,#4]            ;566
000074  8820              LDRH     r0,[r4,#0]            ;568
000076  f5b05f80          CMP      r0,#0x1000            ;568
00007a  d007              BEQ      |L4.140|
00007c  8820              LDRH     r0,[r4,#0]            ;569
00007e  4e18              LDR      r6,|L4.224|
000080  6836              LDR      r6,[r6,#0]            ;569  ; ram
000082  4430              ADD      r0,r0,r6              ;569
000084  8045              STRH     r5,[r0,#2]            ;569
000086  e001              B        |L4.140|
                  |L4.136|
000088  2001              MOVS     r0,#1                 ;580
00008a  7108              STRB     r0,[r1,#4]            ;580
                  |L4.140|
00008c  4813              LDR      r0,|L4.220|
00008e  6800              LDR      r0,[r0,#0]            ;584  ; lfree
000090  4281              CMP      r1,r0                 ;584
000092  d114              BNE      |L4.190|
000094  e007              B        |L4.166|
                  |L4.150|
000096  4811              LDR      r0,|L4.220|
000098  6800              LDR      r0,[r0,#0]            ;590  ; lfree
00009a  8800              LDRH     r0,[r0,#0]            ;590
00009c  4e10              LDR      r6,|L4.224|
00009e  6836              LDR      r6,[r6,#0]            ;590  ; ram
0000a0  4430              ADD      r0,r0,r6              ;590
0000a2  4e0e              LDR      r6,|L4.220|
0000a4  6030              STR      r0,[r6,#0]            ;590  ; lfree
                  |L4.166|
0000a6  480d              LDR      r0,|L4.220|
0000a8  6800              LDR      r0,[r0,#0]            ;586  ; lfree
0000aa  7900              LDRB     r0,[r0,#4]            ;586
0000ac  b138              CBZ      r0,|L4.190|
0000ae  480b              LDR      r0,|L4.220|
0000b0  6800              LDR      r0,[r0,#0]            ;586  ; lfree
0000b2  4e0c              LDR      r6,|L4.228|
0000b4  6836              LDR      r6,[r6,#0]            ;586  ; ram_end
0000b6  e000              B        |L4.186|
                  |L4.184|
0000b8  e004              B        |L4.196|
                  |L4.186|
0000ba  42b0              CMP      r0,r6                 ;586
0000bc  d1eb              BNE      |L4.150|
                  |L4.190|
0000be  f1010008          ADD      r0,r1,#8              ;603
0000c2  e7a1              B        |L4.8|
                  |L4.196|
0000c4  4806              LDR      r0,|L4.224|
0000c6  6800              LDR      r0,[r0,#0]            ;529  ; ram
0000c8  5ac3              LDRH     r3,[r0,r3]            ;529
                  |L4.202|
0000ca  f5c25080          RSB      r0,r2,#0x1000         ;528
0000ce  4298              CMP      r0,r3                 ;528
0000d0  dcae              BGT      |L4.48|
0000d2  bf00              NOP                            ;610
0000d4  bf00              NOP                            ;610
0000d6  2000              MOVS     r0,#0                 ;614
0000d8  e796              B        |L4.8|
;;;616    
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
                          DCD      lfree
                  |L4.224|
                          DCD      ||ram||
                  |L4.228|
                          DCD      ram_end

                          AREA ||i.mem_realloc||, CODE, READONLY, ALIGN=2

                  mem_realloc PROC
;;;364    void *
;;;365    mem_realloc(void *rmem, mem_size_t newsize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;366    {
000004  4606              MOV      r6,r0
000006  460a              MOV      r2,r1
;;;367      mem_size_t size;
;;;368      mem_size_t ptr, ptr2;
;;;369      struct mem *mem, *mem2;
;;;370      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;371      LWIP_MEM_FREE_DECL_PROTECT();
;;;372    
;;;373      /* Expand the size of the allocated memory region so that we can
;;;374         adjust for alignment. */
;;;375      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000008  1cd0              ADDS     r0,r2,#3
00000a  f0200003          BIC      r0,r0,#3
00000e  b282              UXTH     r2,r0
;;;376    
;;;377      if(newsize < MIN_SIZE_ALIGNED) {
000010  2a0c              CMP      r2,#0xc
000012  da00              BGE      |L5.22|
;;;378        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;379        newsize = MIN_SIZE_ALIGNED;
000014  220c              MOVS     r2,#0xc
                  |L5.22|
;;;380      }
;;;381    
;;;382      if (newsize > MEM_SIZE_ALIGNED) {
000016  f5b25f80          CMP      r2,#0x1000
00001a  dd02              BLE      |L5.34|
;;;383        return NULL;
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;384      }
;;;385    
;;;386      LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;387       (u8_t *)rmem < (u8_t *)ram_end);
;;;388    
;;;389      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;390        SYS_ARCH_DECL_PROTECT(lev);
;;;391        LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
;;;392        /* protect mem stats from concurrent access */
;;;393        SYS_ARCH_PROTECT(lev);
;;;394        MEM_STATS_INC(illegal);
;;;395        SYS_ARCH_UNPROTECT(lev);
;;;396        return rmem;
;;;397      }
;;;398      /* Get the corresponding struct mem ... */
;;;399      mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;400      /* ... and its offset pointer */
;;;401      ptr = (u8_t *)mem - ram;
;;;402    
;;;403      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;404      LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
;;;405      if (newsize > size) {
;;;406        /* not supported */
;;;407        return NULL;
;;;408      }
;;;409      if (newsize == size) {
;;;410        /* No change in size, simply return */
;;;411        return rmem;
;;;412      }
;;;413    
;;;414      /* protect the heap from concurrent access */
;;;415      LWIP_MEM_FREE_PROTECT();
;;;416    
;;;417      MEM_STATS_DEC_USED(used, (size - newsize));
;;;418    
;;;419      mem2 = (struct mem *)&ram[mem->next];
;;;420      if(mem2->used == 0) {
;;;421        /* The next struct is unused, we can simply move it at little */
;;;422        mem_size_t next;
;;;423        /* remember the old next pointer */
;;;424        next = mem2->next;
;;;425        /* create new struct mem which is moved directly after the shrinked mem */
;;;426        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;427        if (lfree == mem2) {
;;;428          lfree = (struct mem *)&ram[ptr2];
;;;429        }
;;;430        mem2 = (struct mem *)&ram[ptr2];
;;;431        mem2->used = 0;
;;;432        /* restore the next pointer */
;;;433        mem2->next = next;
;;;434        /* link it back to mem */
;;;435        mem2->prev = ptr;
;;;436        /* link mem to it */
;;;437        mem->next = ptr2;
;;;438        /* last thing to restore linked list: as we have moved mem2,
;;;439         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;440         * the end of the heap */
;;;441        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;442          ((struct mem *)&ram[mem2->next])->prev = ptr2;
;;;443        }
;;;444        /* no need to plug holes, we've already done that */
;;;445      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;446        /* Next struct is used but there's room for another struct mem with
;;;447         * at least MIN_SIZE_ALIGNED of data.
;;;448         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;449         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;450         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;451         *       region that couldn't hold data, but when mem->next gets freed,
;;;452         *       the 2 regions would be combined, resulting in more free memory */
;;;453        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;454        mem2 = (struct mem *)&ram[ptr2];
;;;455        if (mem2 < lfree) {
;;;456          lfree = mem2;
;;;457        }
;;;458        mem2->used = 0;
;;;459        mem2->next = mem->next;
;;;460        mem2->prev = ptr;
;;;461        mem->next = ptr2;
;;;462        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;463          ((struct mem *)&ram[mem2->next])->prev = ptr2;
;;;464        }
;;;465        /* the original mem->next is used, so no need to plug holes! */
;;;466      }
;;;467      /* else {
;;;468        next struct mem is used but size between mem and mem2 is not big enough
;;;469        to create another struct mem
;;;470        -> don't do anyhting. 
;;;471        -> the remaining space stays unused since it is too small
;;;472      } */
;;;473    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;474      mem_free_count = 1;
;;;475    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;476      LWIP_MEM_FREE_UNPROTECT();
;;;477      return rmem;
;;;478    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.34|
000022  483e              LDR      r0,|L5.284|
000024  6800              LDR      r0,[r0,#0]            ;389  ; ram
000026  4286              CMP      r6,r0                 ;389
000028  d303              BCC      |L5.50|
00002a  483d              LDR      r0,|L5.288|
00002c  6800              LDR      r0,[r0,#0]            ;389  ; ram_end
00002e  4286              CMP      r6,r0                 ;389
000030  d303              BCC      |L5.58|
                  |L5.50|
000032  bf00              NOP                            ;391
000034  bf00              NOP                            ;391
000036  4630              MOV      r0,r6                 ;396
000038  e7f1              B        |L5.30|
                  |L5.58|
00003a  f1a60408          SUB      r4,r6,#8              ;399
00003e  4837              LDR      r0,|L5.284|
000040  6800              LDR      r0,[r0,#0]            ;401  ; ram
000042  1a20              SUBS     r0,r4,r0              ;401
000044  b285              UXTH     r5,r0                 ;401
000046  8820              LDRH     r0,[r4,#0]            ;403
000048  1b40              SUBS     r0,r0,r5              ;403
00004a  3808              SUBS     r0,r0,#8              ;403
00004c  b287              UXTH     r7,r0                 ;403
00004e  42ba              CMP      r2,r7                 ;405
000050  dd01              BLE      |L5.86|
000052  2000              MOVS     r0,#0                 ;407
000054  e7e3              B        |L5.30|
                  |L5.86|
000056  42ba              CMP      r2,r7                 ;409
000058  d101              BNE      |L5.94|
00005a  4630              MOV      r0,r6                 ;411
00005c  e7df              B        |L5.30|
                  |L5.94|
00005e  8820              LDRH     r0,[r4,#0]            ;419
000060  f8dfc0b8          LDR      r12,|L5.284|
000064  f8dcc000          LDR      r12,[r12,#0]          ;419  ; ram
000068  eb00010c          ADD      r1,r0,r12             ;419
00006c  7908              LDRB     r0,[r1,#4]            ;420
00006e  bb80              CBNZ     r0,|L5.210|
000070  8808              LDRH     r0,[r1,#0]            ;424
000072  f1050c08          ADD      r12,r5,#8             ;426
000076  4494              ADD      r12,r12,r2            ;426
000078  fa1ff38c          UXTH     r3,r12                ;426
00007c  f8dfc0a4          LDR      r12,|L5.292|
000080  f8dcc000          LDR      r12,[r12,#0]          ;427  ; lfree
000084  458c              CMP      r12,r1                ;427
000086  d108              BNE      |L5.154|
000088  f8dfc090          LDR      r12,|L5.284|
00008c  f8dcc000          LDR      r12,[r12,#0]          ;428  ; ram
000090  449c              ADD      r12,r12,r3            ;428
000092  f8df8090          LDR      r8,|L5.292|
000096  f8c8c000          STR      r12,[r8,#0]           ;428  ; lfree
                  |L5.154|
00009a  f8dfc080          LDR      r12,|L5.284|
00009e  f8dcc000          LDR      r12,[r12,#0]          ;430  ; ram
0000a2  eb0c0103          ADD      r1,r12,r3             ;430
0000a6  f04f0c00          MOV      r12,#0                ;431
0000aa  f881c004          STRB     r12,[r1,#4]           ;431
0000ae  8008              STRH     r0,[r1,#0]            ;433
0000b0  804d              STRH     r5,[r1,#2]            ;435
0000b2  8023              STRH     r3,[r4,#0]            ;437
0000b4  f8b1c000          LDRH     r12,[r1,#0]           ;441
0000b8  f5bc5f80          CMP      r12,#0x1000           ;441
0000bc  d008              BEQ      |L5.208|
0000be  f8b1c000          LDRH     r12,[r1,#0]           ;442
0000c2  f8df8058          LDR      r8,|L5.284|
0000c6  f8d88000          LDR      r8,[r8,#0]            ;442  ; ram
0000ca  44c4              ADD      r12,r12,r8            ;442
0000cc  f8ac3002          STRH     r3,[r12,#2]           ;442
                  |L5.208|
0000d0  e022              B        |L5.280|
                  |L5.210|
0000d2  e7ff              B        |L5.212|
                  |L5.212|
0000d4  f1020014          ADD      r0,r2,#0x14           ;445
0000d8  42b8              CMP      r0,r7                 ;445
0000da  d81d              BHI      |L5.280|
0000dc  f1050008          ADD      r0,r5,#8              ;453
0000e0  4410              ADD      r0,r0,r2              ;453
0000e2  b283              UXTH     r3,r0                 ;453
0000e4  480d              LDR      r0,|L5.284|
0000e6  6800              LDR      r0,[r0,#0]            ;454  ; ram
0000e8  18c1              ADDS     r1,r0,r3              ;454
0000ea  480e              LDR      r0,|L5.292|
0000ec  6800              LDR      r0,[r0,#0]            ;455  ; lfree
0000ee  4281              CMP      r1,r0                 ;455
0000f0  d201              BCS      |L5.246|
0000f2  480c              LDR      r0,|L5.292|
0000f4  6001              STR      r1,[r0,#0]            ;456  ; lfree
                  |L5.246|
0000f6  2000              MOVS     r0,#0                 ;458
0000f8  7108              STRB     r0,[r1,#4]            ;458
0000fa  8820              LDRH     r0,[r4,#0]            ;459
0000fc  8008              STRH     r0,[r1,#0]            ;459
0000fe  804d              STRH     r5,[r1,#2]            ;460
000100  8023              STRH     r3,[r4,#0]            ;461
000102  8808              LDRH     r0,[r1,#0]            ;462
000104  f5b05f80          CMP      r0,#0x1000            ;462
000108  d006              BEQ      |L5.280|
00010a  8808              LDRH     r0,[r1,#0]            ;463
00010c  f8dfc00c          LDR      r12,|L5.284|
000110  f8dcc000          LDR      r12,[r12,#0]          ;463  ; ram
000114  4460              ADD      r0,r0,r12             ;463
000116  8043              STRH     r3,[r0,#2]            ;463
                  |L5.280|
000118  4630              MOV      r0,r6                 ;477
00011a  e780              B        |L5.30|
;;;479    
                          ENDP

                  |L5.284|
                          DCD      ||ram||
                  |L5.288|
                          DCD      ram_end
                  |L5.292|
                          DCD      lfree

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;229    static void
;;;230    plug_holes(struct mem *mem)
000000  b530              PUSH     {r4,r5,lr}
;;;231    {
;;;232      struct mem *nmem;
;;;233      struct mem *pmem;
;;;234    
;;;235      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
;;;236      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
;;;237      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
;;;238    
;;;239      /* plug hole forward */
;;;240      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
;;;241    
;;;242      nmem = (struct mem *)&ram[mem->next];
000002  8803              LDRH     r3,[r0,#0]
000004  4c19              LDR      r4,|L6.108|
000006  6824              LDR      r4,[r4,#0]  ; ram
000008  1919              ADDS     r1,r3,r4
;;;243      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
00000a  4288              CMP      r0,r1
00000c  d015              BEQ      |L6.58|
00000e  790b              LDRB     r3,[r1,#4]
000010  b99b              CBNZ     r3,|L6.58|
000012  4b17              LDR      r3,|L6.112|
000014  681b              LDR      r3,[r3,#0]  ; ram_end
000016  4299              CMP      r1,r3
000018  d00f              BEQ      |L6.58|
;;;244        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;245        if (lfree == nmem) {
00001a  4b16              LDR      r3,|L6.116|
00001c  681b              LDR      r3,[r3,#0]  ; lfree
00001e  428b              CMP      r3,r1
000020  d101              BNE      |L6.38|
;;;246          lfree = mem;
000022  4b14              LDR      r3,|L6.116|
000024  6018              STR      r0,[r3,#0]  ; lfree
                  |L6.38|
;;;247        }
;;;248        mem->next = nmem->next;
000026  880b              LDRH     r3,[r1,#0]
000028  8003              STRH     r3,[r0,#0]
;;;249        ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
00002a  4b10              LDR      r3,|L6.108|
00002c  681b              LDR      r3,[r3,#0]  ; ram
00002e  1ac3              SUBS     r3,r0,r3
000030  880c              LDRH     r4,[r1,#0]
000032  4d0e              LDR      r5,|L6.108|
000034  682d              LDR      r5,[r5,#0]  ; ram
000036  442c              ADD      r4,r4,r5
000038  8063              STRH     r3,[r4,#2]
                  |L6.58|
;;;250      }
;;;251    
;;;252      /* plug hole backward */
;;;253      pmem = (struct mem *)&ram[mem->prev];
00003a  8843              LDRH     r3,[r0,#2]
00003c  4c0b              LDR      r4,|L6.108|
00003e  6824              LDR      r4,[r4,#0]  ; ram
000040  191a              ADDS     r2,r3,r4
;;;254      if (pmem != mem && pmem->used == 0) {
000042  4282              CMP      r2,r0
000044  d011              BEQ      |L6.106|
000046  7913              LDRB     r3,[r2,#4]
000048  b97b              CBNZ     r3,|L6.106|
;;;255        /* if mem->prev is unused, combine mem and mem->prev */
;;;256        if (lfree == mem) {
00004a  4b0a              LDR      r3,|L6.116|
00004c  681b              LDR      r3,[r3,#0]  ; lfree
00004e  4283              CMP      r3,r0
000050  d101              BNE      |L6.86|
;;;257          lfree = pmem;
000052  4b08              LDR      r3,|L6.116|
000054  601a              STR      r2,[r3,#0]  ; lfree
                  |L6.86|
;;;258        }
;;;259        pmem->next = mem->next;
000056  8803              LDRH     r3,[r0,#0]
000058  8013              STRH     r3,[r2,#0]
;;;260        ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
00005a  4b04              LDR      r3,|L6.108|
00005c  681b              LDR      r3,[r3,#0]  ; ram
00005e  1ad3              SUBS     r3,r2,r3
000060  8804              LDRH     r4,[r0,#0]
000062  4d02              LDR      r5,|L6.108|
000064  682d              LDR      r5,[r5,#0]  ; ram
000066  442c              ADD      r4,r4,r5
000068  8063              STRH     r3,[r4,#2]
                  |L6.106|
;;;261      }
;;;262    }
00006a  bd30              POP      {r4,r5,pc}
;;;263    
                          ENDP

                  |L6.108|
                          DCD      ||ram||
                  |L6.112|
                          DCD      ram_end
                  |L6.116|
                          DCD      lfree

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        4116

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_sem
00000c  00                DCB      0x00
