; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\etharp.o --depend=.\obj\etharp.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\etharp.crf ..\lwIP\src\netif\etharp.c]
                          THUMB

                          AREA ||i.etharp_arp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  etharp_arp_input PROC
;;;619    void
;;;620    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;621    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;622      struct etharp_hdr *hdr;
;;;623      /* these are aligned properly, whereas the ARP header fields might not be */
;;;624      struct ip_addr sipaddr, dipaddr;
;;;625      u8_t i;
;;;626      u8_t for_us;
;;;627    #if LWIP_AUTOIP
;;;628      const u8_t * ethdst_hwaddr;
;;;629    #endif /* LWIP_AUTOIP */
;;;630    
;;;631      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
00000a  bf00              NOP      
00000c  b956              CBNZ     r6,|L1.36|
00000e  bf00              NOP      
000010  a352              ADR      r3,|L1.348|
000012  f2402277          MOV      r2,#0x277
000016  a158              ADR      r1,|L1.376|
000018  a05b              ADR      r0,|L1.392|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L1.32|
;;;632      
;;;633      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;634         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;635      if (p->len < sizeof(struct etharp_hdr)) {
;;;636        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
;;;637        ETHARP_STATS_INC(etharp.lenerr);
;;;638        ETHARP_STATS_INC(etharp.drop);
;;;639        pbuf_free(p);
;;;640        return;
;;;641      }
;;;642    
;;;643      hdr = p->payload;
;;;644    
;;;645      /* RFC 826 "Packet Reception": */
;;;646      if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
;;;647          (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
;;;648          (hdr->proto != htons(ETHTYPE_IP)) ||
;;;649          (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
;;;650        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
;;;651          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;652          hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
;;;653        ETHARP_STATS_INC(etharp.proterr);
;;;654        ETHARP_STATS_INC(etharp.drop);
;;;655        pbuf_free(p);
;;;656        return;
;;;657      }
;;;658      ETHARP_STATS_INC(etharp.recv);
;;;659    
;;;660    #if LWIP_AUTOIP
;;;661      /* We have to check if a host already has configured our random
;;;662       * created link local address and continously check if there is
;;;663       * a host with this IP-address so we can detect collisions */
;;;664      autoip_arp_reply(netif, hdr);
;;;665    #endif /* LWIP_AUTOIP */
;;;666    
;;;667      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;668       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;669      SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
;;;670      SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
;;;671    
;;;672      /* this interface is not configured? */
;;;673      if (netif->ip_addr.addr == 0) {
;;;674        for_us = 0;
;;;675      } else {
;;;676        /* ARP packet directed to us? */
;;;677        for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;678      }
;;;679    
;;;680      /* ARP message directed to us? */
;;;681      if (for_us) {
;;;682        /* add IP address in ARP cache; assume requester wants to talk to us.
;;;683         * can result in directly sending the queued packets for this host. */
;;;684        update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
;;;685      /* ARP message not directed to us? */
;;;686      } else {
;;;687        /* update the source IP address in the cache, if present */
;;;688        update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
;;;689      }
;;;690    
;;;691      /* now act on the message itself */
;;;692      switch (htons(hdr->opcode)) {
;;;693      /* ARP request? */
;;;694      case ARP_REQUEST:
;;;695        /* ARP request. If it asked for our address, we send out a
;;;696         * reply. In any case, we time-stamp any existing ARP entry,
;;;697         * and possiby send out an IP packet that was queued on it. */
;;;698    
;;;699        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;700        /* ARP request for our address? */
;;;701        if (for_us) {
;;;702    
;;;703          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;704          /* Re-use pbuf to send ARP reply.
;;;705             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;706             that would allocate a new pbuf. */
;;;707          hdr->opcode = htons(ARP_REPLY);
;;;708    
;;;709          hdr->dipaddr = hdr->sipaddr;
;;;710          SMEMCPY(&hdr->sipaddr, &netif->ip_addr, sizeof(hdr->sipaddr));
;;;711    
;;;712          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;713                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;714          i = ETHARP_HWADDR_LEN;
;;;715    #if LWIP_AUTOIP
;;;716          /* If we are using Link-Local, ARP packets must be broadcast on the
;;;717           * link layer. (See RFC3927 Section 2.5) */
;;;718          ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;719    #endif /* LWIP_AUTOIP */
;;;720    
;;;721          while(i > 0) {
;;;722            i--;
;;;723            hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
;;;724    #if LWIP_AUTOIP
;;;725            hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
;;;726    #else  /* LWIP_AUTOIP */
;;;727            hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
;;;728    #endif /* LWIP_AUTOIP */
;;;729            hdr->shwaddr.addr[i] = ethaddr->addr[i];
;;;730            hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
;;;731          }
;;;732    
;;;733          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;734             are already correct, we tested that before */
;;;735    
;;;736          /* return ARP reply */
;;;737          netif->linkoutput(netif, p);
;;;738        /* we are not configured? */
;;;739        } else if (netif->ip_addr.addr == 0) {
;;;740          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;741          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;742        /* request was not directed to us */
;;;743        } else {
;;;744          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;745          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;746        }
;;;747        break;
;;;748      case ARP_REPLY:
;;;749        /* ARP reply. We already updated the ARP cache earlier. */
;;;750        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;751    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;752        /* DHCP wants to know about ARP replies from any host with an
;;;753         * IP address also offered to us by the DHCP server. We do not
;;;754         * want to take a duplicate IP address on a single network.
;;;755         * @todo How should we handle redundant (fail-over) interfaces? */
;;;756        dhcp_arp_reply(netif, &sipaddr);
;;;757    #endif
;;;758        break;
;;;759      default:
;;;760        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;761        ETHARP_STATS_INC(etharp.err);
;;;762        break;
;;;763      }
;;;764      /* free ARP packet */
;;;765      pbuf_free(p);
;;;766    }
000020  e8bd87fc          POP      {r2-r10,pc}
                  |L1.36|
000024  bf00              NOP                            ;631
000026  8978              LDRH     r0,[r7,#0xa]          ;635
000028  282a              CMP      r0,#0x2a              ;635
00002a  d205              BCS      |L1.56|
00002c  bf00              NOP                            ;636
00002e  bf00              NOP                            ;636
000030  4638              MOV      r0,r7                 ;639
000032  f7fffffe          BL       pbuf_free
000036  e7f3              B        |L1.32|
                  |L1.56|
000038  687c              LDR      r4,[r7,#4]            ;643
00003a  2001              MOVS     r0,#1                 ;646
00003c  f7fffffe          BL       htons
000040  89e1              LDRH     r1,[r4,#0xe]          ;646
000042  4288              CMP      r0,r1                 ;646
000044  d114              BNE      |L1.112|
000046  f2406004          MOV      r0,#0x604             ;647
00004a  f7fffffe          BL       htons
00004e  8a61              LDRH     r1,[r4,#0x12]         ;647
000050  4288              CMP      r0,r1                 ;647
000052  d10d              BNE      |L1.112|
000054  f44f6000          MOV      r0,#0x800             ;648
000058  f7fffffe          BL       htons
00005c  8a21              LDRH     r1,[r4,#0x10]         ;648
00005e  4288              CMP      r0,r1                 ;648
000060  d106              BNE      |L1.112|
000062  f6400006          MOV      r0,#0x806             ;649
000066  f7fffffe          BL       htons
00006a  89a1              LDRH     r1,[r4,#0xc]          ;649
00006c  4288              CMP      r0,r1                 ;649
00006e  d005              BEQ      |L1.124|
                  |L1.112|
000070  bf00              NOP                            ;650
000072  bf00              NOP                            ;650
000074  4638              MOV      r0,r7                 ;655
000076  f7fffffe          BL       pbuf_free
00007a  e7d1              B        |L1.32|
                  |L1.124|
00007c  69e0              LDR      r0,[r4,#0x1c]         ;669
00007e  9001              STR      r0,[sp,#4]            ;669
000080  f8d40026          LDR      r0,[r4,#0x26]         ;670
000084  9000              STR      r0,[sp,#0]            ;670
000086  6870              LDR      r0,[r6,#4]            ;673
000088  b910              CBNZ     r0,|L1.144|
00008a  f04f0800          MOV      r8,#0                 ;674
00008e  e008              B        |L1.162|
                  |L1.144|
000090  9800              LDR      r0,[sp,#0]            ;677
000092  6871              LDR      r1,[r6,#4]            ;677
000094  4288              CMP      r0,r1                 ;677
000096  d101              BNE      |L1.156|
000098  2001              MOVS     r0,#1                 ;677
00009a  e000              B        |L1.158|
                  |L1.156|
00009c  2000              MOVS     r0,#0                 ;677
                  |L1.158|
00009e  f00008ff          AND      r8,r0,#0xff           ;677
                  |L1.162|
0000a2  f1b80f00          CMP      r8,#0                 ;681
0000a6  d007              BEQ      |L1.184|
0000a8  2301              MOVS     r3,#1                 ;684
0000aa  f1040216          ADD      r2,r4,#0x16           ;684
0000ae  a901              ADD      r1,sp,#4              ;684
0000b0  4630              MOV      r0,r6                 ;684
0000b2  f7fffffe          BL       update_arp_entry
0000b6  e006              B        |L1.198|
                  |L1.184|
0000b8  2300              MOVS     r3,#0                 ;688
0000ba  f1040216          ADD      r2,r4,#0x16           ;688
0000be  a901              ADD      r1,sp,#4              ;688
0000c0  4630              MOV      r0,r6                 ;688
0000c2  f7fffffe          BL       update_arp_entry
                  |L1.198|
0000c6  8aa0              LDRH     r0,[r4,#0x14]         ;692
0000c8  f7fffffe          BL       htons
0000cc  2801              CMP      r0,#1                 ;692
0000ce  d002              BEQ      |L1.214|
0000d0  2802              CMP      r0,#2                 ;692
0000d2  d13a              BNE      |L1.330|
0000d4  e032              B        |L1.316|
                  |L1.214|
0000d6  bf00              NOP                            ;699
0000d8  bf00              NOP                            ;699
0000da  f1b80f00          CMP      r8,#0                 ;701
0000de  d026              BEQ      |L1.302|
0000e0  bf00              NOP                            ;703
0000e2  bf00              NOP                            ;703
0000e4  2002              MOVS     r0,#2                 ;707
0000e6  f7fffffe          BL       htons
0000ea  82a0              STRH     r0,[r4,#0x14]         ;707
0000ec  69e0              LDR      r0,[r4,#0x1c]         ;709
0000ee  f8c40026          STR      r0,[r4,#0x26]         ;709
0000f2  6870              LDR      r0,[r6,#4]            ;710
0000f4  61e0              STR      r0,[r4,#0x1c]         ;710
0000f6  2506              MOVS     r5,#6                 ;714
0000f8  e012              B        |L1.288|
                  |L1.250|
0000fa  1e68              SUBS     r0,r5,#1              ;722
0000fc  b2c5              UXTB     r5,r0                 ;722
0000fe  f1040016          ADD      r0,r4,#0x16           ;723
000102  5d41              LDRB     r1,[r0,r5]            ;723
000104  300a              ADDS     r0,r0,#0xa            ;723
000106  5541              STRB     r1,[r0,r5]            ;723
000108  380a              SUBS     r0,r0,#0xa            ;727
00010a  5d40              LDRB     r0,[r0,r5]            ;727
00010c  5560              STRB     r0,[r4,r5]            ;727
00010e  f8191005          LDRB     r1,[r9,r5]            ;729
000112  f1040016          ADD      r0,r4,#0x16           ;729
000116  5541              STRB     r1,[r0,r5]            ;729
000118  f8191005          LDRB     r1,[r9,r5]            ;730
00011c  1da0              ADDS     r0,r4,#6              ;730
00011e  5541              STRB     r1,[r0,r5]            ;730
                  |L1.288|
000120  2d00              CMP      r5,#0                 ;721
000122  dcea              BGT      |L1.250|
000124  4639              MOV      r1,r7                 ;737
000126  4630              MOV      r0,r6                 ;737
000128  69b2              LDR      r2,[r6,#0x18]         ;737
00012a  4790              BLX      r2                    ;737
00012c  e005              B        |L1.314|
                  |L1.302|
00012e  6870              LDR      r0,[r6,#4]            ;739
000130  b908              CBNZ     r0,|L1.310|
000132  bf00              NOP                            ;741
000134  e001              B        |L1.314|
                  |L1.310|
000136  bf00              NOP                            ;745
000138  bf00              NOP                            ;745
                  |L1.314|
00013a  e009              B        |L1.336|
                  |L1.316|
00013c  bf00              NOP                            ;750
00013e  bf00              NOP                            ;750
000140  a901              ADD      r1,sp,#4              ;756
000142  4630              MOV      r0,r6                 ;756
000144  f7fffffe          BL       dhcp_arp_reply
000148  e002              B        |L1.336|
                  |L1.330|
00014a  bf00              NOP                            ;760
00014c  bf00              NOP                            ;760
00014e  bf00              NOP                            ;762
                  |L1.336|
000150  bf00              NOP                            ;747
000152  4638              MOV      r0,r7                 ;765
000154  f7fffffe          BL       pbuf_free
000158  bf00              NOP      
00015a  e761              B        |L1.32|
;;;767    
                          ENDP

                  |L1.348|
00015c  2e2e5c6c          DCB      "..\\lwIP\\src\\netif\\etharp.c",0
000160  7749505c
000164  7372635c
000168  6e657469
00016c  665c6574
000170  68617270
000174  2e6300  
000177  00                DCB      0
                  |L1.376|
000178  6e657469          DCB      "netif != NULL",0
00017c  6620213d
000180  204e554c
000184  4c00    
000186  00                DCB      0
000187  00                DCB      0
                  |L1.392|
000188  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00018c  7274696f
000190  6e202225
000194  73222066
000198  61696c65
00019c  64206174
0001a0  206c696e
0001a4  65202564
0001a8  20696e20
0001ac  25730a00

                          AREA ||i.etharp_find_addr||, CODE, READONLY, ALIGN=2

                  etharp_find_addr PROC
;;;546    s8_t
;;;547    etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;548             struct eth_addr **eth_ret, struct ip_addr **ip_ret)
;;;549    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;550      s8_t i;
;;;551    
;;;552      LWIP_UNUSED_ARG(netif);
;;;553    
;;;554    #if LWIP_NETIF_HWADDRHINT
;;;555      i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
;;;556    #else /* LWIP_NETIF_HWADDRHINT */
;;;557      i = find_entry(ipaddr, ETHARP_FIND_ONLY);
00000c  2102              MOVS     r1,#2
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       find_entry
000014  4604              MOV      r4,r0
;;;558    #endif /* LWIP_NETIF_HWADDRHINT */
;;;559      if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
000016  2c00              CMP      r4,#0
000018  db16              BLT      |L2.72|
00001a  eb040084          ADD      r0,r4,r4,LSL #2
00001e  490c              LDR      r1,|L2.80|
000020  eb010080          ADD      r0,r1,r0,LSL #2
000024  7b80              LDRB     r0,[r0,#0xe]
000026  2802              CMP      r0,#2
000028  d10e              BNE      |L2.72|
;;;560          *eth_ret = &arp_table[i].ethaddr;
00002a  eb040084          ADD      r0,r4,r4,LSL #2
00002e  eb010080          ADD      r0,r1,r0,LSL #2
000032  3008              ADDS     r0,r0,#8
000034  6030              STR      r0,[r6,#0]
;;;561          *ip_ret = &arp_table[i].ipaddr;
000036  eb040084          ADD      r0,r4,r4,LSL #2
00003a  eb010080          ADD      r0,r1,r0,LSL #2
00003e  1d00              ADDS     r0,r0,#4
000040  6038              STR      r0,[r7,#0]
;;;562          return i;
000042  4620              MOV      r0,r4
                  |L2.68|
;;;563      }
;;;564      return -1;
;;;565    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L2.72|
000048  f04f30ff          MOV      r0,#0xffffffff        ;564
00004c  e7fa              B        |L2.68|
;;;566    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      arp_table

                          AREA ||i.etharp_ip_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  etharp_ip_input PROC
;;;582    void
;;;583    etharp_ip_input(struct netif *netif, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;584    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;585      struct ethip_hdr *hdr;
;;;586      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
000006  bf00              NOP      
000008  b94c              CBNZ     r4,|L3.30|
00000a  bf00              NOP      
00000c  a30f              ADR      r3,|L3.76|
00000e  f240224a          MOV      r2,#0x24a
000012  a115              ADR      r1,|L3.104|
000014  a018              ADR      r0,|L3.120|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
                  |L3.28|
;;;587      /* Only insert an entry if the source IP address of the
;;;588         incoming IP packet comes from a host on the local network. */
;;;589      hdr = p->payload;
;;;590      /* source is not on the local network? */
;;;591      if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
;;;592        /* do nothing */
;;;593        return;
;;;594      }
;;;595    
;;;596      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
;;;597      /* update ARP table */
;;;598      /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
;;;599       * back soon (for example, if the destination IP address is ours. */
;;;600      update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
;;;601    }
00001c  bd70              POP      {r4-r6,pc}
                  |L3.30|
00001e  bf00              NOP                            ;586
000020  6875              LDR      r5,[r6,#4]            ;589
000022  f8d5001a          LDR      r0,[r5,#0x1a]         ;591
000026  68a1              LDR      r1,[r4,#8]            ;591
000028  4008              ANDS     r0,r0,r1              ;591
00002a  e9d41201          LDRD     r1,r2,[r4,#4]         ;591
00002e  4011              ANDS     r1,r1,r2              ;591
000030  4288              CMP      r0,r1                 ;591
000032  d000              BEQ      |L3.54|
000034  e7f2              B        |L3.28|
                  |L3.54|
000036  bf00              NOP                            ;596
000038  bf00              NOP                            ;596
00003a  2300              MOVS     r3,#0                 ;600
00003c  1daa              ADDS     r2,r5,#6              ;600
00003e  f105011a          ADD      r1,r5,#0x1a           ;600
000042  4620              MOV      r0,r4                 ;600
000044  f7fffffe          BL       update_arp_entry
000048  bf00              NOP      
00004a  e7e7              B        |L3.28|
;;;602    
                          ENDP

                  |L3.76|
00004c  2e2e5c6c          DCB      "..\\lwIP\\src\\netif\\etharp.c",0
000050  7749505c
000054  7372635c
000058  6e657469
00005c  665c6574
000060  68617270
000064  2e6300  
000067  00                DCB      0
                  |L3.104|
000068  6e657469          DCB      "netif != NULL",0
00006c  6620213d
000070  204e554c
000074  4c00    
000076  00                DCB      0
000077  00                DCB      0
                  |L3.120|
000078  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00007c  7274696f
000080  6e202225
000084  73222066
000088  61696c65
00008c  64206174
000090  206c696e
000094  65202564
000098  20696e20
00009c  25730a00

                          AREA ||i.etharp_output||, CODE, READONLY, ALIGN=2

                  etharp_output PROC
;;;786    err_t
;;;787    etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;788    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;789      struct eth_addr *dest, mcastaddr;
;;;790    
;;;791      /* make room for Ethernet header - should not fail */
;;;792      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
00000a  210e              MOVS     r1,#0xe
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       pbuf_header
000012  b128              CBZ      r0,|L4.32|
;;;793        /* bail out */
;;;794        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
000014  bf00              NOP      
000016  bf00              NOP      
;;;795        LINK_STATS_INC(link.lenerr);
;;;796        return ERR_BUF;
000018  f06f0001          MVN      r0,#1
                  |L4.28|
;;;797      }
;;;798    
;;;799      /* assume unresolved Ethernet address */
;;;800      dest = NULL;
;;;801      /* Determine on destination hardware address. Broadcasts and multicasts
;;;802       * are special, other IP addresses are looked up in the ARP table. */
;;;803    
;;;804      /* broadcast destination IP address? */
;;;805      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;806        /* broadcast on Ethernet also */
;;;807        dest = (struct eth_addr *)&ethbroadcast;
;;;808      /* multicast destination IP address? */
;;;809      } else if (ip_addr_ismulticast(ipaddr)) {
;;;810        /* Hash IP multicast address to MAC address.*/
;;;811        mcastaddr.addr[0] = 0x01;
;;;812        mcastaddr.addr[1] = 0x00;
;;;813        mcastaddr.addr[2] = 0x5e;
;;;814        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;815        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;816        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;817        /* destination Ethernet address is multicast */
;;;818        dest = &mcastaddr;
;;;819      /* unicast destination IP address? */
;;;820      } else {
;;;821        /* outside local network? */
;;;822        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
;;;823          /* interface has default gateway? */
;;;824          if (netif->gw.addr != 0) {
;;;825            /* send to hardware address of default gateway IP address */
;;;826            ipaddr = &(netif->gw);
;;;827          /* no default gateway available */
;;;828          } else {
;;;829            /* no route to destination error (default gateway missing) */
;;;830            return ERR_RTE;
;;;831          }
;;;832        }
;;;833        /* queue on destination Ethernet address belonging to ipaddr */
;;;834        return etharp_query(netif, ipaddr, q);
;;;835      }
;;;836    
;;;837      /* continuation for multicast/broadcast destinations */
;;;838      /* obtain source Ethernet address of the given interface */
;;;839      /* send packet directly on the link */
;;;840      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;841    }
00001c  e8bd81fc          POP      {r2-r8,pc}
                  |L4.32|
000020  2700              MOVS     r7,#0                 ;800
000022  4621              MOV      r1,r4                 ;805
000024  4628              MOV      r0,r5                 ;805
000026  f7fffffe          BL       ip_addr_isbroadcast
00002a  b108              CBZ      r0,|L4.48|
00002c  4f25              LDR      r7,|L4.196|
00002e  e040              B        |L4.178|
                  |L4.48|
000030  f04f4070          MOV      r0,#0xf0000000        ;809
000034  f7fffffe          BL       ntohl
000038  6829              LDR      r1,[r5,#0]            ;809
00003a  ea000801          AND      r8,r0,r1              ;809
00003e  f04f4060          MOV      r0,#0xe0000000        ;809
000042  f7fffffe          BL       ntohl
000046  4580              CMP      r8,r0                 ;809
000048  d11d              BNE      |L4.134|
00004a  2001              MOVS     r0,#1                 ;811
00004c  f88d0000          STRB     r0,[sp,#0]            ;811
000050  2000              MOVS     r0,#0                 ;812
000052  f88d0001          STRB     r0,[sp,#1]            ;812
000056  205e              MOVS     r0,#0x5e              ;813
000058  f88d0002          STRB     r0,[sp,#2]            ;813
00005c  6828              LDR      r0,[r5,#0]            ;814
00005e  f7fffffe          BL       ntohl
000062  f3c04006          UBFX     r0,r0,#16,#7          ;814
000066  f88d0003          STRB     r0,[sp,#3]            ;814
00006a  6828              LDR      r0,[r5,#0]            ;815
00006c  f7fffffe          BL       ntohl
000070  0a00              LSRS     r0,r0,#8              ;815
000072  f88d0004          STRB     r0,[sp,#4]            ;815
000076  6828              LDR      r0,[r5,#0]            ;816
000078  f7fffffe          BL       ntohl
00007c  b2c0              UXTB     r0,r0                 ;816
00007e  f88d0005          STRB     r0,[sp,#5]            ;816
000082  466f              MOV      r7,sp                 ;818
000084  e015              B        |L4.178|
                  |L4.134|
000086  6828              LDR      r0,[r5,#0]            ;822
000088  68a1              LDR      r1,[r4,#8]            ;822
00008a  4008              ANDS     r0,r0,r1              ;822
00008c  e9d41201          LDRD     r1,r2,[r4,#4]         ;822
000090  4011              ANDS     r1,r1,r2              ;822
000092  4288              CMP      r0,r1                 ;822
000094  d007              BEQ      |L4.166|
000096  68e0              LDR      r0,[r4,#0xc]          ;824
000098  b110              CBZ      r0,|L4.160|
00009a  f104050c          ADD      r5,r4,#0xc            ;826
00009e  e002              B        |L4.166|
                  |L4.160|
0000a0  f06f0003          MVN      r0,#3                 ;830
0000a4  e7ba              B        |L4.28|
                  |L4.166|
0000a6  4632              MOV      r2,r6                 ;834
0000a8  4629              MOV      r1,r5                 ;834
0000aa  4620              MOV      r0,r4                 ;834
0000ac  f7fffffe          BL       etharp_query
0000b0  e7b4              B        |L4.28|
                  |L4.178|
0000b2  463b              MOV      r3,r7                 ;840
0000b4  f1040229          ADD      r2,r4,#0x29           ;840
0000b8  4631              MOV      r1,r6                 ;840
0000ba  4620              MOV      r0,r4                 ;840
0000bc  f7fffffe          BL       etharp_send_ip
0000c0  e7ac              B        |L4.28|
;;;842    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L4.196|
                          DCD      ethbroadcast

                          AREA ||i.etharp_query||, CODE, READONLY, ALIGN=2

                  etharp_query PROC
;;;876    err_t
;;;877    etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;878    {
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;879      struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
00000a  f1090a29          ADD      r10,r9,#0x29
;;;880      err_t result = ERR_MEM;
00000e  f04f30ff          MOV      r0,#0xffffffff
000012  9000              STR      r0,[sp,#0]
;;;881      s8_t i; /* ARP entry index */
;;;882    
;;;883      /* non-unicast address? */
;;;884      if (ip_addr_isbroadcast(ipaddr, netif) ||
000014  4649              MOV      r1,r9
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       ip_addr_isbroadcast
00001c  b978              CBNZ     r0,|L5.62|
;;;885          ip_addr_ismulticast(ipaddr) ||
00001e  f04f4070          MOV      r0,#0xf0000000
000022  f7fffffe          BL       ntohl
000026  6839              LDR      r1,[r7,#0]
000028  ea000501          AND      r5,r0,r1
00002c  f04f4060          MOV      r0,#0xe0000000
000030  f7fffffe          BL       ntohl
000034  4285              CMP      r5,r0
000036  d002              BEQ      |L5.62|
;;;886          ip_addr_isany(ipaddr)) {
000038  b10f              CBZ      r7,|L5.62|
00003a  6838              LDR      r0,[r7,#0]
00003c  b928              CBNZ     r0,|L5.74|
                  |L5.62|
;;;887        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
00003e  bf00              NOP      
000040  bf00              NOP      
;;;888        return ERR_ARG;
000042  f06f0009          MVN      r0,#9
                  |L5.70|
;;;889      }
;;;890    
;;;891      /* find entry in ARP cache, ask to create entry if queueing packet */
;;;892    #if LWIP_NETIF_HWADDRHINT
;;;893      i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
;;;894    #else /* LWIP_NETIF_HWADDRHINT */
;;;895      i = find_entry(ipaddr, ETHARP_TRY_HARD);
;;;896    #endif /* LWIP_NETIF_HWADDRHINT */
;;;897    
;;;898      /* could not find or create entry? */
;;;899      if (i < 0) {
;;;900        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;901        if (q) {
;;;902          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;903          ETHARP_STATS_INC(etharp.memerr);
;;;904        }
;;;905        return (err_t)i;
;;;906      }
;;;907    
;;;908      /* mark a fresh entry as pending (we just sent a request) */
;;;909      if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;910        arp_table[i].state = ETHARP_STATE_PENDING;
;;;911      }
;;;912    
;;;913      /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;914      LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;915      ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;916       (arp_table[i].state == ETHARP_STATE_STABLE)));
;;;917    
;;;918      /* do we have a pending entry? or an implicit query request? */
;;;919      if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;920        /* try to resolve it; send out ARP request */
;;;921        result = etharp_request(netif, ipaddr);
;;;922        if (result != ERR_OK) {
;;;923          /* ARP request couldn't be sent */
;;;924          /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;925             since this failure could be temporary, and the next packet calling
;;;926             etharp_query again could lead to sending the queued packets. */
;;;927        }
;;;928      }
;;;929      
;;;930      /* packet given? */
;;;931      if (q != NULL) {
;;;932        /* stable entry? */
;;;933        if (arp_table[i].state == ETHARP_STATE_STABLE) {
;;;934          /* we have a valid IP->Ethernet address mapping */
;;;935          /* send the packet */
;;;936          result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;937        /* pending entry? (either just created or already pending */
;;;938        } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;939    #if ARP_QUEUEING /* queue the given q packet */
;;;940          struct pbuf *p;
;;;941          int copy_needed = 0;
;;;942          /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;943           * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;944           * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;945          p = q;
;;;946          while (p) {
;;;947            LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;948            if(p->type != PBUF_ROM) {
;;;949              copy_needed = 1;
;;;950              break;
;;;951            }
;;;952            p = p->next;
;;;953          }
;;;954          if(copy_needed) {
;;;955            /* copy the whole packet into new pbufs */
;;;956            p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;957            if(p != NULL) {
;;;958              if (pbuf_copy(p, q) != ERR_OK) {
;;;959                pbuf_free(p);
;;;960                p = NULL;
;;;961              }
;;;962            }
;;;963          } else {
;;;964            /* referencing the old pbuf is enough */
;;;965            p = q;
;;;966            pbuf_ref(p);
;;;967          }
;;;968          /* packet could be taken over? */
;;;969          if (p != NULL) {
;;;970            /* queue packet ... */
;;;971            struct etharp_q_entry *new_entry;
;;;972            /* allocate a new arp queue entry */
;;;973            new_entry = memp_malloc(MEMP_ARP_QUEUE);
;;;974            if (new_entry != NULL) {
;;;975              new_entry->next = 0;
;;;976              new_entry->p = p;
;;;977              if(arp_table[i].q != NULL) {
;;;978                /* queue was already existent, append the new entry to the end */
;;;979                struct etharp_q_entry *r;
;;;980                r = arp_table[i].q;
;;;981                while (r->next != NULL) {
;;;982                  r = r->next;
;;;983                }
;;;984                r->next = new_entry;
;;;985              } else {
;;;986                /* queue did not exist, first item in queue */
;;;987                arp_table[i].q = new_entry;
;;;988              }
;;;989              LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;990              result = ERR_OK;
;;;991            } else {
;;;992              /* the pool MEMP_ARP_QUEUE is empty */
;;;993              pbuf_free(p);
;;;994              LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;995              /* { result == ERR_MEM } through initialization */
;;;996            }
;;;997          } else {
;;;998            ETHARP_STATS_INC(etharp.memerr);
;;;999            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1000           /* { result == ERR_MEM } through initialization */
;;;1001         }
;;;1002   #else /* ARP_QUEUEING == 0 */
;;;1003         /* q && state == PENDING && ARP_QUEUEING == 0 => result = ERR_MEM */
;;;1004         /* { result == ERR_MEM } through initialization */
;;;1005         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
;;;1006   #endif
;;;1007       }
;;;1008     }
;;;1009     return result;
;;;1010   }
000046  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.74|
00004a  2101              MOVS     r1,#1                 ;895
00004c  4638              MOV      r0,r7                 ;895
00004e  f7fffffe          BL       find_entry
000052  4604              MOV      r4,r0                 ;895
000054  2c00              CMP      r4,#0                 ;899
000056  da06              BGE      |L5.102|
000058  bf00              NOP                            ;900
00005a  bf00              NOP                            ;900
00005c  b10e              CBZ      r6,|L5.98|
00005e  bf00              NOP                            ;902
000060  bf00              NOP                            ;902
                  |L5.98|
000062  4620              MOV      r0,r4                 ;905
000064  e7ef              B        |L5.70|
                  |L5.102|
000066  eb040084          ADD      r0,r4,r4,LSL #2       ;909
00006a  494a              LDR      r1,|L5.404|
00006c  eb010080          ADD      r0,r1,r0,LSL #2       ;909
000070  7b80              LDRB     r0,[r0,#0xe]          ;909
000072  b930              CBNZ     r0,|L5.130|
000074  2001              MOVS     r0,#1                 ;910
000076  eb040184          ADD      r1,r4,r4,LSL #2       ;910
00007a  4a46              LDR      r2,|L5.404|
00007c  eb020181          ADD      r1,r2,r1,LSL #2       ;910
000080  7388              STRB     r0,[r1,#0xe]          ;910
                  |L5.130|
000082  eb040084          ADD      r0,r4,r4,LSL #2       ;919
000086  4943              LDR      r1,|L5.404|
000088  eb010080          ADD      r0,r1,r0,LSL #2       ;919
00008c  7b80              LDRB     r0,[r0,#0xe]          ;919
00008e  2801              CMP      r0,#1                 ;919
000090  d000              BEQ      |L5.148|
000092  b92e              CBNZ     r6,|L5.160|
                  |L5.148|
000094  4639              MOV      r1,r7                 ;921
000096  4648              MOV      r0,r9                 ;921
000098  f7fffffe          BL       etharp_request
00009c  9000              STR      r0,[sp,#0]            ;921
00009e  bf00              NOP                            ;922
                  |L5.160|
0000a0  b3f6              CBZ      r6,|L5.288|
0000a2  eb040084          ADD      r0,r4,r4,LSL #2       ;933
0000a6  493b              LDR      r1,|L5.404|
0000a8  eb010080          ADD      r0,r1,r0,LSL #2       ;933
0000ac  7b80              LDRB     r0,[r0,#0xe]          ;933
0000ae  2802              CMP      r0,#2                 ;933
0000b0  d10c              BNE      |L5.204|
0000b2  eb040084          ADD      r0,r4,r4,LSL #2       ;936
0000b6  eb010080          ADD      r0,r1,r0,LSL #2       ;936
0000ba  f1000308          ADD      r3,r0,#8              ;936
0000be  4652              MOV      r2,r10                ;936
0000c0  4631              MOV      r1,r6                 ;936
0000c2  4648              MOV      r0,r9                 ;936
0000c4  f7fffffe          BL       etharp_send_ip
0000c8  9000              STR      r0,[sp,#0]            ;936
0000ca  e061              B        |L5.400|
                  |L5.204|
0000cc  eb040084          ADD      r0,r4,r4,LSL #2       ;938
0000d0  4930              LDR      r1,|L5.404|
0000d2  eb010080          ADD      r0,r1,r0,LSL #2       ;938
0000d6  7b80              LDRB     r0,[r0,#0xe]          ;938
0000d8  2801              CMP      r0,#1                 ;938
0000da  d159              BNE      |L5.400|
0000dc  f04f0b00          MOV      r11,#0                ;941
0000e0  4635              MOV      r5,r6                 ;945
0000e2  e006              B        |L5.242|
                  |L5.228|
0000e4  7b28              LDRB     r0,[r5,#0xc]          ;948
0000e6  2801              CMP      r0,#1                 ;948
0000e8  d002              BEQ      |L5.240|
0000ea  f04f0b01          MOV      r11,#1                ;949
0000ee  e002              B        |L5.246|
                  |L5.240|
0000f0  682d              LDR      r5,[r5,#0]            ;952
                  |L5.242|
0000f2  2d00              CMP      r5,#0                 ;946
0000f4  d1f6              BNE      |L5.228|
                  |L5.246|
0000f6  bf00              NOP                            ;950
0000f8  f1bb0f00          CMP      r11,#0                ;954
0000fc  d011              BEQ      |L5.290|
0000fe  8929              LDRH     r1,[r5,#8]            ;956
000100  2200              MOVS     r2,#0                 ;956
000102  2003              MOVS     r0,#3                 ;956
000104  f7fffffe          BL       pbuf_alloc
000108  4605              MOV      r5,r0                 ;956
00010a  b175              CBZ      r5,|L5.298|
00010c  4631              MOV      r1,r6                 ;958
00010e  4628              MOV      r0,r5                 ;958
000110  f7fffffe          BL       pbuf_copy
000114  b148              CBZ      r0,|L5.298|
000116  4628              MOV      r0,r5                 ;959
000118  f7fffffe          BL       pbuf_free
00011c  2500              MOVS     r5,#0                 ;960
00011e  e004              B        |L5.298|
                  |L5.288|
000120  e036              B        |L5.400|
                  |L5.290|
000122  4635              MOV      r5,r6                 ;965
000124  4628              MOV      r0,r5                 ;966
000126  f7fffffe          BL       pbuf_ref
                  |L5.298|
00012a  b375              CBZ      r5,|L5.394|
00012c  2006              MOVS     r0,#6                 ;973
00012e  f7fffffe          BL       memp_malloc
000132  4680              MOV      r8,r0                 ;973
000134  f1b80f00          CMP      r8,#0                 ;974
000138  d021              BEQ      |L5.382|
00013a  2000              MOVS     r0,#0                 ;975
00013c  f8c80000          STR      r0,[r8,#0]            ;975
000140  f8c85004          STR      r5,[r8,#4]            ;976
000144  eb040084          ADD      r0,r4,r4,LSL #2       ;977
000148  4912              LDR      r1,|L5.404|
00014a  f8510020          LDR      r0,[r1,r0,LSL #2]     ;977
00014e  b160              CBZ      r0,|L5.362|
000150  eb040184          ADD      r1,r4,r4,LSL #2       ;980
000154  4a0f              LDR      r2,|L5.404|
000156  f8520021          LDR      r0,[r2,r1,LSL #2]     ;980
00015a  e000              B        |L5.350|
                  |L5.348|
00015c  6800              LDR      r0,[r0,#0]            ;982
                  |L5.350|
00015e  6801              LDR      r1,[r0,#0]            ;981
000160  2900              CMP      r1,#0                 ;981
000162  d1fb              BNE      |L5.348|
000164  f8c08000          STR      r8,[r0,#0]            ;984
000168  e004              B        |L5.372|
                  |L5.362|
00016a  eb040084          ADD      r0,r4,r4,LSL #2       ;987
00016e  4909              LDR      r1,|L5.404|
000170  f8418020          STR      r8,[r1,r0,LSL #2]     ;987
                  |L5.372|
000174  bf00              NOP                            ;989
000176  bf00              NOP                            ;989
000178  2000              MOVS     r0,#0                 ;990
00017a  9000              STR      r0,[sp,#0]            ;990
00017c  e004              B        |L5.392|
                  |L5.382|
00017e  4628              MOV      r0,r5                 ;993
000180  f7fffffe          BL       pbuf_free
000184  bf00              NOP                            ;994
000186  bf00              NOP                            ;994
                  |L5.392|
000188  e001              B        |L5.398|
                  |L5.394|
00018a  bf00              NOP                            ;999
00018c  bf00              NOP                            ;999
                  |L5.398|
00018e  bf00              NOP                            ;1007
                  |L5.400|
000190  9800              LDR      r0,[sp,#0]            ;1009
000192  e758              B        |L5.70|
;;;1011   
                          ENDP

                  |L5.404|
                          DCD      arp_table

                          AREA ||i.etharp_raw||, CODE, READONLY, ALIGN=1

                  etharp_raw PROC
;;;1030   err_t
;;;1031   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1032              const struct eth_addr *ethdst_addr,
;;;1033              const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
;;;1034              const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
;;;1035              const u16_t opcode)
;;;1036   {
000004  b081              SUB      sp,sp,#4
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  f8ddb038          LDR      r11,[sp,#0x38]
;;;1037     struct pbuf *p;
;;;1038     err_t result = ERR_OK;
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
;;;1039     u8_t k; /* ARP entry index */
;;;1040     struct etharp_hdr *hdr;
;;;1041   #if LWIP_AUTOIP
;;;1042     const u8_t * ethdst_hwaddr;
;;;1043   #endif /* LWIP_AUTOIP */
;;;1044   
;;;1045     /* allocate a pbuf for the outgoing ARP request packet */
;;;1046     p = pbuf_alloc(PBUF_RAW, sizeof(struct etharp_hdr), PBUF_RAM);
000016  2200              MOVS     r2,#0
000018  212a              MOVS     r1,#0x2a
00001a  2003              MOVS     r0,#3
00001c  f7fffffe          BL       pbuf_alloc
000020  4606              MOV      r6,r0
;;;1047     /* could allocate a pbuf for an ARP request? */
;;;1048     if (p == NULL) {
000022  b936              CBNZ     r6,|L6.50|
;;;1049       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
000024  bf00              NOP      
000026  bf00              NOP      
;;;1050       ETHARP_STATS_INC(etharp.memerr);
;;;1051       return ERR_MEM;
000028  f04f30ff          MOV      r0,#0xffffffff
                  |L6.44|
;;;1052     }
;;;1053     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
;;;1054                 (p->len >= sizeof(struct etharp_hdr)));
;;;1055   
;;;1056     hdr = p->payload;
;;;1057     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1058     hdr->opcode = htons(opcode);
;;;1059   
;;;1060     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1061                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1062     k = ETHARP_HWADDR_LEN;
;;;1063   #if LWIP_AUTOIP
;;;1064     /* If we are using Link-Local, ARP packets must be broadcast on the
;;;1065      * link layer. (See RFC3927 Section 2.5) */
;;;1066     ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1067   #endif /* LWIP_AUTOIP */
;;;1068     /* Write MAC-Addresses (combined loop for both headers) */
;;;1069     while(k > 0) {
;;;1070       k--;
;;;1071       /* Write the ARP MAC-Addresses */
;;;1072       hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
;;;1073       hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
;;;1074       /* Write the Ethernet MAC-Addresses */
;;;1075   #if LWIP_AUTOIP
;;;1076       hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
;;;1077   #else  /* LWIP_AUTOIP */
;;;1078       hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
;;;1079   #endif /* LWIP_AUTOIP */
;;;1080       hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
;;;1081     }
;;;1082     hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
;;;1083     hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
;;;1084   
;;;1085     hdr->hwtype = htons(HWTYPE_ETHERNET);
;;;1086     hdr->proto = htons(ETHTYPE_IP);
;;;1087     /* set hwlen and protolen together */
;;;1088     hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
;;;1089   
;;;1090     hdr->ethhdr.type = htons(ETHTYPE_ARP);
;;;1091     /* send ARP query */
;;;1092     result = netif->linkoutput(netif, p);
;;;1093     ETHARP_STATS_INC(etharp.xmit);
;;;1094     /* free ARP query packet */
;;;1095     pbuf_free(p);
;;;1096     p = NULL;
;;;1097     /* could not allocate pbuf for ARP request */
;;;1098   
;;;1099     return result;
;;;1100   }
00002c  b005              ADD      sp,sp,#0x14
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.50|
000032  6874              LDR      r4,[r6,#4]            ;1056
000034  bf00              NOP                            ;1057
000036  bf00              NOP                            ;1057
000038  9811              LDR      r0,[sp,#0x44]         ;1058
00003a  f7fffffe          BL       htons
00003e  82a0              STRH     r0,[r4,#0x14]         ;1058
000040  2506              MOVS     r5,#6                 ;1062
000042  e012              B        |L6.106|
                  |L6.68|
000044  1e68              SUBS     r0,r5,#1              ;1070
000046  b2c5              UXTB     r5,r0                 ;1070
000048  f81a1005          LDRB     r1,[r10,r5]           ;1072
00004c  f1040016          ADD      r0,r4,#0x16           ;1072
000050  5541              STRB     r1,[r0,r5]            ;1072
000052  980f              LDR      r0,[sp,#0x3c]         ;1073
000054  5d41              LDRB     r1,[r0,r5]            ;1073
000056  f1040020          ADD      r0,r4,#0x20           ;1073
00005a  5541              STRB     r1,[r0,r5]            ;1073
00005c  f8190005          LDRB     r0,[r9,r5]            ;1078
000060  5560              STRB     r0,[r4,r5]            ;1078
000062  f8181005          LDRB     r1,[r8,r5]            ;1080
000066  1da0              ADDS     r0,r4,#6              ;1080
000068  5541              STRB     r1,[r0,r5]            ;1080
                  |L6.106|
00006a  2d00              CMP      r5,#0                 ;1069
00006c  dcea              BGT      |L6.68|
00006e  f8db0000          LDR      r0,[r11,#0]           ;1082
000072  61e0              STR      r0,[r4,#0x1c]         ;1082
000074  9810              LDR      r0,[sp,#0x40]         ;1083
000076  6800              LDR      r0,[r0,#0]            ;1083
000078  f8c40026          STR      r0,[r4,#0x26]         ;1083
00007c  2001              MOVS     r0,#1                 ;1085
00007e  f7fffffe          BL       htons
000082  81e0              STRH     r0,[r4,#0xe]          ;1085
000084  f44f6000          MOV      r0,#0x800             ;1086
000088  f7fffffe          BL       htons
00008c  8220              STRH     r0,[r4,#0x10]         ;1086
00008e  f2406004          MOV      r0,#0x604             ;1088
000092  f7fffffe          BL       htons
000096  8260              STRH     r0,[r4,#0x12]         ;1088
000098  f6400006          MOV      r0,#0x806             ;1090
00009c  f7fffffe          BL       htons
0000a0  81a0              STRH     r0,[r4,#0xc]          ;1090
0000a2  4631              MOV      r1,r6                 ;1092
0000a4  4638              MOV      r0,r7                 ;1092
0000a6  69ba              LDR      r2,[r7,#0x18]         ;1092
0000a8  4790              BLX      r2                    ;1092
0000aa  9000              STR      r0,[sp,#0]            ;1092
0000ac  4630              MOV      r0,r6                 ;1095
0000ae  f7fffffe          BL       pbuf_free
0000b2  2600              MOVS     r6,#0                 ;1096
0000b4  9800              LDR      r0,[sp,#0]            ;1099
0000b6  e7b9              B        |L6.44|
;;;1101   
                          ENDP


                          AREA ||i.etharp_request||, CODE, READONLY, ALIGN=2

                  etharp_request PROC
;;;1111   err_t
;;;1112   etharp_request(struct netif *netif, struct ip_addr *ipaddr)
000000  b57f              PUSH     {r0-r6,lr}
;;;1113   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1114     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
000006  bf00              NOP      
000008  bf00              NOP      
;;;1115     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
00000a  2301              MOVS     r3,#1
00000c  4906              LDR      r1,|L7.40|
00000e  1d20              ADDS     r0,r4,#4
000010  e88d0023          STM      sp,{r0,r1,r5}
000014  9303              STR      r3,[sp,#0xc]
000016  f1040329          ADD      r3,r4,#0x29
00001a  4a04              LDR      r2,|L7.44|
00001c  4619              MOV      r1,r3
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       etharp_raw
;;;1116                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1117                       ipaddr, ARP_REQUEST);
;;;1118   }
000024  b004              ADD      sp,sp,#0x10
000026  bd70              POP      {r4-r6,pc}
;;;1119   #include "common.h"
                          ENDP

                  |L7.40|
                          DCD      ethzero
                  |L7.44|
                          DCD      ethbroadcast

                          AREA ||i.etharp_send_ip||, CODE, READONLY, ALIGN=1

                  etharp_send_ip PROC
;;;430    static err_t
;;;431    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;432    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;433      struct eth_hdr *ethhdr = p->payload;
00000c  687d              LDR      r5,[r7,#4]
;;;434      u8_t k;
;;;435    
;;;436      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;437                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;438      k = ETHARP_HWADDR_LEN;
00000e  2406              MOVS     r4,#6
;;;439      while(k > 0) {
000010  e008              B        |L8.36|
                  |L8.18|
;;;440        k--;
000012  1e60              SUBS     r0,r4,#1
000014  b2c4              UXTB     r4,r0
;;;441        ethhdr->dest.addr[k] = dst->addr[k];
000016  f8190004          LDRB     r0,[r9,r4]
00001a  5528              STRB     r0,[r5,r4]
;;;442        ethhdr->src.addr[k]  = src->addr[k];
00001c  f8181004          LDRB     r1,[r8,r4]
000020  1da8              ADDS     r0,r5,#6
000022  5501              STRB     r1,[r0,r4]
                  |L8.36|
000024  2c00              CMP      r4,#0                 ;439
000026  dcf4              BGT      |L8.18|
;;;443      }
;;;444      ethhdr->type = htons(ETHTYPE_IP);
000028  f44f6000          MOV      r0,#0x800
00002c  f7fffffe          BL       htons
000030  81a8              STRH     r0,[r5,#0xc]
;;;445      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
000032  bf00              NOP      
000034  bf00              NOP      
;;;446      /* send the packet */
;;;447      return netif->linkoutput(netif, p);
000036  4639              MOV      r1,r7
000038  4630              MOV      r0,r6
00003a  69b2              LDR      r2,[r6,#0x18]
00003c  4790              BLX      r2
;;;448    }
00003e  e8bd87f0          POP      {r4-r10,pc}
;;;449    
                          ENDP


                          AREA ||i.etharp_tmr||, CODE, READONLY, ALIGN=2

                  etharp_tmr PROC
;;;167    void
;;;168    etharp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170      u8_t i;
;;;171    
;;;172      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
000002  bf00              NOP      
000004  bf00              NOP      
;;;173      /* remove expired entries from the ARP table */
;;;174      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000006  2400              MOVS     r4,#0
000008  e04a              B        |L9.160|
                  |L9.10|
;;;175        arp_table[i].ctime++;
00000a  eb040084          ADD      r0,r4,r4,LSL #2
00000e  4926              LDR      r1,|L9.168|
000010  eb010080          ADD      r0,r1,r0,LSL #2
000014  7bc0              LDRB     r0,[r0,#0xf]
000016  1c40              ADDS     r0,r0,#1
000018  eb040184          ADD      r1,r4,r4,LSL #2
00001c  4a22              LDR      r2,|L9.168|
00001e  eb020181          ADD      r1,r2,r1,LSL #2
000022  73c8              STRB     r0,[r1,#0xf]
;;;176        if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  4611              MOV      r1,r2
00002a  eb010080          ADD      r0,r1,r0,LSL #2
00002e  7b80              LDRB     r0,[r0,#0xe]
000030  2802              CMP      r0,#2
000032  d106              BNE      |L9.66|
;;;177             (arp_table[i].ctime >= ARP_MAXAGE)) ||
000034  eb040084          ADD      r0,r4,r4,LSL #2
000038  eb010080          ADD      r0,r1,r0,LSL #2
00003c  7bc0              LDRB     r0,[r0,#0xf]
00003e  28f0              CMP      r0,#0xf0
000040  da0e              BGE      |L9.96|
                  |L9.66|
;;;178            ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
000042  eb040084          ADD      r0,r4,r4,LSL #2
000046  4918              LDR      r1,|L9.168|
000048  eb010080          ADD      r0,r1,r0,LSL #2
00004c  7b80              LDRB     r0,[r0,#0xe]
00004e  2801              CMP      r0,#1
000050  d124              BNE      |L9.156|
;;;179             (arp_table[i].ctime >= ARP_MAXPENDING))) {
000052  eb040084          ADD      r0,r4,r4,LSL #2
000056  eb010080          ADD      r0,r1,r0,LSL #2
00005a  7bc0              LDRB     r0,[r0,#0xf]
00005c  2802              CMP      r0,#2
00005e  db1d              BLT      |L9.156|
                  |L9.96|
;;;180             /* pending or stable entry has become old! */
;;;181          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
000060  bf00              NOP      
000062  bf00              NOP      
;;;182               arp_table[i].state == ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;183          /* clean up entries that have just been expired */
;;;184          /* remove from SNMP ARP index tree */
;;;185          snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;186    #if ARP_QUEUEING
;;;187          /* and empty packet queue */
;;;188          if (arp_table[i].q != NULL) {
000064  eb040084          ADD      r0,r4,r4,LSL #2
000068  490f              LDR      r1,|L9.168|
00006a  f8510020          LDR      r0,[r1,r0,LSL #2]
00006e  b170              CBZ      r0,|L9.142|
;;;189            /* remove all queued packets */
;;;190            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
000070  bf00              NOP      
000072  bf00              NOP      
;;;191            free_etharp_q(arp_table[i].q);
000074  eb040184          ADD      r1,r4,r4,LSL #2
000078  4a0b              LDR      r2,|L9.168|
00007a  f8520021          LDR      r0,[r2,r1,LSL #2]
00007e  f7fffffe          BL       free_etharp_q
;;;192            arp_table[i].q = NULL;
000082  2000              MOVS     r0,#0
000084  eb040184          ADD      r1,r4,r4,LSL #2
000088  4a07              LDR      r2,|L9.168|
00008a  f8420021          STR      r0,[r2,r1,LSL #2]
                  |L9.142|
;;;193          }
;;;194    #endif
;;;195          /* recycle entry for re-use */      
;;;196          arp_table[i].state = ETHARP_STATE_EMPTY;
00008e  2000              MOVS     r0,#0
000090  eb040184          ADD      r1,r4,r4,LSL #2
000094  4a04              LDR      r2,|L9.168|
000096  eb020181          ADD      r1,r2,r1,LSL #2
00009a  7388              STRB     r0,[r1,#0xe]
                  |L9.156|
00009c  1c60              ADDS     r0,r4,#1              ;174
00009e  b2c4              UXTB     r4,r0                 ;174
                  |L9.160|
0000a0  2c0a              CMP      r4,#0xa               ;174
0000a2  dbb2              BLT      |L9.10|
;;;197        }
;;;198    #if ARP_QUEUEING
;;;199        /* still pending entry? (not expired) */
;;;200        if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;201            /* resend an ARP query here? */
;;;202        }
;;;203    #endif
;;;204      }
;;;205    }
0000a4  bd10              POP      {r4,pc}
;;;206    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L9.168|
                          DCD      arp_table

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  ethernet_input PROC
;;;1128   err_t
;;;1129   ethernet_input(struct pbuf *p, struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1130   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1131     struct eth_hdr* ethhdr;
;;;1132     /* points to packet payload, which starts with an Ethernet header */
;;;1133     ethhdr = p->payload;
000008  6866              LDR      r6,[r4,#4]
;;;1134     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1135       ("ethernet_input: dest:%02x:%02x:%02x:%02x:%02x:%02x, src:%02x:%02x:%02x:%02x:%02x:%02x, type:%2hx\n",
;;;1136        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1137        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1138        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1139        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1140        (unsigned)htons(ethhdr->type)));
;;;1141   
;;;1142     switch (htons(ethhdr->type)) {
00000e  89b0              LDRH     r0,[r6,#0xc]
000010  f7fffffe          BL       htons
000014  f5b06f00          CMP      r0,#0x800
000018  d004              BEQ      |L10.36|
00001a  f5a06000          SUB      r0,r0,#0x800
00001e  3806              SUBS     r0,#6
000020  d11b              BNE      |L10.90|
000022  e013              B        |L10.76|
                  |L10.36|
;;;1143       /* IP packet? */
;;;1144       case ETHTYPE_IP:
;;;1145   #if ETHARP_TRUST_IP_MAC
;;;1146         /* update ARP table */
;;;1147         etharp_ip_input(netif, p);
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       etharp_ip_input
;;;1148   #endif /* ETHARP_TRUST_IP_MAC */
;;;1149         /* skip Ethernet header */
;;;1150         if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
00002c  f06f010d          MVN      r1,#0xd
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       pbuf_header
000036  b120              CBZ      r0,|L10.66|
;;;1151           LWIP_ASSERT("Can't move over header in packet", 0);
;;;1152           pbuf_free(p);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       pbuf_free
;;;1153           p = NULL;
00003e  2400              MOVS     r4,#0
000040  e003              B        |L10.74|
                  |L10.66|
;;;1154         } else {
;;;1155           /* pass to IP layer */
;;;1156           ip_input(p, netif);
000042  4629              MOV      r1,r5
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       ip_input
                  |L10.74|
;;;1157         }
;;;1158         break;
00004a  e013              B        |L10.116|
                  |L10.76|
;;;1159         
;;;1160       case ETHTYPE_ARP:
;;;1161         /* pass p to ARP module */
;;;1162         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
00004c  4622              MOV      r2,r4
00004e  f1050129          ADD      r1,r5,#0x29
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       etharp_arp_input
;;;1163         break;
000058  e00c              B        |L10.116|
                  |L10.90|
;;;1164   
;;;1165   #if PPPOE_SUPPORT
;;;1166       case ETHTYPE_PPPOEDISC: /* PPP Over Ethernet Discovery Stage */
;;;1167         pppoe_disc_input(netif, p);
;;;1168         break;
;;;1169   
;;;1170       case ETHTYPE_PPPOE: /* PPP Over Ethernet Session Stage */
;;;1171         pppoe_data_input(netif, p);
;;;1172         break;
;;;1173   #endif /* PPPOE_SUPPORT */
;;;1174   
;;;1175       default:
;;;1176         printf("type=0x%x)!\n",htons(ethhdr->type));
00005a  89b0              LDRH     r0,[r6,#0xc]
00005c  f7fffffe          BL       htons
000060  4607              MOV      r7,r0
000062  4601              MOV      r1,r0
000064  a005              ADR      r0,|L10.124|
000066  f7fffffe          BL       __2printf
;;;1177   	  #if WPA_ENABLE == 1
;;;1178   	  ETHARP_STATS_INC_P();
;;;1179   	  #endif
;;;1180         ETHARP_STATS_INC(etharp.proterr);
;;;1181         ETHARP_STATS_INC(etharp.drop);
;;;1182         pbuf_free(p);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       pbuf_free
;;;1183         p = NULL;
000070  2400              MOVS     r4,#0
;;;1184         break;
000072  bf00              NOP      
                  |L10.116|
000074  bf00              NOP                            ;1158
;;;1185     }
;;;1186   
;;;1187     /* This means the pbuf is freed or consumed,
;;;1188        so the caller doesn't have to free it again */
;;;1189     return ERR_OK;
000076  2000              MOVS     r0,#0
;;;1190   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;1191   #endif /* LWIP_ARP */
                          ENDP

                  |L10.124|
00007c  74797065          DCB      "type=0x%x)!\n",0
000080  3d307825
000084  7829210a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.find_entry||, CODE, READONLY, ALIGN=2

                  find_entry PROC
;;;232    #else /* LWIP_NETIF_HWADDRHINT */
;;;233    find_entry(struct ip_addr *ipaddr, u8_t flags)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;234    #endif /* LWIP_NETIF_HWADDRHINT */
;;;235    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;236      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
000008  f04f080a          MOV      r8,#0xa
00000c  46c1              MOV      r9,r8
;;;237      s8_t empty = ARP_TABLE_SIZE;
00000e  260a              MOVS     r6,#0xa
;;;238      u8_t i = 0, age_pending = 0, age_stable = 0;
000010  2400              MOVS     r4,#0
000012  46a3              MOV      r11,r4
000014  2000              MOVS     r0,#0
000016  9001              STR      r0,[sp,#4]
;;;239    #if ARP_QUEUEING
;;;240      /* oldest entry with packets on queue */
;;;241      s8_t old_queue = ARP_TABLE_SIZE;
000018  46b2              MOV      r10,r6
;;;242      /* its age */
;;;243      u8_t age_queue = 0;
00001a  9000              STR      r0,[sp,#0]
;;;244    #endif
;;;245    
;;;246      /* First, test if the last call to this function asked for the
;;;247       * same address. If so, we're really fast! */
;;;248      if (ipaddr) {
00001c  b1cd              CBZ      r5,|L11.82|
;;;249        /* ipaddr to search for was given */
;;;250    #if LWIP_NETIF_HWADDRHINT
;;;251        if ((netif != NULL) && (netif->addr_hint != NULL)) {
;;;252          /* per-pcb cached entry was given */
;;;253          u8_t per_pcb_cache = *(netif->addr_hint);
;;;254          if ((per_pcb_cache < ARP_TABLE_SIZE) && arp_table[per_pcb_cache].state == ETHARP_STATE_STABLE) {
;;;255            /* the per-pcb-cached entry is stable */
;;;256            if (ip_addr_cmp(ipaddr, &arp_table[per_pcb_cache].ipaddr)) {
;;;257              /* per-pcb cached entry was the right one! */
;;;258              ETHARP_STATS_INC(etharp.cachehit);
;;;259              return per_pcb_cache;
;;;260            }
;;;261          }
;;;262        }
;;;263    #else /* #if LWIP_NETIF_HWADDRHINT */
;;;264        if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
00001e  4876              LDR      r0,|L11.504|
000020  7800              LDRB     r0,[r0,#0]  ; etharp_cached_entry
000022  eb000080          ADD      r0,r0,r0,LSL #2
000026  4975              LDR      r1,|L11.508|
000028  eb010080          ADD      r0,r1,r0,LSL #2
00002c  7b80              LDRB     r0,[r0,#0xe]
00002e  2802              CMP      r0,#2
000030  d10f              BNE      |L11.82|
;;;265          /* the cached entry is stable */
;;;266          if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
000032  6828              LDR      r0,[r5,#0]
000034  4970              LDR      r1,|L11.504|
000036  7809              LDRB     r1,[r1,#0]  ; etharp_cached_entry
000038  eb010181          ADD      r1,r1,r1,LSL #2
00003c  4a6f              LDR      r2,|L11.508|
00003e  eb020181          ADD      r1,r2,r1,LSL #2
000042  6849              LDR      r1,[r1,#4]
000044  4288              CMP      r0,r1
000046  d104              BNE      |L11.82|
;;;267            /* cached entry was the right one! */
;;;268            ETHARP_STATS_INC(etharp.cachehit);
;;;269            return etharp_cached_entry;
000048  486b              LDR      r0,|L11.504|
00004a  7800              LDRB     r0,[r0,#0]  ; etharp_cached_entry
00004c  b240              SXTB     r0,r0
                  |L11.78|
;;;270          }
;;;271        }
;;;272    #endif /* #if LWIP_NETIF_HWADDRHINT */
;;;273      }
;;;274    
;;;275      /**
;;;276       * a) do a search through the cache, remember candidates
;;;277       * b) select candidate entry
;;;278       * c) create new entry
;;;279       */
;;;280    
;;;281      /* a) in a single search sweep, do all of this
;;;282       * 1) remember the first empty entry (if any)
;;;283       * 2) remember the oldest stable entry (if any)
;;;284       * 3) remember the oldest pending entry without queued packets (if any)
;;;285       * 4) remember the oldest pending entry with queued packets (if any)
;;;286       * 5) search for a matching IP entry, either pending or stable
;;;287       *    until 5 matches, or all entries are searched for.
;;;288       */
;;;289    
;;;290      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;291        /* no empty entry found yet and now we do find one? */
;;;292        if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
;;;293          LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
;;;294          /* remember first empty entry */
;;;295          empty = i;
;;;296        }
;;;297        /* pending entry? */
;;;298        else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;299          /* if given, does IP address match IP address in ARP entry? */
;;;300          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
;;;301            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
;;;302            /* found exact IP address match, simply bail out */
;;;303    #if LWIP_NETIF_HWADDRHINT
;;;304            NETIF_SET_HINT(netif, i);
;;;305    #else /* #if LWIP_NETIF_HWADDRHINT */
;;;306            etharp_cached_entry = i;
;;;307    #endif /* #if LWIP_NETIF_HWADDRHINT */
;;;308            return i;
;;;309    #if ARP_QUEUEING
;;;310          /* pending with queued packets? */
;;;311          } else if (arp_table[i].q != NULL) {
;;;312            if (arp_table[i].ctime >= age_queue) {
;;;313              old_queue = i;
;;;314              age_queue = arp_table[i].ctime;
;;;315            }
;;;316    #endif
;;;317          /* pending without queued packets? */
;;;318          } else {
;;;319            if (arp_table[i].ctime >= age_pending) {
;;;320              old_pending = i;
;;;321              age_pending = arp_table[i].ctime;
;;;322            }
;;;323          }        
;;;324        }
;;;325        /* stable entry? */
;;;326        else if (arp_table[i].state == ETHARP_STATE_STABLE) {
;;;327          /* if given, does IP address match IP address in ARP entry? */
;;;328          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
;;;329            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
;;;330            /* found exact IP address match, simply bail out */
;;;331    #if LWIP_NETIF_HWADDRHINT
;;;332            NETIF_SET_HINT(netif, i);
;;;333    #else /* #if LWIP_NETIF_HWADDRHINT */
;;;334            etharp_cached_entry = i;
;;;335    #endif /* #if LWIP_NETIF_HWADDRHINT */
;;;336            return i;
;;;337          /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;338          } else if (arp_table[i].ctime >= age_stable) {
;;;339            old_stable = i;
;;;340            age_stable = arp_table[i].ctime;
;;;341          }
;;;342        }
;;;343      }
;;;344      /* { we have no match } => try to create a new entry */
;;;345       
;;;346      /* no empty entry found and not allowed to recycle? */
;;;347      if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
;;;348          /* or don't create new entry, only search? */
;;;349          || ((flags & ETHARP_FIND_ONLY) != 0)) {
;;;350        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
;;;351        return (s8_t)ERR_MEM;
;;;352      }
;;;353      
;;;354      /* b) choose the least destructive entry to recycle:
;;;355       * 1) empty entry
;;;356       * 2) oldest stable entry
;;;357       * 3) oldest pending entry without queued packets
;;;358       * 4) oldest pending entry with queued packets
;;;359       * 
;;;360       * { ETHARP_TRY_HARD is set at this point }
;;;361       */ 
;;;362    
;;;363      /* 1) empty entry available? */
;;;364      if (empty < ARP_TABLE_SIZE) {
;;;365        i = empty;
;;;366        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;367      }
;;;368      /* 2) found recyclable stable entry? */
;;;369      else if (old_stable < ARP_TABLE_SIZE) {
;;;370        /* recycle oldest stable*/
;;;371        i = old_stable;
;;;372        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;373    #if ARP_QUEUEING
;;;374        /* no queued packets should exist on stable entries */
;;;375        LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;376    #endif
;;;377      /* 3) found recyclable pending entry without queued packets? */
;;;378      } else if (old_pending < ARP_TABLE_SIZE) {
;;;379        /* recycle oldest pending */
;;;380        i = old_pending;
;;;381        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;382    #if ARP_QUEUEING
;;;383      /* 4) found recyclable pending entry with queued packets? */
;;;384      } else if (old_queue < ARP_TABLE_SIZE) {
;;;385        /* recycle oldest pending */
;;;386        i = old_queue;
;;;387        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;388        free_etharp_q(arp_table[i].q);
;;;389        arp_table[i].q = NULL;
;;;390    #endif
;;;391        /* no empty or recyclable entries found */
;;;392      } else {
;;;393        return (s8_t)ERR_MEM;
;;;394      }
;;;395    
;;;396      /* { empty or recyclable entry found } */
;;;397      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;398    
;;;399      if (arp_table[i].state != ETHARP_STATE_EMPTY)
;;;400      {
;;;401        snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;402      }
;;;403      /* recycle entry (no-op for an already empty entry) */
;;;404      arp_table[i].state = ETHARP_STATE_EMPTY;
;;;405    
;;;406      /* IP address given? */
;;;407      if (ipaddr != NULL) {
;;;408        /* set IP address */
;;;409        ip_addr_set(&arp_table[i].ipaddr, ipaddr);
;;;410      }
;;;411      arp_table[i].ctime = 0;
;;;412    #if LWIP_NETIF_HWADDRHINT
;;;413      NETIF_SET_HINT(netif, i);
;;;414    #else /* #if LWIP_NETIF_HWADDRHINT */
;;;415      etharp_cached_entry = i;
;;;416    #endif /* #if LWIP_NETIF_HWADDRHINT */
;;;417      return (err_t)i;
;;;418    }
00004e  e8bd9ffc          POP      {r2-r12,pc}
                  |L11.82|
000052  2400              MOVS     r4,#0                 ;290
000054  e079              B        |L11.330|
                  |L11.86|
000056  2e0a              CMP      r6,#0xa               ;292
000058  d10a              BNE      |L11.112|
00005a  eb040084          ADD      r0,r4,r4,LSL #2       ;292
00005e  4967              LDR      r1,|L11.508|
000060  eb010080          ADD      r0,r1,r0,LSL #2       ;292
000064  7b80              LDRB     r0,[r0,#0xe]          ;292
000066  b918              CBNZ     r0,|L11.112|
000068  bf00              NOP                            ;293
00006a  bf00              NOP                            ;293
00006c  b266              SXTB     r6,r4                 ;295
00006e  e06a              B        |L11.326|
                  |L11.112|
000070  eb040084          ADD      r0,r4,r4,LSL #2       ;298
000074  4961              LDR      r1,|L11.508|
000076  eb010080          ADD      r0,r1,r0,LSL #2       ;298
00007a  7b80              LDRB     r0,[r0,#0xe]          ;298
00007c  2801              CMP      r0,#1                 ;298
00007e  d138              BNE      |L11.242|
000080  b175              CBZ      r5,|L11.160|
000082  6828              LDR      r0,[r5,#0]            ;300
000084  eb040184          ADD      r1,r4,r4,LSL #2       ;300
000088  4a5c              LDR      r2,|L11.508|
00008a  eb020181          ADD      r1,r2,r1,LSL #2       ;300
00008e  6849              LDR      r1,[r1,#4]            ;300
000090  4288              CMP      r0,r1                 ;300
000092  d105              BNE      |L11.160|
000094  bf00              NOP                            ;301
000096  bf00              NOP                            ;301
000098  4857              LDR      r0,|L11.504|
00009a  7004              STRB     r4,[r0,#0]            ;306
00009c  b260              SXTB     r0,r4                 ;308
00009e  e7d6              B        |L11.78|
                  |L11.160|
0000a0  eb040084          ADD      r0,r4,r4,LSL #2       ;311
0000a4  4955              LDR      r1,|L11.508|
0000a6  f8510020          LDR      r0,[r1,r0,LSL #2]     ;311
0000aa  b188              CBZ      r0,|L11.208|
0000ac  eb040084          ADD      r0,r4,r4,LSL #2       ;312
0000b0  eb010080          ADD      r0,r1,r0,LSL #2       ;312
0000b4  7bc1              LDRB     r1,[r0,#0xf]          ;312
0000b6  9800              LDR      r0,[sp,#0]            ;312
0000b8  4281              CMP      r1,r0                 ;312
0000ba  db44              BLT      |L11.326|
0000bc  fa4ffa84          SXTB     r10,r4                ;313
0000c0  eb040084          ADD      r0,r4,r4,LSL #2       ;314
0000c4  494d              LDR      r1,|L11.508|
0000c6  eb010080          ADD      r0,r1,r0,LSL #2       ;314
0000ca  7bc0              LDRB     r0,[r0,#0xf]          ;314
0000cc  9000              STR      r0,[sp,#0]            ;314
0000ce  e03a              B        |L11.326|
                  |L11.208|
0000d0  eb040084          ADD      r0,r4,r4,LSL #2       ;319
0000d4  4949              LDR      r1,|L11.508|
0000d6  eb010080          ADD      r0,r1,r0,LSL #2       ;319
0000da  7bc0              LDRB     r0,[r0,#0xf]          ;319
0000dc  4558              CMP      r0,r11                ;319
0000de  db32              BLT      |L11.326|
0000e0  fa4ff884          SXTB     r8,r4                 ;320
0000e4  eb040084          ADD      r0,r4,r4,LSL #2       ;321
0000e8  eb010080          ADD      r0,r1,r0,LSL #2       ;321
0000ec  f890b00f          LDRB     r11,[r0,#0xf]         ;321
0000f0  e029              B        |L11.326|
                  |L11.242|
0000f2  eb040084          ADD      r0,r4,r4,LSL #2       ;326
0000f6  4941              LDR      r1,|L11.508|
0000f8  eb010080          ADD      r0,r1,r0,LSL #2       ;326
0000fc  7b80              LDRB     r0,[r0,#0xe]          ;326
0000fe  2802              CMP      r0,#2                 ;326
000100  d121              BNE      |L11.326|
000102  b175              CBZ      r5,|L11.290|
000104  6828              LDR      r0,[r5,#0]            ;328
000106  eb040184          ADD      r1,r4,r4,LSL #2       ;328
00010a  4a3c              LDR      r2,|L11.508|
00010c  eb020181          ADD      r1,r2,r1,LSL #2       ;328
000110  6849              LDR      r1,[r1,#4]            ;328
000112  4288              CMP      r0,r1                 ;328
000114  d105              BNE      |L11.290|
000116  bf00              NOP                            ;329
000118  bf00              NOP                            ;329
00011a  4837              LDR      r0,|L11.504|
00011c  7004              STRB     r4,[r0,#0]            ;334
00011e  b260              SXTB     r0,r4                 ;336
000120  e795              B        |L11.78|
                  |L11.290|
000122  eb040084          ADD      r0,r4,r4,LSL #2       ;338
000126  4935              LDR      r1,|L11.508|
000128  eb010080          ADD      r0,r1,r0,LSL #2       ;338
00012c  7bc1              LDRB     r1,[r0,#0xf]          ;338
00012e  9801              LDR      r0,[sp,#4]            ;338
000130  4281              CMP      r1,r0                 ;338
000132  db08              BLT      |L11.326|
000134  fa4ff984          SXTB     r9,r4                 ;339
000138  eb040084          ADD      r0,r4,r4,LSL #2       ;340
00013c  492f              LDR      r1,|L11.508|
00013e  eb010080          ADD      r0,r1,r0,LSL #2       ;340
000142  7bc0              LDRB     r0,[r0,#0xf]          ;340
000144  9001              STR      r0,[sp,#4]            ;340
                  |L11.326|
000146  1c60              ADDS     r0,r4,#1              ;290
000148  b2c4              UXTB     r4,r0                 ;290
                  |L11.330|
00014a  2c0a              CMP      r4,#0xa               ;290
00014c  db83              BLT      |L11.86|
00014e  2e0a              CMP      r6,#0xa               ;347
000150  d102              BNE      |L11.344|
000152  f0170f01          TST      r7,#1                 ;347
000156  d002              BEQ      |L11.350|
                  |L11.344|
000158  f0170f02          TST      r7,#2                 ;349
00015c  d004              BEQ      |L11.360|
                  |L11.350|
00015e  bf00              NOP                            ;350
000160  bf00              NOP                            ;350
000162  f04f30ff          MOV      r0,#0xffffffff        ;351
000166  e772              B        |L11.78|
                  |L11.360|
000168  2e0a              CMP      r6,#0xa               ;364
00016a  da02              BGE      |L11.370|
00016c  b2f4              UXTB     r4,r6                 ;365
00016e  bf00              NOP                            ;366
000170  e025              B        |L11.446|
                  |L11.370|
000172  f1b90f0a          CMP      r9,#0xa               ;369
000176  da03              BGE      |L11.384|
000178  f00904ff          AND      r4,r9,#0xff           ;371
00017c  bf00              NOP                            ;372
00017e  e01e              B        |L11.446|
                  |L11.384|
000180  f1b80f0a          CMP      r8,#0xa               ;378
000184  da03              BGE      |L11.398|
000186  f00804ff          AND      r4,r8,#0xff           ;380
00018a  bf00              NOP                            ;381
00018c  e017              B        |L11.446|
                  |L11.398|
00018e  f1ba0f0a          CMP      r10,#0xa              ;384
000192  da11              BGE      |L11.440|
000194  f00a04ff          AND      r4,r10,#0xff          ;386
000198  bf00              NOP                            ;387
00019a  bf00              NOP                            ;387
00019c  eb040184          ADD      r1,r4,r4,LSL #2       ;388
0001a0  4a16              LDR      r2,|L11.508|
0001a2  f8520021          LDR      r0,[r2,r1,LSL #2]     ;388
0001a6  f7fffffe          BL       free_etharp_q
0001aa  2000              MOVS     r0,#0                 ;389
0001ac  eb040184          ADD      r1,r4,r4,LSL #2       ;389
0001b0  4a12              LDR      r2,|L11.508|
0001b2  f8420021          STR      r0,[r2,r1,LSL #2]     ;389
0001b6  e002              B        |L11.446|
                  |L11.440|
0001b8  f04f30ff          MOV      r0,#0xffffffff        ;393
0001bc  e747              B        |L11.78|
                  |L11.446|
0001be  2000              MOVS     r0,#0                 ;404
0001c0  eb040184          ADD      r1,r4,r4,LSL #2       ;404
0001c4  4a0d              LDR      r2,|L11.508|
0001c6  eb020181          ADD      r1,r2,r1,LSL #2       ;404
0001ca  7388              STRB     r0,[r1,#0xe]          ;404
0001cc  b145              CBZ      r5,|L11.480|
0001ce  b905              CBNZ     r5,|L11.466|
0001d0  e000              B        |L11.468|
                  |L11.466|
0001d2  6828              LDR      r0,[r5,#0]            ;409
                  |L11.468|
0001d4  eb040184          ADD      r1,r4,r4,LSL #2       ;409
0001d8  4a08              LDR      r2,|L11.508|
0001da  eb020181          ADD      r1,r2,r1,LSL #2       ;409
0001de  6048              STR      r0,[r1,#4]            ;409
                  |L11.480|
0001e0  2000              MOVS     r0,#0                 ;411
0001e2  eb040184          ADD      r1,r4,r4,LSL #2       ;411
0001e6  4a05              LDR      r2,|L11.508|
0001e8  eb020181          ADD      r1,r2,r1,LSL #2       ;411
0001ec  73c8              STRB     r0,[r1,#0xf]          ;411
0001ee  4802              LDR      r0,|L11.504|
0001f0  7004              STRB     r4,[r0,#0]            ;415
0001f2  b260              SXTB     r0,r4                 ;417
0001f4  e72b              B        |L11.78|
;;;419    
                          ENDP

0001f6  0000              DCW      0x0000
                  |L11.504|
                          DCD      etharp_cached_entry
                  |L11.508|
                          DCD      arp_table

                          AREA ||i.free_etharp_q||, CODE, READONLY, ALIGN=1

                  free_etharp_q PROC
;;;145    static void
;;;146    free_etharp_q(struct etharp_q_entry *q)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148      struct etharp_q_entry *r;
;;;149      LWIP_ASSERT("q != NULL", q != NULL);
;;;150      LWIP_ASSERT("q->p != NULL", q->p != NULL);
;;;151      while (q) {
000004  e008              B        |L12.24|
                  |L12.6|
;;;152        r = q;
000006  4625              MOV      r5,r4
;;;153        q = q->next;
000008  6824              LDR      r4,[r4,#0]
;;;154        LWIP_ASSERT("r->p != NULL", (r->p != NULL));
;;;155        pbuf_free(r->p);
00000a  6868              LDR      r0,[r5,#4]
00000c  f7fffffe          BL       pbuf_free
;;;156        memp_free(MEMP_ARP_QUEUE, r);
000010  4629              MOV      r1,r5
000012  2006              MOVS     r0,#6
000014  f7fffffe          BL       memp_free
                  |L12.24|
000018  2c00              CMP      r4,#0                 ;151
00001a  d1f4              BNE      |L12.6|
;;;157      }
;;;158    }
00001c  bd70              POP      {r4-r6,pc}
;;;159    #endif
                          ENDP


                          AREA ||i.update_arp_entry||, CODE, READONLY, ALIGN=2

                  update_arp_entry PROC
;;;469    static err_t
;;;470    update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;471    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  469a              MOV      r10,r3
;;;472      s8_t i;
;;;473      u8_t k;
;;;474      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;475      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
;;;476      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
000010  bf00              NOP      
000012  bf00              NOP      
;;;477                                            ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
;;;478                                            ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;479                                            ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;480      /* non-unicast address? */
;;;481      if (ip_addr_isany(ipaddr) ||
000014  b19d              CBZ      r5,|L13.62|
000016  6828              LDR      r0,[r5,#0]
000018  b188              CBZ      r0,|L13.62|
;;;482          ip_addr_isbroadcast(ipaddr, netif) ||
00001a  4639              MOV      r1,r7
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       ip_addr_isbroadcast
000022  b960              CBNZ     r0,|L13.62|
;;;483          ip_addr_ismulticast(ipaddr)) {
000024  f04f4070          MOV      r0,#0xf0000000
000028  f7fffffe          BL       ntohl
00002c  6829              LDR      r1,[r5,#0]
00002e  ea000901          AND      r9,r0,r1
000032  f04f4060          MOV      r0,#0xe0000000
000036  f7fffffe          BL       ntohl
00003a  4581              CMP      r9,r0
00003c  d105              BNE      |L13.74|
                  |L13.62|
;;;484        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
00003e  bf00              NOP      
000040  bf00              NOP      
;;;485        return ERR_ARG;
000042  f06f0009          MVN      r0,#9
                  |L13.70|
;;;486      }
;;;487      /* find or create ARP entry */
;;;488    #if LWIP_NETIF_HWADDRHINT
;;;489      i = find_entry(ipaddr, flags, netif);
;;;490    #else /* LWIP_NETIF_HWADDRHINT */
;;;491      i = find_entry(ipaddr, flags);
;;;492    #endif /* LWIP_NETIF_HWADDRHINT */
;;;493      /* bail out if no entry could be found */
;;;494      if (i < 0)
;;;495        return (err_t)i;
;;;496      
;;;497      /* mark it stable */
;;;498      arp_table[i].state = ETHARP_STATE_STABLE;
;;;499      /* record network interface */
;;;500      arp_table[i].netif = netif;
;;;501    
;;;502      /* insert in SNMP ARP index tree */
;;;503      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;504    
;;;505      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;506      /* update address */
;;;507      k = ETHARP_HWADDR_LEN;
;;;508      while (k > 0) {
;;;509        k--;
;;;510        arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
;;;511      }
;;;512      /* reset time stamp */
;;;513      arp_table[i].ctime = 0;
;;;514    #if ARP_QUEUEING
;;;515      /* this is where we will send out queued packets! */
;;;516      while (arp_table[i].q != NULL) {
;;;517        struct pbuf *p;
;;;518        /* remember remainder of queue */
;;;519        struct etharp_q_entry *q = arp_table[i].q;
;;;520        /* pop first item off the queue */
;;;521        arp_table[i].q = q->next;
;;;522        /* get the packet pointer */
;;;523        p = q->p;
;;;524        /* now queue entry can be freed */
;;;525        memp_free(MEMP_ARP_QUEUE, q);
;;;526        /* send the queued IP packet */
;;;527        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;528        /* free the queued IP packet */
;;;529        pbuf_free(p);
;;;530      }
;;;531    #endif
;;;532      return ERR_OK;
;;;533    }
000046  e8bd9ff0          POP      {r4-r12,pc}
                  |L13.74|
00004a  4651              MOV      r1,r10                ;491
00004c  4628              MOV      r0,r5                 ;491
00004e  f7fffffe          BL       find_entry
000052  4604              MOV      r4,r0                 ;491
000054  2c00              CMP      r4,#0                 ;494
000056  da01              BGE      |L13.92|
000058  4620              MOV      r0,r4                 ;495
00005a  e7f4              B        |L13.70|
                  |L13.92|
00005c  2002              MOVS     r0,#2                 ;498
00005e  eb040184          ADD      r1,r4,r4,LSL #2       ;498
000062  4a24              LDR      r2,|L13.244|
000064  eb020181          ADD      r1,r2,r1,LSL #2       ;498
000068  7388              STRB     r0,[r1,#0xe]          ;498
00006a  eb040084          ADD      r0,r4,r4,LSL #2       ;500
00006e  4611              MOV      r1,r2                 ;500
000070  eb010080          ADD      r0,r1,r0,LSL #2       ;500
000074  6107              STR      r7,[r0,#0x10]         ;500
000076  bf00              NOP                            ;505
000078  bf00              NOP                            ;505
00007a  2606              MOVS     r6,#6                 ;507
00007c  e00a              B        |L13.148|
                  |L13.126|
00007e  1e70              SUBS     r0,r6,#1              ;509
000080  b2c6              UXTB     r6,r0                 ;509
000082  f8181006          LDRB     r1,[r8,r6]            ;510
000086  eb040084          ADD      r0,r4,r4,LSL #2       ;510
00008a  4a1a              LDR      r2,|L13.244|
00008c  eb020080          ADD      r0,r2,r0,LSL #2       ;510
000090  3008              ADDS     r0,r0,#8              ;510
000092  5581              STRB     r1,[r0,r6]            ;510
                  |L13.148|
000094  2e00              CMP      r6,#0                 ;508
000096  dcf2              BGT      |L13.126|
000098  2000              MOVS     r0,#0                 ;513
00009a  eb040184          ADD      r1,r4,r4,LSL #2       ;513
00009e  4a15              LDR      r2,|L13.244|
0000a0  eb020181          ADD      r1,r2,r1,LSL #2       ;513
0000a4  73c8              STRB     r0,[r1,#0xf]          ;513
0000a6  e01c              B        |L13.226|
                  |L13.168|
0000a8  eb040084          ADD      r0,r4,r4,LSL #2       ;519
0000ac  4911              LDR      r1,|L13.244|
0000ae  f8519020          LDR      r9,[r1,r0,LSL #2]     ;519
0000b2  eb040184          ADD      r1,r4,r4,LSL #2       ;521
0000b6  4a0f              LDR      r2,|L13.244|
0000b8  f8d90000          LDR      r0,[r9,#0]            ;521
0000bc  f8420021          STR      r0,[r2,r1,LSL #2]     ;521
0000c0  f8d9b004          LDR      r11,[r9,#4]           ;523
0000c4  4649              MOV      r1,r9                 ;525
0000c6  2006              MOVS     r0,#6                 ;525
0000c8  f7fffffe          BL       memp_free
0000cc  4643              MOV      r3,r8                 ;527
0000ce  f1070229          ADD      r2,r7,#0x29           ;527
0000d2  4659              MOV      r1,r11                ;527
0000d4  4638              MOV      r0,r7                 ;527
0000d6  f7fffffe          BL       etharp_send_ip
0000da  4658              MOV      r0,r11                ;529
0000dc  f7fffffe          BL       pbuf_free
0000e0  bf00              NOP                            ;530
                  |L13.226|
0000e2  eb040084          ADD      r0,r4,r4,LSL #2       ;516
0000e6  4903              LDR      r1,|L13.244|
0000e8  f8510020          LDR      r0,[r1,r0,LSL #2]     ;516
0000ec  2800              CMP      r0,#0                 ;516
0000ee  d1db              BNE      |L13.168|
0000f0  bf00              NOP                            ;532
0000f2  e7a8              B        |L13.70|
;;;534    
                          ENDP

                  |L13.244|
                          DCD      arp_table

                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L14.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L14.32|
                  |L14.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L14.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L14.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L14.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L14.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L14.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L14.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
