; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eapol_supp_sm.o --depend=.\obj\eapol_supp_sm.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eapol_supp_sm.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eapol_supp\eapol_supp_sm.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_peer_method_load||, CODE, READONLY, ALIGN=1

                  eap_peer_method_load PROC
;;;78     
;;;79     static inline int eap_peer_method_load(const char *so)
000000  4601              MOV      r1,r0
;;;80     {
;;;81     	return 0;
000002  2000              MOVS     r0,#0
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.eap_peer_method_unload||, CODE, READONLY, ALIGN=1

                  eap_peer_method_unload PROC
;;;83     
;;;84     static inline int eap_peer_method_unload(struct eap_method *method)
000000  4601              MOV      r1,r0
;;;85     {
;;;86     	return 0;
000002  2000              MOVS     r0,#0
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.eapol_enable_timer_tick||, CODE, READONLY, ALIGN=2

                  eapol_enable_timer_tick PROC
;;;237    
;;;238    static void eapol_enable_timer_tick(struct eapol_sm *sm)
000000  b538              PUSH     {r3-r5,lr}
;;;239    {
000002  4604              MOV      r4,r0
;;;240    	if (sm->timer_tick_enabled)
000004  6920              LDR      r0,[r4,#0x10]
000006  b100              CBZ      r0,|L4.10|
                  |L4.8|
;;;241    		return;
;;;242    	wpa_printf(MSG_DEBUG, "EAPOL: enable timer tick");
;;;243    	sm->timer_tick_enabled = 1;
;;;244    	eloop_cancel_timeout(eapol_port_timers_tick, NULL, sm);
;;;245    	eloop_register_timeout(1, 0, eapol_port_timers_tick, NULL, sm);
;;;246    }
000008  bd38              POP      {r3-r5,pc}
                  |L4.10|
00000a  a10a              ADR      r1,|L4.52|
00000c  2000              MOVS     r0,#0                 ;242
00000e  f7fffffe          BL       wpa_printf
000012  2001              MOVS     r0,#1                 ;243
000014  6120              STR      r0,[r4,#0x10]         ;243
000016  4622              MOV      r2,r4                 ;244
000018  2100              MOVS     r1,#0                 ;244
00001a  480d              LDR      r0,|L4.80|
00001c  f7fffffe          BL       eloop_cancel_timeout
000020  2300              MOVS     r3,#0                 ;245
000022  4a0b              LDR      r2,|L4.80|
000024  4619              MOV      r1,r3                 ;245
000026  2001              MOVS     r0,#1                 ;245
000028  9400              STR      r4,[sp,#0]            ;245
00002a  f7fffffe          BL       eloop_register_timeout
00002e  bf00              NOP      
000030  e7ea              B        |L4.8|
;;;247    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
000034  4541504f          DCB      "EAPOL: enable timer tick",0
000038  4c3a2065
00003c  6e61626c
000040  65207469
000044  6d657220
000048  7469636b
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L4.80|
                          DCD      eapol_port_timers_tick

                          AREA ||i.eapol_port_control||, CODE, READONLY, ALIGN=2

                  eapol_port_control PROC
;;;988    #if defined(CONFIG_CTRL_IFACE) || !defined(CONFIG_NO_STDOUT_DEBUG)
;;;989    static const char * eapol_port_control(PortControl ctrl)
000000  4601              MOV      r1,r0
;;;990    {
;;;991    	switch (ctrl) {
000002  b121              CBZ      r1,|L5.14|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L5.18|
000008  2902              CMP      r1,#2
00000a  d106              BNE      |L5.26|
00000c  e003              B        |L5.22|
                  |L5.14|
;;;992    	case Auto:
;;;993    		return "Auto";
00000e  a004              ADR      r0,|L5.32|
                  |L5.16|
;;;994    	case ForceUnauthorized:
;;;995    		return "ForceUnauthorized";
;;;996    	case ForceAuthorized:
;;;997    		return "ForceAuthorized";
;;;998    	default:
;;;999    		return "Unknown";
;;;1000   	}
;;;1001   }
000010  4770              BX       lr
                  |L5.18|
000012  a005              ADR      r0,|L5.40|
000014  e7fc              B        |L5.16|
                  |L5.22|
000016  a009              ADR      r0,|L5.60|
000018  e7fa              B        |L5.16|
                  |L5.26|
00001a  a00c              ADR      r0,|L5.76|
00001c  e7f8              B        |L5.16|
;;;1002   #endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
000020  4175746f          DCB      "Auto",0
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
                  |L5.40|
000028  466f7263          DCB      "ForceUnauthorized",0
00002c  65556e61
000030  7574686f
000034  72697a65
000038  6400    
00003a  00                DCB      0
00003b  00                DCB      0
                  |L5.60|
00003c  466f7263          DCB      "ForceAuthorized",0
000040  65417574
000044  686f7269
000048  7a656400
                  |L5.76|
00004c  556e6b6e          DCB      "Unknown",0
000050  6f776e00

                          AREA ||i.eapol_port_timers_tick||, CODE, READONLY, ALIGN=2

                  eapol_port_timers_tick PROC
;;;201     * once a second as a registered event loop timeout */
;;;202    static void eapol_port_timers_tick(void *eloop_ctx, void *timeout_ctx)
000000  b5f8              PUSH     {r3-r7,lr}
;;;203    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;204    	struct eapol_sm *sm = timeout_ctx;
000006  462c              MOV      r4,r5
;;;205    
;;;206    	if (sm->authWhile > 0) {
000008  6820              LDR      r0,[r4,#0]
00000a  b140              CBZ      r0,|L6.30|
;;;207    		sm->authWhile--;
00000c  6820              LDR      r0,[r4,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  6020              STR      r0,[r4,#0]
;;;208    		if (sm->authWhile == 0)
000012  6820              LDR      r0,[r4,#0]
000014  b918              CBNZ     r0,|L6.30|
;;;209    			wpa_printf(MSG_DEBUG, "EAPOL: authWhile --> 0");
000016  a11f              ADR      r1,|L6.148|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L6.30|
;;;210    	}
;;;211    	if (sm->heldWhile > 0) {
00001e  6860              LDR      r0,[r4,#4]
000020  b140              CBZ      r0,|L6.52|
;;;212    		sm->heldWhile--;
000022  6860              LDR      r0,[r4,#4]
000024  1e40              SUBS     r0,r0,#1
000026  6060              STR      r0,[r4,#4]
;;;213    		if (sm->heldWhile == 0)
000028  6860              LDR      r0,[r4,#4]
00002a  b918              CBNZ     r0,|L6.52|
;;;214    			wpa_printf(MSG_DEBUG, "EAPOL: heldWhile --> 0");
00002c  a11f              ADR      r1,|L6.172|
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       wpa_printf
                  |L6.52|
;;;215    	}
;;;216    	if (sm->startWhen > 0) {
000034  68a0              LDR      r0,[r4,#8]
000036  b140              CBZ      r0,|L6.74|
;;;217    		sm->startWhen--;
000038  68a0              LDR      r0,[r4,#8]
00003a  1e40              SUBS     r0,r0,#1
00003c  60a0              STR      r0,[r4,#8]
;;;218    		if (sm->startWhen == 0)
00003e  68a0              LDR      r0,[r4,#8]
000040  b918              CBNZ     r0,|L6.74|
;;;219    			wpa_printf(MSG_DEBUG, "EAPOL: startWhen --> 0");
000042  a120              ADR      r1,|L6.196|
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       wpa_printf
                  |L6.74|
;;;220    	}
;;;221    	if (sm->idleWhile > 0) {
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  b140              CBZ      r0,|L6.96|
;;;222    		sm->idleWhile--;
00004e  68e0              LDR      r0,[r4,#0xc]
000050  1e40              SUBS     r0,r0,#1
000052  60e0              STR      r0,[r4,#0xc]
;;;223    		if (sm->idleWhile == 0)
000054  68e0              LDR      r0,[r4,#0xc]
000056  b918              CBNZ     r0,|L6.96|
;;;224    			wpa_printf(MSG_DEBUG, "EAPOL: idleWhile --> 0");
000058  a120              ADR      r1,|L6.220|
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       wpa_printf
                  |L6.96|
;;;225    	}
;;;226    
;;;227    	if (sm->authWhile | sm->heldWhile | sm->startWhen | sm->idleWhile) {
000060  e9d40100          LDRD     r0,r1,[r4,#0]
000064  4308              ORRS     r0,r0,r1
000066  68a1              LDR      r1,[r4,#8]
000068  4308              ORRS     r0,r0,r1
00006a  68e1              LDR      r1,[r4,#0xc]
00006c  4308              ORRS     r0,r0,r1
00006e  d007              BEQ      |L6.128|
;;;228    		eloop_register_timeout(1, 0, eapol_port_timers_tick, eloop_ctx,
000070  4633              MOV      r3,r6
000072  4a20              LDR      r2,|L6.244|
000074  2100              MOVS     r1,#0
000076  2001              MOVS     r0,#1
000078  9400              STR      r4,[sp,#0]
00007a  f7fffffe          BL       eloop_register_timeout
00007e  e005              B        |L6.140|
                  |L6.128|
;;;229    				       sm);
;;;230    	} else {
;;;231    		wpa_printf(MSG_DEBUG, "EAPOL: disable timer tick");
000080  a11d              ADR      r1,|L6.248|
000082  2000              MOVS     r0,#0
000084  f7fffffe          BL       wpa_printf
;;;232    		sm->timer_tick_enabled = 0;
000088  2000              MOVS     r0,#0
00008a  6120              STR      r0,[r4,#0x10]
                  |L6.140|
;;;233    	}
;;;234    	eapol_sm_step(sm);
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       eapol_sm_step
;;;235    }
000092  bdf8              POP      {r3-r7,pc}
;;;236    
                          ENDP

                  |L6.148|
000094  4541504f          DCB      "EAPOL: authWhile --> 0",0
000098  4c3a2061
00009c  75746857
0000a0  68696c65
0000a4  202d2d3e
0000a8  203000  
0000ab  00                DCB      0
                  |L6.172|
0000ac  4541504f          DCB      "EAPOL: heldWhile --> 0",0
0000b0  4c3a2068
0000b4  656c6457
0000b8  68696c65
0000bc  202d2d3e
0000c0  203000  
0000c3  00                DCB      0
                  |L6.196|
0000c4  4541504f          DCB      "EAPOL: startWhen --> 0",0
0000c8  4c3a2073
0000cc  74617274
0000d0  5768656e
0000d4  202d2d3e
0000d8  203000  
0000db  00                DCB      0
                  |L6.220|
0000dc  4541504f          DCB      "EAPOL: idleWhile --> 0",0
0000e0  4c3a2069
0000e4  646c6557
0000e8  68696c65
0000ec  202d2d3e
0000f0  203000  
0000f3  00                DCB      0
                  |L6.244|
                          DCD      eapol_port_timers_tick
                  |L6.248|
0000f8  4541504f          DCB      "EAPOL: disable timer tick",0
0000fc  4c3a2064
000100  69736162
000104  6c652074
000108  696d6572
00010c  20746963
000110  6b00    
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.eapol_sm_abortSupp||, CODE, READONLY, ALIGN=1

                  eapol_sm_abortSupp PROC
;;;854    
;;;855    static void eapol_sm_abortSupp(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;856    {
000002  4604              MOV      r4,r0
;;;857    	/* release system resources that may have been allocated for the
;;;858    	 * authentication session */
;;;859    	os_free(sm->last_rx_key);
000004  f10404c4          ADD      r4,r4,#0xc4
000008  68e0              LDR      r0,[r4,#0xc]
00000a  f7fffffe          BL       os_free
;;;860    	sm->last_rx_key = NULL;
00000e  2000              MOVS     r0,#0
000010  60e0              STR      r0,[r4,#0xc]
;;;861    	wpabuf_free(sm->eapReqData);
000012  6960              LDR      r0,[r4,#0x14]
000014  f7fffffe          BL       wpabuf_free
;;;862    	sm->eapReqData = NULL;
000018  2000              MOVS     r0,#0
00001a  6160              STR      r0,[r4,#0x14]
;;;863    	eap_sm_abort(sm->eap);
00001c  f85409c4          LDR      r0,[r4],#-0xc4
000020  f7fffffe          BL       eap_sm_abort
;;;864    }
000024  bd10              POP      {r4,pc}
;;;865    
                          ENDP


                          AREA ||i.eapol_sm_abort_cached||, CODE, READONLY, ALIGN=2

                  eapol_sm_abort_cached PROC
;;;1508   
;;;1509   static void eapol_sm_abort_cached(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1510   {
000002  4604              MOV      r4,r0
;;;1511   	wpa_printf(MSG_DEBUG, "RSN: Authenticator did not accept PMKID, "
000004  4910              LDR      r1,|L8.72|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       wpa_printf
;;;1512   		   "doing full EAP authentication");
;;;1513   	if (sm == NULL)
00000c  b904              CBNZ     r4,|L8.16|
                  |L8.14|
;;;1514   		return;
;;;1515   	sm->cached_pmk = FALSE;
;;;1516   	sm->SUPP_PAE_state = SUPP_PAE_CONNECTING;
;;;1517   	sm->suppPortStatus = Unauthorized;
;;;1518   	eapol_sm_set_port_unauthorized(sm);
;;;1519   
;;;1520   	/* Make sure we do not start sending EAPOL-Start frames first, but
;;;1521   	 * instead move to RESTART state to start EAPOL authentication. */
;;;1522   	sm->startWhen = 3;
;;;1523   	eapol_enable_timer_tick(sm);
;;;1524   
;;;1525   	if (sm->ctx->aborted_cached)
;;;1526   		sm->ctx->aborted_cached(sm->ctx->ctx);
;;;1527   }
00000e  bd10              POP      {r4,pc}
                  |L8.16|
000010  2000              MOVS     r0,#0                 ;1515
000012  f8c40114          STR      r0,[r4,#0x114]        ;1515
000016  2003              MOVS     r0,#3                 ;1516
000018  f8840050          STRB     r0,[r4,#0x50]         ;1516
00001c  2000              MOVS     r0,#0                 ;1517
00001e  f8840034          STRB     r0,[r4,#0x34]         ;1517
000022  4620              MOV      r0,r4                 ;1518
000024  f7fffffe          BL       eapol_sm_set_port_unauthorized
000028  2003              MOVS     r0,#3                 ;1522
00002a  60a0              STR      r0,[r4,#8]            ;1522
00002c  4620              MOV      r0,r4                 ;1523
00002e  f7fffffe          BL       eapol_enable_timer_tick
000032  f8d4010c          LDR      r0,[r4,#0x10c]        ;1525
000036  6b00              LDR      r0,[r0,#0x30]         ;1525
000038  b120              CBZ      r0,|L8.68|
00003a  f8d4210c          LDR      r2,[r4,#0x10c]        ;1526
00003e  6b11              LDR      r1,[r2,#0x30]         ;1526
000040  6810              LDR      r0,[r2,#0]            ;1526
000042  4788              BLX      r1                    ;1526
                  |L8.68|
000044  bf00              NOP      
000046  e7e2              B        |L8.14|
;;;1528   
                          ENDP

                  |L8.72|
                          DCD      ||.constdata||+0x1a0

                          AREA ||i.eapol_sm_configure||, CODE, READONLY, ALIGN=1

                  eapol_sm_configure PROC
;;;1015    */
;;;1016   void eapol_sm_configure(struct eapol_sm *sm, int heldPeriod, int authPeriod,
000000  b510              PUSH     {r4,lr}
;;;1017   			int startPeriod, int maxStart)
;;;1018   {
000002  9c02              LDR      r4,[sp,#8]
;;;1019   	if (sm == NULL)
000004  b900              CBNZ     r0,|L9.8|
                  |L9.6|
;;;1020   		return;
;;;1021   	if (heldPeriod >= 0)
;;;1022   		sm->heldPeriod = heldPeriod;
;;;1023   	if (authPeriod >= 0)
;;;1024   		sm->authPeriod = authPeriod;
;;;1025   	if (startPeriod >= 0)
;;;1026   		sm->startPeriod = startPeriod;
;;;1027   	if (maxStart >= 0)
;;;1028   		sm->maxStart = maxStart;
;;;1029   }
000006  bd10              POP      {r4,pc}
                  |L9.8|
000008  2900              CMP      r1,#0                 ;1021
00000a  db00              BLT      |L9.14|
00000c  6681              STR      r1,[r0,#0x68]         ;1022
                  |L9.14|
00000e  2a00              CMP      r2,#0                 ;1023
000010  db01              BLT      |L9.22|
000012  f8c0208c          STR      r2,[r0,#0x8c]         ;1024
                  |L9.22|
000016  2b00              CMP      r3,#0                 ;1025
000018  db00              BLT      |L9.28|
00001a  66c3              STR      r3,[r0,#0x6c]         ;1026
                  |L9.28|
00001c  2c00              CMP      r4,#0                 ;1027
00001e  db00              BLT      |L9.34|
000020  6704              STR      r4,[r0,#0x70]         ;1028
                  |L9.34|
000022  bf00              NOP      
000024  e7ef              B        |L9.6|
;;;1030   
                          ENDP


                          AREA ||i.eapol_sm_deinit||, CODE, READONLY, ALIGN=2

                  eapol_sm_deinit PROC
;;;1889    */
;;;1890   void eapol_sm_deinit(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1891   {
000002  4604              MOV      r4,r0
;;;1892   	if (sm == NULL)
000004  b904              CBNZ     r4,|L10.8|
                  |L10.6|
;;;1893   		return;
;;;1894   	eloop_cancel_timeout(eapol_sm_step_timeout, NULL, sm);
;;;1895   	eloop_cancel_timeout(eapol_port_timers_tick, NULL, sm);
;;;1896   	eap_peer_sm_deinit(sm->eap);
;;;1897   	os_free(sm->last_rx_key);
;;;1898   	wpabuf_free(sm->eapReqData);
;;;1899   	os_free(sm->ctx);
;;;1900   	os_free(sm);
;;;1901   }
000006  bd10              POP      {r4,pc}
                  |L10.8|
000008  4622              MOV      r2,r4                 ;1894
00000a  2100              MOVS     r1,#0                 ;1894
00000c  480d              LDR      r0,|L10.68|
00000e  f7fffffe          BL       eloop_cancel_timeout
000012  4622              MOV      r2,r4                 ;1895
000014  2100              MOVS     r1,#0                 ;1895
000016  480c              LDR      r0,|L10.72|
000018  f7fffffe          BL       eloop_cancel_timeout
00001c  f8540fc4          LDR      r0,[r4,#0xc4]!        ;1896
000020  f7fffffe          BL       eap_peer_sm_deinit
000024  68e0              LDR      r0,[r4,#0xc]          ;1897
000026  f7fffffe          BL       os_free
00002a  6960              LDR      r0,[r4,#0x14]         ;1898
00002c  f7fffffe          BL       wpabuf_free
000030  6ca0              LDR      r0,[r4,#0x48]         ;1899
000032  f1a404c4          SUB      r4,r4,#0xc4           ;1899
000036  f7fffffe          BL       os_free
00003a  4620              MOV      r0,r4                 ;1900
00003c  f7fffffe          BL       os_free
000040  bf00              NOP      
000042  e7e0              B        |L10.6|
                          ENDP

                  |L10.68|
                          DCD      eapol_sm_step_timeout
                  |L10.72|
                          DCD      eapol_port_timers_tick

                          AREA ||i.eapol_sm_eap_param_needed||, CODE, READONLY, ALIGN=2

                  eapol_sm_eap_param_needed PROC
;;;1803   #if defined(CONFIG_CTRL_IFACE) || !defined(CONFIG_NO_STDOUT_DEBUG)
;;;1804   static void eapol_sm_eap_param_needed(void *ctx, const char *field,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1805   				      const char *txt)
;;;1806   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1807   	struct eapol_sm *sm = ctx;
00000a  4625              MOV      r5,r4
;;;1808   	wpa_printf(MSG_DEBUG, "EAPOL: EAP parameter needed");
00000c  a108              ADR      r1,|L11.48|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       wpa_printf
;;;1809   	if (sm->ctx->eap_param_needed)
000014  f8d5010c          LDR      r0,[r5,#0x10c]
000018  6c40              LDR      r0,[r0,#0x44]
00001a  b130              CBZ      r0,|L11.42|
;;;1810   		sm->ctx->eap_param_needed(sm->ctx->ctx, field, txt);
00001c  f8d5110c          LDR      r1,[r5,#0x10c]
000020  463a              MOV      r2,r7
000022  6c4b              LDR      r3,[r1,#0x44]
000024  6808              LDR      r0,[r1,#0]
000026  4631              MOV      r1,r6
000028  4798              BLX      r3
                  |L11.42|
;;;1811   }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;1812   #else /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
000030  4541504f          DCB      "EAPOL: EAP parameter needed",0
000034  4c3a2045
000038  41502070
00003c  6172616d
000040  65746572
000044  206e6565
000048  64656400

                          AREA ||i.eapol_sm_getSuppRsp||, CODE, READONLY, ALIGN=2

                  eapol_sm_getSuppRsp PROC
;;;815    
;;;816    static void eapol_sm_getSuppRsp(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;817    {
000002  4604              MOV      r4,r0
;;;818    	wpa_printf(MSG_DEBUG, "EAPOL: getSuppRsp");
000004  a102              ADR      r1,|L12.16|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       wpa_printf
;;;819    	/* EAP layer processing; no special code is needed, since Supplicant
;;;820    	 * Backend state machine is waiting for eapNoResp or eapResp to be set
;;;821    	 * and these are only set in the EAP state machine when the processing
;;;822    	 * has finished. */
;;;823    }
00000c  bd10              POP      {r4,pc}
;;;824    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
000010  4541504f          DCB      "EAPOL: getSuppRsp",0
000014  4c3a2067
000018  65745375
00001c  70705273
000020  7000    
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.eapol_sm_get_bool||, CODE, READONLY, ALIGN=1

                  eapol_sm_get_bool PROC
;;;1667   
;;;1668   static Boolean eapol_sm_get_bool(void *ctx, enum eapol_bool_var variable)
000000  4602              MOV      r2,r0
;;;1669   {
000002  460b              MOV      r3,r1
;;;1670   	struct eapol_sm *sm = ctx;
000004  4611              MOV      r1,r2
;;;1671   	if (sm == NULL)
000006  b909              CBNZ     r1,|L13.12|
;;;1672   		return FALSE;
000008  2000              MOVS     r0,#0
                  |L13.10|
;;;1673   	switch (variable) {
;;;1674   	case EAPOL_eapSuccess:
;;;1675   		return sm->eapSuccess;
;;;1676   	case EAPOL_eapRestart:
;;;1677   		return sm->eapRestart;
;;;1678   	case EAPOL_eapFail:
;;;1679   		return sm->eapFail;
;;;1680   	case EAPOL_eapResp:
;;;1681   		return sm->eapResp;
;;;1682   	case EAPOL_eapNoResp:
;;;1683   		return sm->eapNoResp;
;;;1684   	case EAPOL_eapReq:
;;;1685   		return sm->eapReq;
;;;1686   	case EAPOL_portEnabled:
;;;1687   		return sm->portEnabled;
;;;1688   	case EAPOL_altAccept:
;;;1689   		return sm->altAccept;
;;;1690   	case EAPOL_altReject:
;;;1691   		return sm->altReject;
;;;1692   	}
;;;1693   	return FALSE;
;;;1694   }
00000a  4770              BX       lr
                  |L13.12|
00000c  2b09              CMP      r3,#9                 ;1673
00000e  d21d              BCS      |L13.76|
000010  e8dff003          TBB      [pc,r3]               ;1673
000014  0507090b          DCB      0x05,0x07,0x09,0x0b
000018  0e111416          DCB      0x0e,0x11,0x14,0x16
00001c  1900              DCB      0x19,0x00
00001e  69c8              LDR      r0,[r1,#0x1c]         ;1675
000020  e7f3              B        |L13.10|
000022  6e08              LDR      r0,[r1,#0x60]         ;1677
000024  e7f1              B        |L13.10|
000026  6948              LDR      r0,[r1,#0x14]         ;1679
000028  e7ef              B        |L13.10|
00002a  f8d10088          LDR      r0,[r1,#0x88]         ;1681
00002e  e7ec              B        |L13.10|
000030  f8d10080          LDR      r0,[r1,#0x80]         ;1683
000034  e7e9              B        |L13.10|
000036  f8d10084          LDR      r0,[r1,#0x84]         ;1685
00003a  e7e6              B        |L13.10|
00003c  6b08              LDR      r0,[r1,#0x30]         ;1687
00003e  e7e4              B        |L13.10|
000040  f8d100dc          LDR      r0,[r1,#0xdc]         ;1689
000044  e7e1              B        |L13.10|
000046  f8d100e0          LDR      r0,[r1,#0xe0]         ;1691
00004a  e7de              B        |L13.10|
                  |L13.76|
00004c  2000              MOVS     r0,#0                 ;1693
00004e  e7dc              B        |L13.10|
;;;1695   
                          ENDP


                          AREA ||i.eapol_sm_get_config||, CODE, READONLY, ALIGN=1

                  eapol_sm_get_config PROC
;;;1650   
;;;1651   static struct eap_peer_config * eapol_sm_get_config(void *ctx)
000000  4601              MOV      r1,r0
;;;1652   {
;;;1653   	struct eapol_sm *sm = ctx;
000002  460a              MOV      r2,r1
;;;1654   	return sm ? sm->config : NULL;
000004  b112              CBZ      r2,|L14.12|
000006  f8d200c8          LDR      r0,[r2,#0xc8]
                  |L14.10|
;;;1655   }
00000a  4770              BX       lr
                  |L14.12|
00000c  2000              MOVS     r0,#0                 ;1654
00000e  e7fc              B        |L14.10|
;;;1656   
                          ENDP


                          AREA ||i.eapol_sm_get_config_blob||, CODE, READONLY, ALIGN=1

                  eapol_sm_get_config_blob PROC
;;;1773   static const struct wpa_config_blob *
;;;1774   eapol_sm_get_config_blob(void *ctx, const char *name)
000000  b570              PUSH     {r4-r6,lr}
;;;1775   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1776   #ifndef CONFIG_NO_CONFIG_BLOBS
;;;1777   	struct eapol_sm *sm = ctx;
000006  462c              MOV      r4,r5
;;;1778   	if (sm && sm->ctx && sm->ctx->get_config_blob)
000008  b16c              CBZ      r4,|L15.38|
00000a  f8d4010c          LDR      r0,[r4,#0x10c]
00000e  b150              CBZ      r0,|L15.38|
000010  f8d4010c          LDR      r0,[r4,#0x10c]
000014  6ac0              LDR      r0,[r0,#0x2c]
000016  b130              CBZ      r0,|L15.38|
;;;1779   		return sm->ctx->get_config_blob(sm->ctx->ctx, name);
000018  f8d4110c          LDR      r1,[r4,#0x10c]
00001c  6aca              LDR      r2,[r1,#0x2c]
00001e  6808              LDR      r0,[r1,#0]
000020  4631              MOV      r1,r6
000022  4790              BLX      r2
                  |L15.36|
;;;1780   	else
;;;1781   		return NULL;
;;;1782   #else /* CONFIG_NO_CONFIG_BLOBS */
;;;1783   	return NULL;
;;;1784   #endif /* CONFIG_NO_CONFIG_BLOBS */
;;;1785   }
000024  bd70              POP      {r4-r6,pc}
                  |L15.38|
000026  2000              MOVS     r0,#0                 ;1781
000028  e7fc              B        |L15.36|
;;;1786   
                          ENDP


                          AREA ||i.eapol_sm_get_eapReqData||, CODE, READONLY, ALIGN=1

                  eapol_sm_get_eapReqData PROC
;;;1657   
;;;1658   static struct wpabuf * eapol_sm_get_eapReqData(void *ctx)
000000  4601              MOV      r1,r0
;;;1659   {
;;;1660   	struct eapol_sm *sm = ctx;
000002  460a              MOV      r2,r1
;;;1661   	if (sm == NULL || sm->eapReqData == NULL)
000004  b112              CBZ      r2,|L16.12|
000006  f8d200d8          LDR      r0,[r2,#0xd8]
00000a  b908              CBNZ     r0,|L16.16|
                  |L16.12|
;;;1662   		return NULL;
00000c  2000              MOVS     r0,#0
                  |L16.14|
;;;1663   
;;;1664   	return sm->eapReqData;
;;;1665   }
00000e  4770              BX       lr
                  |L16.16|
000010  f8d200d8          LDR      r0,[r2,#0xd8]         ;1664
000014  e7fb              B        |L16.14|
;;;1666   
                          ENDP


                          AREA ||i.eapol_sm_get_int||, CODE, READONLY, ALIGN=1

                  eapol_sm_get_int PROC
;;;1734   
;;;1735   static unsigned int eapol_sm_get_int(void *ctx, enum eapol_int_var variable)
000000  4602              MOV      r2,r0
;;;1736   {
;;;1737   	struct eapol_sm *sm = ctx;
000002  4613              MOV      r3,r2
;;;1738   	if (sm == NULL)
000004  b90b              CBNZ     r3,|L17.10|
;;;1739   		return 0;
000006  2000              MOVS     r0,#0
                  |L17.8|
;;;1740   	switch (variable) {
;;;1741   	case EAPOL_idleWhile:
;;;1742   		return sm->idleWhile;
;;;1743   	}
;;;1744   	return 0;
;;;1745   }
000008  4770              BX       lr
                  |L17.10|
00000a  b909              CBNZ     r1,|L17.16|
00000c  68d8              LDR      r0,[r3,#0xc]          ;1742
00000e  e7fb              B        |L17.8|
                  |L17.16|
000010  2000              MOVS     r0,#0                 ;1744
000012  e7f9              B        |L17.8|
;;;1746   
                          ENDP


                          AREA ||i.eapol_sm_get_key||, CODE, READONLY, ALIGN=2

                  eapol_sm_get_key PROC
;;;1423    */
;;;1424   int eapol_sm_get_key(struct eapol_sm *sm, u8 *key, size_t len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1425   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1426   	const u8 *eap_key;
;;;1427   	size_t eap_len;
;;;1428   
;;;1429   	if (sm == NULL || !eap_key_available(sm->eap)) {
000008  b124              CBZ      r4,|L18.20|
00000a  f8d400c4          LDR      r0,[r4,#0xc4]
00000e  f7fffffe          BL       eap_key_available
000012  b930              CBNZ     r0,|L18.34|
                  |L18.20|
;;;1430   		wpa_printf(MSG_DEBUG, "EAPOL: EAP key not available");
000014  a115              ADR      r1,|L18.108|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       wpa_printf
;;;1431   		return -1;
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L18.32|
;;;1432   	}
;;;1433   	eap_key = eap_get_eapKeyData(sm->eap, &eap_len);
;;;1434   	if (eap_key == NULL) {
;;;1435   		wpa_printf(MSG_DEBUG, "EAPOL: Failed to get eapKeyData");
;;;1436   		return -1;
;;;1437   	}
;;;1438   	if (len > eap_len) {
;;;1439   		wpa_printf(MSG_DEBUG, "EAPOL: Requested key length (%lu) not "
;;;1440   			   "available (len=%lu)",
;;;1441   			   (unsigned long) len, (unsigned long) eap_len);
;;;1442   		return eap_len;
;;;1443   	}
;;;1444   	os_memcpy(key, eap_key, len);
;;;1445   	wpa_printf(MSG_DEBUG, "EAPOL: Successfully fetched key (len=%lu)",
;;;1446   		   (unsigned long) len);
;;;1447   	return 0;
;;;1448   }
000020  bdf8              POP      {r3-r7,pc}
                  |L18.34|
000022  4669              MOV      r1,sp                 ;1433
000024  f8d400c4          LDR      r0,[r4,#0xc4]         ;1433
000028  f7fffffe          BL       eap_get_eapKeyData
00002c  4605              MOV      r5,r0                 ;1433
00002e  b935              CBNZ     r5,|L18.62|
000030  a116              ADR      r1,|L18.140|
000032  2000              MOVS     r0,#0                 ;1435
000034  f7fffffe          BL       wpa_printf
000038  f04f30ff          MOV      r0,#0xffffffff        ;1436
00003c  e7f0              B        |L18.32|
                  |L18.62|
00003e  9800              LDR      r0,[sp,#0]            ;1438
000040  4287              CMP      r7,r0                 ;1438
000042  d907              BLS      |L18.84|
000044  463a              MOV      r2,r7                 ;1439
000046  a119              ADR      r1,|L18.172|
000048  2000              MOVS     r0,#0                 ;1439
00004a  9b00              LDR      r3,[sp,#0]            ;1439
00004c  f7fffffe          BL       wpa_printf
000050  9800              LDR      r0,[sp,#0]            ;1442
000052  e7e5              B        |L18.32|
                  |L18.84|
000054  463a              MOV      r2,r7                 ;1444
000056  4629              MOV      r1,r5                 ;1444
000058  4630              MOV      r0,r6                 ;1444
00005a  f7fffffe          BL       os_memcpy
00005e  463a              MOV      r2,r7                 ;1445
000060  a121              ADR      r1,|L18.232|
000062  2000              MOVS     r0,#0                 ;1445
000064  f7fffffe          BL       wpa_printf
000068  2000              MOVS     r0,#0                 ;1447
00006a  e7d9              B        |L18.32|
;;;1449   
                          ENDP

                  |L18.108|
00006c  4541504f          DCB      "EAPOL: EAP key not available",0
000070  4c3a2045
000074  4150206b
000078  6579206e
00007c  6f742061
000080  7661696c
000084  61626c65
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L18.140|
00008c  4541504f          DCB      "EAPOL: Failed to get eapKeyData",0
000090  4c3a2046
000094  61696c65
000098  6420746f
00009c  20676574
0000a0  20656170
0000a4  4b657944
0000a8  61746100
                  |L18.172|
0000ac  4541504f          DCB      "EAPOL: Requested key length (%lu) not available (len=%l"
0000b0  4c3a2052
0000b4  65717565
0000b8  73746564
0000bc  206b6579
0000c0  206c656e
0000c4  67746820
0000c8  28256c75
0000cc  29206e6f
0000d0  74206176
0000d4  61696c61
0000d8  626c6520
0000dc  286c656e
0000e0  3d256c  
0000e3  752900            DCB      "u)",0
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L18.232|
0000e8  4541504f          DCB      "EAPOL: Successfully fetched key (len=%lu)",0
0000ec  4c3a2053
0000f0  75636365
0000f4  73736675
0000f8  6c6c7920
0000fc  66657463
000100  68656420
000104  6b657920
000108  286c656e
00010c  3d256c75
000110  2900    
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.eapol_sm_init||, CODE, READONLY, ALIGN=2

                  eapol_sm_init PROC
;;;1839    */
;;;1840   struct eapol_sm *eapol_sm_init(struct eapol_ctx *ctx)
000000  b530              PUSH     {r4,r5,lr}
;;;1841   {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
;;;1842   	struct eapol_sm *sm;
;;;1843   	struct eap_config conf;
;;;1844   	sm = os_zalloc(sizeof(*sm));
000006  f44f7090          MOV      r0,#0x120
00000a  f7fffffe          BL       os_zalloc
00000e  4604              MOV      r4,r0
;;;1845   	if (sm == NULL)
000010  b914              CBNZ     r4,|L19.24|
;;;1846   		return NULL;
000012  2000              MOVS     r0,#0
                  |L19.20|
;;;1847   	sm->ctx = ctx;
;;;1848   
;;;1849   	sm->portControl = Auto;
;;;1850   
;;;1851   	/* Supplicant PAE state machine */
;;;1852   	sm->heldPeriod = 60;
;;;1853   	sm->startPeriod = 30;
;;;1854   	sm->maxStart = 3;
;;;1855   
;;;1856   	/* Supplicant Backend state machine */
;;;1857   	sm->authPeriod = 30;
;;;1858   
;;;1859   	os_memset(&conf, 0, sizeof(conf));
;;;1860   	conf.opensc_engine_path = ctx->opensc_engine_path;
;;;1861   	conf.pkcs11_engine_path = ctx->pkcs11_engine_path;
;;;1862   	conf.pkcs11_module_path = ctx->pkcs11_module_path;
;;;1863   	conf.wps = ctx->wps;
;;;1864   
;;;1865   	sm->eap = eap_peer_sm_init(sm, &eapol_cb, sm->ctx->msg_ctx, &conf);
;;;1866   	if (sm->eap == NULL) {
;;;1867   		os_free(sm);
;;;1868   		return NULL;
;;;1869   	}
;;;1870   
;;;1871   	/* Initialize EAPOL state machines */
;;;1872   	sm->initialize = TRUE;
;;;1873   	eapol_sm_step(sm);
;;;1874   	sm->initialize = FALSE;
;;;1875   	eapol_sm_step(sm);
;;;1876   
;;;1877   	sm->timer_tick_enabled = 1;
;;;1878   	eloop_register_timeout(1, 0, eapol_port_timers_tick, NULL, sm);
;;;1879   
;;;1880   	return sm;
;;;1881   }
000014  b005              ADD      sp,sp,#0x14
000016  bd30              POP      {r4,r5,pc}
                  |L19.24|
000018  f8c4510c          STR      r5,[r4,#0x10c]        ;1847
00001c  2000              MOVS     r0,#0                 ;1849
00001e  f884002c          STRB     r0,[r4,#0x2c]         ;1849
000022  203c              MOVS     r0,#0x3c              ;1852
000024  66a0              STR      r0,[r4,#0x68]         ;1852
000026  201e              MOVS     r0,#0x1e              ;1853
000028  66e0              STR      r0,[r4,#0x6c]         ;1853
00002a  2003              MOVS     r0,#3                 ;1854
00002c  6720              STR      r0,[r4,#0x70]         ;1854
00002e  201e              MOVS     r0,#0x1e              ;1857
000030  f8c4008c          STR      r0,[r4,#0x8c]         ;1857
000034  2210              MOVS     r2,#0x10              ;1859
000036  2100              MOVS     r1,#0                 ;1859
000038  a801              ADD      r0,sp,#4              ;1859
00003a  f7fffffe          BL       os_memset
00003e  6b68              LDR      r0,[r5,#0x34]         ;1860
000040  9001              STR      r0,[sp,#4]            ;1860
000042  6ba8              LDR      r0,[r5,#0x38]         ;1861
000044  9002              STR      r0,[sp,#8]            ;1861
000046  6be8              LDR      r0,[r5,#0x3c]         ;1862
000048  9003              STR      r0,[sp,#0xc]          ;1862
00004a  6c28              LDR      r0,[r5,#0x40]         ;1863
00004c  9004              STR      r0,[sp,#0x10]         ;1863
00004e  f8d4010c          LDR      r0,[r4,#0x10c]        ;1865
000052  ab01              ADD      r3,sp,#4              ;1865
000054  4911              LDR      r1,|L19.156|
000056  6902              LDR      r2,[r0,#0x10]         ;1865
000058  4620              MOV      r0,r4                 ;1865
00005a  f7fffffe          BL       eap_peer_sm_init
00005e  f8c400c4          STR      r0,[r4,#0xc4]         ;1865
000062  f8d400c4          LDR      r0,[r4,#0xc4]         ;1866
000066  b920              CBNZ     r0,|L19.114|
000068  4620              MOV      r0,r4                 ;1867
00006a  f7fffffe          BL       os_free
00006e  2000              MOVS     r0,#0                 ;1868
000070  e7d0              B        |L19.20|
                  |L19.114|
000072  2001              MOVS     r0,#1                 ;1872
000074  6220              STR      r0,[r4,#0x20]         ;1872
000076  4620              MOV      r0,r4                 ;1873
000078  f7fffffe          BL       eapol_sm_step
00007c  2000              MOVS     r0,#0                 ;1874
00007e  6220              STR      r0,[r4,#0x20]         ;1874
000080  4620              MOV      r0,r4                 ;1875
000082  f7fffffe          BL       eapol_sm_step
000086  2001              MOVS     r0,#1                 ;1877
000088  6120              STR      r0,[r4,#0x10]         ;1877
00008a  2300              MOVS     r3,#0                 ;1878
00008c  4a04              LDR      r2,|L19.160|
00008e  4619              MOV      r1,r3                 ;1878
000090  9400              STR      r4,[sp,#0]            ;1878
000092  f7fffffe          BL       eloop_register_timeout
000096  4620              MOV      r0,r4                 ;1880
000098  e7bc              B        |L19.20|
;;;1882   
                          ENDP

00009a  0000              DCW      0x0000
                  |L19.156|
                          DCD      eapol_cb
                  |L19.160|
                          DCD      eapol_port_timers_tick

                          AREA ||i.eapol_sm_invalidate_cached_session||, CODE, READONLY, ALIGN=1

                  eapol_sm_invalidate_cached_session PROC
;;;1643    */
;;;1644   void eapol_sm_invalidate_cached_session(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1645   {
000002  4604              MOV      r4,r0
;;;1646   	if (sm)
000004  b11c              CBZ      r4,|L20.14|
;;;1647   		eap_invalidate_cached_session(sm->eap);
000006  f8d400c4          LDR      r0,[r4,#0xc4]
00000a  f7fffffe          BL       eap_invalidate_cached_session
                  |L20.14|
;;;1648   }
00000e  bd10              POP      {r4,pc}
;;;1649   
                          ENDP


                          AREA ||i.eapol_sm_notify_cached||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_cached PROC
;;;1473    */
;;;1474   void eapol_sm_notify_cached(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1475   {
000002  4604              MOV      r4,r0
;;;1476   	if (sm == NULL)
000004  b904              CBNZ     r4,|L21.8|
                  |L21.6|
;;;1477   		return;
;;;1478   	wpa_printf(MSG_DEBUG, "EAPOL: PMKSA caching was used - skip EAPOL");
;;;1479   	sm->SUPP_PAE_state = SUPP_PAE_AUTHENTICATED;
;;;1480   	sm->suppPortStatus = Authorized;
;;;1481   	eapol_sm_set_port_authorized(sm);
;;;1482   	sm->portValid = TRUE;
;;;1483   	eap_notify_success(sm->eap);
;;;1484   	eapol_sm_step(sm);
;;;1485   }
000006  bd10              POP      {r4,pc}
                  |L21.8|
000008  a10b              ADR      r1,|L21.56|
00000a  2000              MOVS     r0,#0                 ;1478
00000c  f7fffffe          BL       wpa_printf
000010  2005              MOVS     r0,#5                 ;1479
000012  f8840050          STRB     r0,[r4,#0x50]         ;1479
000016  2001              MOVS     r0,#1                 ;1480
000018  f8840034          STRB     r0,[r4,#0x34]         ;1480
00001c  4620              MOV      r0,r4                 ;1481
00001e  f7fffffe          BL       eapol_sm_set_port_authorized
000022  2001              MOVS     r0,#1                 ;1482
000024  63a0              STR      r0,[r4,#0x38]         ;1482
000026  f8d400c4          LDR      r0,[r4,#0xc4]         ;1483
00002a  f7fffffe          BL       eap_notify_success
00002e  4620              MOV      r0,r4                 ;1484
000030  f7fffffe          BL       eapol_sm_step
000034  bf00              NOP      
000036  e7e6              B        |L21.6|
;;;1486   
                          ENDP

                  |L21.56|
000038  4541504f          DCB      "EAPOL: PMKSA caching was used - skip EAPOL",0
00003c  4c3a2050
000040  4d4b5341
000044  20636163
000048  68696e67
00004c  20776173
000050  20757365
000054  64202d20
000058  736b6970
00005c  20454150
000060  4f4c00  
000063  00                DCB      0

                          AREA ||i.eapol_sm_notify_config||, CODE, READONLY, ALIGN=1

                  eapol_sm_notify_config PROC
;;;1388    */
;;;1389   void eapol_sm_notify_config(struct eapol_sm *sm,
000000  b570              PUSH     {r4-r6,lr}
;;;1390   			    struct eap_peer_config *config,
;;;1391   			    const struct eapol_config *conf)
;;;1392   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1393   	if (sm == NULL)
000008  b904              CBNZ     r4,|L22.12|
                  |L22.10|
;;;1394   		return;
;;;1395   
;;;1396   	sm->config = config;
;;;1397   
;;;1398   	if (conf == NULL)
;;;1399   		return;
;;;1400   
;;;1401   	sm->conf.accept_802_1x_keys = conf->accept_802_1x_keys;
;;;1402   	sm->conf.required_keys = conf->required_keys;
;;;1403   	sm->conf.fast_reauth = conf->fast_reauth;
;;;1404   	sm->conf.workaround = conf->workaround;
;;;1405   	if (sm->eap) {
;;;1406   		eap_set_fast_reauth(sm->eap, conf->fast_reauth);
;;;1407   		eap_set_workaround(sm->eap, conf->workaround);
;;;1408   		eap_set_force_disabled(sm->eap, conf->eap_disabled);
;;;1409   	}
;;;1410   }
00000a  bd70              POP      {r4-r6,pc}
                  |L22.12|
00000c  f8c460c8          STR      r6,[r4,#0xc8]         ;1396
000010  b905              CBNZ     r5,|L22.20|
000012  e7fa              B        |L22.10|
                  |L22.20|
000014  6828              LDR      r0,[r5,#0]            ;1401
000016  f8c400f8          STR      r0,[r4,#0xf8]         ;1401
00001a  20fc              MOVS     r0,#0xfc              ;1402
00001c  6869              LDR      r1,[r5,#4]            ;1402
00001e  5101              STR      r1,[r0,r4]            ;1402
000020  1d00              ADDS     r0,r0,#4              ;1403
000022  68a9              LDR      r1,[r5,#8]            ;1403
000024  5101              STR      r1,[r0,r4]            ;1403
000026  1d00              ADDS     r0,r0,#4              ;1404
000028  68e9              LDR      r1,[r5,#0xc]          ;1404
00002a  5101              STR      r1,[r0,r4]            ;1404
00002c  f8d400c4          LDR      r0,[r4,#0xc4]         ;1405
000030  b168              CBZ      r0,|L22.78|
000032  68a9              LDR      r1,[r5,#8]            ;1406
000034  f8540fc4          LDR      r0,[r4,#0xc4]!        ;1406
000038  f7fffffe          BL       eap_set_fast_reauth
00003c  68e9              LDR      r1,[r5,#0xc]          ;1407
00003e  6820              LDR      r0,[r4,#0]            ;1407
000040  f7fffffe          BL       eap_set_workaround
000044  6929              LDR      r1,[r5,#0x10]         ;1408
000046  f85409c4          LDR      r0,[r4],#-0xc4        ;1408
00004a  f7fffffe          BL       eap_set_force_disabled
                  |L22.78|
00004e  bf00              NOP      
000050  e7db              B        |L22.10|
;;;1411   
                          ENDP


                          AREA ||i.eapol_sm_notify_ctrl_attached||, CODE, READONLY, ALIGN=1

                  eapol_sm_notify_ctrl_attached PROC
;;;1571    */
;;;1572   void eapol_sm_notify_ctrl_attached(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1573   {
000002  4604              MOV      r4,r0
;;;1574   	if (sm == NULL)
000004  b904              CBNZ     r4,|L23.8|
                  |L23.6|
;;;1575   		return;
;;;1576   	eap_sm_notify_ctrl_attached(sm->eap);
;;;1577   }
000006  bd10              POP      {r4,pc}
                  |L23.8|
000008  f8d400c4          LDR      r0,[r4,#0xc4]         ;1576
00000c  f7fffffe          BL       eap_sm_notify_ctrl_attached
000010  bf00              NOP      
000012  e7f8              B        |L23.6|
;;;1578   
                          ENDP


                          AREA ||i.eapol_sm_notify_ctrl_response||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_ctrl_response PROC
;;;1586    */
;;;1587   void eapol_sm_notify_ctrl_response(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1588   {
000002  4604              MOV      r4,r0
;;;1589   	if (sm == NULL)
000004  b904              CBNZ     r4,|L24.8|
                  |L24.6|
;;;1590   		return;
;;;1591   	if (sm->eapReqData && !sm->eapReq) {
;;;1592   		wpa_printf(MSG_DEBUG, "EAPOL: received control response (user "
;;;1593   			   "input) notification - retrying pending EAP "
;;;1594   			   "Request");
;;;1595   		sm->eapolEap = TRUE;
;;;1596   		sm->eapReq = TRUE;
;;;1597   		eapol_sm_step(sm);
;;;1598   	}
;;;1599   }
000006  bd10              POP      {r4,pc}
                  |L24.8|
000008  f8d400d8          LDR      r0,[r4,#0xd8]         ;1591
00000c  b168              CBZ      r0,|L24.42|
00000e  f8d40084          LDR      r0,[r4,#0x84]         ;1591
000012  b950              CBNZ     r0,|L24.42|
000014  4906              LDR      r1,|L24.48|
000016  2000              MOVS     r0,#0                 ;1592
000018  f7fffffe          BL       wpa_printf
00001c  2001              MOVS     r0,#1                 ;1595
00001e  61a0              STR      r0,[r4,#0x18]         ;1595
000020  f8c40084          STR      r0,[r4,#0x84]         ;1596
000024  4620              MOV      r0,r4                 ;1597
000026  f7fffffe          BL       eapol_sm_step
                  |L24.42|
00002a  bf00              NOP      
00002c  e7eb              B        |L24.6|
;;;1600   
                          ENDP

00002e  0000              DCW      0x0000
                  |L24.48|
                          DCD      ||.constdata||+0x1e8

                          AREA ||i.eapol_sm_notify_eap_fail||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_eap_fail PROC
;;;1364    */
;;;1365   void eapol_sm_notify_eap_fail(struct eapol_sm *sm, Boolean fail)
000000  b570              PUSH     {r4-r6,lr}
;;;1366   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1367   	if (sm == NULL)
000006  b904              CBNZ     r4,|L25.10|
                  |L25.8|
;;;1368   		return;
;;;1369   	wpa_printf(MSG_DEBUG, "EAPOL: External notification - "
;;;1370   		   "EAP fail=%d", fail);
;;;1371   	sm->eapFail = fail;
;;;1372   	sm->altReject = fail;
;;;1373   	eapol_sm_step(sm);
;;;1374   }
000008  bd70              POP      {r4-r6,pc}
                  |L25.10|
00000a  462a              MOV      r2,r5                 ;1369
00000c  a105              ADR      r1,|L25.36|
00000e  2000              MOVS     r0,#0                 ;1369
000010  f7fffffe          BL       wpa_printf
000014  6165              STR      r5,[r4,#0x14]         ;1371
000016  f8c450e0          STR      r5,[r4,#0xe0]         ;1372
00001a  4620              MOV      r0,r4                 ;1373
00001c  f7fffffe          BL       eapol_sm_step
000020  bf00              NOP      
000022  e7f1              B        |L25.8|
;;;1375   
                          ENDP

                  |L25.36|
000024  4541504f          DCB      "EAPOL: External notification - EAP fail=%d",0
000028  4c3a2045
00002c  78746572
000030  6e616c20
000034  6e6f7469
000038  66696361
00003c  74696f6e
000040  202d2045
000044  41502066
000048  61696c3d
00004c  256400  
00004f  00                DCB      0

                          AREA ||i.eapol_sm_notify_eap_success||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_eap_success PROC
;;;1342    */
;;;1343   void eapol_sm_notify_eap_success(struct eapol_sm *sm, Boolean success)
000000  b570              PUSH     {r4-r6,lr}
;;;1344   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1345   	if (sm == NULL)
000006  b904              CBNZ     r4,|L26.10|
                  |L26.8|
;;;1346   		return;
;;;1347   	wpa_printf(MSG_DEBUG, "EAPOL: External notification - "
;;;1348   		   "EAP success=%d", success);
;;;1349   	sm->eapSuccess = success;
;;;1350   	sm->altAccept = success;
;;;1351   	if (success)
;;;1352   		eap_notify_success(sm->eap);
;;;1353   	eapol_sm_step(sm);
;;;1354   }
000008  bd70              POP      {r4-r6,pc}
                  |L26.10|
00000a  462a              MOV      r2,r5                 ;1347
00000c  a108              ADR      r1,|L26.48|
00000e  2000              MOVS     r0,#0                 ;1347
000010  f7fffffe          BL       wpa_printf
000014  61e5              STR      r5,[r4,#0x1c]         ;1349
000016  f8c450dc          STR      r5,[r4,#0xdc]         ;1350
00001a  b11d              CBZ      r5,|L26.36|
00001c  f8d400c4          LDR      r0,[r4,#0xc4]         ;1352
000020  f7fffffe          BL       eap_notify_success
                  |L26.36|
000024  4620              MOV      r0,r4                 ;1353
000026  f7fffffe          BL       eapol_sm_step
00002a  bf00              NOP      
00002c  e7ec              B        |L26.8|
;;;1355   
                          ENDP

00002e  0000              DCW      0x0000
                  |L26.48|
000030  4541504f          DCB      "EAPOL: External notification - EAP success=%d",0
000034  4c3a2045
000038  78746572
00003c  6e616c20
000040  6e6f7469
000044  66696361
000048  74696f6e
00004c  202d2045
000050  41502073
000054  75636365
000058  73733d25
00005c  6400    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.eapol_sm_notify_logoff||, CODE, READONLY, ALIGN=1

                  eapol_sm_notify_logoff PROC
;;;1457    */
;;;1458   void eapol_sm_notify_logoff(struct eapol_sm *sm, Boolean logoff)
000000  b570              PUSH     {r4-r6,lr}
;;;1459   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1460   	if (sm) {
000006  b11c              CBZ      r4,|L27.16|
;;;1461   		sm->userLogoff = logoff;
000008  6565              STR      r5,[r4,#0x54]
;;;1462   		eapol_sm_step(sm);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eapol_sm_step
                  |L27.16|
;;;1463   	}
;;;1464   }
000010  bd70              POP      {r4-r6,pc}
;;;1465   
                          ENDP


                          AREA ||i.eapol_sm_notify_lower_layer_success||, CODE, READONLY, ALIGN=1

                  eapol_sm_notify_lower_layer_success PROC
;;;1626    */
;;;1627   void eapol_sm_notify_lower_layer_success(struct eapol_sm *sm, int in_eapol_sm)
000000  b570              PUSH     {r4-r6,lr}
;;;1628   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1629   	if (sm == NULL)
000006  b904              CBNZ     r4,|L28.10|
                  |L28.8|
;;;1630   		return;
;;;1631   	WPA_RUN_TEST;
;;;1632   	WPA_RUN_TEST;
;;;1633   	eap_notify_lower_layer_success(sm->eap);
;;;1634   	WPA_RUN_TEST;
;;;1635   	if (!in_eapol_sm)
;;;1636   		eapol_sm_step(sm);
;;;1637   }
000008  bd70              POP      {r4-r6,pc}
                  |L28.10|
00000a  f8d400c4          LDR      r0,[r4,#0xc4]         ;1633
00000e  f7fffffe          BL       eap_notify_lower_layer_success
000012  b915              CBNZ     r5,|L28.26|
000014  4620              MOV      r0,r4                 ;1636
000016  f7fffffe          BL       eapol_sm_step
                  |L28.26|
00001a  bf00              NOP      
00001c  e7f4              B        |L28.8|
;;;1638   
                          ENDP


                          AREA ||i.eapol_sm_notify_pending||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_pending PROC
;;;1787   
;;;1788   static void eapol_sm_notify_pending(void *ctx)
000000  b570              PUSH     {r4-r6,lr}
;;;1789   {
000002  4605              MOV      r5,r0
;;;1790   	struct eapol_sm *sm = ctx;
000004  462c              MOV      r4,r5
;;;1791   	if (sm == NULL)
000006  b904              CBNZ     r4,|L29.10|
                  |L29.8|
;;;1792   		return;
;;;1793   	if (sm->eapReqData && !sm->eapReq) {
;;;1794   		wpa_printf(MSG_DEBUG, "EAPOL: received notification from EAP "
;;;1795   			   "state machine - retrying pending EAP Request");
;;;1796   		sm->eapolEap = TRUE;
;;;1797   		sm->eapReq = TRUE;
;;;1798   		eapol_sm_step(sm);
;;;1799   	}
;;;1800   }
000008  bd70              POP      {r4-r6,pc}
                  |L29.10|
00000a  f8d400d8          LDR      r0,[r4,#0xd8]         ;1793
00000e  b168              CBZ      r0,|L29.44|
000010  f8d40084          LDR      r0,[r4,#0x84]         ;1793
000014  b950              CBNZ     r0,|L29.44|
000016  4906              LDR      r1,|L29.48|
000018  2000              MOVS     r0,#0                 ;1794
00001a  f7fffffe          BL       wpa_printf
00001e  2001              MOVS     r0,#1                 ;1796
000020  61a0              STR      r0,[r4,#0x18]         ;1796
000022  f8c40084          STR      r0,[r4,#0x84]         ;1797
000026  4620              MOV      r0,r4                 ;1798
000028  f7fffffe          BL       eapol_sm_step
                  |L29.44|
00002c  bf00              NOP      
00002e  e7eb              B        |L29.8|
;;;1801   
                          ENDP

                  |L29.48|
                          DCD      ||.constdata||+0x244

                          AREA ||i.eapol_sm_notify_pmkid_attempt||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_pmkid_attempt PROC
;;;1494    */
;;;1495   void eapol_sm_notify_pmkid_attempt(struct eapol_sm *sm, int attempt)
000000  b570              PUSH     {r4-r6,lr}
;;;1496   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1497   	if (sm == NULL)
000006  b904              CBNZ     r4,|L30.10|
                  |L30.8|
;;;1498   		return;
;;;1499   	if (attempt) {
;;;1500   		wpa_printf(MSG_DEBUG, "RSN: Trying to use cached PMKSA");
;;;1501   		sm->cached_pmk = TRUE;
;;;1502   	} else {
;;;1503   		wpa_printf(MSG_DEBUG, "RSN: Do not try to use cached PMKSA");
;;;1504   		sm->cached_pmk = FALSE;
;;;1505   	}
;;;1506   }
000008  bd70              POP      {r4-r6,pc}
                  |L30.10|
00000a  b13d              CBZ      r5,|L30.28|
00000c  a108              ADR      r1,|L30.48|
00000e  2000              MOVS     r0,#0                 ;1500
000010  f7fffffe          BL       wpa_printf
000014  2001              MOVS     r0,#1                 ;1501
000016  f8c40114          STR      r0,[r4,#0x114]        ;1501
00001a  e006              B        |L30.42|
                  |L30.28|
00001c  a10c              ADR      r1,|L30.80|
00001e  2000              MOVS     r0,#0                 ;1503
000020  f7fffffe          BL       wpa_printf
000024  2000              MOVS     r0,#0                 ;1504
000026  f8c40114          STR      r0,[r4,#0x114]        ;1504
                  |L30.42|
00002a  bf00              NOP      
00002c  e7ec              B        |L30.8|
;;;1507   
                          ENDP

00002e  0000              DCW      0x0000
                  |L30.48|
000030  52534e3a          DCB      "RSN: Trying to use cached PMKSA",0
000034  20547279
000038  696e6720
00003c  746f2075
000040  73652063
000044  61636865
000048  6420504d
00004c  4b534100
                  |L30.80|
000050  52534e3a          DCB      "RSN: Do not try to use cached PMKSA",0
000054  20446f20
000058  6e6f7420
00005c  74727920
000060  746f2075
000064  73652063
000068  61636865
00006c  6420504d
000070  4b534100

                          AREA ||i.eapol_sm_notify_portControl||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_portControl PROC
;;;1553    */
;;;1554   void eapol_sm_notify_portControl(struct eapol_sm *sm, PortControl portControl)
000000  b570              PUSH     {r4-r6,lr}
;;;1555   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1556   	if (sm == NULL)
000006  b904              CBNZ     r4,|L31.10|
                  |L31.8|
;;;1557   		return;
;;;1558   	wpa_printf(MSG_DEBUG, "EAPOL: External notification - "
;;;1559   		   "portControl=%s", eapol_port_control(portControl));
;;;1560   	sm->portControl = portControl;
;;;1561   	eapol_sm_step(sm);
;;;1562   }
000008  bd70              POP      {r4-r6,pc}
                  |L31.10|
00000a  4628              MOV      r0,r5                 ;1558
00000c  f7fffffe          BL       eapol_port_control
000010  4606              MOV      r6,r0                 ;1558
000012  4602              MOV      r2,r0                 ;1558
000014  a105              ADR      r1,|L31.44|
000016  2000              MOVS     r0,#0                 ;1558
000018  f7fffffe          BL       wpa_printf
00001c  f884502c          STRB     r5,[r4,#0x2c]         ;1560
000020  4620              MOV      r0,r4                 ;1561
000022  f7fffffe          BL       eapol_sm_step
000026  bf00              NOP      
000028  e7ee              B        |L31.8|
;;;1563   
                          ENDP

00002a  0000              DCW      0x0000
                  |L31.44|
00002c  4541504f          DCB      "EAPOL: External notification - portControl=%s",0
000030  4c3a2045
000034  78746572
000038  6e616c20
00003c  6e6f7469
000040  66696361
000044  74696f6e
000048  202d2070
00004c  6f727443
000050  6f6e7472
000054  6f6c3d25
000058  7300    
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.eapol_sm_notify_portEnabled||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_portEnabled PROC
;;;1302    */
;;;1303   void eapol_sm_notify_portEnabled(struct eapol_sm *sm, Boolean enabled)
000000  b570              PUSH     {r4-r6,lr}
;;;1304   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1305   	if (sm == NULL)
000006  b904              CBNZ     r4,|L32.10|
                  |L32.8|
;;;1306   		return;
;;;1307   	wpa_printf(MSG_DEBUG, "EAPOL: External notification - "
;;;1308   		   "portEnabled=%d", enabled);
;;;1309   	sm->portEnabled = enabled;
;;;1310   	eapol_sm_step(sm);
;;;1311   }
000008  bd70              POP      {r4-r6,pc}
                  |L32.10|
00000a  462a              MOV      r2,r5                 ;1307
00000c  a104              ADR      r1,|L32.32|
00000e  2000              MOVS     r0,#0                 ;1307
000010  f7fffffe          BL       wpa_printf
000014  6325              STR      r5,[r4,#0x30]         ;1309
000016  4620              MOV      r0,r4                 ;1310
000018  f7fffffe          BL       eapol_sm_step
00001c  bf00              NOP      
00001e  e7f3              B        |L32.8|
;;;1312   
                          ENDP

                  |L32.32|
000020  4541504f          DCB      "EAPOL: External notification - portEnabled=%d",0
000024  4c3a2045
000028  78746572
00002c  6e616c20
000030  6e6f7469
000034  66696361
000038  74696f6e
00003c  202d2070
000040  6f727445
000044  6e61626c
000048  65643d25
00004c  6400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.eapol_sm_notify_portValid||, CODE, READONLY, ALIGN=2

                  eapol_sm_notify_portValid PROC
;;;1320    */
;;;1321   void eapol_sm_notify_portValid(struct eapol_sm *sm, Boolean valid)
000000  b570              PUSH     {r4-r6,lr}
;;;1322   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1323   	if (sm == NULL)
000006  b904              CBNZ     r4,|L33.10|
                  |L33.8|
;;;1324   		return;
;;;1325   	wpa_printf(MSG_DEBUG, "EAPOL: External notification - "
;;;1326   		   "portValid=%d", valid);
;;;1327   	sm->portValid = valid;
;;;1328   	eapol_sm_step(sm);
;;;1329   }
000008  bd70              POP      {r4-r6,pc}
                  |L33.10|
00000a  462a              MOV      r2,r5                 ;1325
00000c  a104              ADR      r1,|L33.32|
00000e  2000              MOVS     r0,#0                 ;1325
000010  f7fffffe          BL       wpa_printf
000014  63a5              STR      r5,[r4,#0x38]         ;1327
000016  4620              MOV      r0,r4                 ;1328
000018  f7fffffe          BL       eapol_sm_step
00001c  bf00              NOP      
00001e  e7f3              B        |L33.8|
;;;1330   
                          ENDP

                  |L33.32|
000020  4541504f          DCB      "EAPOL: External notification - portValid=%d",0
000024  4c3a2045
000028  78746572
00002c  6e616c20
000030  6e6f7469
000034  66696361
000038  74696f6e
00003c  202d2070
000040  6f727456
000044  616c6964
000048  3d256400

                          AREA ||i.eapol_sm_notify_tx_eapol_key||, CODE, READONLY, ALIGN=1

                  eapol_sm_notify_tx_eapol_key PROC
;;;1288    */
;;;1289   void eapol_sm_notify_tx_eapol_key(struct eapol_sm *sm)
000000  b120              CBZ      r0,|L34.12|
;;;1290   {
;;;1291   	if (sm)
;;;1292   		sm->dot1xSuppEapolFramesTx++;
000002  f8d01094          LDR      r1,[r0,#0x94]
000006  1c49              ADDS     r1,r1,#1
000008  f8c01094          STR      r1,[r0,#0x94]
                  |L34.12|
;;;1293   }
00000c  4770              BX       lr
;;;1294   
                          ENDP


                          AREA ||i.eapol_sm_processKey||, CODE, READONLY, ALIGN=2

                  eapol_sm_processKey PROC
;;;652    
;;;653    static void eapol_sm_processKey(struct eapol_sm *sm)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;654    {
000004  b0ad              SUB      sp,sp,#0xb4
000006  4604              MOV      r4,r0
;;;655    	struct ieee802_1x_hdr *hdr;
;;;656    	struct ieee802_1x_eapol_key *key;
;;;657    	struct eap_key_data keydata;
;;;658    	u8 orig_key_sign[IEEE8021X_KEY_SIGN_LEN], datakey[32];
;;;659    	u8 ekey[IEEE8021X_KEY_IV_LEN + IEEE8021X_ENCR_KEY_LEN];
;;;660    	int key_len, res, sign_key_len, encr_key_len;
;;;661    	u16 rx_key_length;
;;;662    
;;;663    	wpa_printf(MSG_DEBUG, "EAPOL: processKey");
000008  a1ba              ADR      r1,|L35.756|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       wpa_printf
;;;664    	if (sm->last_rx_key == NULL)
000010  f8d400d0          LDR      r0,[r4,#0xd0]
000014  b910              CBNZ     r0,|L35.28|
                  |L35.22|
;;;665    		return;
;;;666    
;;;667    	if (!sm->conf.accept_802_1x_keys) {
;;;668    		wpa_printf(MSG_WARNING, "EAPOL: Received IEEE 802.1X EAPOL-Key"
;;;669    			   " even though this was not accepted - "
;;;670    			   "ignoring this packet");
;;;671    		return;
;;;672    	}
;;;673    
;;;674    	hdr = (struct ieee802_1x_hdr *) sm->last_rx_key;
;;;675    	key = (struct ieee802_1x_eapol_key *) (hdr + 1);
;;;676    	if (sizeof(*hdr) + be_to_host16(hdr->length) > sm->last_rx_key_len) {
;;;677    		wpa_printf(MSG_WARNING, "EAPOL: Too short EAPOL-Key frame");
;;;678    		return;
;;;679    	}
;;;680    	rx_key_length = WPA_GET_BE16(key->key_length);
;;;681    	wpa_printf(MSG_DEBUG, "EAPOL: RX IEEE 802.1X ver=%d type=%d len=%d "
;;;682    		   "EAPOL-Key: type=%d key_length=%d key_index=0x%x",
;;;683    		   hdr->version, hdr->type, be_to_host16(hdr->length),
;;;684    		   key->type, rx_key_length, key->key_index);
;;;685    
;;;686    	eapol_sm_notify_lower_layer_success(sm, 1);
;;;687    	sign_key_len = IEEE8021X_SIGN_KEY_LEN;
;;;688    	encr_key_len = IEEE8021X_ENCR_KEY_LEN;
;;;689    	res = eapol_sm_get_key(sm, (u8 *) &keydata, sizeof(keydata));
;;;690    	if (res < 0) {
;;;691    		wpa_printf(MSG_DEBUG, "EAPOL: Could not get master key for "
;;;692    			   "decrypting EAPOL-Key keys");
;;;693    		return;
;;;694    	}
;;;695    	if (res == 16) {
;;;696    		/* LEAP derives only 16 bytes of keying material. */
;;;697    		res = eapol_sm_get_key(sm, (u8 *) &keydata, 16);
;;;698    		if (res) {
;;;699    			wpa_printf(MSG_DEBUG, "EAPOL: Could not get LEAP "
;;;700    				   "master key for decrypting EAPOL-Key keys");
;;;701    			return;
;;;702    		}
;;;703    		sign_key_len = 16;
;;;704    		encr_key_len = 16;
;;;705    		os_memcpy(keydata.sign_key, keydata.encr_key, 16);
;;;706    	} else if (res) {
;;;707    		wpa_printf(MSG_DEBUG, "EAPOL: Could not get enough master key "
;;;708    			   "data for decrypting EAPOL-Key keys (res=%d)", res);
;;;709    		return;
;;;710    	}
;;;711    
;;;712    	/* The key replay_counter must increase when same master key */
;;;713    	if (sm->replay_counter_valid &&
;;;714    	    os_memcmp(sm->last_replay_counter, key->replay_counter,
;;;715    		      IEEE8021X_REPLAY_COUNTER_LEN) >= 0) {
;;;716    		wpa_printf(MSG_WARNING, "EAPOL: EAPOL-Key replay counter did "
;;;717    			   "not increase - ignoring key");
;;;718    		wpa_hexdump(MSG_DEBUG, "EAPOL: last replay counter",
;;;719    			    sm->last_replay_counter,
;;;720    			    IEEE8021X_REPLAY_COUNTER_LEN);
;;;721    		wpa_hexdump(MSG_DEBUG, "EAPOL: received replay counter",
;;;722    			    key->replay_counter, IEEE8021X_REPLAY_COUNTER_LEN);
;;;723    		return;
;;;724    	}
;;;725    
;;;726    	/* Verify key signature (HMAC-MD5) */
;;;727    	os_memcpy(orig_key_sign, key->key_signature, IEEE8021X_KEY_SIGN_LEN);
;;;728    	os_memset(key->key_signature, 0, IEEE8021X_KEY_SIGN_LEN);
;;;729    	hmac_md5(keydata.sign_key, sign_key_len,
;;;730    		 sm->last_rx_key, sizeof(*hdr) + be_to_host16(hdr->length),
;;;731    		 key->key_signature);
;;;732    	if (os_memcmp(orig_key_sign, key->key_signature,
;;;733    		      IEEE8021X_KEY_SIGN_LEN) != 0) {
;;;734    		wpa_printf(MSG_DEBUG, "EAPOL: Invalid key signature in "
;;;735    			   "EAPOL-Key packet");
;;;736    		os_memcpy(key->key_signature, orig_key_sign,
;;;737    			  IEEE8021X_KEY_SIGN_LEN);
;;;738    		return;
;;;739    	}
;;;740    	wpa_printf(MSG_DEBUG, "EAPOL: EAPOL-Key key signature verified");
;;;741    
;;;742    	key_len = be_to_host16(hdr->length) - sizeof(*key);
;;;743    	if (key_len > 32 || rx_key_length > 32) {
;;;744    		wpa_printf(MSG_WARNING, "EAPOL: Too long key data length %d",
;;;745    			   key_len ? key_len : rx_key_length);
;;;746    		return;
;;;747    	}
;;;748    	if (key_len == rx_key_length) {
;;;749    		os_memcpy(ekey, key->key_iv, IEEE8021X_KEY_IV_LEN);
;;;750    		os_memcpy(ekey + IEEE8021X_KEY_IV_LEN, keydata.encr_key,
;;;751    			  encr_key_len);
;;;752    		os_memcpy(datakey, key + 1, key_len);
;;;753    		rc4_skip(ekey, IEEE8021X_KEY_IV_LEN + encr_key_len, 0,
;;;754    			 datakey, key_len);
;;;755    		wpa_hexdump_key(MSG_DEBUG, "EAPOL: Decrypted(RC4) key",
;;;756    				datakey, key_len);
;;;757    	} else if (key_len == 0) {
;;;758    		/*
;;;759    		 * IEEE 802.1X-2004 specifies that least significant Key Length
;;;760    		 * octets from MS-MPPE-Send-Key are used as the key if the key
;;;761    		 * data is not present. This seems to be meaning the beginning
;;;762    		 * of the MS-MPPE-Send-Key. In addition, MS-MPPE-Send-Key in
;;;763    		 * Supplicant corresponds to MS-MPPE-Recv-Key in Authenticator.
;;;764    		 * Anyway, taking the beginning of the keying material from EAP
;;;765    		 * seems to interoperate with Authenticators.
;;;766    		 */
;;;767    		key_len = rx_key_length;
;;;768    		os_memcpy(datakey, keydata.encr_key, key_len);
;;;769    		wpa_hexdump_key(MSG_DEBUG, "EAPOL: using part of EAP keying "
;;;770    				"material data encryption key",
;;;771    				datakey, key_len);
;;;772    	} else {
;;;773    		wpa_printf(MSG_DEBUG, "EAPOL: Invalid key data length %d "
;;;774    			   "(key_length=%d)", key_len, rx_key_length);
;;;775    		return;
;;;776    	}
;;;777    
;;;778    	sm->replay_counter_valid = TRUE;
;;;779    	os_memcpy(sm->last_replay_counter, key->replay_counter,
;;;780    		  IEEE8021X_REPLAY_COUNTER_LEN);
;;;781    
;;;782    	wpa_printf(MSG_DEBUG, "EAPOL: Setting dynamic WEP key: %s keyidx %d "
;;;783    		   "len %d",
;;;784    		   key->key_index & IEEE8021X_KEY_INDEX_FLAG ?
;;;785    		   "unicast" : "broadcast",
;;;786    		   key->key_index & IEEE8021X_KEY_INDEX_MASK, key_len);
;;;787    
;;;788    	if (sm->ctx->set_wep_key &&
;;;789    	    sm->ctx->set_wep_key(sm->ctx->ctx,
;;;790    				 key->key_index & IEEE8021X_KEY_INDEX_FLAG,
;;;791    				 key->key_index & IEEE8021X_KEY_INDEX_MASK,
;;;792    				 datakey, key_len) < 0) {
;;;793    		wpa_printf(MSG_WARNING, "EAPOL: Failed to set WEP key to the "
;;;794    			   " driver.");
;;;795    	} else {
;;;796    		if (key->key_index & IEEE8021X_KEY_INDEX_FLAG)
;;;797    			sm->unicast_key_received = TRUE;
;;;798    		else
;;;799    			sm->broadcast_key_received = TRUE;
;;;800    
;;;801    		if ((sm->unicast_key_received ||
;;;802    		     !(sm->conf.required_keys & EAPOL_REQUIRE_KEY_UNICAST)) &&
;;;803    		    (sm->broadcast_key_received ||
;;;804    		     !(sm->conf.required_keys & EAPOL_REQUIRE_KEY_BROADCAST)))
;;;805    		{
;;;806    			wpa_printf(MSG_DEBUG, "EAPOL: all required EAPOL-Key "
;;;807    				   "frames received");
;;;808    			sm->portValid = TRUE;
;;;809    			if (sm->ctx->eapol_done_cb)
;;;810    				sm->ctx->eapol_done_cb(sm->ctx->ctx);
;;;811    		}
;;;812    	}
;;;813    }
000016  b02d              ADD      sp,sp,#0xb4
000018  e8bd8ff0          POP      {r4-r11,pc}
                  |L35.28|
00001c  f8d400f8          LDR      r0,[r4,#0xf8]         ;667
000020  b920              CBNZ     r0,|L35.44|
000022  49b9              LDR      r1,|L35.776|
000024  2000              MOVS     r0,#0                 ;668
000026  f7fffffe          BL       wpa_printf
00002a  e7f4              B        |L35.22|
                  |L35.44|
00002c  f8d460d0          LDR      r6,[r4,#0xd0]         ;674
000030  1d35              ADDS     r5,r6,#4              ;675
000032  8870              LDRH     r0,[r6,#2]            ;676
000034  f44f417f          MOV      r1,#0xff00            ;676
000038  ea012000          AND      r0,r1,r0,LSL #8       ;676
00003c  8871              LDRH     r1,[r6,#2]            ;676
00003e  ea402011          ORR      r0,r0,r1,LSR #8       ;676
000042  1d00              ADDS     r0,r0,#4              ;676
000044  f8d410d4          LDR      r1,[r4,#0xd4]         ;676
000048  4288              CMP      r0,r1                 ;676
00004a  d904              BLS      |L35.86|
00004c  a1af              ADR      r1,|L35.780|
00004e  2000              MOVS     r0,#0                 ;677
000050  f7fffffe          BL       wpa_printf
000054  e7df              B        |L35.22|
                  |L35.86|
000056  78a8              LDRB     r0,[r5,#2]            ;680
000058  7869              LDRB     r1,[r5,#1]            ;680
00005a  ea402901          ORR      r9,r0,r1,LSL #8       ;680
00005e  7eeb              LDRB     r3,[r5,#0x1b]         ;681
000060  7829              LDRB     r1,[r5,#0]            ;681
000062  8870              LDRH     r0,[r6,#2]            ;681
000064  f44f4c7f          MOV      r12,#0xff00           ;681
000068  ea0c2000          AND      r0,r12,r0,LSL #8      ;681
00006c  f8b6c002          LDRH     r12,[r6,#2]           ;681
000070  ea40201c          ORR      r0,r0,r12,LSR #8      ;681
000074  e88d0203          STM      sp,{r0,r1,r9}         ;681
000078  9303              STR      r3,[sp,#0xc]          ;681
00007a  7873              LDRB     r3,[r6,#1]            ;681
00007c  7832              LDRB     r2,[r6,#0]            ;681
00007e  49a2              LDR      r1,|L35.776|
000080  3160              ADDS     r1,r1,#0x60           ;681
000082  2000              MOVS     r0,#0                 ;681
000084  f7fffffe          BL       wpa_printf
000088  2101              MOVS     r1,#1                 ;686
00008a  4620              MOV      r0,r4                 ;686
00008c  f7fffffe          BL       eapol_sm_notify_lower_layer_success
000090  f04f0b20          MOV      r11,#0x20             ;687
000094  46da              MOV      r10,r11               ;688
000096  2240              MOVS     r2,#0x40              ;689
000098  a91d              ADD      r1,sp,#0x74           ;689
00009a  4620              MOV      r0,r4                 ;689
00009c  f7fffffe          BL       eapol_sm_get_key
0000a0  4680              MOV      r8,r0                 ;689
0000a2  f1b80f00          CMP      r8,#0                 ;690
0000a6  da04              BGE      |L35.178|
0000a8  a1a1              ADR      r1,|L35.816|
0000aa  2000              MOVS     r0,#0                 ;691
0000ac  f7fffffe          BL       wpa_printf
0000b0  e7b1              B        |L35.22|
                  |L35.178|
0000b2  f1b80f10          CMP      r8,#0x10              ;695
0000b6  d117              BNE      |L35.232|
0000b8  2210              MOVS     r2,#0x10              ;697
0000ba  a91d              ADD      r1,sp,#0x74           ;697
0000bc  4620              MOV      r0,r4                 ;697
0000be  f7fffffe          BL       eapol_sm_get_key
0000c2  4680              MOV      r8,r0                 ;697
0000c4  f1b80f00          CMP      r8,#0                 ;698
0000c8  d005              BEQ      |L35.214|
0000ca  498f              LDR      r1,|L35.776|
0000cc  31bc              ADDS     r1,r1,#0xbc           ;699
0000ce  2000              MOVS     r0,#0                 ;699
0000d0  f7fffffe          BL       wpa_printf
0000d4  e79f              B        |L35.22|
                  |L35.214|
0000d6  f04f0b10          MOV      r11,#0x10             ;703
0000da  46da              MOV      r10,r11               ;704
0000dc  2210              MOVS     r2,#0x10              ;705
0000de  a91d              ADD      r1,sp,#0x74           ;705
0000e0  a825              ADD      r0,sp,#0x94           ;705
0000e2  f7fffffe          BL       os_memcpy
0000e6  e008              B        |L35.250|
                  |L35.232|
0000e8  f1b80f00          CMP      r8,#0                 ;706
0000ec  d005              BEQ      |L35.250|
0000ee  4642              MOV      r2,r8                 ;707
0000f0  499f              LDR      r1,|L35.880|
0000f2  2000              MOVS     r0,#0                 ;707
0000f4  f7fffffe          BL       wpa_printf
0000f8  e78d              B        |L35.22|
                  |L35.250|
0000fa  f8d400e4          LDR      r0,[r4,#0xe4]         ;713
0000fe  b1c8              CBZ      r0,|L35.308|
000100  2208              MOVS     r2,#8                 ;714
000102  1ce9              ADDS     r1,r5,#3              ;714
000104  f10400e8          ADD      r0,r4,#0xe8           ;714
000108  f7fffffe          BL       os_memcmp
00010c  2800              CMP      r0,#0                 ;714
00010e  db11              BLT      |L35.308|
000110  a198              ADR      r1,|L35.884|
000112  2000              MOVS     r0,#0                 ;716
000114  f7fffffe          BL       wpa_printf
000118  2308              MOVS     r3,#8                 ;718
00011a  f10402e8          ADD      r2,r4,#0xe8           ;718
00011e  a1a5              ADR      r1,|L35.948|
000120  2000              MOVS     r0,#0                 ;718
000122  f7fffffe          BL       wpa_hexdump
000126  2308              MOVS     r3,#8                 ;721
000128  1cea              ADDS     r2,r5,#3              ;721
00012a  a1a9              ADR      r1,|L35.976|
00012c  2000              MOVS     r0,#0                 ;721
00012e  f7fffffe          BL       wpa_hexdump
000132  e770              B        |L35.22|
                  |L35.308|
000134  2210              MOVS     r2,#0x10              ;727
000136  f105011c          ADD      r1,r5,#0x1c           ;727
00013a  a819              ADD      r0,sp,#0x64           ;727
00013c  f7fffffe          BL       os_memcpy
000140  2210              MOVS     r2,#0x10              ;728
000142  2100              MOVS     r1,#0                 ;728
000144  f105001c          ADD      r0,r5,#0x1c           ;728
000148  f7fffffe          BL       os_memset
00014c  f105031c          ADD      r3,r5,#0x1c           ;729
000150  9300              STR      r3,[sp,#0]            ;729
000152  8870              LDRH     r0,[r6,#2]            ;729
000154  f44f417f          MOV      r1,#0xff00            ;729
000158  ea012000          AND      r0,r1,r0,LSL #8       ;729
00015c  8871              LDRH     r1,[r6,#2]            ;729
00015e  ea402011          ORR      r0,r0,r1,LSR #8       ;729
000162  1d03              ADDS     r3,r0,#4              ;729
000164  4659              MOV      r1,r11                ;729
000166  a825              ADD      r0,sp,#0x94           ;729
000168  f8d420d0          LDR      r2,[r4,#0xd0]         ;729
00016c  f7fffffe          BL       hmac_md5
000170  2210              MOVS     r2,#0x10              ;732
000172  f105011c          ADD      r1,r5,#0x1c           ;732
000176  a819              ADD      r0,sp,#0x64           ;732
000178  f7fffffe          BL       os_memcmp
00017c  b150              CBZ      r0,|L35.404|
00017e  a19c              ADR      r1,|L35.1008|
000180  2000              MOVS     r0,#0                 ;734
000182  f7fffffe          BL       wpa_printf
000186  2210              MOVS     r2,#0x10              ;736
000188  a919              ADD      r1,sp,#0x64           ;736
00018a  f105001c          ADD      r0,r5,#0x1c           ;736
00018e  f7fffffe          BL       os_memcpy
000192  e740              B        |L35.22|
                  |L35.404|
000194  a1a3              ADR      r1,|L35.1060|
000196  2000              MOVS     r0,#0                 ;740
000198  f7fffffe          BL       wpa_printf
00019c  8870              LDRH     r0,[r6,#2]            ;742
00019e  f44f417f          MOV      r1,#0xff00            ;742
0001a2  ea012000          AND      r0,r1,r0,LSL #8       ;742
0001a6  8871              LDRH     r1,[r6,#2]            ;742
0001a8  ea402011          ORR      r0,r0,r1,LSR #8       ;742
0001ac  f1a0072c          SUB      r7,r0,#0x2c           ;742
0001b0  2f20              CMP      r7,#0x20              ;743
0001b2  dc02              BGT      |L35.442|
0001b4  f1b90f20          CMP      r9,#0x20              ;743
0001b8  dd09              BLE      |L35.462|
                  |L35.442|
0001ba  b10f              CBZ      r7,|L35.448|
0001bc  4638              MOV      r0,r7                 ;745
0001be  e000              B        |L35.450|
                  |L35.448|
0001c0  4648              MOV      r0,r9                 ;745
                  |L35.450|
0001c2  4602              MOV      r2,r0                 ;745
0001c4  a1a1              ADR      r1,|L35.1100|
0001c6  2000              MOVS     r0,#0                 ;745
0001c8  f7fffffe          BL       wpa_printf
0001cc  e723              B        |L35.22|
                  |L35.462|
0001ce  454f              CMP      r7,r9                 ;748
0001d0  d11f              BNE      |L35.530|
0001d2  2210              MOVS     r2,#0x10              ;749
0001d4  f105010b          ADD      r1,r5,#0xb            ;749
0001d8  a805              ADD      r0,sp,#0x14           ;749
0001da  f7fffffe          BL       os_memcpy
0001de  4652              MOV      r2,r10                ;750
0001e0  a91d              ADD      r1,sp,#0x74           ;750
0001e2  a809              ADD      r0,sp,#0x24           ;750
0001e4  f7fffffe          BL       os_memcpy
0001e8  463a              MOV      r2,r7                 ;752
0001ea  f105012c          ADD      r1,r5,#0x2c           ;752
0001ee  a811              ADD      r0,sp,#0x44           ;752
0001f0  f7fffffe          BL       os_memcpy
0001f4  f10a0110          ADD      r1,r10,#0x10          ;753
0001f8  ab11              ADD      r3,sp,#0x44           ;753
0001fa  2200              MOVS     r2,#0                 ;753
0001fc  a805              ADD      r0,sp,#0x14           ;753
0001fe  9700              STR      r7,[sp,#0]            ;753
000200  f7fffffe          BL       rc4_skip
000204  463b              MOV      r3,r7                 ;755
000206  aa11              ADD      r2,sp,#0x44           ;755
000208  a199              ADR      r1,|L35.1136|
00020a  2000              MOVS     r0,#0                 ;755
00020c  f7fffffe          BL       wpa_hexdump_key
000210  e014              B        |L35.572|
                  |L35.530|
000212  b967              CBNZ     r7,|L35.558|
000214  464f              MOV      r7,r9                 ;767
000216  463a              MOV      r2,r7                 ;768
000218  a91d              ADD      r1,sp,#0x74           ;768
00021a  a811              ADD      r0,sp,#0x44           ;768
00021c  f7fffffe          BL       os_memcpy
000220  463b              MOV      r3,r7                 ;769
000222  aa11              ADD      r2,sp,#0x44           ;769
000224  a199              ADR      r1,|L35.1164|
000226  2000              MOVS     r0,#0                 ;769
000228  f7fffffe          BL       wpa_hexdump_key
00022c  e006              B        |L35.572|
                  |L35.558|
00022e  464b              MOV      r3,r9                 ;773
000230  463a              MOV      r2,r7                 ;773
000232  a1a6              ADR      r1,|L35.1228|
000234  2000              MOVS     r0,#0                 ;773
000236  f7fffffe          BL       wpa_printf
00023a  e6ec              B        |L35.22|
                  |L35.572|
00023c  2001              MOVS     r0,#1                 ;778
00023e  f8c400e4          STR      r0,[r4,#0xe4]         ;778
000242  2208              MOVS     r2,#8                 ;779
000244  1ce9              ADDS     r1,r5,#3              ;779
000246  f10400e8          ADD      r0,r4,#0xe8           ;779
00024a  f7fffffe          BL       os_memcpy
00024e  9700              STR      r7,[sp,#0]            ;782
000250  7ee8              LDRB     r0,[r5,#0x1b]         ;782
000252  f0000303          AND      r3,r0,#3              ;782
000256  f0100f80          TST      r0,#0x80              ;782
00025a  d001              BEQ      |L35.608|
00025c  a0a8              ADR      r0,|L35.1280|
00025e  e000              B        |L35.610|
                  |L35.608|
000260  a0a9              ADR      r0,|L35.1288|
                  |L35.610|
000262  4602              MOV      r2,r0                 ;785
000264  a1ab              ADR      r1,|L35.1300|
000266  2000              MOVS     r0,#0                 ;785
000268  f7fffffe          BL       wpa_printf
00026c  f8d4010c          LDR      r0,[r4,#0x10c]        ;788
000270  6a40              LDR      r0,[r0,#0x24]         ;788
000272  b198              CBZ      r0,|L35.668|
000274  9700              STR      r7,[sp,#0]            ;789
000276  7eeb              LDRB     r3,[r5,#0x1b]         ;789
000278  f0030203          AND      r2,r3,#3              ;789
00027c  f0030180          AND      r1,r3,#0x80           ;789
000280  f8d4310c          LDR      r3,[r4,#0x10c]        ;789
000284  f8d3c024          LDR      r12,[r3,#0x24]        ;789
000288  6818              LDR      r0,[r3,#0]            ;789
00028a  ab11              ADD      r3,sp,#0x44           ;789
00028c  47e0              BLX      r12                   ;789
00028e  2800              CMP      r0,#0                 ;789
000290  da04              BGE      |L35.668|
000292  a1ad              ADR      r1,|L35.1352|
000294  2000              MOVS     r0,#0                 ;793
000296  f7fffffe          BL       wpa_printf
00029a  e029              B        |L35.752|
                  |L35.668|
00029c  7ee8              LDRB     r0,[r5,#0x1b]         ;796
00029e  f0100f80          TST      r0,#0x80              ;796
0002a2  d003              BEQ      |L35.684|
0002a4  2001              MOVS     r0,#1                 ;797
0002a6  f8c40118          STR      r0,[r4,#0x118]        ;797
0002aa  e002              B        |L35.690|
                  |L35.684|
0002ac  2001              MOVS     r0,#1                 ;799
0002ae  f8c4011c          STR      r0,[r4,#0x11c]        ;799
                  |L35.690|
0002b2  f8d40118          LDR      r0,[r4,#0x118]        ;801
0002b6  b920              CBNZ     r0,|L35.706|
0002b8  20fc              MOVS     r0,#0xfc              ;802
0002ba  5900              LDR      r0,[r0,r4]            ;802
0002bc  f0100f01          TST      r0,#1                 ;802
0002c0  d116              BNE      |L35.752|
                  |L35.706|
0002c2  f8d4011c          LDR      r0,[r4,#0x11c]        ;803
0002c6  b920              CBNZ     r0,|L35.722|
0002c8  20fc              MOVS     r0,#0xfc              ;804
0002ca  5900              LDR      r0,[r0,r4]            ;804
0002cc  f0100f02          TST      r0,#2                 ;804
0002d0  d10e              BNE      |L35.752|
                  |L35.722|
0002d2  a1a9              ADR      r1,|L35.1400|
0002d4  2000              MOVS     r0,#0                 ;806
0002d6  f7fffffe          BL       wpa_printf
0002da  2001              MOVS     r0,#1                 ;808
0002dc  63a0              STR      r0,[r4,#0x38]         ;808
0002de  f8d4010c          LDR      r0,[r4,#0x10c]        ;809
0002e2  69c0              LDR      r0,[r0,#0x1c]         ;809
0002e4  b120              CBZ      r0,|L35.752|
0002e6  f8d4210c          LDR      r2,[r4,#0x10c]        ;810
0002ea  69d1              LDR      r1,[r2,#0x1c]         ;810
0002ec  6810              LDR      r0,[r2,#0]            ;810
0002ee  4788              BLX      r1                    ;810
                  |L35.752|
0002f0  bf00              NOP      
0002f2  e690              B        |L35.22|
;;;814    
                          ENDP

                  |L35.756|
0002f4  4541504f          DCB      "EAPOL: processKey",0
0002f8  4c3a2070
0002fc  726f6365
000300  73734b65
000304  7900    
000306  00                DCB      0
000307  00                DCB      0
                  |L35.776|
                          DCD      ||.constdata||
                  |L35.780|
00030c  4541504f          DCB      "EAPOL: Too short EAPOL-Key frame",0
000310  4c3a2054
000314  6f6f2073
000318  686f7274
00031c  20454150
000320  4f4c2d4b
000324  65792066
000328  72616d65
00032c  00      
00032d  00                DCB      0
00032e  00                DCB      0
00032f  00                DCB      0
                  |L35.816|
000330  4541504f          DCB      "EAPOL: Could not get master key for decrypting EAPOL-Ke"
000334  4c3a2043
000338  6f756c64
00033c  206e6f74
000340  20676574
000344  206d6173
000348  74657220
00034c  6b657920
000350  666f7220
000354  64656372
000358  79707469
00035c  6e672045
000360  41504f4c
000364  2d4b65  
000367  79206b65          DCB      "y keys",0
00036b  797300  
00036e  00                DCB      0
00036f  00                DCB      0
                  |L35.880|
                          DCD      ||.constdata||+0x100
                  |L35.884|
000374  4541504f          DCB      "EAPOL: EAPOL-Key replay counter did not increase - igno"
000378  4c3a2045
00037c  41504f4c
000380  2d4b6579
000384  20726570
000388  6c617920
00038c  636f756e
000390  74657220
000394  64696420
000398  6e6f7420
00039c  696e6372
0003a0  65617365
0003a4  202d2069
0003a8  676e6f  
0003ab  72696e67          DCB      "ring key",0
0003af  206b6579
0003b3  00      
                  |L35.948|
0003b4  4541504f          DCB      "EAPOL: last replay counter",0
0003b8  4c3a206c
0003bc  61737420
0003c0  7265706c
0003c4  61792063
0003c8  6f756e74
0003cc  657200  
0003cf  00                DCB      0
                  |L35.976|
0003d0  4541504f          DCB      "EAPOL: received replay counter",0
0003d4  4c3a2072
0003d8  65636569
0003dc  76656420
0003e0  7265706c
0003e4  61792063
0003e8  6f756e74
0003ec  657200  
0003ef  00                DCB      0
                  |L35.1008|
0003f0  4541504f          DCB      "EAPOL: Invalid key signature in EAPOL-Key packet",0
0003f4  4c3a2049
0003f8  6e76616c
0003fc  6964206b
000400  65792073
000404  69676e61
000408  74757265
00040c  20696e20
000410  4541504f
000414  4c2d4b65
000418  79207061
00041c  636b6574
000420  00      
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L35.1060|
000424  4541504f          DCB      "EAPOL: EAPOL-Key key signature verified",0
000428  4c3a2045
00042c  41504f4c
000430  2d4b6579
000434  206b6579
000438  20736967
00043c  6e617475
000440  72652076
000444  65726966
000448  69656400
                  |L35.1100|
00044c  4541504f          DCB      "EAPOL: Too long key data length %d",0
000450  4c3a2054
000454  6f6f206c
000458  6f6e6720
00045c  6b657920
000460  64617461
000464  206c656e
000468  67746820
00046c  256400  
00046f  00                DCB      0
                  |L35.1136|
000470  4541504f          DCB      "EAPOL: Decrypted(RC4) key",0
000474  4c3a2044
000478  65637279
00047c  70746564
000480  28524334
000484  29206b65
000488  7900    
00048a  00                DCB      0
00048b  00                DCB      0
                  |L35.1164|
00048c  4541504f          DCB      "EAPOL: using part of EAP keying material data encryptio"
000490  4c3a2075
000494  73696e67
000498  20706172
00049c  74206f66
0004a0  20454150
0004a4  206b6579
0004a8  696e6720
0004ac  6d617465
0004b0  7269616c
0004b4  20646174
0004b8  6120656e
0004bc  63727970
0004c0  74696f  
0004c3  6e206b65          DCB      "n key",0
0004c7  7900    
0004c9  00                DCB      0
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L35.1228|
0004cc  4541504f          DCB      "EAPOL: Invalid key data length %d (key_length=%d)",0
0004d0  4c3a2049
0004d4  6e76616c
0004d8  6964206b
0004dc  65792064
0004e0  61746120
0004e4  6c656e67
0004e8  74682025
0004ec  6420286b
0004f0  65795f6c
0004f4  656e6774
0004f8  683d2564
0004fc  2900    
0004fe  00                DCB      0
0004ff  00                DCB      0
                  |L35.1280|
000500  756e6963          DCB      "unicast",0
000504  61737400
                  |L35.1288|
000508  62726f61          DCB      "broadcast",0
00050c  64636173
000510  7400    
000512  00                DCB      0
000513  00                DCB      0
                  |L35.1300|
000514  4541504f          DCB      "EAPOL: Setting dynamic WEP key: %s keyidx %d len %d",0
000518  4c3a2053
00051c  65747469
000520  6e672064
000524  796e616d
000528  69632057
00052c  4550206b
000530  65793a20
000534  2573206b
000538  65796964
00053c  78202564
000540  206c656e
000544  20256400
                  |L35.1352|
000548  4541504f          DCB      "EAPOL: Failed to set WEP key to the  driver.",0
00054c  4c3a2046
000550  61696c65
000554  6420746f
000558  20736574
00055c  20574550
000560  206b6579
000564  20746f20
000568  74686520
00056c  20647269
000570  7665722e
000574  00      
000575  00                DCB      0
000576  00                DCB      0
000577  00                DCB      0
                  |L35.1400|
000578  4541504f          DCB      "EAPOL: all required EAPOL-Key frames received",0
00057c  4c3a2061
000580  6c6c2072
000584  65717569
000588  72656420
00058c  4541504f
000590  4c2d4b65
000594  79206672
000598  616d6573
00059c  20726563
0005a0  65697665
0005a4  6400    
0005a6  00                DCB      0
0005a7  00                DCB      0

                          AREA ||i.eapol_sm_register_scard_ctx||, CODE, READONLY, ALIGN=1

                  eapol_sm_register_scard_ctx PROC
;;;1537    */
;;;1538   void eapol_sm_register_scard_ctx(struct eapol_sm *sm, void *ctx)
000000  b570              PUSH     {r4-r6,lr}
;;;1539   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1540   	if (sm) {
000006  b13c              CBZ      r4,|L36.24|
;;;1541   		sm->ctx->scard_ctx = ctx;
000008  f8d4010c          LDR      r0,[r4,#0x10c]
00000c  6145              STR      r5,[r0,#0x14]
;;;1542   		eap_register_scard_ctx(sm->eap, ctx);
00000e  4629              MOV      r1,r5
000010  f8d400c4          LDR      r0,[r4,#0xc4]
000014  f7fffffe          BL       eap_register_scard_ctx
                  |L36.24|
;;;1543   	}
;;;1544   }
000018  bd70              POP      {r4-r6,pc}
;;;1545   
                          ENDP


                          AREA ||i.eapol_sm_request_reauth||, CODE, READONLY, ALIGN=1

                  eapol_sm_request_reauth PROC
;;;1608    */
;;;1609   void eapol_sm_request_reauth(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1610   {
000002  4604              MOV      r4,r0
;;;1611   	if (sm == NULL || sm->SUPP_PAE_state != SUPP_PAE_AUTHENTICATED)
000004  b11c              CBZ      r4,|L37.14|
000006  f8940050          LDRB     r0,[r4,#0x50]
00000a  2805              CMP      r0,#5
00000c  d000              BEQ      |L37.16|
                  |L37.14|
;;;1612   		return;
;;;1613   	eapol_sm_txStart(sm);
;;;1614   }
00000e  bd10              POP      {r4,pc}
                  |L37.16|
000010  4620              MOV      r0,r4                 ;1613
000012  f7fffffe          BL       eapol_sm_txStart
000016  bf00              NOP      
000018  e7f9              B        |L37.14|
;;;1615   
                          ENDP


                          AREA ||i.eapol_sm_rx_eapol||, CODE, READONLY, ALIGN=2

                  eapol_sm_rx_eapol PROC
;;;1167    */
;;;1168   int eapol_sm_rx_eapol(struct eapol_sm *sm, const u8 *src, const u8 *buf,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1169   		      size_t len)
;;;1170   {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4616              MOV      r6,r2
00000a  469a              MOV      r10,r3
;;;1171   	const struct ieee802_1x_hdr *hdr;
;;;1172   	const struct ieee802_1x_eapol_key *key;
;;;1173   	int data_len;
;;;1174   	int res = 1;
00000c  2001              MOVS     r0,#1
00000e  9000              STR      r0,[sp,#0]
;;;1175   	size_t plen;
;;;1176   
;;;1177   	if (sm == NULL)
000010  b914              CBNZ     r4,|L38.24|
;;;1178   		return 0;
000012  2000              MOVS     r0,#0
                  |L38.20|
;;;1179   	sm->dot1xSuppEapolFramesRx++;
;;;1180   	if (len < sizeof(*hdr)) {
;;;1181   		sm->dot1xSuppInvalidEapolFramesRx++;
;;;1182   		return 0;
;;;1183   	}
;;;1184   	hdr = (const struct ieee802_1x_hdr *) buf;
;;;1185   	sm->dot1xSuppLastEapolFrameVersion = hdr->version;
;;;1186   	os_memcpy(sm->dot1xSuppLastEapolFrameSource, src, ETH_ALEN);
;;;1187   	if (hdr->version < EAPOL_VERSION) {
;;;1188   		/* TODO: backwards compatibility */
;;;1189   	}
;;;1190   	plen = be_to_host16(hdr->length);
;;;1191   	if (plen > len - sizeof(*hdr)) {
;;;1192   		sm->dot1xSuppEapLengthErrorFramesRx++;
;;;1193   		return 0;
;;;1194   	}
;;;1195   #ifdef CONFIG_WPS
;;;1196   	if (sm->conf.workaround &&
;;;1197   	    plen < len - sizeof(*hdr) &&
;;;1198   	    hdr->type == IEEE802_1X_TYPE_EAP_PACKET &&
;;;1199   	    len - sizeof(*hdr) > sizeof(struct eap_hdr)) {
;;;1200   		const struct eap_hdr *ehdr =
;;;1201   			(const struct eap_hdr *) (hdr + 1);
;;;1202   		u16 elen;
;;;1203   
;;;1204   		elen = be_to_host16(ehdr->length);
;;;1205   		if (elen > plen && elen <= len - sizeof(*hdr)) {
;;;1206   			/*
;;;1207   			 * Buffalo WHR-G125 Ver.1.47 seems to send EAP-WPS
;;;1208   			 * packets with too short EAPOL header length field
;;;1209   			 * (14 octets). This is fixed in firmware Ver.1.49.
;;;1210   			 * As a workaround, fix the EAPOL header based on the
;;;1211   			 * correct length in the EAP packet.
;;;1212   			 */
;;;1213   			wpa_printf(MSG_DEBUG, "EAPOL: Workaround - fix EAPOL "
;;;1214   				   "payload length based on EAP header: "
;;;1215   				   "%d -> %d", (int) plen, elen);
;;;1216   			plen = elen;
;;;1217   		}
;;;1218   	}
;;;1219   #endif /* CONFIG_WPS */
;;;1220   	data_len = plen + sizeof(*hdr);
;;;1221   
;;;1222   	switch (hdr->type) {
;;;1223   	case IEEE802_1X_TYPE_EAP_PACKET:
;;;1224   		if (sm->cached_pmk) {
;;;1225   			/* Trying to use PMKSA caching, but Authenticator did
;;;1226   			 * not seem to have a matching entry. Need to restart
;;;1227   			 * EAPOL state machines.
;;;1228   			 */
;;;1229   			eapol_sm_abort_cached(sm);
;;;1230   		}
;;;1231   		wpabuf_free(sm->eapReqData);
;;;1232   		sm->eapReqData = wpabuf_alloc_copy(hdr + 1, plen);
;;;1233   		if (sm->eapReqData) {
;;;1234   			wpa_printf(MSG_DEBUG, "EAPOL: Received EAP-Packet "
;;;1235   				   "frame");
;;;1236   			sm->eapolEap = TRUE;
;;;1237   			eapol_sm_step(sm);
;;;1238   		}
;;;1239   		break;
;;;1240   	case IEEE802_1X_TYPE_EAPOL_KEY:
;;;1241   		if (plen < sizeof(*key)) {
;;;1242   			wpa_printf(MSG_DEBUG, "EAPOL: Too short EAPOL-Key "
;;;1243   				   "frame received");
;;;1244   			break;
;;;1245   		}
;;;1246   		key = (const struct ieee802_1x_eapol_key *) (hdr + 1);
;;;1247   		if (key->type == EAPOL_KEY_TYPE_WPA ||
;;;1248   		    key->type == EAPOL_KEY_TYPE_RSN) {
;;;1249   			/* WPA Supplicant takes care of this frame. */
;;;1250   			wpa_printf(MSG_DEBUG, "EAPOL: Ignoring WPA EAPOL-Key "
;;;1251   				   "frame in EAPOL state machines");
;;;1252   			res = 0;
;;;1253   			break;
;;;1254   		}
;;;1255   		if (key->type != EAPOL_KEY_TYPE_RC4) {
;;;1256   			wpa_printf(MSG_DEBUG, "EAPOL: Ignored unknown "
;;;1257   				   "EAPOL-Key type %d", key->type);
;;;1258   			break;
;;;1259   		}
;;;1260   		os_free(sm->last_rx_key);
;;;1261   		sm->last_rx_key = os_malloc(data_len);
;;;1262   		if (sm->last_rx_key) {
;;;1263   			wpa_printf(MSG_DEBUG, "EAPOL: Received EAPOL-Key "
;;;1264   				   "frame");
;;;1265   			os_memcpy(sm->last_rx_key, buf, data_len);
;;;1266   			sm->last_rx_key_len = data_len;
;;;1267   			sm->rxKey = TRUE;
;;;1268   			eapol_sm_step(sm);
;;;1269   		}
;;;1270   		break;
;;;1271   	default:
;;;1272   		wpa_printf(MSG_DEBUG, "EAPOL: Received unknown EAPOL type %d",
;;;1273   			   hdr->type);
;;;1274   		sm->dot1xSuppInvalidEapolFramesRx++;
;;;1275   		break;
;;;1276   	}
;;;1277   
;;;1278   	return res;
;;;1279   }
000014  e8bd8ff8          POP      {r3-r11,pc}
                  |L38.24|
000018  f8d40090          LDR      r0,[r4,#0x90]         ;1179
00001c  1c40              ADDS     r0,r0,#1              ;1179
00001e  f8c40090          STR      r0,[r4,#0x90]         ;1179
000022  f1ba0f04          CMP      r10,#4                ;1180
000026  d206              BCS      |L38.54|
000028  f8d400ac          LDR      r0,[r4,#0xac]         ;1181
00002c  1c40              ADDS     r0,r0,#1              ;1181
00002e  f8c400ac          STR      r0,[r4,#0xac]         ;1181
000032  2000              MOVS     r0,#0                 ;1182
000034  e7ee              B        |L38.20|
                  |L38.54|
000036  4635              MOV      r5,r6                 ;1184
000038  7828              LDRB     r0,[r5,#0]            ;1185
00003a  f8c400b4          STR      r0,[r4,#0xb4]         ;1185
00003e  2206              MOVS     r2,#6                 ;1186
000040  4659              MOV      r1,r11                ;1186
000042  f10400b8          ADD      r0,r4,#0xb8           ;1186
000046  f7fffffe          BL       os_memcpy
00004a  8868              LDRH     r0,[r5,#2]            ;1190
00004c  f44f417f          MOV      r1,#0xff00            ;1190
000050  ea012000          AND      r0,r1,r0,LSL #8       ;1190
000054  8869              LDRH     r1,[r5,#2]            ;1190
000056  ea402811          ORR      r8,r0,r1,LSR #8       ;1190
00005a  f1aa0004          SUB      r0,r10,#4             ;1191
00005e  4540              CMP      r0,r8                 ;1191
000060  d206              BCS      |L38.112|
000062  f8d400b0          LDR      r0,[r4,#0xb0]         ;1192
000066  1c40              ADDS     r0,r0,#1              ;1192
000068  f8c400b0          STR      r0,[r4,#0xb0]         ;1192
00006c  2000              MOVS     r0,#0                 ;1193
00006e  e7d1              B        |L38.20|
                  |L38.112|
000070  f1080904          ADD      r9,r8,#4              ;1220
000074  7868              LDRB     r0,[r5,#1]            ;1222
000076  b110              CBZ      r0,|L38.126|
000078  2803              CMP      r0,#3                 ;1222
00007a  d158              BNE      |L38.302|
00007c  e01b              B        |L38.182|
                  |L38.126|
00007e  f8d40114          LDR      r0,[r4,#0x114]        ;1224
000082  b110              CBZ      r0,|L38.138|
000084  4620              MOV      r0,r4                 ;1229
000086  f7fffffe          BL       eapol_sm_abort_cached
                  |L38.138|
00008a  f8540fd8          LDR      r0,[r4,#0xd8]!        ;1231
00008e  f7fffffe          BL       wpabuf_free
000092  4641              MOV      r1,r8                 ;1232
000094  1d28              ADDS     r0,r5,#4              ;1232
000096  f7fffffe          BL       wpabuf_alloc_copy
00009a  6020              STR      r0,[r4,#0]            ;1232
00009c  f85409d8          LDR      r0,[r4],#-0xd8        ;1233
0000a0  b140              CBZ      r0,|L38.180|
0000a2  a12a              ADR      r1,|L38.332|
0000a4  2000              MOVS     r0,#0                 ;1234
0000a6  f7fffffe          BL       wpa_printf
0000aa  2001              MOVS     r0,#1                 ;1236
0000ac  61a0              STR      r0,[r4,#0x18]         ;1236
0000ae  4620              MOV      r0,r4                 ;1237
0000b0  f7fffffe          BL       eapol_sm_step
                  |L38.180|
0000b4  e046              B        |L38.324|
                  |L38.182|
0000b6  f1b80f2c          CMP      r8,#0x2c              ;1241
0000ba  d204              BCS      |L38.198|
0000bc  a12c              ADR      r1,|L38.368|
0000be  2000              MOVS     r0,#0                 ;1242
0000c0  f7fffffe          BL       wpa_printf
0000c4  e03e              B        |L38.324|
                  |L38.198|
0000c6  1d2f              ADDS     r7,r5,#4              ;1246
0000c8  7838              LDRB     r0,[r7,#0]            ;1247
0000ca  28fe              CMP      r0,#0xfe              ;1247
0000cc  d002              BEQ      |L38.212|
0000ce  7838              LDRB     r0,[r7,#0]            ;1248
0000d0  2802              CMP      r0,#2                 ;1248
0000d2  d106              BNE      |L38.226|
                  |L38.212|
0000d4  a131              ADR      r1,|L38.412|
0000d6  2000              MOVS     r0,#0                 ;1250
0000d8  f7fffffe          BL       wpa_printf
0000dc  2000              MOVS     r0,#0                 ;1252
0000de  9000              STR      r0,[sp,#0]            ;1252
0000e0  e030              B        |L38.324|
                  |L38.226|
0000e2  7838              LDRB     r0,[r7,#0]            ;1255
0000e4  2801              CMP      r0,#1                 ;1255
0000e6  d005              BEQ      |L38.244|
0000e8  783a              LDRB     r2,[r7,#0]            ;1256
0000ea  a13b              ADR      r1,|L38.472|
0000ec  2000              MOVS     r0,#0                 ;1256
0000ee  f7fffffe          BL       wpa_printf
0000f2  e027              B        |L38.324|
                  |L38.244|
0000f4  f8540fd0          LDR      r0,[r4,#0xd0]!        ;1260
0000f8  f7fffffe          BL       os_free
0000fc  4648              MOV      r0,r9                 ;1261
0000fe  f7fffffe          BL       os_malloc
000102  6020              STR      r0,[r4,#0]            ;1261
000104  f85409d0          LDR      r0,[r4],#-0xd0        ;1262
000108  b180              CBZ      r0,|L38.300|
00010a  a13e              ADR      r1,|L38.516|
00010c  2000              MOVS     r0,#0                 ;1263
00010e  f7fffffe          BL       wpa_printf
000112  464a              MOV      r2,r9                 ;1265
000114  4631              MOV      r1,r6                 ;1265
000116  f8d400d0          LDR      r0,[r4,#0xd0]         ;1265
00011a  f7fffffe          BL       os_memcpy
00011e  f8c490d4          STR      r9,[r4,#0xd4]         ;1266
000122  2001              MOVS     r0,#1                 ;1267
000124  67a0              STR      r0,[r4,#0x78]         ;1267
000126  4620              MOV      r0,r4                 ;1268
000128  f7fffffe          BL       eapol_sm_step
                  |L38.300|
00012c  e00a              B        |L38.324|
                  |L38.302|
00012e  786a              LDRB     r2,[r5,#1]            ;1272
000130  a13c              ADR      r1,|L38.548|
000132  2000              MOVS     r0,#0                 ;1272
000134  f7fffffe          BL       wpa_printf
000138  f8d400ac          LDR      r0,[r4,#0xac]         ;1274
00013c  1c40              ADDS     r0,r0,#1              ;1274
00013e  f8c400ac          STR      r0,[r4,#0xac]         ;1274
000142  bf00              NOP                            ;1275
                  |L38.324|
000144  bf00              NOP                            ;1239
000146  9800              LDR      r0,[sp,#0]            ;1278
000148  e764              B        |L38.20|
;;;1280   
                          ENDP

00014a  0000              DCW      0x0000
                  |L38.332|
00014c  4541504f          DCB      "EAPOL: Received EAP-Packet frame",0
000150  4c3a2052
000154  65636569
000158  76656420
00015c  4541502d
000160  5061636b
000164  65742066
000168  72616d65
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L38.368|
000170  4541504f          DCB      "EAPOL: Too short EAPOL-Key frame received",0
000174  4c3a2054
000178  6f6f2073
00017c  686f7274
000180  20454150
000184  4f4c2d4b
000188  65792066
00018c  72616d65
000190  20726563
000194  65697665
000198  6400    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L38.412|
00019c  4541504f          DCB      "EAPOL: Ignoring WPA EAPOL-Key frame in EAPOL state mach"
0001a0  4c3a2049
0001a4  676e6f72
0001a8  696e6720
0001ac  57504120
0001b0  4541504f
0001b4  4c2d4b65
0001b8  79206672
0001bc  616d6520
0001c0  696e2045
0001c4  41504f4c
0001c8  20737461
0001cc  7465206d
0001d0  616368  
0001d3  696e6573          DCB      "ines",0
0001d7  00      
                  |L38.472|
0001d8  4541504f          DCB      "EAPOL: Ignored unknown EAPOL-Key type %d",0
0001dc  4c3a2049
0001e0  676e6f72
0001e4  65642075
0001e8  6e6b6e6f
0001ec  776e2045
0001f0  41504f4c
0001f4  2d4b6579
0001f8  20747970
0001fc  65202564
000200  00      
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L38.516|
000204  4541504f          DCB      "EAPOL: Received EAPOL-Key frame",0
000208  4c3a2052
00020c  65636569
000210  76656420
000214  4541504f
000218  4c2d4b65
00021c  79206672
000220  616d6500
                  |L38.548|
000224  4541504f          DCB      "EAPOL: Received unknown EAPOL type %d",0
000228  4c3a2052
00022c  65636569
000230  76656420
000234  756e6b6e
000238  6f776e20
00023c  4541504f
000240  4c207479
000244  70652025
000248  6400    
00024a  00                DCB      0
00024b  00                DCB      0

                          AREA ||i.eapol_sm_set_bool||, CODE, READONLY, ALIGN=1

                  eapol_sm_set_bool PROC
;;;1696   
;;;1697   static void eapol_sm_set_bool(void *ctx, enum eapol_bool_var variable,
000000  4603              MOV      r3,r0
;;;1698   			      Boolean value)
;;;1699   {
;;;1700   	struct eapol_sm *sm = ctx;
000002  4618              MOV      r0,r3
;;;1701   	if (sm == NULL)
000004  b900              CBNZ     r0,|L39.8|
                  |L39.6|
;;;1702   		return;
;;;1703   	switch (variable) {
;;;1704   	case EAPOL_eapSuccess:
;;;1705   		sm->eapSuccess = value;
;;;1706   		break;
;;;1707   	case EAPOL_eapRestart:
;;;1708   		sm->eapRestart = value;
;;;1709   		break;
;;;1710   	case EAPOL_eapFail:
;;;1711   		sm->eapFail = value;
;;;1712   		break;
;;;1713   	case EAPOL_eapResp:
;;;1714   		sm->eapResp = value;
;;;1715   		break;
;;;1716   	case EAPOL_eapNoResp:
;;;1717   		sm->eapNoResp = value;
;;;1718   		break;
;;;1719   	case EAPOL_eapReq:
;;;1720   		sm->eapReq = value;
;;;1721   		break;
;;;1722   	case EAPOL_portEnabled:
;;;1723   		sm->portEnabled = value;
;;;1724   		break;
;;;1725   	case EAPOL_altAccept:
;;;1726   		sm->altAccept = value;
;;;1727   		break;
;;;1728   	case EAPOL_altReject:
;;;1729   		sm->altReject = value;
;;;1730   		break;
;;;1731   	}
;;;1732   }
000006  4770              BX       lr
                  |L39.8|
000008  2909              CMP      r1,#9                 ;1703
00000a  d21d              BCS      |L39.72|
00000c  e8dff001          TBB      [pc,r1]               ;1703
000010  0507090b          DCB      0x05,0x07,0x09,0x0b
000014  0e111416          DCB      0x0e,0x11,0x14,0x16
000018  1900              DCB      0x19,0x00
00001a  61c2              STR      r2,[r0,#0x1c]         ;1705
00001c  e014              B        |L39.72|
00001e  6602              STR      r2,[r0,#0x60]         ;1708
000020  e012              B        |L39.72|
000022  6142              STR      r2,[r0,#0x14]         ;1711
000024  e010              B        |L39.72|
000026  f8c02088          STR      r2,[r0,#0x88]         ;1714
00002a  e00d              B        |L39.72|
00002c  f8c02080          STR      r2,[r0,#0x80]         ;1717
000030  e00a              B        |L39.72|
000032  f8c02084          STR      r2,[r0,#0x84]         ;1720
000036  e007              B        |L39.72|
000038  6302              STR      r2,[r0,#0x30]         ;1723
00003a  e005              B        |L39.72|
00003c  f8c020dc          STR      r2,[r0,#0xdc]         ;1726
000040  e002              B        |L39.72|
000042  f8c020e0          STR      r2,[r0,#0xe0]         ;1729
000046  bf00              NOP                            ;1730
                  |L39.72|
000048  bf00              NOP                            ;1706
00004a  bf00              NOP      
00004c  e7db              B        |L39.6|
;;;1733   
                          ENDP


                          AREA ||i.eapol_sm_set_config_blob||, CODE, READONLY, ALIGN=1

                  eapol_sm_set_config_blob PROC
;;;1762   
;;;1763   static void eapol_sm_set_config_blob(void *ctx, struct wpa_config_blob *blob)
000000  b570              PUSH     {r4-r6,lr}
;;;1764   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1765   #ifndef CONFIG_NO_CONFIG_BLOBS
;;;1766   	struct eapol_sm *sm = ctx;
000006  462c              MOV      r4,r5
;;;1767   	if (sm && sm->ctx && sm->ctx->set_config_blob)
000008  b164              CBZ      r4,|L40.36|
00000a  f8d4010c          LDR      r0,[r4,#0x10c]
00000e  b148              CBZ      r0,|L40.36|
000010  f8d4010c          LDR      r0,[r4,#0x10c]
000014  6a80              LDR      r0,[r0,#0x28]
000016  b128              CBZ      r0,|L40.36|
;;;1768   		sm->ctx->set_config_blob(sm->ctx->ctx, blob);
000018  f8d4110c          LDR      r1,[r4,#0x10c]
00001c  6a8a              LDR      r2,[r1,#0x28]
00001e  6808              LDR      r0,[r1,#0]
000020  4631              MOV      r1,r6
000022  4790              BLX      r2
                  |L40.36|
;;;1769   #endif /* CONFIG_NO_CONFIG_BLOBS */
;;;1770   }
000024  bd70              POP      {r4-r6,pc}
;;;1771   
                          ENDP


                          AREA ||i.eapol_sm_set_int||, CODE, READONLY, ALIGN=1

                  eapol_sm_set_int PROC
;;;1747   
;;;1748   static void eapol_sm_set_int(void *ctx, enum eapol_int_var variable,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1749   			     unsigned int value)
;;;1750   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1751   	struct eapol_sm *sm = ctx;
00000a  4625              MOV      r5,r4
;;;1752   	if (sm == NULL)
00000c  b90d              CBNZ     r5,|L41.18|
                  |L41.14|
;;;1753   		return;
;;;1754   	switch (variable) {
;;;1755   	case EAPOL_idleWhile:
;;;1756   		sm->idleWhile = value;
;;;1757   		eapol_enable_timer_tick(sm);
;;;1758   		break;
;;;1759   	}
;;;1760   }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L41.18|
000012  b926              CBNZ     r6,|L41.30|
000014  60ef              STR      r7,[r5,#0xc]          ;1756
000016  4628              MOV      r0,r5                 ;1757
000018  f7fffffe          BL       eapol_enable_timer_tick
00001c  bf00              NOP                            ;1758
                  |L41.30|
00001e  bf00              NOP                            ;1758
000020  bf00              NOP      
000022  e7f4              B        |L41.14|
;;;1761   
                          ENDP


                          AREA ||i.eapol_sm_set_port_authorized||, CODE, READONLY, ALIGN=1

                  eapol_sm_set_port_authorized PROC
;;;872    
;;;873    static void eapol_sm_set_port_authorized(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;874    {
000002  4604              MOV      r4,r0
;;;875    	if (sm->ctx->port_cb)
000004  f8d4010c          LDR      r0,[r4,#0x10c]
000008  6c80              LDR      r0,[r0,#0x48]
00000a  b128              CBZ      r0,|L42.24|
;;;876    		sm->ctx->port_cb(sm->ctx->ctx, 1);
00000c  f8d4110c          LDR      r1,[r4,#0x10c]
000010  6c8a              LDR      r2,[r1,#0x48]
000012  6808              LDR      r0,[r1,#0]
000014  2101              MOVS     r1,#1
000016  4790              BLX      r2
                  |L42.24|
;;;877    }
000018  bd10              POP      {r4,pc}
;;;878    
                          ENDP


                          AREA ||i.eapol_sm_set_port_unauthorized||, CODE, READONLY, ALIGN=1

                  eapol_sm_set_port_unauthorized PROC
;;;879    
;;;880    static void eapol_sm_set_port_unauthorized(struct eapol_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;881    {
000002  4604              MOV      r4,r0
;;;882    	if (sm->ctx->port_cb)
000004  f8d4010c          LDR      r0,[r4,#0x10c]
000008  6c80              LDR      r0,[r0,#0x48]
00000a  b128              CBZ      r0,|L43.24|
;;;883    		sm->ctx->port_cb(sm->ctx->ctx, 0);
00000c  f8d4110c          LDR      r1,[r4,#0x10c]
000010  6c8a              LDR      r2,[r1,#0x48]
000012  6808              LDR      r0,[r1,#0]
000014  2100              MOVS     r1,#0
000016  4790              BLX      r2
                  |L43.24|
;;;884    }
000018  bd10              POP      {r4,pc}
;;;885    
                          ENDP


                          AREA ||i.eapol_sm_step||, CODE, READONLY, ALIGN=2

                  eapol_sm_step PROC
;;;894     */
;;;895    void eapol_sm_step(struct eapol_sm *sm)
000000  b5f8              PUSH     {r3-r7,lr}
;;;896    {
000002  4604              MOV      r4,r0
;;;897    	int i;
;;;898    
;;;899    	/* In theory, it should be ok to run this in loop until !changed.
;;;900    	 * However, it is better to use a limit on number of iterations to
;;;901    	 * allow events (e.g., SIGTERM) to stop the program cleanly if the
;;;902    	 * state machine were to generate a busy loop. */
;;;903    	for (i = 0; i < 100; i++) {
000004  2500              MOVS     r5,#0
000006  e018              B        |L44.58|
                  |L44.8|
;;;904    		sm->changed = FALSE;
000008  2000              MOVS     r0,#0
00000a  f8c400c0          STR      r0,[r4,#0xc0]
;;;905    		SM_STEP_RUN(SUPP_PAE);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sm_SUPP_PAE_Step
;;;906    		SM_STEP_RUN(KEY_RX);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       sm_KEY_RX_Step
;;;907    		SM_STEP_RUN(SUPP_BE);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       sm_SUPP_BE_Step
;;;908    		if (eap_peer_sm_step(sm->eap))
000020  f8d400c4          LDR      r0,[r4,#0xc4]
000024  f7fffffe          BL       eap_peer_sm_step
000028  b110              CBZ      r0,|L44.48|
;;;909    			sm->changed = TRUE;
00002a  2001              MOVS     r0,#1
00002c  f8c400c0          STR      r0,[r4,#0xc0]
                  |L44.48|
;;;910    		if (!sm->changed)
000030  f8d400c0          LDR      r0,[r4,#0xc0]
000034  b900              CBNZ     r0,|L44.56|
;;;911    			break;
000036  e002              B        |L44.62|
                  |L44.56|
000038  1c6d              ADDS     r5,r5,#1              ;903
                  |L44.58|
00003a  2d64              CMP      r5,#0x64              ;903
00003c  dbe4              BLT      |L44.8|
                  |L44.62|
00003e  bf00              NOP      
;;;912    	}
;;;913    
;;;914    	if (sm->changed) {
000040  f8d400c0          LDR      r0,[r4,#0xc0]
000044  b158              CBZ      r0,|L44.94|
;;;915    		/* restart EAPOL state machine step from timeout call in order
;;;916    		 * to allow other events to be processed. */
;;;917    		eloop_cancel_timeout(eapol_sm_step_timeout, NULL, sm);
000046  4622              MOV      r2,r4
000048  2100              MOVS     r1,#0
00004a  4812              LDR      r0,|L44.148|
00004c  f7fffffe          BL       eloop_cancel_timeout
;;;918    		eloop_register_timeout(0, 0, eapol_sm_step_timeout, NULL, sm);
000050  2300              MOVS     r3,#0
000052  4a10              LDR      r2,|L44.148|
000054  4619              MOV      r1,r3
000056  4618              MOV      r0,r3
000058  9400              STR      r4,[sp,#0]
00005a  f7fffffe          BL       eloop_register_timeout
                  |L44.94|
;;;919    	}
;;;920    
;;;921    	if (sm->ctx->cb && sm->cb_status != EAPOL_CB_IN_PROGRESS) {
00005e  f8d4010c          LDR      r0,[r4,#0x10c]
000062  6880              LDR      r0,[r0,#8]
000064  b1a0              CBZ      r0,|L44.144|
000066  f8940110          LDRB     r0,[r4,#0x110]
00006a  b188              CBZ      r0,|L44.144|
;;;922    		int success = sm->cb_status == EAPOL_CB_SUCCESS ? 1 : 0;
00006c  f8940110          LDRB     r0,[r4,#0x110]
000070  2801              CMP      r0,#1
000072  d100              BNE      |L44.118|
000074  e000              B        |L44.120|
                  |L44.118|
000076  2000              MOVS     r0,#0
                  |L44.120|
000078  4606              MOV      r6,r0
;;;923    		sm->cb_status = EAPOL_CB_IN_PROGRESS;
00007a  2000              MOVS     r0,#0
00007c  f8840110          STRB     r0,[r4,#0x110]
;;;924    		sm->ctx->cb(sm, success, sm->ctx->cb_ctx);
000080  f8d4010c          LDR      r0,[r4,#0x10c]
000084  4631              MOV      r1,r6
000086  e9d03202          LDRD     r3,r2,[r0,#8]
00008a  4620              MOV      r0,r4
00008c  4798              BLX      r3
;;;925    	}
00008e  bf00              NOP      
                  |L44.144|
;;;926    }
000090  bdf8              POP      {r3-r7,pc}
;;;927    
                          ENDP

000092  0000              DCW      0x0000
                  |L44.148|
                          DCD      eapol_sm_step_timeout

                          AREA ||i.eapol_sm_step_timeout||, CODE, READONLY, ALIGN=1

                  eapol_sm_step_timeout PROC
;;;866    
;;;867    static void eapol_sm_step_timeout(void *eloop_ctx, void *timeout_ctx)
000000  b570              PUSH     {r4-r6,lr}
;;;868    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;869    	eapol_sm_step(timeout_ctx);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       eapol_sm_step
;;;870    }
00000c  bd70              POP      {r4-r6,pc}
;;;871    
                          ENDP


                          AREA ||i.eapol_sm_txLogoff||, CODE, READONLY, ALIGN=2

                  eapol_sm_txLogoff PROC
;;;623    
;;;624    static void eapol_sm_txLogoff(struct eapol_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;625    {
000002  4604              MOV      r4,r0
;;;626    	wpa_printf(MSG_DEBUG, "EAPOL: txLogoff");
000004  a10b              ADR      r1,|L46.52|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       wpa_printf
;;;627    	sm->ctx->eapol_send(sm->ctx->eapol_send_ctx,
00000c  f1040494          ADD      r4,r4,#0x94
000010  6fa1              LDR      r1,[r4,#0x78]
000012  f04f0300          MOV      r3,#0
000016  a20b              ADR      r2,|L46.68|
000018  6a0d              LDR      r5,[r1,#0x20]
00001a  6988              LDR      r0,[r1,#0x18]
00001c  f04f0102          MOV      r1,#2
000020  47a8              BLX      r5
;;;628    			    IEEE802_1X_TYPE_EAPOL_LOGOFF, (u8 *) "", 0);
;;;629    	sm->dot1xSuppEapolLogoffFramesTx++;
000022  68a0              LDR      r0,[r4,#8]
000024  1c40              ADDS     r0,r0,#1
000026  60a0              STR      r0,[r4,#8]
;;;630    	sm->dot1xSuppEapolFramesTx++;
000028  6820              LDR      r0,[r4,#0]
00002a  1c40              ADDS     r0,r0,#1
00002c  f8440994          STR      r0,[r4],#-0x94
;;;631    }
000030  bd70              POP      {r4-r6,pc}
;;;632    
                          ENDP

000032  0000              DCW      0x0000
                  |L46.52|
000034  4541504f          DCB      "EAPOL: txLogoff",0
000038  4c3a2074
00003c  784c6f67
000040  6f666600
                  |L46.68|
000044  00                DCB      0
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.eapol_sm_txStart||, CODE, READONLY, ALIGN=2

                  eapol_sm_txStart PROC
;;;633    
;;;634    static void eapol_sm_txStart(struct eapol_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;635    {
000002  4604              MOV      r4,r0
;;;636    	wpa_printf(MSG_DEBUG, "EAPOL: txStart");
000004  a10b              ADR      r1,|L47.52|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       wpa_printf
;;;637    	sm->ctx->eapol_send(sm->ctx->eapol_send_ctx,
00000c  f1040494          ADD      r4,r4,#0x94
000010  6fa1              LDR      r1,[r4,#0x78]
000012  f04f0300          MOV      r3,#0
000016  a20b              ADR      r2,|L47.68|
000018  6a0d              LDR      r5,[r1,#0x20]
00001a  6988              LDR      r0,[r1,#0x18]
00001c  f04f0101          MOV      r1,#1
000020  47a8              BLX      r5
;;;638    			    IEEE802_1X_TYPE_EAPOL_START, (u8 *) "", 0);
;;;639    	sm->dot1xSuppEapolStartFramesTx++;
000022  6860              LDR      r0,[r4,#4]
000024  1c40              ADDS     r0,r0,#1
000026  6060              STR      r0,[r4,#4]
;;;640    	sm->dot1xSuppEapolFramesTx++;
000028  6820              LDR      r0,[r4,#0]
00002a  1c40              ADDS     r0,r0,#1
00002c  f8440994          STR      r0,[r4],#-0x94
;;;641    }
000030  bd70              POP      {r4-r6,pc}
;;;642    
                          ENDP

000032  0000              DCW      0x0000
                  |L47.52|
000034  4541504f          DCB      "EAPOL: txStart",0
000038  4c3a2074
00003c  78537461
000040  727400  
000043  00                DCB      0
                  |L47.68|
000044  00                DCB      0
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.eapol_sm_txSuppRsp||, CODE, READONLY, ALIGN=2

                  eapol_sm_txSuppRsp PROC
;;;825    
;;;826    static void eapol_sm_txSuppRsp(struct eapol_sm *sm)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;827    {
000004  4604              MOV      r4,r0
;;;828    	struct wpabuf *resp;
;;;829    
;;;830    	wpa_printf(MSG_DEBUG, "EAPOL: txSuppRsp");
000006  a120              ADR      r1,|L48.136|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       wpa_printf
;;;831    	resp = eap_get_eapRespData(sm->eap);
00000e  f8d400c4          LDR      r0,[r4,#0xc4]
000012  f7fffffe          BL       eap_get_eapRespData
000016  4605              MOV      r5,r0
;;;832    	if (resp == NULL) {
000018  b92d              CBNZ     r5,|L48.38|
;;;833    		wpa_printf(MSG_WARNING, "EAPOL: txSuppRsp - EAP response data "
00001a  a120              ADR      r1,|L48.156|
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       wpa_printf
                  |L48.34|
;;;834    			   "not available");
;;;835    		return;
;;;836    	}
;;;837    
;;;838    	/* Send EAP-Packet from the EAP layer to the Authenticator */
;;;839    	sm->ctx->eapol_send(sm->ctx->eapol_send_ctx,
;;;840    			    IEEE802_1X_TYPE_EAP_PACKET, wpabuf_head(resp),
;;;841    			    wpabuf_len(resp));
;;;842    
;;;843    	/* eapRespData is not used anymore, so free it here */
;;;844    	wpabuf_free(resp);
;;;845    
;;;846    	if (sm->initial_req)
;;;847    		sm->dot1xSuppEapolReqIdFramesRx++;
;;;848    	else
;;;849    		sm->dot1xSuppEapolReqFramesRx++;
;;;850    	sm->dot1xSuppEapolRespFramesTx++;
;;;851    	sm->dot1xSuppEapolFramesTx++;
;;;852    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L48.38|
000026  4628              MOV      r0,r5                 ;839
000028  f7fffffe          BL       wpabuf_len
00002c  4607              MOV      r7,r0                 ;839
00002e  4628              MOV      r0,r5                 ;839
000030  f7fffffe          BL       wpabuf_head
000034  4680              MOV      r8,r0                 ;839
000036  f10404cc          ADD      r4,r4,#0xcc           ;839
00003a  6c21              LDR      r1,[r4,#0x40]         ;839
00003c  463b              MOV      r3,r7                 ;839
00003e  4642              MOV      r2,r8                 ;839
000040  6a0e              LDR      r6,[r1,#0x20]         ;839
000042  6988              LDR      r0,[r1,#0x18]         ;839
000044  f04f0100          MOV      r1,#0                 ;839
000048  47b0              BLX      r6                    ;839
00004a  4628              MOV      r0,r5                 ;844
00004c  f7fffffe          BL       wpabuf_free
000050  f85409cc          LDR      r0,[r4],#-0xcc        ;846
000054  b128              CBZ      r0,|L48.98|
000056  f8d400a4          LDR      r0,[r4,#0xa4]         ;847
00005a  1c40              ADDS     r0,r0,#1              ;847
00005c  f8c400a4          STR      r0,[r4,#0xa4]         ;847
000060  e004              B        |L48.108|
                  |L48.98|
000062  f8d400a8          LDR      r0,[r4,#0xa8]         ;849
000066  1c40              ADDS     r0,r0,#1              ;849
000068  f8c400a8          STR      r0,[r4,#0xa8]         ;849
                  |L48.108|
00006c  f1040494          ADD      r4,r4,#0x94           ;850
000070  68e0              LDR      r0,[r4,#0xc]          ;850
000072  f1000001          ADD      r0,r0,#1              ;850
000076  60e0              STR      r0,[r4,#0xc]          ;850
000078  6820              LDR      r0,[r4,#0]            ;851
00007a  f1000001          ADD      r0,r0,#1              ;851
00007e  f8440994          STR      r0,[r4],#-0x94        ;851
000082  bf00              NOP      
000084  e7cd              B        |L48.34|
;;;853    
                          ENDP

000086  0000              DCW      0x0000
                  |L48.136|
000088  4541504f          DCB      "EAPOL: txSuppRsp",0
00008c  4c3a2074
000090  78537570
000094  70527370
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L48.156|
00009c  4541504f          DCB      "EAPOL: txSuppRsp - EAP response data not available",0
0000a0  4c3a2074
0000a4  78537570
0000a8  70527370
0000ac  202d2045
0000b0  41502072
0000b4  6573706f
0000b8  6e736520
0000bc  64617461
0000c0  206e6f74
0000c4  20617661
0000c8  696c6162
0000cc  6c6500  
0000cf  00                DCB      0

                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L49.30|
00001a  2001              MOVS     r0,#1
                  |L49.28|
;;;495    }
00001c  4770              BX       lr
                  |L49.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L49.28|
;;;496    
                          ENDP


                          AREA ||i.sm_KEY_RX_KEY_RECEIVE_Enter||, CODE, READONLY, ALIGN=2

                  sm_KEY_RX_KEY_RECEIVE_Enter PROC
;;;452    
;;;453    SM_STATE(KEY_RX, KEY_RECEIVE)
000000  b570              PUSH     {r4-r6,lr}
;;;454    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;455    	SM_ENTRY(KEY_RX, KEY_RECEIVE);
000006  b11d              CBZ      r5,|L50.16|
000008  f8940074          LDRB     r0,[r4,#0x74]
00000c  2802              CMP      r0,#2
00000e  d006              BEQ      |L50.30|
                  |L50.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a106              ADR      r1,|L50.48|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L50.30|
00001e  2002              MOVS     r0,#2
000020  f8840074          STRB     r0,[r4,#0x74]
;;;456    	eapol_sm_processKey(sm);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       eapol_sm_processKey
;;;457    	sm->rxKey = FALSE;
00002a  2000              MOVS     r0,#0
00002c  67a0              STR      r0,[r4,#0x78]
;;;458    }
00002e  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP

                  |L50.48|
000030  4541504f          DCB      "EAPOL: KEY_RX entering state KEY_RECEIVE",0
000034  4c3a204b
000038  45595f52
00003c  5820656e
000040  74657269
000044  6e672073
000048  74617465
00004c  204b4559
000050  5f524543
000054  45495645
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.sm_KEY_RX_NO_KEY_RECEIVE_Enter||, CODE, READONLY, ALIGN=2

                  sm_KEY_RX_NO_KEY_RECEIVE_Enter PROC
;;;446    
;;;447    SM_STATE(KEY_RX, NO_KEY_RECEIVE)
000000  b570              PUSH     {r4-r6,lr}
;;;448    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;449    	SM_ENTRY(KEY_RX, NO_KEY_RECEIVE);
000006  b11d              CBZ      r5,|L51.16|
000008  f8940074          LDRB     r0,[r4,#0x74]
00000c  2801              CMP      r0,#1
00000e  d006              BEQ      |L51.30|
                  |L51.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a104              ADR      r1,|L51.40|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L51.30|
00001e  2001              MOVS     r0,#1
000020  f8840074          STRB     r0,[r4,#0x74]
;;;450    }
000024  bd70              POP      {r4-r6,pc}
;;;451    
                          ENDP

000026  0000              DCW      0x0000
                  |L51.40|
000028  4541504f          DCB      "EAPOL: KEY_RX entering state NO_KEY_RECEIVE",0
00002c  4c3a204b
000030  45595f52
000034  5820656e
000038  74657269
00003c  6e672073
000040  74617465
000044  204e4f5f
000048  4b45595f
00004c  52454345
000050  49564500

                          AREA ||i.sm_KEY_RX_Step||, CODE, READONLY, ALIGN=1

                  sm_KEY_RX_Step PROC
;;;460    
;;;461    SM_STEP(KEY_RX)
000000  b510              PUSH     {r4,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463    	if (sm->initialize || !sm->portEnabled)
000004  6a20              LDR      r0,[r4,#0x20]
000006  b908              CBNZ     r0,|L52.12|
000008  6b20              LDR      r0,[r4,#0x30]
00000a  b918              CBNZ     r0,|L52.20|
                  |L52.12|
;;;464    		SM_ENTER_GLOBAL(KEY_RX, NO_KEY_RECEIVE);
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sm_KEY_RX_NO_KEY_RECEIVE_Enter
                  |L52.20|
;;;465    	switch (sm->KEY_RX_state) {
000014  f8940074          LDRB     r0,[r4,#0x74]
000018  b120              CBZ      r0,|L52.36|
00001a  2801              CMP      r0,#1
00001c  d003              BEQ      |L52.38|
00001e  2802              CMP      r0,#2
000020  d10f              BNE      |L52.66|
000022  e007              B        |L52.52|
                  |L52.36|
;;;466    	case KEY_RX_UNKNOWN:
;;;467    		break;
000024  e00d              B        |L52.66|
                  |L52.38|
;;;468    	case KEY_RX_NO_KEY_RECEIVE:
;;;469    		if (sm->rxKey)
000026  6fa0              LDR      r0,[r4,#0x78]
000028  b118              CBZ      r0,|L52.50|
;;;470    			SM_ENTER(KEY_RX, KEY_RECEIVE);
00002a  2100              MOVS     r1,#0
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       sm_KEY_RX_KEY_RECEIVE_Enter
                  |L52.50|
;;;471    		break;
000032  e006              B        |L52.66|
                  |L52.52|
;;;472    	case KEY_RX_KEY_RECEIVE:
;;;473    		if (sm->rxKey)
000034  6fa0              LDR      r0,[r4,#0x78]
000036  b118              CBZ      r0,|L52.64|
;;;474    			SM_ENTER(KEY_RX, KEY_RECEIVE);
000038  2100              MOVS     r1,#0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       sm_KEY_RX_KEY_RECEIVE_Enter
                  |L52.64|
;;;475    		break;
000040  bf00              NOP      
                  |L52.66|
000042  bf00              NOP                            ;467
;;;476    	}
;;;477    }
000044  bd10              POP      {r4,pc}
;;;478    
                          ENDP


                          AREA ||i.sm_SUPP_BE_FAIL_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_FAIL_Enter PROC
;;;510    
;;;511    SM_STATE(SUPP_BE, FAIL)
000000  b570              PUSH     {r4-r6,lr}
;;;512    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;513    	SM_ENTRY(SUPP_BE, FAIL);
000006  b11d              CBZ      r5,|L53.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2806              CMP      r0,#6
00000e  d006              BEQ      |L53.30|
                  |L53.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a105              ADR      r1,|L53.44|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L53.30|
00001e  2006              MOVS     r0,#6
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;514    	sm->suppFail = TRUE;
000024  2001              MOVS     r0,#1
000026  6420              STR      r0,[r4,#0x40]
;;;515    }
000028  bd70              POP      {r4-r6,pc}
;;;516    
                          ENDP

00002a  0000              DCW      0x0000
                  |L53.44|
00002c  4541504f          DCB      "EAPOL: SUPP_BE entering state FAIL",0
000030  4c3a2053
000034  5550505f
000038  42452065
00003c  6e746572
000040  696e6720
000044  73746174
000048  65204641
00004c  494c00  
00004f  00                DCB      0

                          AREA ||i.sm_SUPP_BE_IDLE_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_IDLE_Enter PROC
;;;524    
;;;525    SM_STATE(SUPP_BE, IDLE)
000000  b570              PUSH     {r4-r6,lr}
;;;526    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;527    	SM_ENTRY(SUPP_BE, IDLE);
000006  b11d              CBZ      r5,|L54.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2802              CMP      r0,#2
00000e  d006              BEQ      |L54.30|
                  |L54.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a106              ADR      r1,|L54.48|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L54.30|
00001e  2002              MOVS     r0,#2
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;528    	sm->suppStart = FALSE;
000024  2000              MOVS     r0,#0
000026  6460              STR      r0,[r4,#0x44]
;;;529    	sm->initial_req = TRUE;
000028  2001              MOVS     r0,#1
00002a  f8c400cc          STR      r0,[r4,#0xcc]
;;;530    }
00002e  bd70              POP      {r4-r6,pc}
;;;531    
                          ENDP

                  |L54.48|
000030  4541504f          DCB      "EAPOL: SUPP_BE entering state IDLE",0
000034  4c3a2053
000038  5550505f
00003c  42452065
000040  6e746572
000044  696e6720
000048  73746174
00004c  65204944
000050  4c4500  
000053  00                DCB      0

                          AREA ||i.sm_SUPP_BE_INITIALIZE_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_INITIALIZE_Enter PROC
;;;532    
;;;533    SM_STATE(SUPP_BE, INITIALIZE)
000000  b570              PUSH     {r4-r6,lr}
;;;534    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;535    	SM_ENTRY(SUPP_BE, INITIALIZE);
000006  b11d              CBZ      r5,|L55.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2801              CMP      r0,#1
00000e  d006              BEQ      |L55.30|
                  |L55.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a106              ADR      r1,|L55.48|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L55.30|
00001e  2001              MOVS     r0,#1
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;536    	eapol_sm_abortSupp(sm);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       eapol_sm_abortSupp
;;;537    	sm->suppAbort = FALSE;
00002a  2000              MOVS     r0,#0
00002c  63e0              STR      r0,[r4,#0x3c]
;;;538    }
00002e  bd70              POP      {r4-r6,pc}
;;;539    
                          ENDP

                  |L55.48|
000030  4541504f          DCB      "EAPOL: SUPP_BE entering state INITIALIZE",0
000034  4c3a2053
000038  5550505f
00003c  42452065
000040  6e746572
000044  696e6720
000048  73746174
00004c  6520494e
000050  49544941
000054  4c495a45
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.sm_SUPP_BE_RECEIVE_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_RECEIVE_Enter PROC
;;;540    
;;;541    SM_STATE(SUPP_BE, RECEIVE)
000000  b570              PUSH     {r4-r6,lr}
;;;542    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;543    	SM_ENTRY(SUPP_BE, RECEIVE);
000006  b11d              CBZ      r5,|L56.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2804              CMP      r0,#4
00000e  d006              BEQ      |L56.30|
                  |L56.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a10a              ADR      r1,|L56.64|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L56.30|
00001e  2004              MOVS     r0,#4
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;544    	sm->authWhile = sm->authPeriod;
000024  f8d4008c          LDR      r0,[r4,#0x8c]
000028  6020              STR      r0,[r4,#0]
;;;545    	eapol_enable_timer_tick(sm);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       eapol_enable_timer_tick
;;;546    	sm->eapolEap = FALSE;
000030  2000              MOVS     r0,#0
000032  61a0              STR      r0,[r4,#0x18]
;;;547    	sm->eapNoResp = FALSE;
000034  f8c40080          STR      r0,[r4,#0x80]
;;;548    	sm->initial_req = FALSE;
000038  f8c400cc          STR      r0,[r4,#0xcc]
;;;549    }
00003c  bd70              POP      {r4-r6,pc}
;;;550    
                          ENDP

00003e  0000              DCW      0x0000
                  |L56.64|
000040  4541504f          DCB      "EAPOL: SUPP_BE entering state RECEIVE",0
000044  4c3a2053
000048  5550505f
00004c  42452065
000050  6e746572
000054  696e6720
000058  73746174
00005c  65205245
000060  43454956
000064  4500    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.sm_SUPP_BE_REQUEST_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_REQUEST_Enter PROC
;;;479    
;;;480    SM_STATE(SUPP_BE, REQUEST)
000000  b570              PUSH     {r4-r6,lr}
;;;481    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;482    	SM_ENTRY(SUPP_BE, REQUEST);
000006  b11d              CBZ      r5,|L57.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2803              CMP      r0,#3
00000e  d006              BEQ      |L57.30|
                  |L57.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a108              ADR      r1,|L57.56|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L57.30|
00001e  2003              MOVS     r0,#3
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;483    	sm->authWhile = 0;
000024  2000              MOVS     r0,#0
000026  6020              STR      r0,[r4,#0]
;;;484    	sm->eapReq = TRUE;
000028  2001              MOVS     r0,#1
00002a  f8c40084          STR      r0,[r4,#0x84]
;;;485    	eapol_sm_getSuppRsp(sm);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       eapol_sm_getSuppRsp
;;;486    }
000034  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP

000036  0000              DCW      0x0000
                  |L57.56|
000038  4541504f          DCB      "EAPOL: SUPP_BE entering state REQUEST",0
00003c  4c3a2053
000040  5550505f
000044  42452065
000048  6e746572
00004c  696e6720
000050  73746174
000054  65205245
000058  51554553
00005c  5400    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.sm_SUPP_BE_RESPONSE_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_RESPONSE_Enter PROC
;;;488    
;;;489    SM_STATE(SUPP_BE, RESPONSE)
000000  b570              PUSH     {r4-r6,lr}
;;;490    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;491    	SM_ENTRY(SUPP_BE, RESPONSE);
000006  b11d              CBZ      r5,|L58.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2805              CMP      r0,#5
00000e  d006              BEQ      |L58.30|
                  |L58.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a107              ADR      r1,|L58.52|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L58.30|
00001e  2005              MOVS     r0,#5
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;492    	eapol_sm_txSuppRsp(sm);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       eapol_sm_txSuppRsp
;;;493    	sm->eapResp = FALSE;
00002a  2000              MOVS     r0,#0
00002c  f8c40088          STR      r0,[r4,#0x88]
;;;494    }
000030  bd70              POP      {r4-r6,pc}
;;;495    
                          ENDP

000032  0000              DCW      0x0000
                  |L58.52|
000034  4541504f          DCB      "EAPOL: SUPP_BE entering state RESPONSE",0
000038  4c3a2053
00003c  5550505f
000040  42452065
000044  6e746572
000048  696e6720
00004c  73746174
000050  65205245
000054  53504f4e
000058  534500  
00005b  00                DCB      0

                          AREA ||i.sm_SUPP_BE_SUCCESS_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_SUCCESS_Enter PROC
;;;496    
;;;497    SM_STATE(SUPP_BE, SUCCESS)
000000  b570              PUSH     {r4-r6,lr}
;;;498    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;499    	SM_ENTRY(SUPP_BE, SUCCESS);
000006  b11d              CBZ      r5,|L59.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2808              CMP      r0,#8
00000e  d006              BEQ      |L59.30|
                  |L59.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a109              ADR      r1,|L59.60|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L59.30|
00001e  2008              MOVS     r0,#8
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;500    	sm->keyRun = TRUE;
000024  2001              MOVS     r0,#1
000026  62a0              STR      r0,[r4,#0x28]
;;;501    	sm->suppSuccess = TRUE;
000028  64a0              STR      r0,[r4,#0x48]
;;;502    
;;;503    	if (eap_key_available(sm->eap)) {
00002a  f8d400c4          LDR      r0,[r4,#0xc4]
00002e  f7fffffe          BL       eap_key_available
000032  b110              CBZ      r0,|L59.58|
;;;504    		/* New key received - clear IEEE 802.1X EAPOL-Key replay
;;;505    		 * counter */
;;;506    		sm->replay_counter_valid = FALSE;
000034  2000              MOVS     r0,#0
000036  f8c400e4          STR      r0,[r4,#0xe4]
                  |L59.58|
;;;507    	}
;;;508    }
00003a  bd70              POP      {r4-r6,pc}
;;;509    
                          ENDP

                  |L59.60|
00003c  4541504f          DCB      "EAPOL: SUPP_BE entering state SUCCESS",0
000040  4c3a2053
000044  5550505f
000048  42452065
00004c  6e746572
000050  696e6720
000054  73746174
000058  65205355
00005c  43434553
000060  5300    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.sm_SUPP_BE_Step||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_Step PROC
;;;551    
;;;552    SM_STEP(SUPP_BE)
000000  b510              PUSH     {r4,lr}
;;;553    {
000002  4604              MOV      r4,r0
;;;554    	if (sm->initialize || sm->suppAbort)
000004  6a20              LDR      r0,[r4,#0x20]
000006  b908              CBNZ     r0,|L60.12|
000008  6be0              LDR      r0,[r4,#0x3c]
00000a  b120              CBZ      r0,|L60.22|
                  |L60.12|
;;;555    		SM_ENTER_GLOBAL(SUPP_BE, INITIALIZE);
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sm_SUPP_BE_INITIALIZE_Enter
000014  e084              B        |L60.288|
                  |L60.22|
;;;556    	else switch (sm->SUPP_BE_state) {
000016  f894007c          LDRB     r0,[r4,#0x7c]
00001a  2809              CMP      r0,#9
00001c  d27f              BCS      |L60.286|
00001e  e8dff000          TBB      [pc,r0]
000022  055d              DCB      0x05,0x5d
000024  4206622e          DCB      0x42,0x06,0x62,0x2e
000028  383d3300          DCB      0x38,0x3d,0x33,0x00
;;;557    	case SUPP_BE_UNKNOWN:
;;;558    		break;
00002c  e077              B        |L60.286|
;;;559    	case SUPP_BE_REQUEST:
;;;560    		/*
;;;561    		 * IEEE Std 802.1X-2004 has transitions from REQUEST to FAIL
;;;562    		 * and SUCCESS based on eapFail and eapSuccess, respectively.
;;;563    		 * However, IEEE Std 802.1X-2004 is also specifying that
;;;564    		 * eapNoResp should be set in conjuction with eapSuccess and
;;;565    		 * eapFail which would mean that more than one of the
;;;566    		 * transitions here would be activated at the same time.
;;;567    		 * Skipping RESPONSE and/or RECEIVE states in these cases can
;;;568    		 * cause problems and the direct transitions to do not seem
;;;569    		 * correct. Because of this, the conditions for these
;;;570    		 * transitions are verified only after eapNoResp. They are
;;;571    		 * unlikely to be used since eapNoResp should always be set if
;;;572    		 * either of eapSuccess or eapFail is set.
;;;573    		 */
;;;574    		if (sm->eapResp && sm->eapNoResp) {
00002e  f8d40088          LDR      r0,[r4,#0x88]
000032  b130              CBZ      r0,|L60.66|
000034  f8d40080          LDR      r0,[r4,#0x80]
000038  b118              CBZ      r0,|L60.66|
;;;575    			wpa_printf(MSG_DEBUG, "EAPOL: SUPP_BE REQUEST: both "
00003a  a13a              ADR      r1,|L60.292|
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       wpa_printf
                  |L60.66|
;;;576    				   "eapResp and eapNoResp set?!");
;;;577    		}
;;;578    		if (sm->eapResp)
000042  f8d40088          LDR      r0,[r4,#0x88]
000046  b120              CBZ      r0,|L60.82|
;;;579    			SM_ENTER(SUPP_BE, RESPONSE);
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       sm_SUPP_BE_RESPONSE_Enter
000050  e014              B        |L60.124|
                  |L60.82|
;;;580    		else if (sm->eapNoResp)
000052  f8d40080          LDR      r0,[r4,#0x80]
000056  b120              CBZ      r0,|L60.98|
;;;581    			SM_ENTER(SUPP_BE, RECEIVE);
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       sm_SUPP_BE_RECEIVE_Enter
000060  e00c              B        |L60.124|
                  |L60.98|
;;;582    		else if (sm->eapFail)
000062  6960              LDR      r0,[r4,#0x14]
000064  b120              CBZ      r0,|L60.112|
;;;583    			SM_ENTER(SUPP_BE, FAIL);
000066  2100              MOVS     r1,#0
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       sm_SUPP_BE_FAIL_Enter
00006e  e005              B        |L60.124|
                  |L60.112|
;;;584    		else if (sm->eapSuccess)
000070  69e0              LDR      r0,[r4,#0x1c]
000072  b118              CBZ      r0,|L60.124|
;;;585    			SM_ENTER(SUPP_BE, SUCCESS);
000074  2100              MOVS     r1,#0
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       sm_SUPP_BE_SUCCESS_Enter
                  |L60.124|
;;;586    		break;
00007c  e04f              B        |L60.286|
;;;587    	case SUPP_BE_RESPONSE:
;;;588    		SM_ENTER(SUPP_BE, RECEIVE);
00007e  2100              MOVS     r1,#0
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       sm_SUPP_BE_RECEIVE_Enter
;;;589    		break;
000086  e04a              B        |L60.286|
;;;590    	case SUPP_BE_SUCCESS:
;;;591    		SM_ENTER(SUPP_BE, IDLE);
000088  2100              MOVS     r1,#0
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       sm_SUPP_BE_IDLE_Enter
;;;592    		break;
000090  e045              B        |L60.286|
;;;593    	case SUPP_BE_FAIL:
;;;594    		SM_ENTER(SUPP_BE, IDLE);
000092  2100              MOVS     r1,#0
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       sm_SUPP_BE_IDLE_Enter
;;;595    		break;
00009a  e040              B        |L60.286|
;;;596    	case SUPP_BE_TIMEOUT:
;;;597    		SM_ENTER(SUPP_BE, IDLE);
00009c  2100              MOVS     r1,#0
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       sm_SUPP_BE_IDLE_Enter
;;;598    		break;
0000a4  e03b              B        |L60.286|
;;;599    	case SUPP_BE_IDLE:
;;;600    		if (sm->eapFail && sm->suppStart)
0000a6  6960              LDR      r0,[r4,#0x14]
0000a8  b130              CBZ      r0,|L60.184|
0000aa  6c60              LDR      r0,[r4,#0x44]
0000ac  b120              CBZ      r0,|L60.184|
;;;601    			SM_ENTER(SUPP_BE, FAIL);
0000ae  2100              MOVS     r1,#0
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       sm_SUPP_BE_FAIL_Enter
0000b6  e010              B        |L60.218|
                  |L60.184|
;;;602    		else if (sm->eapolEap && sm->suppStart)
0000b8  69a0              LDR      r0,[r4,#0x18]
0000ba  b130              CBZ      r0,|L60.202|
0000bc  6c60              LDR      r0,[r4,#0x44]
0000be  b120              CBZ      r0,|L60.202|
;;;603    			SM_ENTER(SUPP_BE, REQUEST);
0000c0  2100              MOVS     r1,#0
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       sm_SUPP_BE_REQUEST_Enter
0000c8  e007              B        |L60.218|
                  |L60.202|
;;;604    		else if (sm->eapSuccess && sm->suppStart)
0000ca  69e0              LDR      r0,[r4,#0x1c]
0000cc  b128              CBZ      r0,|L60.218|
0000ce  6c60              LDR      r0,[r4,#0x44]
0000d0  b118              CBZ      r0,|L60.218|
;;;605    			SM_ENTER(SUPP_BE, SUCCESS);
0000d2  2100              MOVS     r1,#0
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       sm_SUPP_BE_SUCCESS_Enter
                  |L60.218|
;;;606    		break;
0000da  e020              B        |L60.286|
;;;607    	case SUPP_BE_INITIALIZE:
;;;608    		SM_ENTER(SUPP_BE, IDLE);
0000dc  2100              MOVS     r1,#0
0000de  4620              MOV      r0,r4
0000e0  f7fffffe          BL       sm_SUPP_BE_IDLE_Enter
;;;609    		break;
0000e4  e01b              B        |L60.286|
;;;610    	case SUPP_BE_RECEIVE:
;;;611    		if (sm->eapolEap)
0000e6  69a0              LDR      r0,[r4,#0x18]
0000e8  b120              CBZ      r0,|L60.244|
;;;612    			SM_ENTER(SUPP_BE, REQUEST);
0000ea  2100              MOVS     r1,#0
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       sm_SUPP_BE_REQUEST_Enter
0000f2  e013              B        |L60.284|
                  |L60.244|
;;;613    		else if (sm->eapFail)
0000f4  6960              LDR      r0,[r4,#0x14]
0000f6  b120              CBZ      r0,|L60.258|
;;;614    			SM_ENTER(SUPP_BE, FAIL);
0000f8  2100              MOVS     r1,#0
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       sm_SUPP_BE_FAIL_Enter
000100  e00c              B        |L60.284|
                  |L60.258|
;;;615    		else if (sm->authWhile == 0)
000102  6820              LDR      r0,[r4,#0]
000104  b920              CBNZ     r0,|L60.272|
;;;616    			SM_ENTER(SUPP_BE, TIMEOUT);
000106  2100              MOVS     r1,#0
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       sm_SUPP_BE_TIMEOUT_Enter
00010e  e005              B        |L60.284|
                  |L60.272|
;;;617    		else if (sm->eapSuccess)
000110  69e0              LDR      r0,[r4,#0x1c]
000112  b118              CBZ      r0,|L60.284|
;;;618    			SM_ENTER(SUPP_BE, SUCCESS);
000114  2100              MOVS     r1,#0
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       sm_SUPP_BE_SUCCESS_Enter
                  |L60.284|
;;;619    		break;
00011c  bf00              NOP      
                  |L60.286|
00011e  bf00              NOP                            ;558
                  |L60.288|
;;;620    	}
;;;621    }
000120  bd10              POP      {r4,pc}
;;;622    
                          ENDP

000122  0000              DCW      0x0000
                  |L60.292|
000124  4541504f          DCB      "EAPOL: SUPP_BE REQUEST: both eapResp and eapNoResp set?"
000128  4c3a2053
00012c  5550505f
000130  42452052
000134  45515545
000138  53543a20
00013c  626f7468
000140  20656170
000144  52657370
000148  20616e64
00014c  20656170
000150  4e6f5265
000154  73702073
000158  65743f  
00015b  2100              DCB      "!",0
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0

                          AREA ||i.sm_SUPP_BE_TIMEOUT_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_BE_TIMEOUT_Enter PROC
;;;517    
;;;518    SM_STATE(SUPP_BE, TIMEOUT)
000000  b570              PUSH     {r4-r6,lr}
;;;519    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;520    	SM_ENTRY(SUPP_BE, TIMEOUT);
000006  b11d              CBZ      r5,|L61.16|
000008  f894007c          LDRB     r0,[r4,#0x7c]
00000c  2807              CMP      r0,#7
00000e  d006              BEQ      |L61.30|
                  |L61.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a105              ADR      r1,|L61.44|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L61.30|
00001e  2007              MOVS     r0,#7
000020  f884007c          STRB     r0,[r4,#0x7c]
;;;521    	sm->suppTimeout = TRUE;
000024  2001              MOVS     r0,#1
000026  64e0              STR      r0,[r4,#0x4c]
;;;522    }
000028  bd70              POP      {r4-r6,pc}
;;;523    
                          ENDP

00002a  0000              DCW      0x0000
                  |L61.44|
00002c  4541504f          DCB      "EAPOL: SUPP_BE entering state TIMEOUT",0
000030  4c3a2053
000034  5550505f
000038  42452065
00003c  6e746572
000040  696e6720
000044  73746174
000048  65205449
00004c  4d454f55
000050  5400    
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_AUTHENTICATED_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_AUTHENTICATED_Enter PROC
;;;326    
;;;327    SM_STATE(SUPP_PAE, AUTHENTICATED)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;329    	SM_ENTRY(SUPP_PAE, AUTHENTICATED);
000006  b11d              CBZ      r5,|L62.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2805              CMP      r0,#5
00000e  d006              BEQ      |L62.30|
                  |L62.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a108              ADR      r1,|L62.56|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L62.30|
00001e  2005              MOVS     r0,#5
000020  f8840050          STRB     r0,[r4,#0x50]
;;;330    	sm->suppPortStatus = Authorized;
000024  2001              MOVS     r0,#1
000026  f8840034          STRB     r0,[r4,#0x34]
;;;331    	eapol_sm_set_port_authorized(sm);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       eapol_sm_set_port_authorized
;;;332    	sm->cb_status = EAPOL_CB_SUCCESS;
000030  2001              MOVS     r0,#1
000032  f8840110          STRB     r0,[r4,#0x110]
;;;333    }
000036  bd70              POP      {r4-r6,pc}
;;;334    
                          ENDP

                  |L62.56|
000038  4541504f          DCB      "EAPOL: SUPP_PAE entering state AUTHENTICATED",0
00003c  4c3a2053
000040  5550505f
000044  50414520
000048  656e7465
00004c  72696e67
000050  20737461
000054  74652041
000058  55544845
00005c  4e544943
000060  41544544
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_AUTHENTICATING_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_AUTHENTICATING_Enter PROC
;;;302    
;;;303    SM_STATE(SUPP_PAE, AUTHENTICATING)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;305    	SM_ENTRY(SUPP_PAE, AUTHENTICATING);
000006  b11d              CBZ      r5,|L63.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2804              CMP      r0,#4
00000e  d006              BEQ      |L63.30|
                  |L63.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a108              ADR      r1,|L63.56|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L63.30|
00001e  2004              MOVS     r0,#4
000020  f8840050          STRB     r0,[r4,#0x50]
;;;306    	sm->startCount = 0;
000024  2000              MOVS     r0,#0
000026  65e0              STR      r0,[r4,#0x5c]
;;;307    	sm->suppSuccess = FALSE;
000028  64a0              STR      r0,[r4,#0x48]
;;;308    	sm->suppFail = FALSE;
00002a  6420              STR      r0,[r4,#0x40]
;;;309    	sm->suppTimeout = FALSE;
00002c  64e0              STR      r0,[r4,#0x4c]
;;;310    	sm->keyRun = FALSE;
00002e  62a0              STR      r0,[r4,#0x28]
;;;311    	sm->keyDone = FALSE;
000030  6260              STR      r0,[r4,#0x24]
;;;312    	sm->suppStart = TRUE;
000032  2001              MOVS     r0,#1
000034  6460              STR      r0,[r4,#0x44]
;;;313    }
000036  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

                  |L63.56|
000038  4541504f          DCB      "EAPOL: SUPP_PAE entering state AUTHENTICATING",0
00003c  4c3a2053
000040  5550505f
000044  50414520
000048  656e7465
00004c  72696e67
000050  20737461
000054  74652041
000058  55544845
00005c  4e544943
000060  4154494e
000064  4700    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_CONNECTING_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_CONNECTING_Enter PROC
;;;273    
;;;274    SM_STATE(SUPP_PAE, CONNECTING)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;276    	int send_start = sm->SUPP_PAE_state == SUPP_PAE_CONNECTING;
000006  f8940050          LDRB     r0,[r4,#0x50]
00000a  2803              CMP      r0,#3
00000c  d101              BNE      |L64.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L64.20|
                  |L64.18|
000012  2000              MOVS     r0,#0
                  |L64.20|
000014  4606              MOV      r6,r0
;;;277    	SM_ENTRY(SUPP_PAE, CONNECTING);
000016  b11d              CBZ      r5,|L64.32|
000018  f8940050          LDRB     r0,[r4,#0x50]
00001c  2803              CMP      r0,#3
00001e  d006              BEQ      |L64.46|
                  |L64.32|
000020  2001              MOVS     r0,#1
000022  f8c400c0          STR      r0,[r4,#0xc0]
000026  a10d              ADR      r1,|L64.92|
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       wpa_printf
                  |L64.46|
00002e  2003              MOVS     r0,#3
000030  f8840050          STRB     r0,[r4,#0x50]
;;;278    	if (send_start) {
000034  b12e              CBZ      r6,|L64.66|
;;;279    		sm->startWhen = sm->startPeriod;
000036  6ee0              LDR      r0,[r4,#0x6c]
000038  60a0              STR      r0,[r4,#8]
;;;280    		sm->startCount++;
00003a  6de0              LDR      r0,[r4,#0x5c]
00003c  1c40              ADDS     r0,r0,#1
00003e  65e0              STR      r0,[r4,#0x5c]
000040  e001              B        |L64.70|
                  |L64.66|
;;;281    	} else {
;;;282    		/*
;;;283    		 * Do not send EAPOL-Start immediately since in most cases,
;;;284    		 * Authenticator is going to start authentication immediately
;;;285    		 * after association and an extra EAPOL-Start is just going to
;;;286    		 * delay authentication. Use a short timeout to send the first
;;;287    		 * EAPOL-Start if Authenticator does not start authentication.
;;;288    		 */
;;;289    #ifdef CONFIG_WPS
;;;290    		/* Reduce latency on starting WPS negotiation. */
;;;291    		sm->startWhen = 1;
;;;292    #else /* CONFIG_WPS */
;;;293    		sm->startWhen = 3;
000042  2003              MOVS     r0,#3
000044  60a0              STR      r0,[r4,#8]
                  |L64.70|
;;;294    #endif /* CONFIG_WPS */
;;;295    	}
;;;296    	eapol_enable_timer_tick(sm);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       eapol_enable_timer_tick
;;;297    	sm->eapolEap = FALSE;
00004c  2000              MOVS     r0,#0
00004e  61a0              STR      r0,[r4,#0x18]
;;;298    	if (send_start)
000050  b116              CBZ      r6,|L64.88|
;;;299    		eapol_sm_txStart(sm);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       eapol_sm_txStart
                  |L64.88|
;;;300    }
000058  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

00005a  0000              DCW      0x0000
                  |L64.92|
00005c  4541504f          DCB      "EAPOL: SUPP_PAE entering state CONNECTING",0
000060  4c3a2053
000064  5550505f
000068  50414520
00006c  656e7465
000070  72696e67
000074  20737461
000078  74652043
00007c  4f4e4e45
000080  4354494e
000084  4700    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_DISCONNECTED_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_DISCONNECTED_Enter PROC
;;;258    
;;;259    SM_STATE(SUPP_PAE, DISCONNECTED)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;261    	SM_ENTRY(SUPP_PAE, DISCONNECTED);
000006  b11d              CBZ      r5,|L65.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2801              CMP      r0,#1
00000e  d006              BEQ      |L65.30|
                  |L65.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a10c              ADR      r1,|L65.72|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L65.30|
00001e  2001              MOVS     r0,#1
000020  f8840050          STRB     r0,[r4,#0x50]
;;;262    	sm->sPortMode = Auto;
000024  2000              MOVS     r0,#0
000026  f8840064          STRB     r0,[r4,#0x64]
;;;263    	sm->startCount = 0;
00002a  65e0              STR      r0,[r4,#0x5c]
;;;264    	sm->logoffSent = FALSE;
00002c  65a0              STR      r0,[r4,#0x58]
;;;265    	sm->suppPortStatus = Unauthorized;
00002e  f8840034          STRB     r0,[r4,#0x34]
;;;266    	eapol_sm_set_port_unauthorized(sm);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       eapol_sm_set_port_unauthorized
;;;267    	sm->suppAbort = TRUE;
000038  2001              MOVS     r0,#1
00003a  63e0              STR      r0,[r4,#0x3c]
;;;268    
;;;269    	sm->unicast_key_received = FALSE;
00003c  2000              MOVS     r0,#0
00003e  f8c40118          STR      r0,[r4,#0x118]
;;;270    	sm->broadcast_key_received = FALSE;
000042  f8c4011c          STR      r0,[r4,#0x11c]
;;;271    }
000046  bd70              POP      {r4-r6,pc}
;;;272    
                          ENDP

                  |L65.72|
000048  4541504f          DCB      "EAPOL: SUPP_PAE entering state DISCONNECTED",0
00004c  4c3a2053
000050  5550505f
000054  50414520
000058  656e7465
00005c  72696e67
000060  20737461
000064  74652044
000068  4953434f
00006c  4e4e4543
000070  54454400

                          AREA ||i.sm_SUPP_PAE_HELD_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_HELD_Enter PROC
;;;315    
;;;316    SM_STATE(SUPP_PAE, HELD)
000000  b570              PUSH     {r4-r6,lr}
;;;317    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;318    	SM_ENTRY(SUPP_PAE, HELD);
000006  b11d              CBZ      r5,|L66.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2807              CMP      r0,#7
00000e  d006              BEQ      |L66.30|
                  |L66.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a10b              ADR      r1,|L66.68|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L66.30|
00001e  2007              MOVS     r0,#7
000020  f8840050          STRB     r0,[r4,#0x50]
;;;319    	sm->heldWhile = sm->heldPeriod;
000024  6ea0              LDR      r0,[r4,#0x68]
000026  6060              STR      r0,[r4,#4]
;;;320    	eapol_enable_timer_tick(sm);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       eapol_enable_timer_tick
;;;321    	sm->suppPortStatus = Unauthorized;
00002e  2000              MOVS     r0,#0
000030  f8840034          STRB     r0,[r4,#0x34]
;;;322    	eapol_sm_set_port_unauthorized(sm);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       eapol_sm_set_port_unauthorized
;;;323    	sm->cb_status = EAPOL_CB_FAILURE;
00003a  2002              MOVS     r0,#2
00003c  f8840110          STRB     r0,[r4,#0x110]
;;;324    }
000040  bd70              POP      {r4-r6,pc}
;;;325    
                          ENDP

000042  0000              DCW      0x0000
                  |L66.68|
000044  4541504f          DCB      "EAPOL: SUPP_PAE entering state HELD",0
000048  4c3a2053
00004c  5550505f
000050  50414520
000054  656e7465
000058  72696e67
00005c  20737461
000060  74652048
000064  454c4400

                          AREA ||i.sm_SUPP_PAE_LOGOFF_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_LOGOFF_Enter PROC
;;;248    
;;;249    SM_STATE(SUPP_PAE, LOGOFF)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;251    	SM_ENTRY(SUPP_PAE, LOGOFF);
000006  b11d              CBZ      r5,|L67.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2802              CMP      r0,#2
00000e  d006              BEQ      |L67.30|
                  |L67.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a109              ADR      r1,|L67.60|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L67.30|
00001e  2002              MOVS     r0,#2
000020  f8840050          STRB     r0,[r4,#0x50]
;;;252    	eapol_sm_txLogoff(sm);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       eapol_sm_txLogoff
;;;253    	sm->logoffSent = TRUE;
00002a  2001              MOVS     r0,#1
00002c  65a0              STR      r0,[r4,#0x58]
;;;254    	sm->suppPortStatus = Unauthorized;
00002e  2000              MOVS     r0,#0
000030  f8840034          STRB     r0,[r4,#0x34]
;;;255    	eapol_sm_set_port_unauthorized(sm);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       eapol_sm_set_port_unauthorized
;;;256    }
00003a  bd70              POP      {r4-r6,pc}
;;;257    
                          ENDP

                  |L67.60|
00003c  4541504f          DCB      "EAPOL: SUPP_PAE entering state LOGOFF",0
000040  4c3a2053
000044  5550505f
000048  50414520
00004c  656e7465
000050  72696e67
000054  20737461
000058  7465204c
00005c  4f474f46
000060  4600    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_RESTART_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_RESTART_Enter PROC
;;;335    
;;;336    SM_STATE(SUPP_PAE, RESTART)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;338    	SM_ENTRY(SUPP_PAE, RESTART);
000006  b11d              CBZ      r5,|L68.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2808              CMP      r0,#8
00000e  d006              BEQ      |L68.30|
                  |L68.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a105              ADR      r1,|L68.44|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L68.30|
00001e  2008              MOVS     r0,#8
000020  f8840050          STRB     r0,[r4,#0x50]
;;;339    	sm->eapRestart = TRUE;
000024  2001              MOVS     r0,#1
000026  6620              STR      r0,[r4,#0x60]
;;;340    }
000028  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

00002a  0000              DCW      0x0000
                  |L68.44|
00002c  4541504f          DCB      "EAPOL: SUPP_PAE entering state RESTART",0
000030  4c3a2053
000034  5550505f
000038  50414520
00003c  656e7465
000040  72696e67
000044  20737461
000048  74652052
00004c  45535441
000050  525400  
000053  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_S_FORCE_AUTH_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_S_FORCE_AUTH_Enter PROC
;;;342    
;;;343    SM_STATE(SUPP_PAE, S_FORCE_AUTH)
000000  b570              PUSH     {r4-r6,lr}
;;;344    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;345    	SM_ENTRY(SUPP_PAE, S_FORCE_AUTH);
000006  b11d              CBZ      r5,|L69.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  2809              CMP      r0,#9
00000e  d006              BEQ      |L69.30|
                  |L69.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a108              ADR      r1,|L69.56|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L69.30|
00001e  2009              MOVS     r0,#9
000020  f8840050          STRB     r0,[r4,#0x50]
;;;346    	sm->suppPortStatus = Authorized;
000024  2001              MOVS     r0,#1
000026  f8840034          STRB     r0,[r4,#0x34]
;;;347    	eapol_sm_set_port_authorized(sm);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       eapol_sm_set_port_authorized
;;;348    	sm->sPortMode = ForceAuthorized;
000030  2002              MOVS     r0,#2
000032  f8840064          STRB     r0,[r4,#0x64]
;;;349    }
000036  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  |L69.56|
000038  4541504f          DCB      "EAPOL: SUPP_PAE entering state S_FORCE_AUTH",0
00003c  4c3a2053
000040  5550505f
000044  50414520
000048  656e7465
00004c  72696e67
000050  20737461
000054  74652053
000058  5f464f52
00005c  43455f41
000060  55544800

                          AREA ||i.sm_SUPP_PAE_S_FORCE_UNAUTH_Enter||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_S_FORCE_UNAUTH_Enter PROC
;;;351    
;;;352    SM_STATE(SUPP_PAE, S_FORCE_UNAUTH)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;354    	SM_ENTRY(SUPP_PAE, S_FORCE_UNAUTH);
000006  b11d              CBZ      r5,|L70.16|
000008  f8940050          LDRB     r0,[r4,#0x50]
00000c  280a              CMP      r0,#0xa
00000e  d006              BEQ      |L70.30|
                  |L70.16|
000010  2001              MOVS     r0,#1
000012  f8c400c0          STR      r0,[r4,#0xc0]
000016  a10a              ADR      r1,|L70.64|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       wpa_printf
                  |L70.30|
00001e  200a              MOVS     r0,#0xa
000020  f8840050          STRB     r0,[r4,#0x50]
;;;355    	sm->suppPortStatus = Unauthorized;
000024  2000              MOVS     r0,#0
000026  f8840034          STRB     r0,[r4,#0x34]
;;;356    	eapol_sm_set_port_unauthorized(sm);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       eapol_sm_set_port_unauthorized
;;;357    	sm->sPortMode = ForceUnauthorized;
000030  2001              MOVS     r0,#1
000032  f8840064          STRB     r0,[r4,#0x64]
;;;358    	eapol_sm_txLogoff(sm);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       eapol_sm_txLogoff
;;;359    }
00003c  bd70              POP      {r4-r6,pc}
;;;360    
                          ENDP

00003e  0000              DCW      0x0000
                  |L70.64|
000040  4541504f          DCB      "EAPOL: SUPP_PAE entering state S_FORCE_UNAUTH",0
000044  4c3a2053
000048  5550505f
00004c  50414520
000050  656e7465
000054  72696e67
000058  20737461
00005c  74652053
000060  5f464f52
000064  43455f55
000068  4e415554
00006c  4800    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.sm_SUPP_PAE_Step||, CODE, READONLY, ALIGN=2

                  sm_SUPP_PAE_Step PROC
;;;361    
;;;362    SM_STEP(SUPP_PAE)
000000  b510              PUSH     {r4,lr}
;;;363    {
000002  4604              MOV      r4,r0
;;;364    	if ((sm->userLogoff && !sm->logoffSent) &&
000004  6d60              LDR      r0,[r4,#0x54]
000006  b150              CBZ      r0,|L71.30|
000008  6da0              LDR      r0,[r4,#0x58]
00000a  b940              CBNZ     r0,|L71.30|
;;;365    	    !(sm->initialize || !sm->portEnabled))
00000c  6a20              LDR      r0,[r4,#0x20]
00000e  b930              CBNZ     r0,|L71.30|
000010  6b20              LDR      r0,[r4,#0x30]
000012  b120              CBZ      r0,|L71.30|
;;;366    		SM_ENTER_GLOBAL(SUPP_PAE, LOGOFF);
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       sm_SUPP_PAE_LOGOFF_Enter
00001c  e0e1              B        |L71.482|
                  |L71.30|
;;;367    	else if (((sm->portControl == Auto) &&
00001e  f894002c          LDRB     r0,[r4,#0x2c]
000022  b928              CBNZ     r0,|L71.48|
;;;368    		  (sm->sPortMode != sm->portControl)) ||
000024  f8940064          LDRB     r0,[r4,#0x64]
000028  f894102c          LDRB     r1,[r4,#0x2c]
00002c  4288              CMP      r0,r1
00002e  d103              BNE      |L71.56|
                  |L71.48|
;;;369    		 sm->initialize || !sm->portEnabled)
000030  6a20              LDR      r0,[r4,#0x20]
000032  b908              CBNZ     r0,|L71.56|
000034  6b20              LDR      r0,[r4,#0x30]
000036  b920              CBNZ     r0,|L71.66|
                  |L71.56|
;;;370    		SM_ENTER_GLOBAL(SUPP_PAE, DISCONNECTED);
000038  2101              MOVS     r1,#1
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       sm_SUPP_PAE_DISCONNECTED_Enter
000040  e0cf              B        |L71.482|
                  |L71.66|
;;;371    	else if ((sm->portControl == ForceAuthorized) &&
000042  f894002c          LDRB     r0,[r4,#0x2c]
000046  2802              CMP      r0,#2
000048  d10e              BNE      |L71.104|
;;;372    		 (sm->sPortMode != sm->portControl) &&
00004a  f8940064          LDRB     r0,[r4,#0x64]
00004e  f894102c          LDRB     r1,[r4,#0x2c]
000052  4288              CMP      r0,r1
000054  d008              BEQ      |L71.104|
;;;373    		 !(sm->initialize || !sm->portEnabled))
000056  6a20              LDR      r0,[r4,#0x20]
000058  b930              CBNZ     r0,|L71.104|
00005a  6b20              LDR      r0,[r4,#0x30]
00005c  b120              CBZ      r0,|L71.104|
;;;374    		SM_ENTER_GLOBAL(SUPP_PAE, S_FORCE_AUTH);
00005e  2101              MOVS     r1,#1
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       sm_SUPP_PAE_S_FORCE_AUTH_Enter
000066  e0bc              B        |L71.482|
                  |L71.104|
;;;375    	else if ((sm->portControl == ForceUnauthorized) &&
000068  f894002c          LDRB     r0,[r4,#0x2c]
00006c  2801              CMP      r0,#1
00006e  d10e              BNE      |L71.142|
;;;376    		 (sm->sPortMode != sm->portControl) &&
000070  f8940064          LDRB     r0,[r4,#0x64]
000074  f894102c          LDRB     r1,[r4,#0x2c]
000078  4288              CMP      r0,r1
00007a  d008              BEQ      |L71.142|
;;;377    		 !(sm->initialize || !sm->portEnabled))
00007c  6a20              LDR      r0,[r4,#0x20]
00007e  b930              CBNZ     r0,|L71.142|
000080  6b20              LDR      r0,[r4,#0x30]
000082  b120              CBZ      r0,|L71.142|
;;;378    		SM_ENTER_GLOBAL(SUPP_PAE, S_FORCE_UNAUTH);
000084  2101              MOVS     r1,#1
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       sm_SUPP_PAE_S_FORCE_UNAUTH_Enter
00008c  e0a9              B        |L71.482|
                  |L71.142|
;;;379    	else switch (sm->SUPP_PAE_state) {
00008e  f8940050          LDRB     r0,[r4,#0x50]
000092  280b              CMP      r0,#0xb
000094  d207              BCS      |L71.166|
000096  e8dff000          TBB      [pc,r0]
00009a  060e              DCB      0x06,0x0e
00009c  0713488a          DCB      0x07,0x13,0x48,0x8a
0000a0  a37c9aa1          DCB      0xa3,0x7c,0x9a,0xa1
0000a4  a200              DCB      0xa2,0x00
                  |L71.166|
;;;380    	case SUPP_PAE_UNKNOWN:
;;;381    		break;
0000a6  e09b              B        |L71.480|
;;;382    	case SUPP_PAE_LOGOFF:
;;;383    		if (!sm->userLogoff)
0000a8  6d60              LDR      r0,[r4,#0x54]
0000aa  b918              CBNZ     r0,|L71.180|
;;;384    			SM_ENTER(SUPP_PAE, DISCONNECTED);
0000ac  2100              MOVS     r1,#0
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       sm_SUPP_PAE_DISCONNECTED_Enter
                  |L71.180|
;;;385    		break;
0000b4  e094              B        |L71.480|
;;;386    	case SUPP_PAE_DISCONNECTED:
;;;387    		SM_ENTER(SUPP_PAE, CONNECTING);
0000b6  2100              MOVS     r1,#0
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       sm_SUPP_PAE_CONNECTING_Enter
;;;388    		break;
0000be  e08f              B        |L71.480|
;;;389    	case SUPP_PAE_CONNECTING:
;;;390    		if (sm->startWhen == 0 && sm->startCount < sm->maxStart)
0000c0  68a0              LDR      r0,[r4,#8]
0000c2  b940              CBNZ     r0,|L71.214|
0000c4  6f21              LDR      r1,[r4,#0x70]
0000c6  6de0              LDR      r0,[r4,#0x5c]
0000c8  4288              CMP      r0,r1
0000ca  d204              BCS      |L71.214|
;;;391    			SM_ENTER(SUPP_PAE, CONNECTING);
0000cc  2100              MOVS     r1,#0
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       sm_SUPP_PAE_CONNECTING_Enter
0000d4  e028              B        |L71.296|
                  |L71.214|
;;;392    		else if (sm->startWhen == 0 &&
0000d6  68a0              LDR      r0,[r4,#8]
0000d8  b950              CBNZ     r0,|L71.240|
;;;393    			 sm->startCount >= sm->maxStart &&
0000da  6f21              LDR      r1,[r4,#0x70]
0000dc  6de0              LDR      r0,[r4,#0x5c]
0000de  4288              CMP      r0,r1
0000e0  d306              BCC      |L71.240|
;;;394    			 sm->portValid)
0000e2  6ba0              LDR      r0,[r4,#0x38]
0000e4  b120              CBZ      r0,|L71.240|
;;;395    			SM_ENTER(SUPP_PAE, AUTHENTICATED);
0000e6  2100              MOVS     r1,#0
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       sm_SUPP_PAE_AUTHENTICATED_Enter
0000ee  e01b              B        |L71.296|
                  |L71.240|
;;;396    		else if (sm->eapSuccess || sm->eapFail)
0000f0  69e0              LDR      r0,[r4,#0x1c]
0000f2  b908              CBNZ     r0,|L71.248|
0000f4  6960              LDR      r0,[r4,#0x14]
0000f6  b120              CBZ      r0,|L71.258|
                  |L71.248|
;;;397    			SM_ENTER(SUPP_PAE, AUTHENTICATING);
0000f8  2100              MOVS     r1,#0
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       sm_SUPP_PAE_AUTHENTICATING_Enter
000100  e012              B        |L71.296|
                  |L71.258|
;;;398    		else if (sm->eapolEap)
000102  69a0              LDR      r0,[r4,#0x18]
000104  b120              CBZ      r0,|L71.272|
;;;399    			SM_ENTER(SUPP_PAE, RESTART);
000106  2100              MOVS     r1,#0
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       sm_SUPP_PAE_RESTART_Enter
00010e  e00b              B        |L71.296|
                  |L71.272|
;;;400    		else if (sm->startWhen == 0 &&
000110  68a0              LDR      r0,[r4,#8]
000112  b948              CBNZ     r0,|L71.296|
;;;401    			 sm->startCount >= sm->maxStart &&
000114  6f21              LDR      r1,[r4,#0x70]
000116  6de0              LDR      r0,[r4,#0x5c]
000118  4288              CMP      r0,r1
00011a  d305              BCC      |L71.296|
;;;402    			 !sm->portValid)
00011c  6ba0              LDR      r0,[r4,#0x38]
00011e  b918              CBNZ     r0,|L71.296|
;;;403    			SM_ENTER(SUPP_PAE, HELD);
000120  2100              MOVS     r1,#0
000122  4620              MOV      r0,r4
000124  f7fffffe          BL       sm_SUPP_PAE_HELD_Enter
                  |L71.296|
;;;404    		break;
000128  e05a              B        |L71.480|
;;;405    	case SUPP_PAE_AUTHENTICATING:
;;;406    		if (sm->eapSuccess && !sm->portValid &&
00012a  69e0              LDR      r0,[r4,#0x1c]
00012c  b1b0              CBZ      r0,|L71.348|
00012e  6ba0              LDR      r0,[r4,#0x38]
000130  b9a0              CBNZ     r0,|L71.348|
;;;407    		    sm->conf.accept_802_1x_keys &&
000132  f8d400f8          LDR      r0,[r4,#0xf8]
000136  b188              CBZ      r0,|L71.348|
;;;408    		    sm->conf.required_keys == 0) {
000138  20fc              MOVS     r0,#0xfc
00013a  5900              LDR      r0,[r0,r4]
00013c  b970              CBNZ     r0,|L71.348|
;;;409    			wpa_printf(MSG_DEBUG, "EAPOL: IEEE 802.1X for "
00013e  4929              LDR      r1,|L71.484|
000140  2000              MOVS     r0,#0
000142  f7fffffe          BL       wpa_printf
;;;410    				   "plaintext connection; no EAPOL-Key frames "
;;;411    				   "required");
;;;412    			sm->portValid = TRUE;
000146  2001              MOVS     r0,#1
000148  63a0              STR      r0,[r4,#0x38]
;;;413    			if (sm->ctx->eapol_done_cb)
00014a  f8d4010c          LDR      r0,[r4,#0x10c]
00014e  69c0              LDR      r0,[r0,#0x1c]
000150  b120              CBZ      r0,|L71.348|
;;;414    				sm->ctx->eapol_done_cb(sm->ctx->ctx);
000152  f8d4210c          LDR      r2,[r4,#0x10c]
000156  69d1              LDR      r1,[r2,#0x1c]
000158  6810              LDR      r0,[r2,#0]
00015a  4788              BLX      r1
                  |L71.348|
;;;415    		}
;;;416    		if (sm->eapSuccess && sm->portValid)
00015c  69e0              LDR      r0,[r4,#0x1c]
00015e  b130              CBZ      r0,|L71.366|
000160  6ba0              LDR      r0,[r4,#0x38]
000162  b120              CBZ      r0,|L71.366|
;;;417    			SM_ENTER(SUPP_PAE, AUTHENTICATED);
000164  2100              MOVS     r1,#0
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       sm_SUPP_PAE_AUTHENTICATED_Enter
00016c  e010              B        |L71.400|
                  |L71.366|
;;;418    		else if (sm->eapFail || (sm->keyDone && !sm->portValid))
00016e  6960              LDR      r0,[r4,#0x14]
000170  b918              CBNZ     r0,|L71.378|
000172  6a60              LDR      r0,[r4,#0x24]
000174  b130              CBZ      r0,|L71.388|
000176  6ba0              LDR      r0,[r4,#0x38]
000178  b920              CBNZ     r0,|L71.388|
                  |L71.378|
;;;419    			SM_ENTER(SUPP_PAE, HELD);
00017a  2100              MOVS     r1,#0
00017c  4620              MOV      r0,r4
00017e  f7fffffe          BL       sm_SUPP_PAE_HELD_Enter
000182  e005              B        |L71.400|
                  |L71.388|
;;;420    		else if (sm->suppTimeout)
000184  6ce0              LDR      r0,[r4,#0x4c]
000186  b118              CBZ      r0,|L71.400|
;;;421    			SM_ENTER(SUPP_PAE, CONNECTING);
000188  2100              MOVS     r1,#0
00018a  4620              MOV      r0,r4
00018c  f7fffffe          BL       sm_SUPP_PAE_CONNECTING_Enter
                  |L71.400|
;;;422    		break;
000190  e026              B        |L71.480|
;;;423    	case SUPP_PAE_HELD:
;;;424    		if (sm->heldWhile == 0)
000192  6860              LDR      r0,[r4,#4]
000194  b920              CBNZ     r0,|L71.416|
;;;425    			SM_ENTER(SUPP_PAE, CONNECTING);
000196  2100              MOVS     r1,#0
000198  4620              MOV      r0,r4
00019a  f7fffffe          BL       sm_SUPP_PAE_CONNECTING_Enter
00019e  e005              B        |L71.428|
                  |L71.416|
;;;426    		else if (sm->eapolEap)
0001a0  69a0              LDR      r0,[r4,#0x18]
0001a2  b118              CBZ      r0,|L71.428|
;;;427    			SM_ENTER(SUPP_PAE, RESTART);
0001a4  2100              MOVS     r1,#0
0001a6  4620              MOV      r0,r4
0001a8  f7fffffe          BL       sm_SUPP_PAE_RESTART_Enter
                  |L71.428|
;;;428    		break;
0001ac  e018              B        |L71.480|
;;;429    	case SUPP_PAE_AUTHENTICATED:
;;;430    		if (sm->eapolEap && sm->portValid)
0001ae  69a0              LDR      r0,[r4,#0x18]
0001b0  b130              CBZ      r0,|L71.448|
0001b2  6ba0              LDR      r0,[r4,#0x38]
0001b4  b120              CBZ      r0,|L71.448|
;;;431    			SM_ENTER(SUPP_PAE, RESTART);
0001b6  2100              MOVS     r1,#0
0001b8  4620              MOV      r0,r4
0001ba  f7fffffe          BL       sm_SUPP_PAE_RESTART_Enter
0001be  e005              B        |L71.460|
                  |L71.448|
;;;432    		else if (!sm->portValid)
0001c0  6ba0              LDR      r0,[r4,#0x38]
0001c2  b918              CBNZ     r0,|L71.460|
;;;433    			SM_ENTER(SUPP_PAE, DISCONNECTED);
0001c4  2100              MOVS     r1,#0
0001c6  4620              MOV      r0,r4
0001c8  f7fffffe          BL       sm_SUPP_PAE_DISCONNECTED_Enter
                  |L71.460|
;;;434    		break;
0001cc  e008              B        |L71.480|
;;;435    	case SUPP_PAE_RESTART:
;;;436    		if (!sm->eapRestart)
0001ce  6e20              LDR      r0,[r4,#0x60]
0001d0  b918              CBNZ     r0,|L71.474|
;;;437    			SM_ENTER(SUPP_PAE, AUTHENTICATING);
0001d2  2100              MOVS     r1,#0
0001d4  4620              MOV      r0,r4
0001d6  f7fffffe          BL       sm_SUPP_PAE_AUTHENTICATING_Enter
                  |L71.474|
;;;438    		break;
0001da  e001              B        |L71.480|
;;;439    	case SUPP_PAE_S_FORCE_AUTH:
;;;440    		break;
0001dc  e000              B        |L71.480|
;;;441    	case SUPP_PAE_S_FORCE_UNAUTH:
;;;442    		break;
0001de  bf00              NOP      
                  |L71.480|
0001e0  bf00              NOP                            ;381
                  |L71.482|
;;;443    	}
;;;444    }
0001e2  bd10              POP      {r4,pc}
;;;445    
                          ENDP

                  |L71.484|
                          DCD      ||.constdata||+0x154

                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpa_key_mgmt_ft||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_ft PROC
;;;65     
;;;66     static inline int wpa_key_mgmt_ft(int akm)
000000  4601              MOV      r1,r0
;;;67     {
;;;68     	return akm == WPA_KEY_MGMT_FT_PSK ||
000002  2940              CMP      r1,#0x40
000004  d001              BEQ      |L76.10|
;;;69     		akm == WPA_KEY_MGMT_FT_IEEE8021X;
000006  2920              CMP      r1,#0x20
000008  d101              BNE      |L76.14|
                  |L76.10|
00000a  2001              MOVS     r0,#1                 ;68
                  |L76.12|
;;;70     }
00000c  4770              BX       lr
                  |L76.14|
00000e  2000              MOVS     r0,#0                 ;68
000010  e7fc              B        |L76.12|
;;;71     
                          ENDP


                          AREA ||i.wpa_key_mgmt_sha256||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_sha256 PROC
;;;71     
;;;72     static inline int wpa_key_mgmt_sha256(int akm)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return akm == WPA_KEY_MGMT_PSK_SHA256 ||
000002  f5b17f80          CMP      r1,#0x100
000006  d001              BEQ      |L77.12|
;;;75     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
000008  2980              CMP      r1,#0x80
00000a  d101              BNE      |L77.16|
                  |L77.12|
00000c  2001              MOVS     r0,#1                 ;74
                  |L77.14|
;;;76     }
00000e  4770              BX       lr
                  |L77.16|
000010  2000              MOVS     r0,#0                 ;74
000012  e7fc              B        |L77.14|
;;;77     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_ieee8021x||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_ieee8021x PROC
;;;51     
;;;52     static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return akm == WPA_KEY_MGMT_IEEE8021X ||
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L78.14|
;;;55     		akm == WPA_KEY_MGMT_FT_IEEE8021X ||
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L78.14|
;;;56     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
00000a  2980              CMP      r1,#0x80
00000c  d101              BNE      |L78.18|
                  |L78.14|
00000e  2001              MOVS     r0,#1                 ;54
                  |L78.16|
;;;57     }
000010  4770              BX       lr
                  |L78.18|
000012  2000              MOVS     r0,#0                 ;54
000014  e7fc              B        |L78.16|
;;;58     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_psk||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_psk PROC
;;;58     
;;;59     static inline int wpa_key_mgmt_wpa_psk(int akm)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     	return akm == WPA_KEY_MGMT_PSK ||
000002  2902              CMP      r1,#2
000004  d004              BEQ      |L79.16|
;;;62     		akm == WPA_KEY_MGMT_FT_PSK ||
000006  2940              CMP      r1,#0x40
000008  d002              BEQ      |L79.16|
;;;63     		akm == WPA_KEY_MGMT_PSK_SHA256;
00000a  f5b17f80          CMP      r1,#0x100
00000e  d101              BNE      |L79.20|
                  |L79.16|
000010  2001              MOVS     r0,#1                 ;61
                  |L79.18|
;;;64     }
000012  4770              BX       lr
                  |L79.20|
000014  2000              MOVS     r0,#0                 ;61
000016  e7fc              B        |L79.18|
;;;65     
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L80.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L80.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L80.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L80.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L83.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L83.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L83.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L83.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L89.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L89.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  4541504f          DCB      0x45,0x41,0x50,0x4f
000004  4c3a2052          DCB      0x4c,0x3a,0x20,0x52
000008  65636569          DCB      0x65,0x63,0x65,0x69
00000c  76656420          DCB      0x76,0x65,0x64,0x20
000010  49454545          DCB      0x49,0x45,0x45,0x45
000014  20383032          DCB      0x20,0x38,0x30,0x32
000018  2e315820          DCB      0x2e,0x31,0x58,0x20
00001c  4541504f          DCB      0x45,0x41,0x50,0x4f
000020  4c2d4b65          DCB      0x4c,0x2d,0x4b,0x65
000024  79206576          DCB      0x79,0x20,0x65,0x76
000028  656e2074          DCB      0x65,0x6e,0x20,0x74
00002c  686f7567          DCB      0x68,0x6f,0x75,0x67
000030  68207468          DCB      0x68,0x20,0x74,0x68
000034  69732077          DCB      0x69,0x73,0x20,0x77
000038  6173206e          DCB      0x61,0x73,0x20,0x6e
00003c  6f742061          DCB      0x6f,0x74,0x20,0x61
000040  63636570          DCB      0x63,0x63,0x65,0x70
000044  74656420          DCB      0x74,0x65,0x64,0x20
000048  2d206967          DCB      0x2d,0x20,0x69,0x67
00004c  6e6f7269          DCB      0x6e,0x6f,0x72,0x69
000050  6e672074          DCB      0x6e,0x67,0x20,0x74
000054  68697320          DCB      0x68,0x69,0x73,0x20
000058  7061636b          DCB      0x70,0x61,0x63,0x6b
00005c  65740000          DCB      0x65,0x74,0x00,0x00
000060  4541504f          DCB      0x45,0x41,0x50,0x4f
000064  4c3a2052          DCB      0x4c,0x3a,0x20,0x52
000068  58204945          DCB      0x58,0x20,0x49,0x45
00006c  45452038          DCB      0x45,0x45,0x20,0x38
000070  30322e31          DCB      0x30,0x32,0x2e,0x31
000074  58207665          DCB      0x58,0x20,0x76,0x65
000078  723d2564          DCB      0x72,0x3d,0x25,0x64
00007c  20747970          DCB      0x20,0x74,0x79,0x70
000080  653d2564          DCB      0x65,0x3d,0x25,0x64
000084  206c656e          DCB      0x20,0x6c,0x65,0x6e
000088  3d256420          DCB      0x3d,0x25,0x64,0x20
00008c  4541504f          DCB      0x45,0x41,0x50,0x4f
000090  4c2d4b65          DCB      0x4c,0x2d,0x4b,0x65
000094  793a2074          DCB      0x79,0x3a,0x20,0x74
000098  7970653d          DCB      0x79,0x70,0x65,0x3d
00009c  2564206b          DCB      0x25,0x64,0x20,0x6b
0000a0  65795f6c          DCB      0x65,0x79,0x5f,0x6c
0000a4  656e6774          DCB      0x65,0x6e,0x67,0x74
0000a8  683d2564          DCB      0x68,0x3d,0x25,0x64
0000ac  206b6579          DCB      0x20,0x6b,0x65,0x79
0000b0  5f696e64          DCB      0x5f,0x69,0x6e,0x64
0000b4  65783d30          DCB      0x65,0x78,0x3d,0x30
0000b8  78257800          DCB      0x78,0x25,0x78,0x00
0000bc  4541504f          DCB      0x45,0x41,0x50,0x4f
0000c0  4c3a2043          DCB      0x4c,0x3a,0x20,0x43
0000c4  6f756c64          DCB      0x6f,0x75,0x6c,0x64
0000c8  206e6f74          DCB      0x20,0x6e,0x6f,0x74
0000cc  20676574          DCB      0x20,0x67,0x65,0x74
0000d0  204c4541          DCB      0x20,0x4c,0x45,0x41
0000d4  50206d61          DCB      0x50,0x20,0x6d,0x61
0000d8  73746572          DCB      0x73,0x74,0x65,0x72
0000dc  206b6579          DCB      0x20,0x6b,0x65,0x79
0000e0  20666f72          DCB      0x20,0x66,0x6f,0x72
0000e4  20646563          DCB      0x20,0x64,0x65,0x63
0000e8  72797074          DCB      0x72,0x79,0x70,0x74
0000ec  696e6720          DCB      0x69,0x6e,0x67,0x20
0000f0  4541504f          DCB      0x45,0x41,0x50,0x4f
0000f4  4c2d4b65          DCB      0x4c,0x2d,0x4b,0x65
0000f8  79206b65          DCB      0x79,0x20,0x6b,0x65
0000fc  79730000          DCB      0x79,0x73,0x00,0x00
000100  4541504f          DCB      0x45,0x41,0x50,0x4f
000104  4c3a2043          DCB      0x4c,0x3a,0x20,0x43
000108  6f756c64          DCB      0x6f,0x75,0x6c,0x64
00010c  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000110  20676574          DCB      0x20,0x67,0x65,0x74
000114  20656e6f          DCB      0x20,0x65,0x6e,0x6f
000118  75676820          DCB      0x75,0x67,0x68,0x20
00011c  6d617374          DCB      0x6d,0x61,0x73,0x74
000120  6572206b          DCB      0x65,0x72,0x20,0x6b
000124  65792064          DCB      0x65,0x79,0x20,0x64
000128  61746120          DCB      0x61,0x74,0x61,0x20
00012c  666f7220          DCB      0x66,0x6f,0x72,0x20
000130  64656372          DCB      0x64,0x65,0x63,0x72
000134  79707469          DCB      0x79,0x70,0x74,0x69
000138  6e672045          DCB      0x6e,0x67,0x20,0x45
00013c  41504f4c          DCB      0x41,0x50,0x4f,0x4c
000140  2d4b6579          DCB      0x2d,0x4b,0x65,0x79
000144  206b6579          DCB      0x20,0x6b,0x65,0x79
000148  73202872          DCB      0x73,0x20,0x28,0x72
00014c  65733d25          DCB      0x65,0x73,0x3d,0x25
000150  64290000          DCB      0x64,0x29,0x00,0x00
000154  4541504f          DCB      0x45,0x41,0x50,0x4f
000158  4c3a2049          DCB      0x4c,0x3a,0x20,0x49
00015c  45454520          DCB      0x45,0x45,0x45,0x20
000160  3830322e          DCB      0x38,0x30,0x32,0x2e
000164  31582066          DCB      0x31,0x58,0x20,0x66
000168  6f722070          DCB      0x6f,0x72,0x20,0x70
00016c  6c61696e          DCB      0x6c,0x61,0x69,0x6e
000170  74657874          DCB      0x74,0x65,0x78,0x74
000174  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000178  6e656374          DCB      0x6e,0x65,0x63,0x74
00017c  696f6e3b          DCB      0x69,0x6f,0x6e,0x3b
000180  206e6f20          DCB      0x20,0x6e,0x6f,0x20
000184  4541504f          DCB      0x45,0x41,0x50,0x4f
000188  4c2d4b65          DCB      0x4c,0x2d,0x4b,0x65
00018c  79206672          DCB      0x79,0x20,0x66,0x72
000190  616d6573          DCB      0x61,0x6d,0x65,0x73
000194  20726571          DCB      0x20,0x72,0x65,0x71
000198  75697265          DCB      0x75,0x69,0x72,0x65
00019c  64000000          DCB      0x64,0x00,0x00,0x00
0001a0  52534e3a          DCB      0x52,0x53,0x4e,0x3a
0001a4  20417574          DCB      0x20,0x41,0x75,0x74
0001a8  68656e74          DCB      0x68,0x65,0x6e,0x74
0001ac  69636174          DCB      0x69,0x63,0x61,0x74
0001b0  6f722064          DCB      0x6f,0x72,0x20,0x64
0001b4  6964206e          DCB      0x69,0x64,0x20,0x6e
0001b8  6f742061          DCB      0x6f,0x74,0x20,0x61
0001bc  63636570          DCB      0x63,0x63,0x65,0x70
0001c0  7420504d          DCB      0x74,0x20,0x50,0x4d
0001c4  4b49442c          DCB      0x4b,0x49,0x44,0x2c
0001c8  20646f69          DCB      0x20,0x64,0x6f,0x69
0001cc  6e672066          DCB      0x6e,0x67,0x20,0x66
0001d0  756c6c20          DCB      0x75,0x6c,0x6c,0x20
0001d4  45415020          DCB      0x45,0x41,0x50,0x20
0001d8  61757468          DCB      0x61,0x75,0x74,0x68
0001dc  656e7469          DCB      0x65,0x6e,0x74,0x69
0001e0  63617469          DCB      0x63,0x61,0x74,0x69
0001e4  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
0001e8  4541504f          DCB      0x45,0x41,0x50,0x4f
0001ec  4c3a2072          DCB      0x4c,0x3a,0x20,0x72
0001f0  65636569          DCB      0x65,0x63,0x65,0x69
0001f4  76656420          DCB      0x76,0x65,0x64,0x20
0001f8  636f6e74          DCB      0x63,0x6f,0x6e,0x74
0001fc  726f6c20          DCB      0x72,0x6f,0x6c,0x20
000200  72657370          DCB      0x72,0x65,0x73,0x70
000204  6f6e7365          DCB      0x6f,0x6e,0x73,0x65
000208  20287573          DCB      0x20,0x28,0x75,0x73
00020c  65722069          DCB      0x65,0x72,0x20,0x69
000210  6e707574          DCB      0x6e,0x70,0x75,0x74
000214  29206e6f          DCB      0x29,0x20,0x6e,0x6f
000218  74696669          DCB      0x74,0x69,0x66,0x69
00021c  63617469          DCB      0x63,0x61,0x74,0x69
000220  6f6e202d          DCB      0x6f,0x6e,0x20,0x2d
000224  20726574          DCB      0x20,0x72,0x65,0x74
000228  7279696e          DCB      0x72,0x79,0x69,0x6e
00022c  67207065          DCB      0x67,0x20,0x70,0x65
000230  6e64696e          DCB      0x6e,0x64,0x69,0x6e
000234  67204541          DCB      0x67,0x20,0x45,0x41
000238  50205265          DCB      0x50,0x20,0x52,0x65
00023c  71756573          DCB      0x71,0x75,0x65,0x73
000240  74000000          DCB      0x74,0x00,0x00,0x00
000244  4541504f          DCB      0x45,0x41,0x50,0x4f
000248  4c3a2072          DCB      0x4c,0x3a,0x20,0x72
00024c  65636569          DCB      0x65,0x63,0x65,0x69
000250  76656420          DCB      0x76,0x65,0x64,0x20
000254  6e6f7469          DCB      0x6e,0x6f,0x74,0x69
000258  66696361          DCB      0x66,0x69,0x63,0x61
00025c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000260  2066726f          DCB      0x20,0x66,0x72,0x6f
000264  6d204541          DCB      0x6d,0x20,0x45,0x41
000268  50207374          DCB      0x50,0x20,0x73,0x74
00026c  61746520          DCB      0x61,0x74,0x65,0x20
000270  6d616368          DCB      0x6d,0x61,0x63,0x68
000274  696e6520          DCB      0x69,0x6e,0x65,0x20
000278  2d207265          DCB      0x2d,0x20,0x72,0x65
00027c  74727969          DCB      0x74,0x72,0x79,0x69
000280  6e672070          DCB      0x6e,0x67,0x20,0x70
000284  656e6469          DCB      0x65,0x6e,0x64,0x69
000288  6e672045          DCB      0x6e,0x67,0x20,0x45
00028c  41502052          DCB      0x41,0x50,0x20,0x52
000290  65717565          DCB      0x65,0x71,0x75,0x65
000294  737400            DCB      0x73,0x74,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  eapol_cb
                          DCD      eapol_sm_get_config
                          DCD      eapol_sm_get_bool
                          DCD      eapol_sm_set_bool
                          DCD      eapol_sm_get_int
                          DCD      eapol_sm_set_int
                          DCD      eapol_sm_get_eapReqData
                          DCD      eapol_sm_set_config_blob
                          DCD      eapol_sm_get_config_blob
                          DCD      eapol_sm_notify_pending
                          DCD      eapol_sm_eap_param_needed
