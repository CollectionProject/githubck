; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\icmp.o --depend=.\obj\icmp.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\icmp.crf ..\lwIP\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;263    void
;;;264    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  b570              PUSH     {r4-r6,lr}
;;;265    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;266      icmp_send_response(p, ICMP_DUR, t);
000006  4622              MOV      r2,r4
000008  2103              MOVS     r1,#3
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       icmp_send_response
;;;267    }
000010  bd70              POP      {r4-r6,pc}
;;;268    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=1

                  icmp_input PROC
;;;77     void
;;;78     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;79     {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  4689              MOV      r9,r1
;;;80       u8_t type;
;;;81     #ifdef LWIP_DEBUG
;;;82       u8_t code;
;;;83     #endif /* LWIP_DEBUG */
;;;84       struct icmp_echo_hdr *iecho;
;;;85       struct ip_hdr *iphdr;
;;;86       struct ip_addr tmpaddr;
;;;87       s16_t hlen;
;;;88     
;;;89       ICMP_STATS_INC(icmp.recv);
;;;90       snmp_inc_icmpinmsgs();
;;;91     
;;;92     
;;;93       iphdr = p->payload;
00000a  686c              LDR      r4,[r5,#4]
;;;94       hlen = IPH_HL(iphdr) * 4;
00000c  8820              LDRH     r0,[r4,#0]
00000e  f7fffffe          BL       ntohs
000012  f3c02003          UBFX     r0,r0,#8,#4
000016  ea4f0880          LSL      r8,r0,#2
;;;95       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
00001a  f1c80100          RSB      r1,r8,#0
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       pbuf_header
000024  b910              CBNZ     r0,|L2.44|
000026  8928              LDRH     r0,[r5,#8]
000028  2804              CMP      r0,#4
00002a  d202              BCS      |L2.50|
                  |L2.44|
;;;96         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;97         goto lenerr;
000030  e0b9              B        |L2.422|
                  |L2.50|
;;;98       }
;;;99     
;;;100      type = *((u8_t *)p->payload);
000032  6868              LDR      r0,[r5,#4]
000034  f890a000          LDRB     r10,[r0,#0]
;;;101    #ifdef LWIP_DEBUG
;;;102      code = *(((u8_t *)p->payload)+1);
000038  6868              LDR      r0,[r5,#4]
00003a  7840              LDRB     r0,[r0,#1]
00003c  9004              STR      r0,[sp,#0x10]
;;;103    #endif /* LWIP_DEBUG */
;;;104      switch (type) {
00003e  f1ba0f08          CMP      r10,#8
000042  d179              BNE      |L2.312|
;;;105      case ICMP_ECHO:
;;;106    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;107        {
;;;108          int accepted = 1;
000044  2701              MOVS     r7,#1
;;;109    #if !LWIP_MULTICAST_PING
;;;110          /* multicast destination address? */
;;;111          if (ip_addr_ismulticast(&iphdr->dest)) {
000046  f04f4070          MOV      r0,#0xf0000000
00004a  f7fffffe          BL       ntohl
00004e  6921              LDR      r1,[r4,#0x10]
000050  ea000b01          AND      r11,r0,r1
000054  f04f4060          MOV      r0,#0xe0000000
000058  f7fffffe          BL       ntohl
00005c  4583              CMP      r11,r0
00005e  d100              BNE      |L2.98|
;;;112            accepted = 0;
000060  2700              MOVS     r7,#0
                  |L2.98|
;;;113          }
;;;114    #endif /* LWIP_MULTICAST_PING */
;;;115    #if !LWIP_BROADCAST_PING
;;;116          /* broadcast destination address? */
;;;117          if (ip_addr_isbroadcast(&iphdr->dest, inp)) {
000062  4649              MOV      r1,r9
000064  f1040010          ADD      r0,r4,#0x10
000068  f7fffffe          BL       ip_addr_isbroadcast
00006c  b100              CBZ      r0,|L2.112|
;;;118            accepted = 0;
00006e  2700              MOVS     r7,#0
                  |L2.112|
;;;119          }
;;;120    #endif /* LWIP_BROADCAST_PING */
;;;121          /* broadcast or multicast destination address not acceptd? */
;;;122          if (!accepted) {
000070  b93f              CBNZ     r7,|L2.130|
;;;123            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
000072  bf00              NOP      
000074  bf00              NOP      
;;;124            ICMP_STATS_INC(icmp.err);
;;;125            pbuf_free(p);
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       pbuf_free
                  |L2.124|
;;;126            return;
;;;127          }
;;;128        }
;;;129    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;130        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;131        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;132          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;133          goto lenerr;
;;;134        }
;;;135        if (inet_chksum_pbuf(p) != 0) {
;;;136          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;137          pbuf_free(p);
;;;138          ICMP_STATS_INC(icmp.chkerr);
;;;139          snmp_inc_icmpinerrors();
;;;140          return;
;;;141        }
;;;142    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;143        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;144          /* p is not big enough to contain link headers
;;;145           * allocate a new one and copy p into it
;;;146           */
;;;147          struct pbuf *r;
;;;148          /* switch p->payload to ip header */
;;;149          if (pbuf_header(p, hlen)) {
;;;150            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;151            goto memerr;
;;;152          }
;;;153          /* allocate new packet buffer with space for link headers */
;;;154          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;155          if (r == NULL) {
;;;156            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;157            goto memerr;
;;;158          }
;;;159          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;160                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;161          /* copy the whole packet including ip header */
;;;162          if (pbuf_copy(r, p) != ERR_OK) {
;;;163            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;164            goto memerr;
;;;165          }
;;;166          iphdr = r->payload;
;;;167          /* switch r->payload back to icmp header */
;;;168          if (pbuf_header(r, -hlen)) {
;;;169            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;170            goto memerr;
;;;171          }
;;;172          /* free the original p */
;;;173          pbuf_free(p);
;;;174          /* we now have an identical copy of p that has room for link headers */
;;;175          p = r;
;;;176        } else {
;;;177          /* restore p->payload to point to icmp header */
;;;178          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;179            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;180            goto memerr;
;;;181          }
;;;182        }
;;;183    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;184        /* At this point, all checks are OK. */
;;;185        /* We generate an answer by switching the dest and src ip addresses,
;;;186         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;187        iecho = p->payload;
;;;188        tmpaddr.addr = iphdr->src.addr;
;;;189        iphdr->src.addr = iphdr->dest.addr;
;;;190        iphdr->dest.addr = tmpaddr.addr;
;;;191        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;192        
;;;193    
;;;194    /* This part of code has been modified by ST's MCD Application Team */
;;;195    /* To use the Checksum Offload Engine for the putgoing ICMP packets,
;;;196       the ICMP checksum field should be set to 0, this is required only for Tx ICMP*/
;;;197    #ifdef CHECKSUM_BY_HARDWARE
;;;198        iecho->chksum = 0;
;;;199    #else	
;;;200    	/* adjust the checksum */
;;;201        if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
;;;202          iecho->chksum += htons(ICMP_ECHO << 8) + 1;
;;;203        } else {
;;;204          iecho->chksum += htons(ICMP_ECHO << 8);
;;;205        }	
;;;206    #endif
;;;207    
;;;208        /* Set the correct TTL and recalculate the header checksum. */
;;;209        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;210        IPH_CHKSUM_SET(iphdr, 0);
;;;211    #if CHECKSUM_GEN_IP
;;;212        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;213    #endif /* CHECKSUM_GEN_IP */
;;;214    
;;;215        ICMP_STATS_INC(icmp.xmit);
;;;216        /* increase number of messages attempted to send */
;;;217        snmp_inc_icmpoutmsgs();
;;;218        /* increase number of echo replies attempted to send */
;;;219        snmp_inc_icmpoutechoreps();
;;;220    
;;;221        if(pbuf_header(p, hlen)) {
;;;222          LWIP_ASSERT("Can't move over header in packet", 0);
;;;223        } else {
;;;224          err_t ret;
;;;225          ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
;;;226                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;227          if (ret != ERR_OK) {
;;;228            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;229          }
;;;230        }
;;;231        break;
;;;232      default:
;;;233        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;234                    (s16_t)type, (s16_t)code));
;;;235        ICMP_STATS_INC(icmp.proterr);
;;;236        ICMP_STATS_INC(icmp.drop);
;;;237      }
;;;238      pbuf_free(p);
;;;239      return;
;;;240    lenerr:
;;;241      pbuf_free(p);
;;;242      ICMP_STATS_INC(icmp.lenerr);
;;;243      snmp_inc_icmpinerrors();
;;;244      return;
;;;245    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;246    memerr:
;;;247      pbuf_free(p);
;;;248      ICMP_STATS_INC(icmp.err);
;;;249      snmp_inc_icmpinerrors();
;;;250      return;
;;;251    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;252    }
00007c  b005              ADD      sp,sp,#0x14
00007e  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.130|
000082  bf00              NOP                            ;130
000084  bf00              NOP                            ;130
000086  8928              LDRH     r0,[r5,#8]            ;131
000088  2808              CMP      r0,#8                 ;131
00008a  d202              BCS      |L2.146|
00008c  bf00              NOP                            ;132
00008e  bf00              NOP                            ;132
000090  e089              B        |L2.422|
                  |L2.146|
000092  4628              MOV      r0,r5                 ;135
000094  f7fffffe          BL       inet_chksum_pbuf
000098  b128              CBZ      r0,|L2.166|
00009a  bf00              NOP                            ;136
00009c  bf00              NOP                            ;136
00009e  4628              MOV      r0,r5                 ;137
0000a0  f7fffffe          BL       pbuf_free
0000a4  e7ea              B        |L2.124|
                  |L2.166|
0000a6  2122              MOVS     r1,#0x22              ;143
0000a8  4628              MOV      r0,r5                 ;143
0000aa  f7fffffe          BL       pbuf_header
0000ae  b318              CBZ      r0,|L2.248|
0000b0  4641              MOV      r1,r8                 ;149
0000b2  4628              MOV      r0,r5                 ;149
0000b4  f7fffffe          BL       pbuf_header
0000b8  b100              CBZ      r0,|L2.188|
0000ba  e078              B        |L2.430|
                  |L2.188|
0000bc  8929              LDRH     r1,[r5,#8]            ;154
0000be  2200              MOVS     r2,#0                 ;154
0000c0  2002              MOVS     r0,#2                 ;154
0000c2  f7fffffe          BL       pbuf_alloc
0000c6  4607              MOV      r7,r0                 ;154
0000c8  b917              CBNZ     r7,|L2.208|
0000ca  bf00              NOP                            ;156
0000cc  bf00              NOP                            ;156
0000ce  e06e              B        |L2.430|
                  |L2.208|
0000d0  4629              MOV      r1,r5                 ;162
0000d2  4638              MOV      r0,r7                 ;162
0000d4  f7fffffe          BL       pbuf_copy
0000d8  b100              CBZ      r0,|L2.220|
0000da  e068              B        |L2.430|
                  |L2.220|
0000dc  687c              LDR      r4,[r7,#4]            ;166
0000de  f1c80000          RSB      r0,r8,#0              ;168
0000e2  b201              SXTH     r1,r0                 ;168
0000e4  4638              MOV      r0,r7                 ;168
0000e6  f7fffffe          BL       pbuf_header
0000ea  b100              CBZ      r0,|L2.238|
0000ec  e05f              B        |L2.430|
                  |L2.238|
0000ee  4628              MOV      r0,r5                 ;173
0000f0  f7fffffe          BL       pbuf_free
0000f4  463d              MOV      r5,r7                 ;175
0000f6  e006              B        |L2.262|
                  |L2.248|
0000f8  f06f0121          MVN      r1,#0x21              ;178
0000fc  4628              MOV      r0,r5                 ;178
0000fe  f7fffffe          BL       pbuf_header
000102  b100              CBZ      r0,|L2.262|
000104  e053              B        |L2.430|
                  |L2.262|
000106  686e              LDR      r6,[r5,#4]            ;187
000108  68e0              LDR      r0,[r4,#0xc]          ;188
00010a  9003              STR      r0,[sp,#0xc]          ;188
00010c  6920              LDR      r0,[r4,#0x10]         ;189
00010e  60e0              STR      r0,[r4,#0xc]          ;189
000110  9803              LDR      r0,[sp,#0xc]          ;190
000112  6120              STR      r0,[r4,#0x10]         ;190
000114  2000              MOVS     r0,#0                 ;191
000116  7030              STRB     r0,[r6,#0]            ;191
000118  f24f70ff          MOV      r0,#0xf7ff            ;201
00011c  f7fffffe          BL       htons
000120  8871              LDRH     r1,[r6,#2]            ;201
000122  4288              CMP      r0,r1                 ;201
000124  dc09              BGT      |L2.314|
000126  f44f6000          MOV      r0,#0x800             ;202
00012a  f7fffffe          BL       htons
00012e  1c40              ADDS     r0,r0,#1              ;202
000130  8871              LDRH     r1,[r6,#2]            ;202
000132  4408              ADD      r0,r0,r1              ;202
000134  8070              STRH     r0,[r6,#2]            ;202
000136  e007              B        |L2.328|
                  |L2.312|
000138  e02d              B        |L2.406|
                  |L2.314|
00013a  f44f6000          MOV      r0,#0x800             ;204
00013e  f7fffffe          BL       htons
000142  8871              LDRH     r1,[r6,#2]            ;204
000144  4408              ADD      r0,r0,r1              ;204
000146  8070              STRH     r0,[r6,#2]            ;204
                  |L2.328|
000148  8920              LDRH     r0,[r4,#8]            ;209
00014a  f7fffffe          BL       ntohs
00014e  b2c0              UXTB     r0,r0                 ;209
000150  f440477f          ORR      r7,r0,#0xff00         ;209
000154  4638              MOV      r0,r7                 ;209
000156  f7fffffe          BL       htons
00015a  8120              STRH     r0,[r4,#8]            ;209
00015c  2000              MOVS     r0,#0                 ;210
00015e  8160              STRH     r0,[r4,#0xa]          ;210
000160  2114              MOVS     r1,#0x14              ;212
000162  4620              MOV      r0,r4                 ;212
000164  f7fffffe          BL       inet_chksum
000168  8160              STRH     r0,[r4,#0xa]          ;212
00016a  4641              MOV      r1,r8                 ;221
00016c  4628              MOV      r0,r5                 ;221
00016e  f7fffffe          BL       pbuf_header
000172  b978              CBNZ     r0,|L2.404|
000174  2201              MOVS     r2,#1                 ;225
000176  2100              MOVS     r1,#0                 ;225
000178  23ff              MOVS     r3,#0xff              ;225
00017a  e88d0206          STM      sp,{r1,r2,r9}         ;225
00017e  460a              MOV      r2,r1                 ;225
000180  f104010c          ADD      r1,r4,#0xc            ;225
000184  4628              MOV      r0,r5                 ;225
000186  f7fffffe          BL       ip_output_if
00018a  4607              MOV      r7,r0                 ;225
00018c  b10f              CBZ      r7,|L2.402|
00018e  bf00              NOP                            ;228
000190  bf00              NOP                            ;228
                  |L2.402|
000192  bf00              NOP                            ;230
                  |L2.404|
000194  e002              B        |L2.412|
                  |L2.406|
000196  bf00              NOP                            ;233
000198  bf00              NOP                            ;233
00019a  bf00              NOP                            ;104
                  |L2.412|
00019c  bf00              NOP                            ;231
00019e  4628              MOV      r0,r5                 ;238
0001a0  f7fffffe          BL       pbuf_free
0001a4  e76a              B        |L2.124|
                  |L2.422|
0001a6  4628              MOV      r0,r5                 ;241
0001a8  f7fffffe          BL       pbuf_free
0001ac  e766              B        |L2.124|
                  |L2.430|
0001ae  4628              MOV      r0,r5                 ;247
0001b0  f7fffffe          BL       pbuf_free
0001b4  bf00              NOP                            ;250
0001b6  e761              B        |L2.124|
;;;253    
                          ENDP


                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=1

                  icmp_send_response PROC
;;;293    static void
;;;294    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;295    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;296      struct pbuf *q;
;;;297      struct ip_hdr *iphdr;
;;;298      /* we can use the echo header here */
;;;299      struct icmp_echo_hdr *icmphdr;
;;;300    
;;;301      /* ICMP header + IP header + 8 bytes of data */
;;;302      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       pbuf_alloc
000014  4605              MOV      r5,r0
;;;303                     PBUF_RAM);
;;;304      if (q == NULL) {
000016  b91d              CBNZ     r5,|L3.32|
;;;305        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L3.28|
;;;306        return;
;;;307      }
;;;308      LWIP_ASSERT("check that first pbuf can hold icmp message",
;;;309                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;310    
;;;311      iphdr = p->payload;
;;;312      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;315      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;316      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;317    
;;;318      icmphdr = q->payload;
;;;319      icmphdr->type = type;
;;;320      icmphdr->code = code;
;;;321      icmphdr->id = 0;
;;;322      icmphdr->seqno = 0;
;;;323    
;;;324      /* copy fields from original packet */
;;;325      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
;;;326              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;327    
;;;328      /* calculate checksum */
;;;329      icmphdr->chksum = 0;
;;;330      icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;331      ICMP_STATS_INC(icmp.xmit);
;;;332      /* increase number of messages attempted to send */
;;;333      snmp_inc_icmpoutmsgs();
;;;334      /* increase number of destination unreachable messages attempted to send */
;;;335      snmp_inc_icmpouttimeexcds();
;;;336      ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
;;;337      pbuf_free(q);
;;;338    }
00001c  e8bd87fc          POP      {r2-r10,pc}
                  |L3.32|
000020  f8d69004          LDR      r9,[r6,#4]            ;311
000024  bf00              NOP                            ;312
000026  bf00              NOP                            ;312
000028  bf00              NOP                            ;313
00002a  bf00              NOP                            ;313
00002c  bf00              NOP                            ;314
00002e  bf00              NOP                            ;314
000030  bf00              NOP                            ;315
000032  bf00              NOP                            ;315
000034  bf00              NOP                            ;316
000036  bf00              NOP                            ;316
000038  686c              LDR      r4,[r5,#4]            ;318
00003a  7027              STRB     r7,[r4,#0]            ;319
00003c  f8848001          STRB     r8,[r4,#1]            ;320
000040  2000              MOVS     r0,#0                 ;321
000042  80a0              STRH     r0,[r4,#4]            ;321
000044  80e0              STRH     r0,[r4,#6]            ;322
000046  6871              LDR      r1,[r6,#4]            ;325
000048  686a              LDR      r2,[r5,#4]            ;325
00004a  f1020008          ADD      r0,r2,#8              ;325
00004e  221c              MOVS     r2,#0x1c              ;325
000050  f7fffffe          BL       __aeabi_memcpy
000054  2000              MOVS     r0,#0                 ;329
000056  8060              STRH     r0,[r4,#2]            ;329
000058  8969              LDRH     r1,[r5,#0xa]          ;330
00005a  4620              MOV      r0,r4                 ;330
00005c  f7fffffe          BL       inet_chksum
000060  8060              STRH     r0,[r4,#2]            ;330
000062  2301              MOVS     r3,#1                 ;336
000064  2200              MOVS     r2,#0                 ;336
000066  e9cd2300          STRD     r2,r3,[sp,#0]         ;336
00006a  23ff              MOVS     r3,#0xff              ;336
00006c  f109020c          ADD      r2,r9,#0xc            ;336
000070  2100              MOVS     r1,#0                 ;336
000072  4628              MOV      r0,r5                 ;336
000074  f7fffffe          BL       ip_output
000078  4628              MOV      r0,r5                 ;337
00007a  f7fffffe          BL       pbuf_free
00007e  bf00              NOP      
000080  e7cc              B        |L3.28|
;;;339    
                          ENDP


                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;277    void
;;;278    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  b570              PUSH     {r4-r6,lr}
;;;279    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;280      icmp_send_response(p, ICMP_TE, t);
000006  4622              MOV      r2,r4
000008  210b              MOVS     r1,#0xb
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       icmp_send_response
;;;281    }
000010  bd70              POP      {r4-r6,pc}
;;;282    
                          ENDP

