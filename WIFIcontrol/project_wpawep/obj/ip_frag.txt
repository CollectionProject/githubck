; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\ip_frag.o --depend=.\obj\ip_frag.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\ip_frag.crf ..\lwIP\src\core\ipv4\ip_frag.c]
                          THUMB

                          AREA ||i.ip_frag||, CODE, READONLY, ALIGN=2

                  ip_frag PROC
;;;627    err_t 
;;;628    ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;629    {
000004  b086              SUB      sp,sp,#0x18
000006  4688              MOV      r8,r1
;;;630      struct pbuf *rambuf;
;;;631    #if IP_FRAG_USES_STATIC_BUF
;;;632      struct pbuf *header;
;;;633    #else
;;;634      struct pbuf *newpbuf;
;;;635      struct ip_hdr *original_iphdr;
;;;636    #endif
;;;637      struct ip_hdr *iphdr;
;;;638      u16_t nfb;
;;;639      u16_t left, cop;
;;;640      u16_t mtu = netif->mtu;
000008  f8b80030          LDRH     r0,[r8,#0x30]
00000c  9004              STR      r0,[sp,#0x10]
;;;641      u16_t ofo, omf;
;;;642      u16_t last;
;;;643      u16_t poff = IP_HLEN;
00000e  2014              MOVS     r0,#0x14
000010  9001              STR      r0,[sp,#4]
;;;644      u16_t tmp;
;;;645    #if !IP_FRAG_USES_STATIC_BUF
;;;646      u16_t newpbuflen = 0;
;;;647      u16_t left_to_copy;
;;;648    #endif
;;;649    
;;;650      /* Get a RAM based MTU sized pbuf */
;;;651    #if IP_FRAG_USES_STATIC_BUF
;;;652      /* When using a static buffer, we use a PBUF_REF, which we will
;;;653       * use to reference the packet (without link header).
;;;654       * Layer and length is irrelevant.
;;;655       */
;;;656      rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
000012  2202              MOVS     r2,#2
000014  2100              MOVS     r1,#0
000016  4610              MOV      r0,r2
000018  f7fffffe          BL       pbuf_alloc
00001c  4605              MOV      r5,r0
;;;657      if (rambuf == NULL) {
00001e  b935              CBNZ     r5,|L1.46|
;;;658        LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;659        return ERR_MEM;
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L1.40|
;;;660      }
;;;661      rambuf->tot_len = rambuf->len = mtu;
;;;662      rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
;;;663    
;;;664      /* Copy the IP header in it */
;;;665      iphdr = rambuf->payload;
;;;666      SMEMCPY(iphdr, p->payload, IP_HLEN);
;;;667    #else /* IP_FRAG_USES_STATIC_BUF */
;;;668      original_iphdr = p->payload;
;;;669      iphdr = original_iphdr;
;;;670    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;671    
;;;672      /* Save original offset */
;;;673      tmp = ntohs(IPH_OFFSET(iphdr));
;;;674      ofo = tmp & IP_OFFMASK;
;;;675      omf = tmp & IP_MF;
;;;676    
;;;677      left = p->tot_len - IP_HLEN;
;;;678    
;;;679      nfb = (mtu - IP_HLEN) / 8;
;;;680    
;;;681      while (left) {
;;;682        last = (left <= mtu - IP_HLEN);
;;;683    
;;;684        /* Set new offset and MF flag */
;;;685        tmp = omf | (IP_OFFMASK & (ofo));
;;;686        if (!last)
;;;687          tmp = tmp | IP_MF;
;;;688    
;;;689        /* Fill this fragment */
;;;690        cop = last ? left : nfb * 8;
;;;691    
;;;692    #if IP_FRAG_USES_STATIC_BUF
;;;693        poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
;;;694    #else /* IP_FRAG_USES_STATIC_BUF */
;;;695        /* When not using a static buffer, create a chain of pbufs.
;;;696         * The first will be a PBUF_RAM holding the link and IP header.
;;;697         * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
;;;698         * but limited to the size of an mtu.
;;;699         */
;;;700        rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
;;;701        if (rambuf == NULL) {
;;;702          return ERR_MEM;
;;;703        }
;;;704        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;705                    (p->len >= (IP_HLEN)));
;;;706        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;707        iphdr = rambuf->payload;
;;;708    
;;;709        /* Can just adjust p directly for needed offset. */
;;;710        p->payload = (u8_t *)p->payload + poff;
;;;711        p->len -= poff;
;;;712    
;;;713        left_to_copy = cop;
;;;714        while (left_to_copy) {
;;;715          newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
;;;716          /* Is this pbuf already empty? */
;;;717          if (!newpbuflen) {
;;;718            p = p->next;
;;;719            continue;
;;;720          }
;;;721          newpbuf = pbuf_alloc(PBUF_RAW, 0, PBUF_REF);
;;;722          if (newpbuf == NULL) {
;;;723            pbuf_free(rambuf);
;;;724            return ERR_MEM;
;;;725          }
;;;726          /* Mirror this pbuf, although we might not need all of it. */
;;;727          newpbuf->payload = p->payload;
;;;728          newpbuf->len = newpbuf->tot_len = newpbuflen;
;;;729          /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
;;;730           * so that it is removed when pbuf_dechain is later called on rambuf.
;;;731           */
;;;732          pbuf_cat(rambuf, newpbuf);
;;;733          left_to_copy -= newpbuflen;
;;;734          if (left_to_copy)
;;;735            p = p->next;
;;;736        }
;;;737        poff = newpbuflen;
;;;738    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;739    
;;;740        /* Correct header */
;;;741        IPH_OFFSET_SET(iphdr, htons(tmp));
;;;742        IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
;;;743        IPH_CHKSUM_SET(iphdr, 0);
;;;744        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;745    
;;;746    #if IP_FRAG_USES_STATIC_BUF
;;;747        if (last)
;;;748          pbuf_realloc(rambuf, left + IP_HLEN);
;;;749    
;;;750        /* This part is ugly: we alloc a RAM based pbuf for 
;;;751         * the link level header for each chunk and then 
;;;752         * free it.A PBUF_ROM style pbuf for which pbuf_header
;;;753         * worked would make things simpler.
;;;754         */
;;;755        header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
;;;756        if (header != NULL) {
;;;757          pbuf_chain(header, rambuf);
;;;758          netif->output(netif, header, dest);
;;;759          IPFRAG_STATS_INC(ip_frag.xmit);
;;;760          snmp_inc_ipfragcreates();
;;;761          pbuf_free(header);
;;;762        } else {
;;;763          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
;;;764          pbuf_free(rambuf);
;;;765          return ERR_MEM;
;;;766        }
;;;767    #else /* IP_FRAG_USES_STATIC_BUF */
;;;768        /* No need for separate header pbuf - we allowed room for it in rambuf
;;;769         * when allocated.
;;;770         */
;;;771        netif->output(netif, rambuf, dest);
;;;772        IPFRAG_STATS_INC(ip_frag.xmit);
;;;773    
;;;774        /* Unfortunately we can't reuse rambuf - the hardware may still be
;;;775         * using the buffer. Instead we free it (and the ensuing chain) and
;;;776         * recreate it next time round the loop. If we're lucky the hardware
;;;777         * will have already sent the packet, the free will really free, and
;;;778         * there will be zero memory penalty.
;;;779         */
;;;780        
;;;781        pbuf_free(rambuf);
;;;782    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;783        left -= cop;
;;;784        ofo += nfb;
;;;785      }
;;;786    #if IP_FRAG_USES_STATIC_BUF
;;;787      pbuf_free(rambuf);
;;;788    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;789      snmp_inc_ipfragoks();
;;;790      return ERR_OK;
;;;791    }
000028  b009              ADD      sp,sp,#0x24
00002a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.46|
00002e  9804              LDR      r0,[sp,#0x10]         ;661
000030  8168              STRH     r0,[r5,#0xa]          ;661
000032  8128              STRH     r0,[r5,#8]            ;661
000034  4846              LDR      r0,|L1.336|
000036  f0200003          BIC      r0,r0,#3              ;662
00003a  6068              STR      r0,[r5,#4]            ;662
00003c  686c              LDR      r4,[r5,#4]            ;665
00003e  9806              LDR      r0,[sp,#0x18]         ;666
000040  2214              MOVS     r2,#0x14              ;666
000042  6841              LDR      r1,[r0,#4]            ;666
000044  4620              MOV      r0,r4                 ;666
000046  f7fffffe          BL       __aeabi_memcpy
00004a  88e0              LDRH     r0,[r4,#6]            ;673
00004c  f7fffffe          BL       ntohs
000050  4607              MOV      r7,r0                 ;673
000052  f3c70b0c          UBFX     r11,r7,#0,#13         ;674
000056  f4075000          AND      r0,r7,#0x2000         ;675
00005a  9003              STR      r0,[sp,#0xc]          ;675
00005c  9806              LDR      r0,[sp,#0x18]         ;677
00005e  8900              LDRH     r0,[r0,#8]            ;677
000060  3814              SUBS     r0,r0,#0x14           ;677
000062  b286              UXTH     r6,r0                 ;677
000064  9904              LDR      r1,[sp,#0x10]         ;679
000066  f1a10014          SUB      r0,r1,#0x14           ;679
00006a  17c1              ASRS     r1,r0,#31             ;679
00006c  eb007151          ADD      r1,r0,r1,LSR #29      ;679
000070  f3c101cf          UBFX     r1,r1,#3,#16          ;679
000074  9105              STR      r1,[sp,#0x14]         ;679
000076  e063              B        |L1.320|
                  |L1.120|
000078  9804              LDR      r0,[sp,#0x10]         ;682
00007a  3814              SUBS     r0,r0,#0x14           ;682
00007c  42b0              CMP      r0,r6                 ;682
00007e  db01              BLT      |L1.132|
000080  2001              MOVS     r0,#1                 ;682
000082  e000              B        |L1.134|
                  |L1.132|
000084  2000              MOVS     r0,#0                 ;682
                  |L1.134|
000086  b280              UXTH     r0,r0                 ;682
000088  9002              STR      r0,[sp,#8]            ;682
00008a  f3cb000c          UBFX     r0,r11,#0,#13         ;685
00008e  9903              LDR      r1,[sp,#0xc]          ;685
000090  ea400701          ORR      r7,r0,r1              ;685
000094  9802              LDR      r0,[sp,#8]            ;686
000096  b908              CBNZ     r0,|L1.156|
000098  f4475700          ORR      r7,r7,#0x2000         ;687
                  |L1.156|
00009c  9802              LDR      r0,[sp,#8]            ;690
00009e  b108              CBZ      r0,|L1.164|
0000a0  4630              MOV      r0,r6                 ;690
0000a2  e001              B        |L1.168|
                  |L1.164|
0000a4  9805              LDR      r0,[sp,#0x14]         ;690
0000a6  00c0              LSLS     r0,r0,#3              ;690
                  |L1.168|
0000a8  fa1ffa80          UXTH     r10,r0                ;690
0000ac  4652              MOV      r2,r10                ;693
0000ae  f1040114          ADD      r1,r4,#0x14           ;693
0000b2  9b01              LDR      r3,[sp,#4]            ;693
0000b4  9806              LDR      r0,[sp,#0x18]         ;693
0000b6  f7fffffe          BL       pbuf_copy_partial
0000ba  9901              LDR      r1,[sp,#4]            ;693
0000bc  4408              ADD      r0,r0,r1              ;693
0000be  b280              UXTH     r0,r0                 ;693
0000c0  9001              STR      r0,[sp,#4]            ;693
0000c2  4638              MOV      r0,r7                 ;741
0000c4  f7fffffe          BL       htons
0000c8  80e0              STRH     r0,[r4,#6]            ;741
0000ca  f10a0014          ADD      r0,r10,#0x14          ;742
0000ce  b280              UXTH     r0,r0                 ;742
0000d0  f7fffffe          BL       htons
0000d4  8060              STRH     r0,[r4,#2]            ;742
0000d6  2000              MOVS     r0,#0                 ;743
0000d8  8160              STRH     r0,[r4,#0xa]          ;743
0000da  2114              MOVS     r1,#0x14              ;744
0000dc  4620              MOV      r0,r4                 ;744
0000de  f7fffffe          BL       inet_chksum
0000e2  8160              STRH     r0,[r4,#0xa]          ;744
0000e4  9802              LDR      r0,[sp,#8]            ;747
0000e6  b128              CBZ      r0,|L1.244|
0000e8  f1060014          ADD      r0,r6,#0x14           ;748
0000ec  b281              UXTH     r1,r0                 ;748
0000ee  4628              MOV      r0,r5                 ;748
0000f0  f7fffffe          BL       pbuf_realloc
                  |L1.244|
0000f4  2200              MOVS     r2,#0                 ;755
0000f6  4611              MOV      r1,r2                 ;755
0000f8  2002              MOVS     r0,#2                 ;755
0000fa  f7fffffe          BL       pbuf_alloc
0000fe  4681              MOV      r9,r0                 ;755
000100  f1b90f00          CMP      r9,#0                 ;756
000104  d00d              BEQ      |L1.290|
000106  4629              MOV      r1,r5                 ;757
000108  4648              MOV      r0,r9                 ;757
00010a  f7fffffe          BL       pbuf_chain
00010e  f8d83014          LDR      r3,[r8,#0x14]         ;758
000112  4649              MOV      r1,r9                 ;758
000114  4640              MOV      r0,r8                 ;758
000116  9a08              LDR      r2,[sp,#0x20]         ;758
000118  4798              BLX      r3                    ;758
00011a  4648              MOV      r0,r9                 ;761
00011c  f7fffffe          BL       pbuf_free
000120  e007              B        |L1.306|
                  |L1.290|
000122  bf00              NOP                            ;763
000124  bf00              NOP                            ;763
000126  4628              MOV      r0,r5                 ;764
000128  f7fffffe          BL       pbuf_free
00012c  f04f30ff          MOV      r0,#0xffffffff        ;765
000130  e77a              B        |L1.40|
                  |L1.306|
000132  eba6000a          SUB      r0,r6,r10             ;783
000136  b286              UXTH     r6,r0                 ;783
000138  9805              LDR      r0,[sp,#0x14]         ;784
00013a  4458              ADD      r0,r0,r11             ;784
00013c  fa1ffb80          UXTH     r11,r0                ;784
                  |L1.320|
000140  2e00              CMP      r6,#0                 ;681
000142  d199              BNE      |L1.120|
000144  4628              MOV      r0,r5                 ;787
000146  f7fffffe          BL       pbuf_free
00014a  2000              MOVS     r0,#0                 ;790
00014c  e76c              B        |L1.40|
;;;792    #endif /* IP_FRAG */
                          ENDP

00014e  0000              DCW      0x0000
                  |L1.336|
                          DCD      buf+0x3

                          AREA ||i.ip_reass||, CODE, READONLY, ALIGN=2

                  ip_reass PROC
;;;468    struct pbuf *
;;;469    ip_reass(struct pbuf *p)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;470    {
000004  4680              MOV      r8,r0
;;;471      struct pbuf *r;
;;;472      struct ip_hdr *fraghdr;
;;;473      struct ip_reassdata *ipr;
;;;474      struct ip_reass_helper *iprh;
;;;475      u16_t offset, len;
;;;476      u8_t clen;
;;;477      struct ip_reassdata *ipr_prev = NULL;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;478    
;;;479      IPFRAG_STATS_INC(ip_frag.recv);
;;;480      snmp_inc_ipreasmreqds();
;;;481    
;;;482      fraghdr = (struct ip_hdr*)p->payload;
00000a  f8d85004          LDR      r5,[r8,#4]
;;;483    
;;;484      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
00000e  8828              LDRH     r0,[r5,#0]
000010  f7fffffe          BL       ntohs
000014  f3c02003          UBFX     r0,r0,#8,#4
000018  2114              MOVS     r1,#0x14
00001a  ebb10f80          CMP      r1,r0,LSL #2
00001e  d002              BEQ      |L2.38|
;;;485        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;486        IPFRAG_STATS_INC(ip_frag.err);
;;;487        goto nullreturn;
000024  e0b6              B        |L2.404|
                  |L2.38|
;;;488      }
;;;489    
;;;490      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000026  88e8              LDRH     r0,[r5,#6]
000028  f7fffffe          BL       ntohs
00002c  04c0              LSLS     r0,r0,#19
00002e  ea4f4910          LSR      r9,r0,#16
;;;491      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000032  8868              LDRH     r0,[r5,#2]
000034  f7fffffe          BL       ntohs
000038  4683              MOV      r11,r0
00003a  8828              LDRH     r0,[r5,#0]
00003c  f7fffffe          BL       ntohs
000040  f3c02003          UBFX     r0,r0,#8,#4
000044  ebab0080          SUB      r0,r11,r0,LSL #2
000048  b280              UXTH     r0,r0
00004a  9001              STR      r0,[sp,#4]
;;;492    
;;;493      /* Check if we are allowed to enqueue more datagrams. */
;;;494      clen = pbuf_clen(p);
00004c  4640              MOV      r0,r8
00004e  f7fffffe          BL       pbuf_clen
000052  4606              MOV      r6,r0
;;;495      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
000054  4853              LDR      r0,|L2.420|
000056  8801              LDRH     r1,[r0,#0]  ; ip_reass_pbufcount
000058  1988              ADDS     r0,r1,r6
00005a  280a              CMP      r0,#0xa
00005c  dd0c              BLE      |L2.120|
;;;496    #if IP_REASS_FREE_OLDEST
;;;497        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
00005e  4631              MOV      r1,r6
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       ip_reass_remove_oldest_datagram
000066  b120              CBZ      r0,|L2.114|
;;;498            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
000068  484e              LDR      r0,|L2.420|
00006a  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
00006c  4430              ADD      r0,r0,r6
00006e  280a              CMP      r0,#0xa
000070  dd02              BLE      |L2.120|
                  |L2.114|
;;;499    #endif /* IP_REASS_FREE_OLDEST */
;;;500        {
;;;501          /* No datagram could be freed and still too many pbufs enqueued */
;;;502          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
000072  bf00              NOP      
000074  bf00              NOP      
;;;503            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;504          IPFRAG_STATS_INC(ip_frag.memerr);
;;;505          /* @todo: send ICMP time exceeded here? */
;;;506          /* drop this pbuf */
;;;507          goto nullreturn;
000076  e08d              B        |L2.404|
                  |L2.120|
;;;508        }
;;;509      }
;;;510    
;;;511      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;512       * remembering the previous in the queue for later dequeueing. */
;;;513      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
000078  484b              LDR      r0,|L2.424|
00007a  6804              LDR      r4,[r0,#0]  ; reassdatagrams
00007c  e014              B        |L2.168|
                  |L2.126|
;;;514        /* Check if the incoming fragment matches the one currently present
;;;515           in the reassembly buffer. If so, we proceed with copying the
;;;516           fragment into the buffer. */
;;;517        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
00007e  6960              LDR      r0,[r4,#0x14]
000080  68e9              LDR      r1,[r5,#0xc]
000082  4288              CMP      r0,r1
000084  d109              BNE      |L2.154|
000086  69a0              LDR      r0,[r4,#0x18]
000088  6929              LDR      r1,[r5,#0x10]
00008a  4288              CMP      r0,r1
00008c  d105              BNE      |L2.154|
00008e  89a0              LDRH     r0,[r4,#0xc]
000090  88a9              LDRH     r1,[r5,#4]
000092  4288              CMP      r0,r1
000094  d101              BNE      |L2.154|
000096  2001              MOVS     r0,#1
000098  e000              B        |L2.156|
                  |L2.154|
00009a  2000              MOVS     r0,#0
                  |L2.156|
00009c  b110              CBZ      r0,|L2.164|
;;;518          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
00009e  bf00              NOP      
0000a0  bf00              NOP      
;;;519            ntohs(IPH_ID(fraghdr))));
;;;520          IPFRAG_STATS_INC(ip_frag.cachehit);
;;;521          break;
0000a2  e003              B        |L2.172|
                  |L2.164|
;;;522        }
;;;523        ipr_prev = ipr;
0000a4  9400              STR      r4,[sp,#0]
0000a6  6824              LDR      r4,[r4,#0]            ;513
                  |L2.168|
0000a8  2c00              CMP      r4,#0                 ;513
0000aa  d1e8              BNE      |L2.126|
                  |L2.172|
0000ac  bf00              NOP                            ;521
;;;524      }
;;;525    
;;;526      if (ipr == NULL) {
0000ae  b934              CBNZ     r4,|L2.190|
;;;527      /* Enqueue a new datagram into the datagram queue */
;;;528        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
0000b0  4631              MOV      r1,r6
0000b2  4628              MOV      r0,r5
0000b4  f7fffffe          BL       ip_reass_enqueue_new_datagram
0000b8  4604              MOV      r4,r0
;;;529        /* Bail if unable to enqueue */
;;;530        if(ipr == NULL) {
0000ba  b994              CBNZ     r4,|L2.226|
;;;531          goto nullreturn;
0000bc  e06a              B        |L2.404|
                  |L2.190|
;;;532        }
;;;533      } else {
;;;534        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
0000be  88e8              LDRH     r0,[r5,#6]
0000c0  f7fffffe          BL       ntohs
0000c4  04c0              LSLS     r0,r0,#19
0000c6  0cc0              LSRS     r0,r0,#19
0000c8  d10b              BNE      |L2.226|
;;;535          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
0000ca  89e0              LDRH     r0,[r4,#0xe]
0000cc  f7fffffe          BL       ntohs
0000d0  04c0              LSLS     r0,r0,#19
0000d2  0cc0              LSRS     r0,r0,#19
0000d4  d005              BEQ      |L2.226|
;;;536          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;537           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;538           * of the first fragment (for ICMP time exceeded and later, for copying
;;;539           * all options, if supported)*/
;;;540          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
0000d6  2214              MOVS     r2,#0x14
0000d8  4629              MOV      r1,r5
0000da  f1040008          ADD      r0,r4,#8
0000de  f7fffffe          BL       __aeabi_memcpy
                  |L2.226|
;;;541        }
;;;542      }
;;;543      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;544      the number of fragments that may be enqueued at any one time */
;;;545      ip_reass_pbufcount += clen;
0000e2  4830              LDR      r0,|L2.420|
0000e4  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0000e6  4430              ADD      r0,r0,r6
0000e8  492e              LDR      r1,|L2.420|
0000ea  8008              STRH     r0,[r1,#0]
;;;546    
;;;547      /* At this point, we have either created a new entry or pointing 
;;;548       * to an existing one */
;;;549    
;;;550      /* check for 'no more fragments', and update queue entry*/
;;;551      if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
0000ec  88e8              LDRH     r0,[r5,#6]
0000ee  f7fffffe          BL       ntohs
0000f2  f4105f00          TST      r0,#0x2000
0000f6  d108              BNE      |L2.266|
;;;552        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
0000f8  7fa0              LDRB     r0,[r4,#0x1e]
0000fa  f0400001          ORR      r0,r0,#1
0000fe  77a0              STRB     r0,[r4,#0x1e]
;;;553        ipr->datagram_len = offset + len;
000100  9801              LDR      r0,[sp,#4]
000102  4448              ADD      r0,r0,r9
000104  83a0              STRH     r0,[r4,#0x1c]
;;;554        LWIP_DEBUGF(IP_REASS_DEBUG,
000106  bf00              NOP      
000108  bf00              NOP      
                  |L2.266|
;;;555         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;556          ipr->datagram_len));
;;;557      }
;;;558      /* find the right place to insert this pbuf */
;;;559      /* @todo: trim pbufs if fragments are overlapping */
;;;560      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
00010a  4641              MOV      r1,r8
00010c  4620              MOV      r0,r4
00010e  f7fffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
000112  b3d0              CBZ      r0,|L2.394|
;;;561        /* the totally last fragment (flag more fragments = 0) was received at least
;;;562         * once AND all fragments are received */
;;;563        ipr->datagram_len += IP_HLEN;
000114  8ba0              LDRH     r0,[r4,#0x1c]
000116  3014              ADDS     r0,r0,#0x14
000118  83a0              STRH     r0,[r4,#0x1c]
;;;564    
;;;565        /* save the second pbuf before copying the header over the pointer */
;;;566        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
00011a  6860              LDR      r0,[r4,#4]
00011c  6840              LDR      r0,[r0,#4]
00011e  6807              LDR      r7,[r0,#0]
;;;567    
;;;568        /* copy the original ip header back to the first pbuf */
;;;569        fraghdr = (struct ip_hdr*)(ipr->p->payload);
000120  6860              LDR      r0,[r4,#4]
000122  6845              LDR      r5,[r0,#4]
;;;570        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
000124  2214              MOVS     r2,#0x14
000126  f1040108          ADD      r1,r4,#8
00012a  4628              MOV      r0,r5
00012c  f7fffffe          BL       __aeabi_memcpy
;;;571        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
000130  8ba0              LDRH     r0,[r4,#0x1c]
000132  f7fffffe          BL       htons
000136  8068              STRH     r0,[r5,#2]
;;;572        IPH_OFFSET_SET(fraghdr, 0);
000138  2000              MOVS     r0,#0
00013a  80e8              STRH     r0,[r5,#6]
;;;573        IPH_CHKSUM_SET(fraghdr, 0);
00013c  8168              STRH     r0,[r5,#0xa]
;;;574        /* @todo: do we need to set calculate the correct checksum? */
;;;575        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
00013e  2114              MOVS     r1,#0x14
000140  4628              MOV      r0,r5
000142  f7fffffe          BL       inet_chksum
000146  8168              STRH     r0,[r5,#0xa]
;;;576    
;;;577        p = ipr->p;
000148  f8d48004          LDR      r8,[r4,#4]
;;;578    
;;;579        /* chain together the pbufs contained within the reass_data list. */
;;;580        while(r != NULL) {
00014c  e00c              B        |L2.360|
                  |L2.334|
;;;581          iprh = (struct ip_reass_helper*)r->payload;
00014e  f8d7a004          LDR      r10,[r7,#4]
;;;582    
;;;583          /* hide the ip header for every succeding fragment */
;;;584          pbuf_header(r, -IP_HLEN);
000152  f06f0113          MVN      r1,#0x13
000156  4638              MOV      r0,r7
000158  f7fffffe          BL       pbuf_header
;;;585          pbuf_cat(p, r);
00015c  4639              MOV      r1,r7
00015e  4640              MOV      r0,r8
000160  f7fffffe          BL       pbuf_cat
;;;586          r = iprh->next_pbuf;
000164  f8da7000          LDR      r7,[r10,#0]
                  |L2.360|
000168  2f00              CMP      r7,#0                 ;580
00016a  d1f0              BNE      |L2.334|
;;;587        }
;;;588        /* release the sources allocate for the fragment queue entry */
;;;589        ip_reass_dequeue_datagram(ipr, ipr_prev);
00016c  4620              MOV      r0,r4
00016e  9900              LDR      r1,[sp,#0]
000170  f7fffffe          BL       ip_reass_dequeue_datagram
;;;590    
;;;591        /* and adjust the number of pbufs currently queued for reassembly. */
;;;592        ip_reass_pbufcount -= pbuf_clen(p);
000174  4640              MOV      r0,r8
000176  f7fffffe          BL       pbuf_clen
00017a  490a              LDR      r1,|L2.420|
00017c  8809              LDRH     r1,[r1,#0]  ; ip_reass_pbufcount
00017e  1a08              SUBS     r0,r1,r0
000180  4908              LDR      r1,|L2.420|
000182  8008              STRH     r0,[r1,#0]
;;;593    
;;;594        /* Return the pbuf chain */
;;;595        return p;
000184  4640              MOV      r0,r8
                  |L2.390|
;;;596      }
;;;597      /* the datagram is not (yet?) reassembled completely */
;;;598      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;599      return NULL;
;;;600    
;;;601    nullreturn:
;;;602      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;603      IPFRAG_STATS_INC(ip_frag.drop);
;;;604      pbuf_free(p);
;;;605      return NULL;
;;;606    }
000186  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.394|
00018a  e7ff              B        |L2.396|
                  |L2.396|
00018c  bf00              NOP                            ;598
00018e  bf00              NOP                            ;598
000190  2000              MOVS     r0,#0                 ;599
000192  e7f8              B        |L2.390|
                  |L2.404|
000194  bf00              NOP                            ;602
000196  bf00              NOP                            ;602
000198  4640              MOV      r0,r8                 ;604
00019a  f7fffffe          BL       pbuf_free
00019e  2000              MOVS     r0,#0                 ;605
0001a0  e7f1              B        |L2.390|
;;;607    #endif /* IP_REASSEMBLY */
                          ENDP

0001a2  0000              DCW      0x0000
                  |L2.420|
                          DCD      ip_reass_pbufcount
                  |L2.424|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;323    static int
;;;324    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;325    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;326      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
000008  2500              MOVS     r5,#0
;;;327      struct pbuf *q;
;;;328      u16_t offset,len;
;;;329      struct ip_hdr *fraghdr;
;;;330      int valid = 1;
00000a  2001              MOVS     r0,#1
00000c  9000              STR      r0,[sp,#0]
;;;331    
;;;332      /* Extract length and fragment offset from current fragment */
;;;333      fraghdr = (struct ip_hdr*)new_p->payload; 
00000e  f8d6a004          LDR      r10,[r6,#4]
;;;334      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000012  f8ba0002          LDRH     r0,[r10,#2]
000016  f7fffffe          BL       ntohs
00001a  4683              MOV      r11,r0
00001c  f8ba0000          LDRH     r0,[r10,#0]
000020  f7fffffe          BL       ntohs
000024  f3c02003          UBFX     r0,r0,#8,#4
000028  ebab0080          SUB      r0,r11,r0,LSL #2
00002c  b280              UXTH     r0,r0
00002e  9001              STR      r0,[sp,#4]
;;;335      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000030  f8ba0006          LDRH     r0,[r10,#6]
000034  f7fffffe          BL       ntohs
000038  04c0              LSLS     r0,r0,#19
00003a  0c00              LSRS     r0,r0,#16
00003c  9002              STR      r0,[sp,#8]
;;;336    
;;;337      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;338       * and setup the embedded helper structure. */
;;;339      /* make sure the struct ip_reass_helper fits into the IP header */
;;;340      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
;;;341                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;342      iprh = (struct ip_reass_helper*)new_p->payload;
00003e  6874              LDR      r4,[r6,#4]
;;;343      iprh->next_pbuf = NULL;
000040  2000              MOVS     r0,#0
000042  6020              STR      r0,[r4,#0]
;;;344      iprh->start = offset;
000044  9802              LDR      r0,[sp,#8]
000046  80a0              STRH     r0,[r4,#4]
;;;345      iprh->end = offset + len;
000048  e9dd1001          LDRD     r1,r0,[sp,#4]
00004c  4408              ADD      r0,r0,r1
00004e  80e0              STRH     r0,[r4,#6]
;;;346    
;;;347      /* Iterate through until we either get to the end of the list (append),
;;;348       * or we find on with a larger offset (insert). */
;;;349      for (q = ipr->p; q != NULL;) {
000050  f8d89004          LDR      r9,[r8,#4]
000054  e02a              B        |L3.172|
                  |L3.86|
;;;350        iprh_tmp = (struct ip_reass_helper*)q->payload;
000056  f8d97004          LDR      r7,[r9,#4]
;;;351        if (iprh->start < iprh_tmp->start) {
00005a  88a0              LDRH     r0,[r4,#4]
00005c  88b9              LDRH     r1,[r7,#4]
00005e  4288              CMP      r0,r1
000060  da10              BGE      |L3.132|
;;;352          /* the new pbuf should be inserted before this */
;;;353          iprh->next_pbuf = q;
000062  f8c49000          STR      r9,[r4,#0]
;;;354          if (iprh_prev != NULL) {
000066  b155              CBZ      r5,|L3.126|
;;;355            /* not the fragment with the lowest offset */
;;;356    #if IP_REASS_CHECK_OVERLAP
;;;357            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
000068  88a0              LDRH     r0,[r4,#4]
00006a  88e9              LDRH     r1,[r5,#6]
00006c  4288              CMP      r0,r1
00006e  db03              BLT      |L3.120|
000070  88e0              LDRH     r0,[r4,#6]
000072  88b9              LDRH     r1,[r7,#4]
000074  4288              CMP      r0,r1
000076  dd00              BLE      |L3.122|
                  |L3.120|
;;;358              /* fragment overlaps with previous or following, throw away */
;;;359              goto freepbuf;
000078  e053              B        |L3.290|
                  |L3.122|
;;;360            }
;;;361    #endif /* IP_REASS_CHECK_OVERLAP */
;;;362            iprh_prev->next_pbuf = new_p;
00007a  602e              STR      r6,[r5,#0]
00007c  e001              B        |L3.130|
                  |L3.126|
;;;363          } else {
;;;364            /* fragment with the lowest offset */
;;;365            ipr->p = new_p;
00007e  f8c86004          STR      r6,[r8,#4]
                  |L3.130|
;;;366          }
;;;367          break;
000082  e016              B        |L3.178|
                  |L3.132|
;;;368        } else if(iprh->start == iprh_tmp->start) {
000084  88a0              LDRH     r0,[r4,#4]
000086  88b9              LDRH     r1,[r7,#4]
000088  4288              CMP      r0,r1
00008a  d100              BNE      |L3.142|
;;;369          /* received the same datagram twice: no need to keep the datagram */
;;;370          goto freepbuf;
00008c  e049              B        |L3.290|
                  |L3.142|
;;;371    #if IP_REASS_CHECK_OVERLAP
;;;372        } else if(iprh->start < iprh_tmp->end) {
00008e  88a0              LDRH     r0,[r4,#4]
000090  88f9              LDRH     r1,[r7,#6]
000092  4288              CMP      r0,r1
000094  da00              BGE      |L3.152|
;;;373          /* overlap: no need to keep the new datagram */
;;;374          goto freepbuf;
000096  e044              B        |L3.290|
                  |L3.152|
;;;375    #endif /* IP_REASS_CHECK_OVERLAP */
;;;376        } else {
;;;377          /* Check if the fragments received so far have no wholes. */
;;;378          if (iprh_prev != NULL) {
000098  b12d              CBZ      r5,|L3.166|
;;;379            if (iprh_prev->end != iprh_tmp->start) {
00009a  88e8              LDRH     r0,[r5,#6]
00009c  88b9              LDRH     r1,[r7,#4]
00009e  4288              CMP      r0,r1
0000a0  d001              BEQ      |L3.166|
;;;380              /* There is a fragment missing between the current
;;;381               * and the previous fragment */
;;;382              valid = 0;
0000a2  2000              MOVS     r0,#0
0000a4  9000              STR      r0,[sp,#0]
                  |L3.166|
;;;383            }
;;;384          }
;;;385        }
;;;386        q = iprh_tmp->next_pbuf;
0000a6  f8d79000          LDR      r9,[r7,#0]
;;;387        iprh_prev = iprh_tmp;
0000aa  463d              MOV      r5,r7
                  |L3.172|
0000ac  f1b90f00          CMP      r9,#0                 ;349
0000b0  d1d1              BNE      |L3.86|
                  |L3.178|
0000b2  bf00              NOP                            ;367
;;;388      }
;;;389    
;;;390      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;391      if (q == NULL) {
0000b4  f1b90f00          CMP      r9,#0
0000b8  d10a              BNE      |L3.208|
;;;392        if (iprh_prev != NULL) {
0000ba  b13d              CBZ      r5,|L3.204|
;;;393          /* this is (for now), the fragment with the highest offset:
;;;394           * chain it to the last fragment */
;;;395    #if IP_REASS_CHECK_OVERLAP
;;;396          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
;;;397    #endif /* IP_REASS_CHECK_OVERLAP */
;;;398          iprh_prev->next_pbuf = new_p;
0000bc  602e              STR      r6,[r5,#0]
;;;399          if (iprh_prev->end != iprh->start) {
0000be  88e8              LDRH     r0,[r5,#6]
0000c0  88a1              LDRH     r1,[r4,#4]
0000c2  4288              CMP      r0,r1
0000c4  d004              BEQ      |L3.208|
;;;400            valid = 0;
0000c6  2000              MOVS     r0,#0
0000c8  9000              STR      r0,[sp,#0]
0000ca  e001              B        |L3.208|
                  |L3.204|
;;;401          }
;;;402        } else {
;;;403    #if IP_REASS_CHECK_OVERLAP
;;;404          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
;;;405            ipr->p == NULL);
;;;406    #endif /* IP_REASS_CHECK_OVERLAP */
;;;407          /* this is the first fragment we ever received for this ip datagram */
;;;408          ipr->p = new_p;
0000cc  f8c86004          STR      r6,[r8,#4]
                  |L3.208|
;;;409        }
;;;410      }
;;;411    
;;;412      /* At this point, the validation part begins: */
;;;413      /* If we already received the last fragment */
;;;414      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
0000d0  f898001e          LDRB     r0,[r8,#0x1e]
0000d4  f0100f01          TST      r0,#1
0000d8  d021              BEQ      |L3.286|
;;;415        /* and had no wholes so far */
;;;416        if (valid) {
0000da  9800              LDR      r0,[sp,#0]
0000dc  b1e0              CBZ      r0,|L3.280|
;;;417          /* then check if the rest of the fragments is here */
;;;418          /* Check if the queue starts with the first datagram */
;;;419          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
0000de  f8d80004          LDR      r0,[r8,#4]
0000e2  6840              LDR      r0,[r0,#4]
0000e4  8880              LDRH     r0,[r0,#4]
0000e6  b110              CBZ      r0,|L3.238|
;;;420            valid = 0;
0000e8  2000              MOVS     r0,#0
0000ea  9000              STR      r0,[sp,#0]
0000ec  e014              B        |L3.280|
                  |L3.238|
;;;421          } else {
;;;422            /* and check that there are no wholes after this datagram */
;;;423            iprh_prev = iprh;
0000ee  4625              MOV      r5,r4
;;;424            q = iprh->next_pbuf;
0000f0  f8d49000          LDR      r9,[r4,#0]
;;;425            while (q != NULL) {
0000f4  e00b              B        |L3.270|
                  |L3.246|
;;;426              iprh = (struct ip_reass_helper*)q->payload;
0000f6  f8d94004          LDR      r4,[r9,#4]
;;;427              if (iprh_prev->end != iprh->start) {
0000fa  88e8              LDRH     r0,[r5,#6]
0000fc  88a1              LDRH     r1,[r4,#4]
0000fe  4288              CMP      r0,r1
000100  d002              BEQ      |L3.264|
;;;428                valid = 0;
000102  2000              MOVS     r0,#0
000104  9000              STR      r0,[sp,#0]
;;;429                break;
000106  e005              B        |L3.276|
                  |L3.264|
;;;430              }
;;;431              iprh_prev = iprh;
000108  4625              MOV      r5,r4
;;;432              q = iprh->next_pbuf;
00010a  f8d49000          LDR      r9,[r4,#0]
                  |L3.270|
00010e  f1b90f00          CMP      r9,#0                 ;425
000112  d1f0              BNE      |L3.246|
                  |L3.276|
000114  bf00              NOP                            ;429
;;;433            }
;;;434            /* if still valid, all fragments are received
;;;435             * (because to the MF==0 already arrived */
;;;436            if (valid) {
000116  bf00              NOP      
                  |L3.280|
;;;437              LWIP_ASSERT("sanity check", ipr->p != NULL);
;;;438              LWIP_ASSERT("sanity check",
;;;439                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;440              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
;;;441                iprh->next_pbuf == NULL);
;;;442              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
;;;443                iprh->end == ipr->datagram_len);
;;;444            }
;;;445          }
;;;446        }
;;;447        /* If valid is 0 here, there are some fragments missing in the middle
;;;448         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;449         * no more fragments are received... */
;;;450        return valid;
000118  9800              LDR      r0,[sp,#0]
                  |L3.282|
;;;451      }
;;;452      /* If we come here, not all fragments were received, yet! */
;;;453      return 0; /* not yet valid! */
;;;454    #if IP_REASS_CHECK_OVERLAP
;;;455    freepbuf:
;;;456      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;457      pbuf_free(new_p);
;;;458      return 0;
;;;459    #endif /* IP_REASS_CHECK_OVERLAP */
;;;460    }
00011a  e8bd8ffe          POP      {r1-r11,pc}
                  |L3.286|
00011e  2000              MOVS     r0,#0                 ;453
000120  e7fb              B        |L3.282|
                  |L3.290|
000122  4630              MOV      r0,r6                 ;456
000124  f7fffffe          BL       pbuf_clen
000128  4904              LDR      r1,|L3.316|
00012a  8809              LDRH     r1,[r1,#0]            ;456  ; ip_reass_pbufcount
00012c  1a08              SUBS     r0,r1,r0              ;456
00012e  4903              LDR      r1,|L3.316|
000130  8008              STRH     r0,[r1,#0]            ;456
000132  4630              MOV      r0,r6                 ;457
000134  f7fffffe          BL       pbuf_free
000138  2000              MOVS     r0,#0                 ;458
00013a  e7ee              B        |L3.282|
;;;461    
                          ENDP

                  |L3.316|
                          DCD      ip_reass_pbufcount

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_dequeue_datagram PROC
;;;296    static void
;;;297    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;299      
;;;300      /* dequeue the reass struct  */
;;;301      if (reassdatagrams == ipr) {
000006  4807              LDR      r0,|L4.36|
000008  6800              LDR      r0,[r0,#0]  ; reassdatagrams
00000a  42a0              CMP      r0,r4
00000c  d103              BNE      |L4.22|
;;;302        /* it was the first in the list */
;;;303        reassdatagrams = ipr->next;
00000e  4905              LDR      r1,|L4.36|
000010  6820              LDR      r0,[r4,#0]
000012  6008              STR      r0,[r1,#0]  ; reassdatagrams
000014  e001              B        |L4.26|
                  |L4.22|
;;;304      } else {
;;;305        /* it wasn't the first, so it must have a valid 'prev' */
;;;306        LWIP_ASSERT("sanity check linked list", prev != NULL);
;;;307        prev->next = ipr->next;
000016  6820              LDR      r0,[r4,#0]
000018  6028              STR      r0,[r5,#0]
                  |L4.26|
;;;308      }
;;;309    
;;;310      /* now we can free the ip_reass struct */
;;;311      memp_free(MEMP_REASSDATA, ipr);
00001a  4621              MOV      r1,r4
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       memp_free
;;;312    }
000022  bd70              POP      {r4-r6,pc}
;;;313    
                          ENDP

                  |L4.36|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_enqueue_new_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_enqueue_new_datagram PROC
;;;261    static struct ip_reassdata*
;;;262    ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;264      struct ip_reassdata* ipr;
;;;265      /* No matching previous fragment found, allocate a new reassdata struct */
;;;266      ipr = memp_malloc(MEMP_REASSDATA);
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       memp_malloc
00000c  4604              MOV      r4,r0
;;;267      if (ipr == NULL) {
00000e  b974              CBNZ     r4,|L5.46|
;;;268    #if IP_REASS_FREE_OLDEST
;;;269        if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       ip_reass_remove_oldest_datagram
000018  42b0              CMP      r0,r6
00001a  db03              BLT      |L5.36|
;;;270          ipr = memp_malloc(MEMP_REASSDATA);
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       memp_malloc
000022  4604              MOV      r4,r0
                  |L5.36|
;;;271        }
;;;272        if (ipr == NULL)
000024  b91c              CBNZ     r4,|L5.46|
;;;273    #endif /* IP_REASS_FREE_OLDEST */
;;;274        {
;;;275          IPFRAG_STATS_INC(ip_frag.memerr);
;;;276          LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
000026  bf00              NOP      
000028  bf00              NOP      
;;;277          return NULL;
00002a  2000              MOVS     r0,#0
                  |L5.44|
;;;278        }
;;;279      }
;;;280      memset(ipr, 0, sizeof(struct ip_reassdata));
;;;281      ipr->timer = IP_REASS_MAXAGE;
;;;282    
;;;283      /* enqueue the new structure to the front of the list */
;;;284      ipr->next = reassdatagrams;
;;;285      reassdatagrams = ipr;
;;;286      /* copy the ip header for later tests and input */
;;;287      /* @todo: no ip options supported? */
;;;288      SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
;;;289      return ipr;
;;;290    }
00002c  bd70              POP      {r4-r6,pc}
                  |L5.46|
00002e  2120              MOVS     r1,#0x20              ;280
000030  4620              MOV      r0,r4                 ;280
000032  f7fffffe          BL       __aeabi_memclr4
000036  2003              MOVS     r0,#3                 ;281
000038  77e0              STRB     r0,[r4,#0x1f]         ;281
00003a  4806              LDR      r0,|L5.84|
00003c  6800              LDR      r0,[r0,#0]            ;284  ; reassdatagrams
00003e  6020              STR      r0,[r4,#0]            ;284
000040  4804              LDR      r0,|L5.84|
000042  6004              STR      r4,[r0,#0]            ;285  ; reassdatagrams
000044  2214              MOVS     r2,#0x14              ;288
000046  4629              MOV      r1,r5                 ;288
000048  f1040008          ADD      r0,r4,#8              ;288
00004c  f7fffffe          BL       __aeabi_memcpy
000050  4620              MOV      r0,r4                 ;289
000052  e7eb              B        |L5.44|
;;;291    
                          ENDP

                  |L5.84|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_free_complete_datagram PROC
;;;155    static int
;;;156    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;157    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;158      int pbufs_freed = 0;
000008  2600              MOVS     r6,#0
;;;159      struct pbuf *p;
;;;160      struct ip_reass_helper *iprh;
;;;161    
;;;162      LWIP_ASSERT("prev != ipr", prev != ipr);
;;;163      if (prev != NULL) {
;;;164        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
;;;165      }
;;;166    
;;;167      snmp_inc_ipreasmfails();
;;;168    #if LWIP_ICMP
;;;169      iprh = (struct ip_reass_helper *)ipr->p->payload;
00000a  6860              LDR      r0,[r4,#4]
00000c  6847              LDR      r7,[r0,#4]
;;;170      if (iprh->start == 0) {
00000e  88b8              LDRH     r0,[r7,#4]
000010  b998              CBNZ     r0,|L6.58|
;;;171        /* The first fragment was received, send ICMP time exceeded. */
;;;172        /* First, de-queue the first pbuf from r->p. */
;;;173        p = ipr->p;
000012  6865              LDR      r5,[r4,#4]
;;;174        ipr->p = iprh->next_pbuf;
000014  6838              LDR      r0,[r7,#0]
000016  6060              STR      r0,[r4,#4]
;;;175        /* Then, copy the original header into it. */
;;;176        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
000018  2214              MOVS     r2,#0x14
00001a  f1040108          ADD      r1,r4,#8
00001e  6868              LDR      r0,[r5,#4]
000020  f7fffffe          BL       __aeabi_memcpy
;;;177        icmp_time_exceeded(p, ICMP_TE_FRAG);
000024  2101              MOVS     r1,#1
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       icmp_time_exceeded
;;;178        pbufs_freed += pbuf_clen(p);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       pbuf_clen
000032  4406              ADD      r6,r6,r0
;;;179        pbuf_free(p);
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       pbuf_free
                  |L6.58|
;;;180      }
;;;181    #endif /* LWIP_ICMP */
;;;182    
;;;183      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;184         separately as they have not yet been chained */
;;;185      p = ipr->p;
00003a  6865              LDR      r5,[r4,#4]
;;;186      while (p != NULL) {
00003c  e00a              B        |L6.84|
                  |L6.62|
;;;187        struct pbuf *pcur;
;;;188        iprh = (struct ip_reass_helper *)p->payload;
00003e  686f              LDR      r7,[r5,#4]
;;;189        pcur = p;
000040  46a9              MOV      r9,r5
;;;190        /* get the next pointer before freeing */
;;;191        p = iprh->next_pbuf;
000042  683d              LDR      r5,[r7,#0]
;;;192        pbufs_freed += pbuf_clen(pcur);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       pbuf_clen
00004a  4406              ADD      r6,r6,r0
;;;193        pbuf_free(pcur);    
00004c  4648              MOV      r0,r9
00004e  f7fffffe          BL       pbuf_free
;;;194      }
000052  bf00              NOP      
                  |L6.84|
000054  2d00              CMP      r5,#0                 ;186
000056  d1f2              BNE      |L6.62|
;;;195      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;196      ip_reass_dequeue_datagram(ipr, prev);
000058  4641              MOV      r1,r8
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       ip_reass_dequeue_datagram
;;;197      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
;;;198      ip_reass_pbufcount -= pbufs_freed;
000060  4803              LDR      r0,|L6.112|
000062  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
000064  1b80              SUBS     r0,r0,r6
000066  4902              LDR      r1,|L6.112|
000068  8008              STRH     r0,[r1,#0]
;;;199    
;;;200      return pbufs_freed;
00006a  4630              MOV      r0,r6
;;;201    }
00006c  e8bd87f0          POP      {r4-r10,pc}
;;;202    
                          ENDP

                  |L6.112|
                          DCD      ip_reass_pbufcount

                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;213    static int
;;;214    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;215    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
;;;216      /* @todo Can't we simply remove the last datagram in the
;;;217       *       linked list behind reassdatagrams?
;;;218       */
;;;219      struct ip_reassdata *r, *oldest, *prev;
;;;220      int pbufs_freed = 0, pbufs_freed_current;
000008  2700              MOVS     r7,#0
;;;221      int other_datagrams;
;;;222    
;;;223      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;224       * but don't free the datagram that 'fraghdr' belongs to! */
;;;225      do {
00000a  bf00              NOP      
                  |L7.12|
;;;226        oldest = NULL;
00000c  2600              MOVS     r6,#0
;;;227        prev = NULL;
00000e  46b3              MOV      r11,r6
;;;228        other_datagrams = 0;
000010  46b2              MOV      r10,r6
;;;229        r = reassdatagrams;
000012  4819              LDR      r0,|L7.120|
000014  6804              LDR      r4,[r0,#0]  ; reassdatagrams
;;;230        while (r != NULL) {
000016  e01d              B        |L7.84|
                  |L7.24|
;;;231          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
000018  6960              LDR      r0,[r4,#0x14]
00001a  68e9              LDR      r1,[r5,#0xc]
00001c  4288              CMP      r0,r1
00001e  d107              BNE      |L7.48|
000020  69a0              LDR      r0,[r4,#0x18]
000022  6929              LDR      r1,[r5,#0x10]
000024  4288              CMP      r0,r1
000026  d103              BNE      |L7.48|
000028  89a0              LDRH     r0,[r4,#0xc]
00002a  88a9              LDRH     r1,[r5,#4]
00002c  4288              CMP      r0,r1
00002e  d001              BEQ      |L7.52|
                  |L7.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L7.54|
                  |L7.52|
000034  2000              MOVS     r0,#0
                  |L7.54|
000036  b148              CBZ      r0,|L7.76|
;;;232            /* Not the same datagram as fraghdr */
;;;233            other_datagrams++;
000038  f10a0a01          ADD      r10,r10,#1
;;;234            if (oldest == NULL) {
00003c  b90e              CBNZ     r6,|L7.66|
;;;235              oldest = r;
00003e  4626              MOV      r6,r4
000040  e004              B        |L7.76|
                  |L7.66|
;;;236            } else if (r->timer <= oldest->timer) {
000042  7fe0              LDRB     r0,[r4,#0x1f]
000044  7ff1              LDRB     r1,[r6,#0x1f]
000046  4288              CMP      r0,r1
000048  dc00              BGT      |L7.76|
;;;237              /* older than the previous oldest */
;;;238              oldest = r;
00004a  4626              MOV      r6,r4
                  |L7.76|
;;;239            }
;;;240          }
;;;241          if (r->next != NULL) {
00004c  6820              LDR      r0,[r4,#0]
00004e  b100              CBZ      r0,|L7.82|
;;;242            prev = r;
000050  46a3              MOV      r11,r4
                  |L7.82|
;;;243          }
;;;244          r = r->next;
000052  6824              LDR      r4,[r4,#0]
                  |L7.84|
000054  2c00              CMP      r4,#0                 ;230
000056  d1df              BNE      |L7.24|
;;;245        }
;;;246        if (oldest != NULL) {
000058  b12e              CBZ      r6,|L7.102|
;;;247          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
00005a  4659              MOV      r1,r11
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       ip_reass_free_complete_datagram
000062  4680              MOV      r8,r0
;;;248          pbufs_freed += pbufs_freed_current;
000064  4447              ADD      r7,r7,r8
                  |L7.102|
;;;249        }
;;;250      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000066  454f              CMP      r7,r9
000068  da02              BGE      |L7.112|
00006a  f1ba0f01          CMP      r10,#1
00006e  dccd              BGT      |L7.12|
                  |L7.112|
;;;251      return pbufs_freed;
000070  4638              MOV      r0,r7
;;;252    }
000072  e8bd9ff0          POP      {r4-r12,pc}
;;;253    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

000076  0000              DCW      0x0000
                  |L7.120|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;119    void
;;;120    ip_reass_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
;;;122      struct ip_reassdata *r, *prev = NULL;
000002  2600              MOVS     r6,#0
;;;123    
;;;124      r = reassdatagrams;
000004  480c              LDR      r0,|L8.56|
000006  6804              LDR      r4,[r0,#0]  ; reassdatagrams
;;;125      while (r != NULL) {
000008  e013              B        |L8.50|
                  |L8.10|
;;;126        /* Decrement the timer. Once it reaches 0,
;;;127         * clean up the incomplete fragment assembly */
;;;128        if (r->timer > 0) {
00000a  7fe0              LDRB     r0,[r4,#0x1f]
00000c  2800              CMP      r0,#0
00000e  dd07              BLE      |L8.32|
;;;129          r->timer--;
000010  7fe0              LDRB     r0,[r4,#0x1f]
000012  1e40              SUBS     r0,r0,#1
000014  77e0              STRB     r0,[r4,#0x1f]
;;;130          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
000016  bf00              NOP      
000018  bf00              NOP      
;;;131          prev = r;
00001a  4626              MOV      r6,r4
;;;132          r = r->next;
00001c  6824              LDR      r4,[r4,#0]
00001e  e008              B        |L8.50|
                  |L8.32|
;;;133        } else {
;;;134          /* reassembly timed out */
;;;135          struct ip_reassdata *tmp;
;;;136          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;137          tmp = r;
000024  4625              MOV      r5,r4
;;;138          /* get the next pointer before freeing */
;;;139          r = r->next;
000026  6824              LDR      r4,[r4,#0]
;;;140          /* free the helper struct and all enqueued pbufs */
;;;141          ip_reass_free_complete_datagram(tmp, prev);
000028  4631              MOV      r1,r6
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       ip_reass_free_complete_datagram
;;;142         }
000030  bf00              NOP      
                  |L8.50|
000032  2c00              CMP      r4,#0                 ;125
000034  d1e9              BNE      |L8.10|
;;;143       }
;;;144    }
000036  bd70              POP      {r4-r6,pc}
;;;145    
                          ENDP

                  |L8.56|
                          DCD      reassdatagrams

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buf
                          %        1504

                          AREA ||.data||, DATA, ALIGN=2

                  reassdatagrams
                          DCD      0x00000000
                  ip_reass_pbufcount
000004  0000              DCB      0x00,0x00
