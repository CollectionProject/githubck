; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\cmd.o --depend=.\obj\cmd.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\cmd.crf ..\marvel\driver\src\cmd.c]
                          THUMB

                          AREA ||i.__lbs_cleanup_and_insert_cmd||, CODE, READONLY, ALIGN=1

                  __lbs_cleanup_and_insert_cmd PROC
;;;32      */
;;;33     static void __lbs_cleanup_and_insert_cmd(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;34     					 struct cmd_ctrl_node *cmdnode)
;;;35     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;36     	lbs_deb_cmd_enter("enter __lbs_cleanup_and_insert_cmd\n");
;;;37     
;;;38     	if (!cmdnode)
000006  b904              CBNZ     r4,|L1.10|
;;;39     		goto out;
000008  e005              B        |L1.22|
                  |L1.10|
;;;40     
;;;41     	list_add_tail(&cmdnode->list, &priv->cmdfreeq);//将未使用的cmdnode链入到空闲链表中
00000a  f1050184          ADD      r1,r5,#0x84
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       list_add_tail
;;;42      out:
000014  bf00              NOP      
                  |L1.22|
;;;43     	lbs_deb_cmd_leave("leave __lbs_cleanup_and_insert_cmd\n");
;;;44     }
000016  bd70              POP      {r4-r6,pc}
;;;45     
                          ENDP


                          AREA ||i.__lbs_cmd||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  __lbs_cmd PROC
;;;455    
;;;456    int __lbs_cmd(struct lbs_private *priv, uint16_t command,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;457    	      struct cmd_header *in_cmd, int in_cmd_size,
;;;458    	      int (*callback)(struct lbs_private *, unsigned long, struct cmd_header *),
;;;459    	      unsigned long callback_arg)
;;;460    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  f8ddb040          LDR      r11,[sp,#0x40]
;;;461    	struct cmd_ctrl_node *cmdnode;
;;;462    //	unsigned long flags;
;;;463    	struct if_sdio_card *card=priv->card;
000012  6ab7              LDR      r7,[r6,#0x28]
;;;464    	int ret = 0;
000014  2400              MOVS     r4,#0
;;;465    	unsigned long time_out;
;;;466    	 lbs_deb_cmd_enter("enter __lbs_cmd\n");
;;;467    
;;;468    	cmdnode = __lbs_cmd_async(priv, command, in_cmd, in_cmd_size,
000016  9b11              LDR      r3,[sp,#0x44]
000018  e9cdb300          STRD     r11,r3,[sp,#0]
00001c  4653              MOV      r3,r10
00001e  464a              MOV      r2,r9
000020  4641              MOV      r1,r8
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       __lbs_cmd_async
000028  4605              MOV      r5,r0
;;;469    				  callback, callback_arg);//异步提交命令，唤醒主线程执行命令
;;;470    
;;;471    	if (IS_ERR(cmdnode)) {
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       IS_ERR
000030  b120              CBZ      r0,|L2.60|
;;;472    		ret = PTR_ERR(cmdnode);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       PTR_ERR
000038  4604              MOV      r4,r0
;;;473    		goto done;
00003a  e041              B        |L2.192|
                  |L2.60|
;;;474    	}
;;;475    	
;;;476    	// might_sleep();
;;;477    	//等待主线程唤醒，可中断的 sdio_irq_thread
;;;478    	// wait_event_interruptible(cmdnode->cmdwait_q, cmdnode->cmdwaitqwoken);
;;;479    	/*we have no choice but to pool*/
;;;480    	time_out=1000;
00003c  f44f707a          MOV      r0,#0x3e8
000040  9002              STR      r0,[sp,#8]
;;;481    re_while:
000042  bf00              NOP      
                  |L2.68|
;;;482    	while(1){
000044  e026              B        |L2.148|
                  |L2.70|
;;;483    		
;;;484    		ret=pool_sdio_interrupt(card->func);
000046  6838              LDR      r0,[r7,#0]
000048  f7fffffe          BL       pool_sdio_interrupt
00004c  4604              MOV      r4,r0
;;;485    		if(ret<0){
00004e  2c00              CMP      r4,#0
000050  da04              BGE      |L2.92|
;;;486    			lbs_pr_err("read interrupt error!\n");
000052  a01d              ADR      r0,|L2.200|
000054  f7fffffe          BL       __2printf
;;;487    			try_bug(0);
000058  bf00              NOP      
                  |L2.90|
00005a  e7fe              B        |L2.90|
                  |L2.92|
;;;488    		}
;;;489    		else if(ret&IF_SDIO_H_INT_UPLD){//先判断数据
00005c  f0140f01          TST      r4,#1
000060  d003              BEQ      |L2.106|
;;;490    			if_sdio_interrupt(card->func);
000062  6838              LDR      r0,[r7,#0]
000064  f7fffffe          BL       if_sdio_interrupt
;;;491    			break;
000068  e015              B        |L2.150|
                  |L2.106|
;;;492    		}
;;;493    		else if(ret&IF_SDIO_H_INT_DNLD)
00006a  f0140f02          TST      r4,#2
00006e  d003              BEQ      |L2.120|
;;;494    				if_sdio_interrupt(card->func);
000070  6838              LDR      r0,[r7,#0]
000072  f7fffffe          BL       if_sdio_interrupt
000076  e00d              B        |L2.148|
                  |L2.120|
;;;495    		else if(time_after(jiffies,&time_out)){
000078  a902              ADD      r1,sp,#8
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       time_after
000080  b140              CBZ      r0,|L2.148|
;;;496    			priv->cmd_timed_out=1;
000082  2001              MOVS     r0,#1
000084  f8c600ac          STR      r0,[r6,#0xac]
;;;497    			 lbs_thread(priv);//处理超时
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       lbs_thread
;;;498    			 ret=-ETIME;
00008e  f06f0448          MVN      r4,#0x48
;;;499    			 break;
000092  e000              B        |L2.150|
                  |L2.148|
000094  e7d7              B        |L2.70|
                  |L2.150|
000096  bf00              NOP                            ;491
;;;500    			}
;;;501    		}
;;;502    	while(!cmdnode->cmdwaitqwoken)
000098  e003              B        |L2.162|
                  |L2.154|
;;;503    	{
;;;504    		printf("@@@@@@@@@@@@@############################################# re while\r\n");
00009a  4811              LDR      r0,|L2.224|
00009c  f7fffffe          BL       __2printf
;;;505    		goto re_while;
0000a0  e7d0              B        |L2.68|
                  |L2.162|
0000a2  8b28              LDRH     r0,[r5,#0x18]         ;502
0000a4  2800              CMP      r0,#0                 ;502
0000a6  d0f8              BEQ      |L2.154|
;;;506    	}//等待命令处理完成
;;;507    
;;;508    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;509    	ret = cmdnode->result;//命令执行的结果
0000a8  68ac              LDR      r4,[r5,#8]
;;;510    	if (ret)
0000aa  b124              CBZ      r4,|L2.182|
;;;511    		lbs_pr_err("PREP_CMD: command 0x%04x failed: %d\n",
0000ac  4622              MOV      r2,r4
0000ae  4641              MOV      r1,r8
0000b0  a00c              ADR      r0,|L2.228|
0000b2  f7fffffe          BL       __2printf
                  |L2.182|
;;;512    			    command, ret);
;;;513    	
;;;514    	__lbs_cleanup_and_insert_cmd(priv, cmdnode);//清除cmdnode，释放到到cmdfree链表
0000b6  4629              MOV      r1,r5
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       __lbs_cleanup_and_insert_cmd
;;;515    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;516    
;;;517    done:
0000be  bf00              NOP      
                  |L2.192|
;;;518    	 lbs_deb_cmd_leave_args( "leave __lbs_cmd(ret=%d)\n", ret);
;;;519    	return ret;
0000c0  4620              MOV      r0,r4
;;;520    }
0000c2  b007              ADD      sp,sp,#0x1c
0000c4  e8bd8ff0          POP      {r4-r11,pc}
;;;521    
                          ENDP

                  |L2.200|
0000c8  72656164          DCB      "read interrupt error!\n",0
0000cc  20696e74
0000d0  65727275
0000d4  70742065
0000d8  72726f72
0000dc  210a00  
0000df  00                DCB      0
                  |L2.224|
                          DCD      ||.constdata||
                  |L2.228|
0000e4  50524550          DCB      "PREP_CMD: command 0x%04x failed: %d\n",0
0000e8  5f434d44
0000ec  3a20636f
0000f0  6d6d616e
0000f4  64203078
0000f8  25303478
0000fc  20666169
000100  6c65643a
000104  2025640a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.__lbs_cmd_async||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  __lbs_cmd_async PROC
;;;401    
;;;402    static struct cmd_ctrl_node *__lbs_cmd_async(struct lbs_private *priv,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;403    	uint16_t command, struct cmd_header *in_cmd, int in_cmd_size,
;;;404    	int (*callback)(struct lbs_private *, unsigned long, struct cmd_header *),
;;;405    	unsigned long callback_arg)
;;;406    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  e9dd9a08          LDRD     r9,r10,[sp,#0x20]
;;;407    	struct cmd_ctrl_node *cmdnode;
;;;408    
;;;409    	 lbs_deb_cmd_enter(LBS_DEB_HOST);
;;;410    
;;;411    	if (priv->surpriseremoved) {
000010  f89501ec          LDRB     r0,[r5,#0x1ec]
000014  b128              CBZ      r0,|L3.34|
;;;412    		lbs_deb_host("PREP_CMD: card removed\n");
;;;413    		cmdnode = ERR_PTR(-ENOENT);
000016  f06f0001          MVN      r0,#1
00001a  f7fffffe          BL       ERR_PTR
00001e  4604              MOV      r4,r0
;;;414    		goto done;
000020  e033              B        |L3.138|
                  |L3.34|
;;;415    	}
;;;416    	//从空闲的命令链表中获取一个未使用的command node
;;;417    	cmdnode = lbs_get_cmd_ctrl_node(priv);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       lbs_get_cmd_ctrl_node
000028  4604              MOV      r4,r0
;;;418    	if (cmdnode == NULL) {
00002a  b944              CBNZ     r4,|L3.62|
;;;419    		lbs_deb_host("PREP_CMD: cmdnode is NULL\n");
;;;420    
;;;421    		/* Wake up main thread to execute next command */
;;;422    		//wake_up_interruptible(&priv->waitq);
;;;423    		lbs_thread(priv);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       lbs_thread
;;;424    		//如果申请不到空闲的cmd块，说明还有很多命令尚未执行，需要唤醒内核线程工作
;;;425    		cmdnode = ERR_PTR(-ENOBUFS);
000032  f06f0036          MVN      r0,#0x36
000036  f7fffffe          BL       ERR_PTR
00003a  4604              MOV      r4,r0
;;;426    		goto done;
00003c  e025              B        |L3.138|
                  |L3.62|
;;;427    	}
;;;428    
;;;429    	cmdnode->callback = callback;//填充命令完成的回调函数
00003e  f8c4900c          STR      r9,[r4,#0xc]
;;;430    	cmdnode->callback_arg = callback_arg;//回调参数
000042  f8c4a010          STR      r10,[r4,#0x10]
;;;431    
;;;432    	/* Copy the incoming command to the buffer */
;;;433    	memcpy(cmdnode->cmdbuf, in_cmd, in_cmd_size);//把命令放入到buffer
000046  4632              MOV      r2,r6
000048  4641              MOV      r1,r8
00004a  6960              LDR      r0,[r4,#0x14]
00004c  f7fffffe          BL       __aeabi_memcpy
;;;434    
;;;435    	/* Set sequence number, clean result, move to buffer */
;;;436    	priv->seqnum++;
000050  f8350f74          LDRH     r0,[r5,#0x74]!
000054  1c40              ADDS     r0,r0,#1
000056  8028              STRH     r0,[r5,#0]
;;;437    	cmdnode->cmdbuf->command = cpu_to_le16(command);//具体的命令
000058  6960              LDR      r0,[r4,#0x14]
00005a  8007              STRH     r7,[r0,#0]
;;;438    	cmdnode->cmdbuf->size    = cpu_to_le16(in_cmd_size);//命令长度
00005c  6961              LDR      r1,[r4,#0x14]
00005e  804e              STRH     r6,[r1,#2]
;;;439    	cmdnode->cmdbuf->seqnum  = cpu_to_le16(priv->seqnum);//命令序列号
000060  f8350974          LDRH     r0,[r5],#-0x74
000064  6961              LDR      r1,[r4,#0x14]
000066  8088              STRH     r0,[r1,#4]
;;;440    	cmdnode->cmdbuf->result  = 0;//清除命令结果
000068  2000              MOVS     r0,#0
00006a  6961              LDR      r1,[r4,#0x14]
00006c  80c8              STRH     r0,[r1,#6]
;;;441    
;;;442    	//lbs_deb_host("PREP_CMD: command 0x%04x\n", command);
;;;443    	printf("PREP_CMD: command 0x%04x\n", command);
00006e  4639              MOV      r1,r7
000070  a007              ADR      r0,|L3.144|
000072  f7fffffe          BL       __2printf
;;;444    
;;;445    	cmdnode->cmdwaitqwoken = 0;//当前命令尚未唤醒，主线程完成命令执行以后会将此位置1，用来唤醒本命令继续执行
000076  2000              MOVS     r0,#0
000078  8320              STRH     r0,[r4,#0x18]
;;;446    	lbs_queue_cmd(priv, cmdnode);//提交命令
00007a  4621              MOV      r1,r4
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       lbs_queue_cmd
;;;447    	//wake_up_interruptible(&priv->waitq);//唤醒主服务线程执行命令
;;;448    	lbs_thread(priv);//命令处理阶段
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       lbs_thread
;;;449    	
;;;450    
;;;451     done:
000088  bf00              NOP      
                  |L3.138|
;;;452    	lbs_deb_cmd_leave_args( "ret %p", cmdnode->cmdwaitqwoken);
;;;453    	return cmdnode;
00008a  4620              MOV      r0,r4
;;;454    }
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;455    
                          ENDP

                  |L3.144|
000090  50524550          DCB      "PREP_CMD: command 0x%04x\n",0
000094  5f434d44
000098  3a20636f
00009c  6d6d616e
0000a0  64203078
0000a4  25303478
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.__list_add||, CODE, READONLY, ALIGN=1

                  __list_add PROC
;;;46     #ifndef CONFIG_DEBUG_LIST
;;;47     static __inline void __list_add(struct list_head *new,
000000  6050              STR      r0,[r2,#4]
;;;48     			      struct list_head *prev,
;;;49     			      struct list_head *next)
;;;50     {
;;;51     	next->prev = new;
;;;52     	new->next = next;
000002  6002              STR      r2,[r0,#0]
;;;53     	new->prev = prev;
000004  6041              STR      r1,[r0,#4]
;;;54     	prev->next = new;
000006  6008              STR      r0,[r1,#0]
;;;55     }
000008  4770              BX       lr
;;;56     #else
                          ENDP


                          AREA ||i.clear_wpa_wpa2_info||, CODE, READONLY, ALIGN=1

                  clear_wpa_wpa2_info PROC
;;;2121   
;;;2122   int clear_wpa_wpa2_info(struct lbs_private *priv)
000000  b538              PUSH     {r3-r5,lr}
;;;2123   {
000002  4604              MOV      r4,r0
;;;2124           if (lbs_set_key_material(priv,KEY_TYPE_ID_WEP,2,0,0) != 0)
000004  2300              MOVS     r3,#0
000006  2202              MOVS     r2,#2
000008  4619              MOV      r1,r3
00000a  4620              MOV      r0,r4
00000c  9300              STR      r3,[sp,#0]
00000e  f7fffffe          BL       lbs_set_key_material
000012  b110              CBZ      r0,|L5.26|
;;;2125                   return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L5.24|
;;;2126           if (lbs_set_key_material(priv,KEY_TYPE_ID_WEP,1,0,0) != 0)
;;;2127                   return -1;
;;;2128           return 0;
;;;2129   }
000018  bd38              POP      {r3-r5,pc}
                  |L5.26|
00001a  2300              MOVS     r3,#0                 ;2126
00001c  2201              MOVS     r2,#1                 ;2126
00001e  4619              MOV      r1,r3                 ;2126
000020  4620              MOV      r0,r4                 ;2126
000022  9300              STR      r3,[sp,#0]            ;2126
000024  f7fffffe          BL       lbs_set_key_material
000028  b110              CBZ      r0,|L5.48|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;2127
00002e  e7f3              B        |L5.24|
                  |L5.48|
000030  2000              MOVS     r0,#0                 ;2128
000032  e7f1              B        |L5.24|
;;;2130   
                          ENDP


                          AREA ||i.handle_cmd_response||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  handle_cmd_response PROC
;;;694    
;;;695    static __inline int handle_cmd_response(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;696    				      struct cmd_header *cmd_response)
;;;697    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;698    	struct cmd_ds_command *resp = (struct cmd_ds_command *) cmd_response;
000008  4634              MOV      r4,r6
;;;699    	int ret = 0;
00000a  f04f0800          MOV      r8,#0
;;;700    //	unsigned long flags;
;;;701    	uint16_t respcmd = le16_to_cpu(resp->command);
00000e  8827              LDRH     r7,[r4,#0]
;;;702    
;;;703    	lbs_deb_cmd_enter("enter handle_cmd_response\n");
;;;704    
;;;705    	switch (respcmd) {
000010  f248014e          MOV      r1,#0x804e
000014  1a78              SUBS     r0,r7,r1
000016  428f              CMP      r7,r1
000018  d051              BEQ      |L6.190|
00001a  dc16              BGT      |L6.74|
00001c  f248011f          MOV      r1,#0x801f
000020  eba70001          SUB      r0,r7,r1
000024  428f              CMP      r7,r1
000026  d032              BEQ      |L6.142|
000028  dc08              BGT      |L6.60|
00002a  f5a74000          SUB      r0,r7,#0x8000
00002e  3819              SUBS     r0,r0,#0x19
000030  d01a              BEQ      |L6.104|
000032  2801              CMP      r0,#1
000034  d019              BEQ      |L6.106|
000036  2802              CMP      r0,#2
000038  d172              BNE      |L6.288|
00003a  e017              B        |L6.108|
                  |L6.60|
00003c  281d              CMP      r0,#0x1d
00003e  d01c              BEQ      |L6.122|
000040  281e              CMP      r0,#0x1e
000042  d01b              BEQ      |L6.124|
000044  282a              CMP      r0,#0x2a
000046  d16b              BNE      |L6.288|
000048  e020              B        |L6.140|
                  |L6.74|
00004a  2839              CMP      r0,#0x39
00004c  d047              BEQ      |L6.222|
00004e  dc06              BGT      |L6.94|
000050  280d              CMP      r0,#0xd
000052  d022              BEQ      |L6.154|
000054  2824              CMP      r0,#0x24
000056  d02a              BEQ      |L6.174|
000058  2832              CMP      r0,#0x32
00005a  d161              BNE      |L6.288|
00005c  e038              B        |L6.208|
                  |L6.94|
00005e  2847              CMP      r0,#0x47
000060  d04c              BEQ      |L6.252|
000062  2862              CMP      r0,#0x62
000064  d15c              BNE      |L6.288|
000066  e054              B        |L6.274|
                  |L6.104|
;;;706    	case CMD_RET(CMD_MAC_REG_ACCESS):
;;;707    	case CMD_RET(CMD_BBP_REG_ACCESS):
000068  bf00              NOP      
                  |L6.106|
;;;708    	case CMD_RET(CMD_RF_REG_ACCESS):
00006a  bf00              NOP      
                  |L6.108|
;;;709    		ret = lbs_ret_reg_access(priv, respcmd, resp);//读取mac、baseband、rf寄存器的值
00006c  4622              MOV      r2,r4
00006e  4639              MOV      r1,r7
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       lbs_ret_reg_access
000076  4680              MOV      r8,r0
;;;710    		break;
000078  e057              B        |L6.298|
                  |L6.122|
;;;711    
;;;712    	case CMD_RET(CMD_802_11_SET_AFC):
;;;713    	case CMD_RET(CMD_802_11_GET_AFC):
00007a  bf00              NOP      
                  |L6.124|
;;;714    		//spin_lock_irqsave(&priv->driver_lock, flags);
;;;715    		memmove((void *)priv->cur_cmd->callback_arg, &resp->params.afc,
00007c  6fe9              LDR      r1,[r5,#0x7c]
00007e  2206              MOVS     r2,#6
000080  6908              LDR      r0,[r1,#0x10]
000082  f1040108          ADD      r1,r4,#8
000086  f7fffffe          BL       __aeabi_memmove
;;;716    			sizeof(struct cmd_ds_802_11_afc));//将返回的内容传递回回调函数
;;;717    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;718    
;;;719    		break;
00008a  e04e              B        |L6.298|
                  |L6.140|
;;;720    
;;;721    	case CMD_RET(CMD_802_11_BEACON_STOP):
;;;722    		break;
00008c  e04d              B        |L6.298|
                  |L6.142|
;;;723    
;;;724    	case CMD_RET(CMD_802_11_RSSI):
;;;725    		ret = lbs_ret_802_11_rssi(priv, resp);
00008e  4621              MOV      r1,r4
000090  4628              MOV      r0,r5
000092  f7fffffe          BL       lbs_ret_802_11_rssi
000096  4680              MOV      r8,r0
;;;726    		break;
000098  e047              B        |L6.298|
                  |L6.154|
;;;727    
;;;728    	case CMD_RET(CMD_802_11D_DOMAIN_INFO):
;;;729    		//ret = lbs_ret_802_11d_domain_info(resp);
;;;730    		pr_err("failed CMD_802_11D_DOMAIN_INFO\n");
00009a  a026              ADR      r0,|L6.308|
00009c  f7fffffe          BL       __2printf
;;;731    		while(1){
0000a0  e002              B        |L6.168|
                  |L6.162|
;;;732    			if(CMD_802_11D_DOMAIN_INFO!=respcmd)
0000a2  2f5b              CMP      r7,#0x5b
0000a4  d000              BEQ      |L6.168|
;;;733    				break;//this is a bug
0000a6  e000              B        |L6.170|
                  |L6.168|
0000a8  e7fb              B        |L6.162|
                  |L6.170|
0000aa  bf00              NOP      
;;;734    		}
;;;735    		break;
0000ac  e03d              B        |L6.298|
                  |L6.174|
;;;736    
;;;737    	case CMD_RET(CMD_802_11_TPC_CFG):
;;;738    		//spin_lock_irqsave(&priv->driver_lock, flags);
;;;739    		memmove((void *)priv->cur_cmd->callback_arg, &resp->params.tpccfg,
0000ae  6fe9              LDR      r1,[r5,#0x7c]
0000b0  220f              MOVS     r2,#0xf
0000b2  6908              LDR      r0,[r1,#0x10]
0000b4  f1040108          ADD      r1,r4,#8
0000b8  f7fffffe          BL       __aeabi_memmove
;;;740    			sizeof(struct cmd_ds_802_11_tpc_cfg));
;;;741    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;742    		break;
0000bc  e035              B        |L6.298|
                  |L6.190|
;;;743    	case CMD_RET(CMD_802_11_LED_GPIO_CTRL):
;;;744    		//spin_lock_irqsave(&priv->driver_lock, flags);
;;;745    		memmove((void *)priv->cur_cmd->callback_arg, &resp->params.ledgpio,
0000be  6fe9              LDR      r1,[r5,#0x7c]
0000c0  f44f7282          MOV      r2,#0x104
0000c4  6908              LDR      r0,[r1,#0x10]
0000c6  f1040108          ADD      r1,r4,#8
0000ca  f7fffffe          BL       __aeabi_memmove
;;;746    			sizeof(struct cmd_ds_802_11_led_ctrl));
;;;747    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;748    		break;
0000ce  e02c              B        |L6.298|
                  |L6.208|
;;;749    
;;;750    	case CMD_RET(CMD_GET_TSF):
;;;751    		//spin_lock_irqsave(&priv->driver_lock, flags);
;;;752    		memcpy((void *)priv->cur_cmd->callback_arg,
0000d0  6fe8              LDR      r0,[r5,#0x7c]
0000d2  6900              LDR      r0,[r0,#0x10]
0000d4  68a1              LDR      r1,[r4,#8]
0000d6  6001              STR      r1,[r0,#0]
0000d8  68e1              LDR      r1,[r4,#0xc]
0000da  6041              STR      r1,[r0,#4]
;;;753    		       (const void *)(__le16 *)&resp->params.gettsf.tsfvalue, sizeof(u64));
;;;754    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;755    		break;
0000dc  e025              B        |L6.298|
                  |L6.222|
;;;756    	case CMD_RET(CMD_BT_ACCESS):
;;;757    		//spin_lock_irqsave(&priv->driver_lock, flags);
;;;758    		if (priv->cur_cmd->callback_arg)
0000de  6fe8              LDR      r0,[r5,#0x7c]
0000e0  6900              LDR      r0,[r0,#0x10]
0000e2  b150              CBZ      r0,|L6.250|
;;;759    			memcpy((void *)priv->cur_cmd->callback_arg,
0000e4  6fe8              LDR      r0,[r5,#0x7c]
0000e6  6901              LDR      r1,[r0,#0x10]
0000e8  f8d4200e          LDR      r2,[r4,#0xe]
0000ec  600a              STR      r2,[r1,#0]
0000ee  f8d42012          LDR      r2,[r4,#0x12]
0000f2  604a              STR      r2,[r1,#4]
0000f4  f8d40016          LDR      r0,[r4,#0x16]
0000f8  6088              STR      r0,[r1,#8]
                  |L6.250|
;;;760    			       &resp->params.bt.addr1, 2 * ETH_ALEN);
;;;761    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;762    		break;
0000fa  e016              B        |L6.298|
                  |L6.252|
;;;763    	case CMD_RET(CMD_FWT_ACCESS):
;;;764    		//spin_lock_irqsave(&priv->driver_lock, flags);
;;;765    		if (priv->cur_cmd->callback_arg)
0000fc  6fe8              LDR      r0,[r5,#0x7c]
0000fe  6900              LDR      r0,[r0,#0x10]
000100  b130              CBZ      r0,|L6.272|
;;;766    			memcpy((void *)priv->cur_cmd->callback_arg, &resp->params.fwt,
000102  6fe9              LDR      r1,[r5,#0x7c]
000104  2236              MOVS     r2,#0x36
000106  6908              LDR      r0,[r1,#0x10]
000108  f1040108          ADD      r1,r4,#8
00010c  f7fffffe          BL       __aeabi_memcpy
                  |L6.272|
;;;767    			       sizeof(resp->params.fwt));
;;;768    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;769    		break;
000110  e00b              B        |L6.298|
                  |L6.274|
;;;770    	case CMD_RET(CMD_802_11_BEACON_CTRL):
;;;771    		ret = lbs_ret_802_11_bcn_ctrl(priv, resp);
000112  4621              MOV      r1,r4
000114  4628              MOV      r0,r5
000116  f7fffffe          BL       lbs_ret_802_11_bcn_ctrl
00011a  4680              MOV      r8,r0
;;;772    		break;
00011c  e005              B        |L6.298|
00011e  e7ff              B        |L6.288|
                  |L6.288|
;;;773    
;;;774    	default:
;;;775    		lbs_pr_err("CMD_RESP: unknown cmd response 0x%04x\n",
000120  8821              LDRH     r1,[r4,#0]
000122  a00c              ADR      r0,|L6.340|
000124  f7fffffe          BL       __2printf
;;;776    			   le16_to_cpu(resp->command));
;;;777    		break;
000128  bf00              NOP      
                  |L6.298|
00012a  bf00              NOP                            ;710
;;;778    	}
;;;779    	 lbs_deb_cmd_leave(LBS_DEB_HOST);
;;;780    	return ret;
00012c  4640              MOV      r0,r8
;;;781    }
00012e  e8bd81f0          POP      {r4-r8,pc}
;;;782    
                          ENDP

000132  0000              DCW      0x0000
                  |L6.308|
000134  6661696c          DCB      "failed CMD_802_11D_DOMAIN_INFO\n",0
000138  65642043
00013c  4d445f38
000140  30325f31
000144  31445f44
000148  4f4d4149
00014c  4e5f494e
000150  464f0a00
                  |L6.340|
000154  434d445f          DCB      "CMD_RESP: unknown cmd response 0x%04x\n",0
000158  52455350
00015c  3a20756e
000160  6b6e6f77
000164  6e20636d
000168  64207265
00016c  73706f6e
000170  73652030
000174  78253034
000178  780a00  
00017b  00                DCB      0

                          AREA ||i.is_command_allowed_in_ps||, CODE, READONLY, ALIGN=1

                  is_command_allowed_in_ps PROC
;;;16      */
;;;17     static u8 is_command_allowed_in_ps(u16 cmd)
000000  4601              MOV      r1,r0
;;;18     {
;;;19     	switch (cmd) {
000002  291f              CMP      r1,#0x1f
000004  d101              BNE      |L7.10|
;;;20     	case CMD_802_11_RSSI:
;;;21     		return 1;
000006  2001              MOVS     r0,#1
                  |L7.8|
;;;22     	default:
;;;23     		break;
;;;24     	}
;;;25     	return 0;
;;;26     }
000008  4770              BX       lr
                  |L7.10|
00000a  bf00              NOP                            ;23
00000c  bf00              NOP                            ;23
00000e  2000              MOVS     r0,#0                 ;25
000010  e7fa              B        |L7.8|
;;;27     
                          ENDP


                          AREA ||i.lbs_allocate_cmd_buffer||, CODE, READONLY, ALIGN=2

                  lbs_allocate_cmd_buffer PROC
;;;171     */
;;;172    int lbs_allocate_cmd_buffer(struct lbs_private *priv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;173    {
000004  4606              MOV      r6,r0
;;;174    	int ret = 0;
000006  2700              MOVS     r7,#0
;;;175    	u32 bufsize;
;;;176    	u32 i;
;;;177    	/*这里把cmdarray的数量做少点1个，因为它占用内存过大，一个cmdbuffer占用2K的内存*/
;;;178    	static u8 gmarvel_cmdarray[sizeof(struct cmd_ctrl_node) * LBS_NUM_CMD_BUFFERS];
;;;179    	static u8 gmarvel_cmdbuffer[LBS_NUM_CMD_BUFFERS][LBS_CMD_BUFFER_SIZE];
;;;180    	struct cmd_ctrl_node *cmdarray;
;;;181    
;;;182    	lbs_deb_cmd_enter("enter lbs_allocate_cmd_buffer\n");
;;;183    
;;;184    	/* Allocate and initialize the command array */
;;;185    	bufsize = sizeof(struct cmd_ctrl_node) * LBS_NUM_CMD_BUFFERS;//命令控制块结构
000008  f04f081c          MOV      r8,#0x1c
;;;186    	/*if (!(cmdarray = kzalloc(bufsize, GFP_KERNEL))) {
;;;187    		lbs_deb_host("ALLOC_CMD_BUF: tempcmd_array is NULL\n");
;;;188    		ret = -1;
;;;189    		goto done;
;;;190    	}*/
;;;191    	cmdarray=(struct cmd_ctrl_node *)gmarvel_cmdarray;
00000c  4d15              LDR      r5,|L8.100|
;;;192    	memset(cmdarray,0,bufsize);//这是cmd_ctrl_node结构的存放地，后面会在这个里面来取
00000e  4641              MOV      r1,r8
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       __aeabi_memclr4
;;;193    	
;;;194    	priv->cmd_array = cmdarray;
000016  67b5              STR      r5,[r6,#0x78]
;;;195    
;;;196    	/* Allocate and initialize each command buffer in the command array */
;;;197    	for (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {
000018  2400              MOVS     r4,#0
00001a  e011              B        |L8.64|
                  |L8.28|
;;;198    		 /*cmdarray[i].cmdbuf = kzalloc(LBS_CMD_BUFFER_SIZE, GFP_KERNEL);//命令参数存放地
;;;199    		if (!cmdarray[i].cmdbuf) {
;;;200    			lbs_deb_host("ALLOC_CMD_BUF: ptempvirtualaddr is NULL\n");
;;;201    			ret = -1;
;;;202    			goto done;
;;;203    		}*/
;;;204    		cmdarray[i].cmdbuf=(struct cmd_header *)&gmarvel_cmdbuffer[i][0];
00001c  4812              LDR      r0,|L8.104|
00001e  eb002084          ADD      r0,r0,r4,LSL #10
000022  ebc401c4          RSB      r1,r4,r4,LSL #3
000026  eb050181          ADD      r1,r5,r1,LSL #2
00002a  6148              STR      r0,[r1,#0x14]
;;;205    		memset(cmdarray[i].cmdbuf,0,LBS_CMD_BUFFER_SIZE);
00002c  ebc401c4          RSB      r1,r4,r4,LSL #3
000030  eb050181          ADD      r1,r5,r1,LSL #2
000034  6948              LDR      r0,[r1,#0x14]
000036  f44f6180          MOV      r1,#0x400
00003a  f7fffffe          BL       __aeabi_memclr
00003e  1c64              ADDS     r4,r4,#1              ;197
                  |L8.64|
000040  2c00              CMP      r4,#0                 ;197
000042  d0eb              BEQ      |L8.28|
;;;206    	}
;;;207    
;;;208    	for (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {
000044  2400              MOVS     r4,#0
000046  e007              B        |L8.88|
                  |L8.72|
;;;209    		//init_waitqueue_head(&cmdarray[i].cmdwait_q);//初始化等待队列头，主服务线程可能在上面睡眠
;;;210    		lbs_cleanup_and_insert_cmd(priv, &cmdarray[i]);//初始化空闲链表
000048  ebc400c4          RSB      r0,r4,r4,LSL #3
00004c  eb050180          ADD      r1,r5,r0,LSL #2
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       lbs_cleanup_and_insert_cmd
000056  1c64              ADDS     r4,r4,#1              ;208
                  |L8.88|
000058  2c00              CMP      r4,#0                 ;208
00005a  d0f5              BEQ      |L8.72|
;;;211    	}
;;;212    	ret = 0;
00005c  2700              MOVS     r7,#0
;;;213    //done:
;;;214    	lbs_deb_cmd_leave_args("leave lbs_allocate_cmd_buffer(ret=%d)\n", ret);
;;;215    	return ret;
00005e  4638              MOV      r0,r7
;;;216    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;217    
                          ENDP

                  |L8.100|
                          DCD      gmarvel_cmdarray
                  |L8.104|
                          DCD      gmarvel_cmdbuffer

                          AREA ||i.lbs_cleanup_and_insert_cmd||, CODE, READONLY, ALIGN=1

                  lbs_cleanup_and_insert_cmd PROC
;;;47     
;;;48     static void lbs_cleanup_and_insert_cmd(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;49     	struct cmd_ctrl_node *ptempcmd)
;;;50     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;51     //	unsigned long flags;
;;;52     
;;;53     	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;54     	__lbs_cleanup_and_insert_cmd(priv, ptempcmd);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __lbs_cleanup_and_insert_cmd
;;;55     	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;56     }
00000e  bd70              POP      {r4-r6,pc}
;;;57     
                          ENDP


                          AREA ||i.lbs_cmd_802_11_enable_rsn||, CODE, READONLY, ALIGN=1

                  lbs_cmd_802_11_enable_rsn PROC
;;;1752   
;;;1753   int lbs_cmd_802_11_enable_rsn(struct lbs_private *priv, uint16_t cmd_action,
000000  b5fe              PUSH     {r1-r7,lr}
;;;1754   			      uint16_t *enable)
;;;1755   {
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1756   	struct cmd_ds_802_11_enable_rsn cmd;
;;;1757   	int ret;
;;;1758   
;;;1759   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1760   
;;;1761   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000008  200c              MOVS     r0,#0xc
00000a  f8ad0002          STRH     r0,[sp,#2]
;;;1762   	cmd.action = cpu_to_le16(cmd_action);
00000e  f8ad4008          STRH     r4,[sp,#8]
;;;1763   
;;;1764   	if (cmd_action == CMD_ACT_GET)
000012  b91c              CBNZ     r4,|L10.28|
;;;1765   		cmd.enable = 0;
000014  2000              MOVS     r0,#0
000016  f8ad000a          STRH     r0,[sp,#0xa]
00001a  e008              B        |L10.46|
                  |L10.28|
;;;1766   	else {
;;;1767   		if (*enable)
00001c  8828              LDRH     r0,[r5,#0]
00001e  b118              CBZ      r0,|L10.40|
;;;1768   			cmd.enable = cpu_to_le16(CMD_ENABLE_RSN);
000020  2001              MOVS     r0,#1
000022  f8ad000a          STRH     r0,[sp,#0xa]
000026  e002              B        |L10.46|
                  |L10.40|
;;;1769   		else
;;;1770   			cmd.enable = cpu_to_le16(CMD_DISABLE_RSN);
000028  2000              MOVS     r0,#0
00002a  f8ad000a          STRH     r0,[sp,#0xa]
                  |L10.46|
;;;1771   		lbs_deb_cmd("ENABLE_RSN: %d\n", *enable);
;;;1772   	}
;;;1773   
;;;1774   	ret = lbs_cmd_with_response(priv, CMD_802_11_ENABLE_RSN, &cmd);
00002e  466a              MOV      r2,sp
000030  212f              MOVS     r1,#0x2f
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       lbs_cmd_with_response
000038  4606              MOV      r6,r0
;;;1775   	if (!ret && cmd_action == CMD_ACT_GET)
00003a  b91e              CBNZ     r6,|L10.68|
00003c  b914              CBNZ     r4,|L10.68|
;;;1776   		*enable = le16_to_cpu(cmd.enable);
00003e  f8bd000a          LDRH     r0,[sp,#0xa]
000042  8028              STRH     r0,[r5,#0]
                  |L10.68|
;;;1777   
;;;1778   	lbs_deb_cmd_leave_args(LBS_DEB_CMD, ret);
;;;1779   	return ret;
000044  4630              MOV      r0,r6
;;;1780   }
000046  bdfe              POP      {r1-r7,pc}
;;;1781   static void set_one_wpa_key(struct MrvlIEtype_keyParamSet *keyparam,
                          ENDP


                          AREA ||i.lbs_cmd_802_11_key_material||, CODE, READONLY, ALIGN=1

                  lbs_cmd_802_11_key_material PROC
;;;1802   
;;;1803   int lbs_cmd_802_11_key_material(struct lbs_private *priv, uint16_t cmd_action,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1804   				struct assoc_request *assoc)
;;;1805   {
000004  b09f              SUB      sp,sp,#0x7c
000006  4682              MOV      r10,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
;;;1806   	struct cmd_ds_802_11_key_material cmd;
;;;1807   	int ret = 0;
00000c  2000              MOVS     r0,#0
00000e  9006              STR      r0,[sp,#0x18]
;;;1808   	int index = 0;
000010  2700              MOVS     r7,#0
;;;1809   
;;;1810   	lbs_deb_enter(LBS_DEB_CMD);
;;;1811   
;;;1812   	cmd.action = cpu_to_le16(cmd_action);
000012  f8ad8024          STRH     r8,[sp,#0x24]
;;;1813   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000016  205e              MOVS     r0,#0x5e
000018  f8ad001e          STRH     r0,[sp,#0x1e]
;;;1814   
;;;1815   	if (cmd_action == CMD_ACT_GET) {
00001c  f1b80f00          CMP      r8,#0
000020  d103              BNE      |L11.42|
;;;1816   		cmd.hdr.size = cpu_to_le16(S_DS_GEN + 2);
000022  200e              MOVS     r0,#0xe
000024  f8ad001e          STRH     r0,[sp,#0x1e]
000028  e032              B        |L11.144|
                  |L11.42|
;;;1817   	} else {
;;;1818   		memset(cmd.keyParamSet, 0, sizeof(cmd.keyParamSet));
00002a  2154              MOVS     r1,#0x54
00002c  f10d0026          ADD      r0,sp,#0x26
000030  f7fffffe          BL       __aeabi_memclr
;;;1819   
;;;1820   		if (test_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc->flags)) {
000034  4649              MOV      r1,r9
000036  2009              MOVS     r0,#9
000038  f7fffffe          BL       test_bit
00003c  b160              CBZ      r0,|L11.88|
;;;1821   			set_one_wpa_key(&cmd.keyParamSet[index],
00003e  ebc701c7          RSB      r1,r7,r7,LSL #3
000042  eb010241          ADD      r2,r1,r1,LSL #1
000046  f10d0126          ADD      r1,sp,#0x26
00004a  eb010042          ADD      r0,r1,r2,LSL #1
00004e  f10901f0          ADD      r1,r9,#0xf0
000052  f7fffffe          BL       set_one_wpa_key
;;;1822   					&assoc->wpa_unicast_key);
;;;1823   			index++;
000056  1c7f              ADDS     r7,r7,#1
                  |L11.88|
;;;1824   		}
;;;1825   
;;;1826   		if (test_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc->flags)) {
000058  4649              MOV      r1,r9
00005a  2008              MOVS     r0,#8
00005c  f7fffffe          BL       test_bit
000060  b160              CBZ      r0,|L11.124|
;;;1827   			set_one_wpa_key(&cmd.keyParamSet[index],
000062  ebc701c7          RSB      r1,r7,r7,LSL #3
000066  eb010241          ADD      r2,r1,r1,LSL #1
00006a  f10d0126          ADD      r1,sp,#0x26
00006e  eb010042          ADD      r0,r1,r2,LSL #1
000072  f10901ca          ADD      r1,r9,#0xca
000076  f7fffffe          BL       set_one_wpa_key
;;;1828   					&assoc->wpa_mcast_key);
;;;1829   			index++;
00007a  1c7f              ADDS     r7,r7,#1
                  |L11.124|
;;;1830   		}
;;;1831   
;;;1832   		/* The common header and as many keys as we included */
;;;1833   		cmd.hdr.size = cpu_to_le16(offsetof(struct cmd_ds_802_11_key_material,//(cmd),
00007c  200a              MOVS     r0,#0xa
00007e  ebc701c7          RSB      r1,r7,r7,LSL #3
000082  eb010141          ADD      r1,r1,r1,LSL #1
000086  eb000041          ADD      r0,r0,r1,LSL #1
00008a  b280              UXTH     r0,r0
00008c  f8ad001e          STRH     r0,[sp,#0x1e]
                  |L11.144|
;;;1834   						    keyParamSet[index]));
;;;1835   	}
;;;1836   	ret = lbs_cmd_with_response(priv, CMD_802_11_KEY_MATERIAL, &cmd);
000090  aa07              ADD      r2,sp,#0x1c
000092  215e              MOVS     r1,#0x5e
000094  4650              MOV      r0,r10
000096  f7fffffe          BL       lbs_cmd_with_response
00009a  9006              STR      r0,[sp,#0x18]
;;;1837   	/* Copy the returned key to driver private data */
;;;1838   	if (!ret && cmd_action == CMD_ACT_GET) {
00009c  9806              LDR      r0,[sp,#0x18]
00009e  bb78              CBNZ     r0,|L11.256|
0000a0  f1b80f00          CMP      r8,#0
0000a4  d141              BNE      |L11.298|
;;;1839   		void *buf_ptr = cmd.keyParamSet;
0000a6  f10d0526          ADD      r5,sp,#0x26
;;;1840   		void *resp_end = &(&cmd)[1];
0000aa  f10d007a          ADD      r0,sp,#0x7a
0000ae  9005              STR      r0,[sp,#0x14]
;;;1841   
;;;1842   		while (buf_ptr < resp_end) {
0000b0  e036              B        |L11.288|
                  |L11.178|
;;;1843   			struct MrvlIEtype_keyParamSet *keyparam = buf_ptr;
0000b2  462e              MOV      r6,r5
;;;1844   			struct enc_key *key;
;;;1845   			uint16_t param_set_len = le16_to_cpu(keyparam->length);
0000b4  8870              LDRH     r0,[r6,#2]
0000b6  9004              STR      r0,[sp,#0x10]
;;;1846   			uint16_t key_len = le16_to_cpu(keyparam->keylen);
0000b8  8930              LDRH     r0,[r6,#8]
0000ba  9003              STR      r0,[sp,#0xc]
;;;1847   			uint16_t key_flags = le16_to_cpu(keyparam->keyinfo);
0000bc  f8b6b006          LDRH     r11,[r6,#6]
;;;1848   			uint16_t key_type = le16_to_cpu(keyparam->keytypeid);
0000c0  88b0              LDRH     r0,[r6,#4]
0000c2  9002              STR      r0,[sp,#8]
;;;1849   			char *end;
;;;1850   
;;;1851   			end =(char *)keyparam + sizeof(keyparam->type)
0000c4  1d30              ADDS     r0,r6,#4
0000c6  9904              LDR      r1,[sp,#0x10]
0000c8  4408              ADD      r0,r0,r1
0000ca  9001              STR      r0,[sp,#4]
;;;1852   				+ sizeof(keyparam->length) + param_set_len;
;;;1853   
;;;1854   			/* Make sure we don't access past the end of the IEs */
;;;1855   			if (end > resp_end)
0000cc  9905              LDR      r1,[sp,#0x14]
0000ce  9801              LDR      r0,[sp,#4]
0000d0  4288              CMP      r0,r1
0000d2  d900              BLS      |L11.214|
;;;1856   				break;
0000d4  e027              B        |L11.294|
                  |L11.214|
;;;1857   
;;;1858   			if (key_flags & KEY_INFO_WPA_UNICAST)
0000d6  f01b0f02          TST      r11,#2
0000da  d002              BEQ      |L11.226|
;;;1859   				key = &priv->wpa_unicast_key;
0000dc  f50a7432          ADD      r4,r10,#0x2c8
0000e0  e006              B        |L11.240|
                  |L11.226|
;;;1860   			else if (key_flags & KEY_INFO_WPA_MCAST)
0000e2  f01b0f01          TST      r11,#1
0000e6  d002              BEQ      |L11.238|
;;;1861   				key = &priv->wpa_mcast_key;
0000e8  f20a24a2          ADD      r4,r10,#0x2a2
0000ec  e000              B        |L11.240|
                  |L11.238|
;;;1862   			else
;;;1863   				break;
0000ee  e01a              B        |L11.294|
                  |L11.240|
;;;1864   
;;;1865   			/* Copy returned key into driver */
;;;1866   			memset(key, 0, sizeof(struct enc_key));
0000f0  2126              MOVS     r1,#0x26
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       __aeabi_memclr
;;;1867   			if (key_len > sizeof(key->key))
0000f8  9803              LDR      r0,[sp,#0xc]
0000fa  2820              CMP      r0,#0x20
0000fc  d901              BLS      |L11.258|
;;;1868   				break;
0000fe  e012              B        |L11.294|
                  |L11.256|
000100  e013              B        |L11.298|
                  |L11.258|
;;;1869   			key->type = key_type;
000102  9802              LDR      r0,[sp,#8]
000104  80a0              STRH     r0,[r4,#4]
;;;1870   			key->flags = key_flags;
000106  f8a4b002          STRH     r11,[r4,#2]
;;;1871   			key->len = key_len;
00010a  9803              LDR      r0,[sp,#0xc]
00010c  8020              STRH     r0,[r4,#0]
;;;1872   			memcpy(key->key, keyparam->key, key->len);
00010e  8822              LDRH     r2,[r4,#0]
000110  f106010a          ADD      r1,r6,#0xa
000114  1da0              ADDS     r0,r4,#6
000116  f7fffffe          BL       __aeabi_memcpy
;;;1873   
;;;1874   			buf_ptr = (void *)(end + 1);
00011a  9801              LDR      r0,[sp,#4]
00011c  1c45              ADDS     r5,r0,#1
;;;1875   		}
00011e  bf00              NOP      
                  |L11.288|
000120  9805              LDR      r0,[sp,#0x14]         ;1842
000122  4285              CMP      r5,r0                 ;1842
000124  d3c5              BCC      |L11.178|
                  |L11.294|
000126  bf00              NOP                            ;1856
;;;1876   	}
000128  bf00              NOP      
                  |L11.298|
;;;1877   
;;;1878   	//lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
;;;1879   	return ret;
00012a  9806              LDR      r0,[sp,#0x18]
;;;1880   }
00012c  b01f              ADD      sp,sp,#0x7c
00012e  e8bd8ff0          POP      {r4-r11,pc}
;;;1881   
                          ENDP


                          AREA ||i.lbs_cmd_802_11_monitor_mode||, CODE, READONLY, ALIGN=1

                  lbs_cmd_802_11_monitor_mode PROC
;;;1251   
;;;1252   static int lbs_cmd_802_11_monitor_mode(struct cmd_ds_command *cmd,
000000  b510              PUSH     {r4,lr}
;;;1253   				      u16 cmd_action, void *pdata_buf)
;;;1254   {
000002  4603              MOV      r3,r0
;;;1255   	struct cmd_ds_802_11_monitor_mode *monitor = &cmd->params.monitor;
000004  f1030408          ADD      r4,r3,#8
;;;1256   
;;;1257   	cmd->command = cpu_to_le16(CMD_802_11_MONITOR_MODE);
000008  2098              MOVS     r0,#0x98
00000a  8018              STRH     r0,[r3,#0]
;;;1258   	cmd->size =
00000c  2010              MOVS     r0,#0x10
00000e  8058              STRH     r0,[r3,#2]
;;;1259   	    cpu_to_le16(sizeof(struct cmd_ds_802_11_monitor_mode) +
;;;1260   			     S_DS_GEN);
;;;1261   
;;;1262   	monitor->action = cpu_to_le16(cmd_action);
000010  8021              STRH     r1,[r4,#0]
;;;1263   	if (cmd_action == CMD_ACT_SET) {
000012  2901              CMP      r1,#1
000014  d101              BNE      |L12.26|
;;;1264   		monitor->mode =
000016  6810              LDR      r0,[r2,#0]
000018  8060              STRH     r0,[r4,#2]
                  |L12.26|
;;;1265   		    cpu_to_le16((u16) (*(u32 *) pdata_buf));
;;;1266   	}
;;;1267   
;;;1268   	return 0;
00001a  2000              MOVS     r0,#0
;;;1269   }
00001c  bd10              POP      {r4,pc}
;;;1270   
                          ENDP


                          AREA ||i.lbs_cmd_802_11_ps_mode||, CODE, READONLY, ALIGN=1

                  lbs_cmd_802_11_ps_mode PROC
;;;1130   
;;;1131   static int lbs_cmd_802_11_ps_mode(struct cmd_ds_command *cmd,
000000  4602              MOV      r2,r0
;;;1132   				   u16 cmd_action)
;;;1133   {
000002  460b              MOV      r3,r1
;;;1134   	struct cmd_ds_802_11_ps_mode *psm = &cmd->params.psmode;
000004  f1020108          ADD      r1,r2,#8
;;;1135   
;;;1136   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1137   
;;;1138   	cmd->command = cpu_to_le16(CMD_802_11_PS_MODE);
000008  2021              MOVS     r0,#0x21
00000a  8010              STRH     r0,[r2,#0]
;;;1139   	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_ps_mode) +
00000c  2016              MOVS     r0,#0x16
00000e  8050              STRH     r0,[r2,#2]
;;;1140   				S_DS_GEN);
;;;1141   	psm->action = cpu_to_le16(cmd_action);
000010  800b              STRH     r3,[r1,#0]
;;;1142   	psm->multipledtim = 0;
000012  2000              MOVS     r0,#0
000014  8088              STRH     r0,[r1,#4]
;;;1143   	switch (cmd_action) {
000016  2b30              CMP      r3,#0x30
000018  d004              BEQ      |L13.36|
00001a  2b31              CMP      r3,#0x31
00001c  d008              BEQ      |L13.48|
00001e  2b34              CMP      r3,#0x34
000020  d108              BNE      |L13.52|
000022  e006              B        |L13.50|
                  |L13.36|
;;;1144   	case CMD_SUBCMD_ENTER_PS:
;;;1145   		lbs_deb_cmd("PS command:" "SubCode- Enter PS\n");
;;;1146   
;;;1147   		psm->locallisteninterval = 0;
000024  2000              MOVS     r0,#0
000026  8108              STRH     r0,[r1,#8]
;;;1148   		psm->nullpktinterval = 0;
000028  8048              STRH     r0,[r1,#2]
;;;1149   		psm->multipledtim =
00002a  2001              MOVS     r0,#1
00002c  8088              STRH     r0,[r1,#4]
;;;1150   		    cpu_to_le16(MRVDRV_DEFAULT_MULTIPLE_DTIM);
;;;1151   		break;
00002e  e002              B        |L13.54|
                  |L13.48|
;;;1152   
;;;1153   	case CMD_SUBCMD_EXIT_PS:
;;;1154   		lbs_deb_cmd("PS command:" "SubCode- Exit PS\n");
;;;1155   		break;
000030  e001              B        |L13.54|
                  |L13.50|
;;;1156   
;;;1157   	case CMD_SUBCMD_SLEEP_CONFIRMED:
;;;1158   		lbs_deb_cmd("PS command: SubCode- sleep confirm\n");
;;;1159   		break;
000032  e000              B        |L13.54|
                  |L13.52|
;;;1160   
;;;1161   	default:
;;;1162   		break;
000034  bf00              NOP      
                  |L13.54|
000036  bf00              NOP                            ;1151
;;;1163   	}
;;;1164   
;;;1165   	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;1166   	return 0;
000038  2000              MOVS     r0,#0
;;;1167   }
00003a  4770              BX       lr
;;;1168   
                          ENDP


                          AREA ||i.lbs_cmd_802_11_rssi||, CODE, READONLY, ALIGN=1

                  lbs_cmd_802_11_rssi PROC
;;;1275   
;;;1276   static int lbs_cmd_802_11_rssi(struct lbs_private *priv,
000000  4602              MOV      r2,r0
;;;1277   				struct cmd_ds_command *cmd)
;;;1278   {
;;;1279   
;;;1280   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1281   	cmd->command = cpu_to_le16(CMD_802_11_RSSI);
000002  201f              MOVS     r0,#0x1f
000004  8008              STRH     r0,[r1,#0]
;;;1282   	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_rssi) + S_DS_GEN);
000006  2014              MOVS     r0,#0x14
000008  8048              STRH     r0,[r1,#2]
;;;1283   	cmd->params.rssi.N = cpu_to_le16(DEFAULT_BCN_AVG_FACTOR);
00000a  2008              MOVS     r0,#8
00000c  8108              STRH     r0,[r1,#8]
;;;1284   
;;;1285   	/* reset Beacon SNR/NF/RSSI values */
;;;1286   	priv->SNR[TYPE_BEACON][TYPE_NOAVG] = 0;
00000e  2000              MOVS     r0,#0
000010  f8a202ee          STRH     r0,[r2,#0x2ee]
;;;1287   	priv->SNR[TYPE_BEACON][TYPE_AVG] = 0;
000014  2300              MOVS     r3,#0
000016  f44f703c          MOV      r0,#0x2f0
00001a  5283              STRH     r3,[r0,r2]
;;;1288   	priv->NF[TYPE_BEACON][TYPE_NOAVG] = 0;
00001c  2000              MOVS     r0,#0
00001e  f8a202f6          STRH     r0,[r2,#0x2f6]
;;;1289   	priv->NF[TYPE_BEACON][TYPE_AVG] = 0;
000022  f44f703e          MOV      r0,#0x2f8
000026  5283              STRH     r3,[r0,r2]
;;;1290   	priv->RSSI[TYPE_BEACON][TYPE_NOAVG] = 0;
000028  2000              MOVS     r0,#0
00002a  f88202fe          STRB     r0,[r2,#0x2fe]
;;;1291   	priv->RSSI[TYPE_BEACON][TYPE_AVG] = 0;
00002e  f24020ff          MOV      r0,#0x2ff
000032  5483              STRB     r3,[r0,r2]
;;;1292   
;;;1293   	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;1294   	return 0;
000034  2000              MOVS     r0,#0
;;;1295   }
000036  4770              BX       lr
;;;1296   
                          ENDP


                          AREA ||i.lbs_cmd_802_11_set_wep||, CODE, READONLY, ALIGN=1

                  lbs_cmd_802_11_set_wep PROC
;;;1688   
;;;1689   int lbs_cmd_802_11_set_wep(struct lbs_private *priv, uint16_t cmd_action,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1690   			   struct assoc_request *assoc)
;;;1691   {
000004  b095              SUB      sp,sp,#0x54
000006  4680              MOV      r8,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;1692   	struct cmd_ds_802_11_set_wep cmd;
;;;1693   	int ret = 0;
00000c  f04f0900          MOV      r9,#0
;;;1694   
;;;1695   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1696   
;;;1697   	memset(&cmd, 0, sizeof(cmd));
000010  2150              MOVS     r1,#0x50
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       __aeabi_memclr4
;;;1698   	cmd.hdr.command = cpu_to_le16(CMD_802_11_SET_WEP);
000018  2013              MOVS     r0,#0x13
00001a  f8ad0004          STRH     r0,[sp,#4]
;;;1699   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
00001e  2050              MOVS     r0,#0x50
000020  f8ad0006          STRH     r0,[sp,#6]
;;;1700   
;;;1701   	cmd.action = cpu_to_le16(cmd_action);
000024  f8ad600c          STRH     r6,[sp,#0xc]
;;;1702   
;;;1703   	if (cmd_action == CMD_ACT_ADD) {
000028  2e02              CMP      r6,#2
00002a  d135              BNE      |L15.152|
;;;1704   		int i;
;;;1705   
;;;1706   		/* default tx key index */
;;;1707   		cmd.keyindex = cpu_to_le16(assoc->wep_tx_keyidx &
00002c  f8b700c8          LDRH     r0,[r7,#0xc8]
000030  f3c0000d          UBFX     r0,r0,#0,#14
000034  f8ad000e          STRH     r0,[sp,#0xe]
;;;1708   					   CMD_WEP_KEY_INDEX_MASK);
;;;1709   
;;;1710   		/* Copy key types and material to host command structure */
;;;1711   		for (i = 0; i < 4; i++) {
000038  2400              MOVS     r4,#0
00003a  e02a              B        |L15.146|
                  |L15.60|
;;;1712   			struct enc_key *pkey = &assoc->wep_keys[i];
00003c  eb040044          ADD      r0,r4,r4,LSL #1
000040  eb001104          ADD      r1,r0,r4,LSL #4
000044  f1070030          ADD      r0,r7,#0x30
000048  eb000541          ADD      r5,r0,r1,LSL #1
;;;1713   
;;;1714   			switch (pkey->len) {
00004c  8828              LDRH     r0,[r5,#0]
00004e  b1d0              CBZ      r0,|L15.134|
000050  2805              CMP      r0,#5
000052  d002              BEQ      |L15.90|
000054  280d              CMP      r0,#0xd
000056  d117              BNE      |L15.136|
000058  e00a              B        |L15.112|
                  |L15.90|
;;;1715   			case KEY_LEN_WEP_40:
;;;1716   				cmd.keytype[i] = CMD_TYPE_WEP_40_BIT;
00005a  2101              MOVS     r1,#1
00005c  a804              ADD      r0,sp,#0x10
00005e  5501              STRB     r1,[r0,r4]
;;;1717   				memmove(cmd.keymaterial[i], pkey->key, pkey->len);
000060  882a              LDRH     r2,[r5,#0]
000062  a905              ADD      r1,sp,#0x14
000064  eb011004          ADD      r0,r1,r4,LSL #4
000068  1da9              ADDS     r1,r5,#6
00006a  f7fffffe          BL       __aeabi_memmove
;;;1718   				lbs_deb_cmd("SET_WEP: add key %d (40 bit)\n", i);
;;;1719   				break;
00006e  e00e              B        |L15.142|
                  |L15.112|
;;;1720   			case KEY_LEN_WEP_104:
;;;1721   				cmd.keytype[i] = CMD_TYPE_WEP_104_BIT;
000070  2102              MOVS     r1,#2
000072  a804              ADD      r0,sp,#0x10
000074  5501              STRB     r1,[r0,r4]
;;;1722   				memmove(cmd.keymaterial[i], pkey->key, pkey->len);
000076  882a              LDRH     r2,[r5,#0]
000078  a905              ADD      r1,sp,#0x14
00007a  eb011004          ADD      r0,r1,r4,LSL #4
00007e  1da9              ADDS     r1,r5,#6
000080  f7fffffe          BL       __aeabi_memmove
;;;1723   				lbs_deb_cmd("SET_WEP: add key %d (104 bit)\n", i);
;;;1724   				break;
000084  e003              B        |L15.142|
                  |L15.134|
;;;1725   			case 0:
;;;1726   				break;
000086  e002              B        |L15.142|
                  |L15.136|
;;;1727   			default:
;;;1728   				lbs_deb_cmd("SET_WEP: invalid key %d, length %d\n",
;;;1729   					    i, pkey->len);
;;;1730   				ret = -1;
000088  f04f39ff          MOV      r9,#0xffffffff
;;;1731   				goto done;
00008c  e013              B        |L15.182|
                  |L15.142|
00008e  bf00              NOP                            ;1719
000090  1c64              ADDS     r4,r4,#1              ;1711
                  |L15.146|
000092  2c04              CMP      r4,#4                 ;1711
000094  dbd2              BLT      |L15.60|
;;;1732   				//break;
;;;1733   			}
;;;1734   		}
;;;1735   	} else if (cmd_action == CMD_ACT_REMOVE) {
000096  e007              B        |L15.168|
                  |L15.152|
000098  2e04              CMP      r6,#4
00009a  d105              BNE      |L15.168|
;;;1736   		/* ACT_REMOVE clears _all_ WEP keys */
;;;1737   
;;;1738   		/* default tx key index */
;;;1739   		cmd.keyindex = cpu_to_le16(priv->wep_tx_keyidx &
00009c  f8b802a0          LDRH     r0,[r8,#0x2a0]
0000a0  f3c0000d          UBFX     r0,r0,#0,#14
0000a4  f8ad000e          STRH     r0,[sp,#0xe]
                  |L15.168|
;;;1740   					   CMD_WEP_KEY_INDEX_MASK);
;;;1741   		lbs_deb_cmd("SET_WEP: remove key %d\n", priv->wep_tx_keyidx);
;;;1742   	}
;;;1743   
;;;1744   	ret = lbs_cmd_with_response(priv, CMD_802_11_SET_WEP, &cmd);
0000a8  aa01              ADD      r2,sp,#4
0000aa  2113              MOVS     r1,#0x13
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       lbs_cmd_with_response
0000b2  4681              MOV      r9,r0
;;;1745   done:
0000b4  bf00              NOP      
                  |L15.182|
;;;1746   	lbs_deb_cmd_leave_args(LBS_DEB_CMD, ret);
;;;1747   	return ret;
0000b6  4648              MOV      r0,r9
;;;1748   }
0000b8  b015              ADD      sp,sp,#0x54
0000ba  e8bd83f0          POP      {r4-r9,pc}
;;;1749   
                          ENDP


                          AREA ||i.lbs_cmd_async||, CODE, READONLY, ALIGN=2

                  lbs_cmd_async PROC
;;;522    
;;;523    void lbs_cmd_async(struct lbs_private *priv, uint16_t command,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;524    	struct cmd_header *in_cmd, int in_cmd_size)
;;;525    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;526    	struct if_sdio_card *card=priv->card;
00000c  6aa5              LDR      r5,[r4,#0x28]
;;;527    	int ret = 0;
00000e  2600              MOVS     r6,#0
;;;528    	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;529    	__lbs_cmd_async(priv, command, in_cmd, in_cmd_size,
000010  2300              MOVS     r3,#0
000012  4a0f              LDR      r2,|L16.80|
000014  e9cd2300          STRD     r2,r3,[sp,#0]
000018  464b              MOV      r3,r9
00001a  4642              MOV      r2,r8
00001c  4639              MOV      r1,r7
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __lbs_cmd_async
;;;530    		lbs_cmd_async_callback, 0);
;;;531    
;;;532    	/*这是一个bug的修复，本来lbs_cmd_async提交的命令是不用等待他返回的，但是卡还是
;;;533    	会返回一个状态码，所以这里必须同步读取*/
;;;534    	while(1){
000024  e00c              B        |L16.64|
                  |L16.38|
;;;535    		ret=pool_sdio_interrupt(card->func);
000026  6828              LDR      r0,[r5,#0]
000028  f7fffffe          BL       pool_sdio_interrupt
00002c  4606              MOV      r6,r0
;;;536    		if(ret<0){
00002e  2e00              CMP      r6,#0
000030  da04              BGE      |L16.60|
;;;537    			lbs_pr_err("read interrupt error!\n");
000032  a008              ADR      r0,|L16.84|
000034  f7fffffe          BL       __2printf
;;;538    			try_bug(0);
000038  bf00              NOP      
                  |L16.58|
00003a  e7fe              B        |L16.58|
                  |L16.60|
;;;539    		}
;;;540    		else if(ret)//读到中断
00003c  b106              CBZ      r6,|L16.64|
;;;541    			break;
00003e  e000              B        |L16.66|
                  |L16.64|
000040  e7f1              B        |L16.38|
                  |L16.66|
000042  bf00              NOP      
;;;542    	}
;;;543    	if_sdio_interrupt(card->func);
000044  6828              LDR      r0,[r5,#0]
000046  f7fffffe          BL       if_sdio_interrupt
;;;544    	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;545    }
00004a  e8bd87fc          POP      {r2-r10,pc}
;;;546    
                          ENDP

00004e  0000              DCW      0x0000
                  |L16.80|
                          DCD      lbs_cmd_async_callback
                  |L16.84|
000054  72656164          DCB      "read interrupt error!\n",0
000058  20696e74
00005c  65727275
000060  70742065
000064  72726f72
000068  210a00  
00006b  00                DCB      0

                          AREA ||i.lbs_cmd_async_callback||, CODE, READONLY, ALIGN=1

                  lbs_cmd_async_callback PROC
;;;280     */
;;;281    static int lbs_cmd_async_callback(struct lbs_private *priv, unsigned long extra,
000000  4603              MOV      r3,r0
;;;282    		     struct cmd_header *resp)
;;;283    {
;;;284    	return 0;
000002  2000              MOVS     r0,#0
;;;285    }
000004  4770              BX       lr
;;;286    
                          ENDP


                          AREA ||i.lbs_cmd_bcn_ctrl||, CODE, READONLY, ALIGN=1

                  lbs_cmd_bcn_ctrl PROC
;;;1361   
;;;1362   static int lbs_cmd_bcn_ctrl(struct lbs_private * priv,
000000  b510              PUSH     {r4,lr}
;;;1363   				struct cmd_ds_command *cmd,
;;;1364   				u16 cmd_action)
;;;1365   {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;1366   	struct cmd_ds_802_11_beacon_control
;;;1367   		*bcn_ctrl = &cmd->params.bcn_ctrl;
000006  f1010208          ADD      r2,r1,#8
;;;1368   
;;;1369   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1370   	cmd->size =
00000a  2012              MOVS     r0,#0x12
00000c  8048              STRH     r0,[r1,#2]
;;;1371   	    cpu_to_le16(sizeof(struct cmd_ds_802_11_beacon_control)
;;;1372   			     + S_DS_GEN);
;;;1373   	cmd->command = cpu_to_le16(CMD_802_11_BEACON_CTRL);
00000e  20b0              MOVS     r0,#0xb0
000010  8008              STRH     r0,[r1,#0]
;;;1374   
;;;1375   	bcn_ctrl->action = cpu_to_le16(cmd_action);
000012  8014              STRH     r4,[r2,#0]
;;;1376   	bcn_ctrl->beacon_enable = cpu_to_le16(priv->beacon_enable);
000014  f8930106          LDRB     r0,[r3,#0x106]
000018  8050              STRH     r0,[r2,#2]
;;;1377   	bcn_ctrl->beacon_period = cpu_to_le16(priv->beacon_period);
00001a  f8b30104          LDRH     r0,[r3,#0x104]
00001e  8090              STRH     r0,[r2,#4]
;;;1378   
;;;1379   	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;1380   	return 0;
000020  2000              MOVS     r0,#0
;;;1381   }
000022  bd10              POP      {r4,pc}
;;;1382   
                          ENDP


                          AREA ||i.lbs_cmd_bt_access||, CODE, READONLY, ALIGN=2

                  lbs_cmd_bt_access PROC
;;;1297   
;;;1298   static int lbs_cmd_bt_access(struct cmd_ds_command *cmd,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1299   			       u16 cmd_action, void *pdata_buf)
;;;1300   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;1301   	struct cmd_ds_bt_access *bt_access = &cmd->params.bt;
00000a  f1050408          ADD      r4,r5,#8
;;;1302   	lbs_deb_cmd_enter_args(LBS_DEB_CMD, cmd_action);
;;;1303   
;;;1304   	cmd->command = cpu_to_le16(CMD_BT_ACCESS);
00000e  2087              MOVS     r0,#0x87
000010  8028              STRH     r0,[r5,#0]
;;;1305   	cmd->size = cpu_to_le16((sizeof(struct cmd_ds_bt_access)+S_DS_GEN));
000012  201e              MOVS     r0,#0x1e
000014  8068              STRH     r0,[r5,#2]
;;;1306   	cmd->result = 0;
000016  2000              MOVS     r0,#0
000018  80e8              STRH     r0,[r5,#6]
;;;1307   	bt_access->action = cpu_to_le16(cmd_action);
00001a  8027              STRH     r7,[r4,#0]
;;;1308   
;;;1309   	switch (cmd_action) {
00001c  1f78              SUBS     r0,r7,#5
00001e  2806              CMP      r0,#6
000020  d22a              BCS      |L19.120|
000022  e8dff000          TBB      [pc,r0]
000026  0313              DCB      0x03,0x13
000028  1f232428          DCB      0x1f,0x23,0x24,0x28
;;;1310   	case CMD_ACT_BT_ACCESS_ADD:
;;;1311   		memcpy(bt_access->addr1, pdata_buf, 2 * ETH_ALEN);
00002c  6830              LDR      r0,[r6,#0]
00002e  f8c40006          STR      r0,[r4,#6]
000032  6870              LDR      r0,[r6,#4]
000034  f8c4000a          STR      r0,[r4,#0xa]
000038  68b0              LDR      r0,[r6,#8]
00003a  f8c4000e          STR      r0,[r4,#0xe]
;;;1312   		lbs_deb_hex(LBS_DEB_MESH, "BT_ADD: blinded MAC addr", bt_access->addr1, 6);
00003e  2306              MOVS     r3,#6
000040  1da2              ADDS     r2,r4,#6
000042  a110              ADR      r1,|L19.132|
000044  2010              MOVS     r0,#0x10
000046  f7fffffe          BL       lbs_hex
;;;1313   		break;
00004a  e016              B        |L19.122|
;;;1314   	case CMD_ACT_BT_ACCESS_DEL:
;;;1315   		memcpy(bt_access->addr1, pdata_buf, 1 * ETH_ALEN);
00004c  6830              LDR      r0,[r6,#0]
00004e  f8c40006          STR      r0,[r4,#6]
000052  88b0              LDRH     r0,[r6,#4]
000054  8160              STRH     r0,[r4,#0xa]
;;;1316   		lbs_deb_hex(LBS_DEB_MESH, "BT_DEL: blinded MAC addr", bt_access->addr1, 6);
000056  2306              MOVS     r3,#6
000058  1da2              ADDS     r2,r4,#6
00005a  a111              ADR      r1,|L19.160|
00005c  2010              MOVS     r0,#0x10
00005e  f7fffffe          BL       lbs_hex
;;;1317   		break;
000062  e00a              B        |L19.122|
;;;1318   	case CMD_ACT_BT_ACCESS_LIST:
;;;1319   		bt_access->id = cpu_to_le32(*(u32 *) pdata_buf);
000064  6830              LDR      r0,[r6,#0]
000066  f8c40002          STR      r0,[r4,#2]
;;;1320   		break;
00006a  e006              B        |L19.122|
;;;1321   	case CMD_ACT_BT_ACCESS_RESET:
;;;1322   		break;
00006c  e005              B        |L19.122|
;;;1323   	case CMD_ACT_BT_ACCESS_SET_INVERT:
;;;1324   		bt_access->id = cpu_to_le32(*(u32 *) pdata_buf);
00006e  6830              LDR      r0,[r6,#0]
000070  f8c40002          STR      r0,[r4,#2]
;;;1325   		break;
000074  e001              B        |L19.122|
;;;1326   	case CMD_ACT_BT_ACCESS_GET_INVERT:
;;;1327   		break;
000076  e000              B        |L19.122|
                  |L19.120|
;;;1328   	default:
;;;1329   		break;
000078  bf00              NOP      
                  |L19.122|
00007a  bf00              NOP                            ;1313
;;;1330   	}
;;;1331   	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;1332   	return 0;
00007c  2000              MOVS     r0,#0
;;;1333   }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;1334   
                          ENDP

000082  0000              DCW      0x0000
                  |L19.132|
000084  42545f41          DCB      "BT_ADD: blinded MAC addr",0
000088  44443a20
00008c  626c696e
000090  64656420
000094  4d414320
000098  61646472
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L19.160|
0000a0  42545f44          DCB      "BT_DEL: blinded MAC addr",0
0000a4  454c3a20
0000a8  626c696e
0000ac  64656420
0000b0  4d414320
0000b4  61646472
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.lbs_cmd_copyback||, CODE, READONLY, ALIGN=1

                  lbs_cmd_copyback PROC
;;;557     */
;;;558    int lbs_cmd_copyback(struct lbs_private *priv, unsigned long extra,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;559    		     struct cmd_header *resp)
;;;560    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;561    	struct cmd_header *buf = (void *)extra;
00000a  462e              MOV      r6,r5
;;;562    	uint16_t copy_len;
;;;563    
;;;564    	copy_len = min(le16_to_cpu(buf->size), le16_to_cpu(resp->size));
00000c  8870              LDRH     r0,[r6,#2]
00000e  8861              LDRH     r1,[r4,#2]
000010  4288              CMP      r0,r1
000012  da01              BGE      |L20.24|
000014  8870              LDRH     r0,[r6,#2]
000016  e000              B        |L20.26|
                  |L20.24|
000018  8860              LDRH     r0,[r4,#2]
                  |L20.26|
00001a  b287              UXTH     r7,r0
;;;565    	memcpy(buf, resp, copy_len);
00001c  463a              MOV      r2,r7
00001e  4621              MOV      r1,r4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       __aeabi_memcpy
;;;566    	return 0;
000026  2000              MOVS     r0,#0
;;;567    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;568    
                          ENDP


                          AREA ||i.lbs_cmd_fwt_access||, CODE, READONLY, ALIGN=1

                  lbs_cmd_fwt_access PROC
;;;1337   
;;;1338   static int lbs_cmd_fwt_access(struct cmd_ds_command *cmd,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1339   			       u16 cmd_action, void *pdata_buf)
;;;1340   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1341   	struct cmd_ds_fwt_access *fwt_access = &cmd->params.fwt;
00000a  f1040708          ADD      r7,r4,#8
;;;1342   	lbs_deb_cmd_enter_args(LBS_DEB_CMD,cmd_action);
;;;1343   
;;;1344   	cmd->command = cpu_to_le16(CMD_FWT_ACCESS);
00000e  2095              MOVS     r0,#0x95
000010  8020              STRH     r0,[r4,#0]
;;;1345   	cmd->size = cpu_to_le16((sizeof(struct cmd_ds_fwt_access)+S_DS_GEN));
000012  2042              MOVS     r0,#0x42
000014  8060              STRH     r0,[r4,#2]
;;;1346   	cmd->result = 0;
000016  2000              MOVS     r0,#0
000018  80e0              STRH     r0,[r4,#6]
;;;1347   
;;;1348   	if (pdata_buf)
00001a  b12d              CBZ      r5,|L21.40|
;;;1349   		memcpy(fwt_access, pdata_buf, sizeof(*fwt_access));
00001c  2236              MOVS     r2,#0x36
00001e  4629              MOV      r1,r5
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       __aeabi_memcpy
000026  e003              B        |L21.48|
                  |L21.40|
;;;1350   	else
;;;1351   		memset(fwt_access, 0, sizeof(*fwt_access));
000028  2136              MOVS     r1,#0x36
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       __aeabi_memclr
                  |L21.48|
;;;1352   
;;;1353   	fwt_access->action = cpu_to_le16(cmd_action);
000030  803e              STRH     r6,[r7,#0]
;;;1354   
;;;1355   	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;1356   	return 0;
000032  2000              MOVS     r0,#0
;;;1357   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1358   
                          ENDP


                          AREA ||i.lbs_cmd_reg_access||, CODE, READONLY, ALIGN=1

                  lbs_cmd_reg_access PROC
;;;1173   
;;;1174   static int lbs_cmd_reg_access(struct cmd_ds_command *cmdptr,
000000  b530              PUSH     {r4,r5,lr}
;;;1175   			       u8 cmd_action, void *pdata_buf)
;;;1176   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1177   	struct lbs_offset_value *offval;
;;;1178   
;;;1179   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1180   
;;;1181   	offval = (struct lbs_offset_value *)pdata_buf;
000006  4611              MOV      r1,r2
;;;1182   
;;;1183   	switch (le16_to_cpu(cmdptr->command)) {
000008  8818              LDRH     r0,[r3,#0]
00000a  2819              CMP      r0,#0x19
00000c  d004              BEQ      |L22.24|
00000e  281a              CMP      r0,#0x1a
000010  d00c              BEQ      |L22.44|
000012  281b              CMP      r0,#0x1b
000014  d11e              BNE      |L22.84|
000016  e013              B        |L22.64|
                  |L22.24|
;;;1184   	case CMD_MAC_REG_ACCESS:
;;;1185   		{
;;;1186   			struct cmd_ds_mac_reg_access *macreg;
;;;1187   
;;;1188   			cmdptr->size =
000018  2514              MOVS     r5,#0x14
00001a  805d              STRH     r5,[r3,#2]
;;;1189   			    cpu_to_le16(sizeof (struct cmd_ds_mac_reg_access)
;;;1190   					+ S_DS_GEN);
;;;1191   			macreg =
00001c  f1030008          ADD      r0,r3,#8
;;;1192   			    (struct cmd_ds_mac_reg_access *)&cmdptr->params.
;;;1193   			    macreg;
;;;1194   
;;;1195   			macreg->action = cpu_to_le16(cmd_action);
000020  8004              STRH     r4,[r0,#0]
;;;1196   			macreg->offset = cpu_to_le16((u16) offval->offset);
000022  680d              LDR      r5,[r1,#0]
000024  8045              STRH     r5,[r0,#2]
;;;1197   			macreg->value = cpu_to_le32(offval->value);
000026  684d              LDR      r5,[r1,#4]
000028  6045              STR      r5,[r0,#4]
;;;1198   
;;;1199   			break;
00002a  e014              B        |L22.86|
                  |L22.44|
;;;1200   		}
;;;1201   
;;;1202   	case CMD_BBP_REG_ACCESS:
;;;1203   		{
;;;1204   			struct cmd_ds_bbp_reg_access *bbpreg;
;;;1205   
;;;1206   			cmdptr->size =
00002c  2514              MOVS     r5,#0x14
00002e  805d              STRH     r5,[r3,#2]
;;;1207   			    cpu_to_le16(sizeof
;;;1208   					     (struct cmd_ds_bbp_reg_access)
;;;1209   					     + S_DS_GEN);
;;;1210   			bbpreg =
000030  f1030008          ADD      r0,r3,#8
;;;1211   			    (struct cmd_ds_bbp_reg_access *)&cmdptr->params.
;;;1212   			    bbpreg;
;;;1213   
;;;1214   			bbpreg->action = cpu_to_le16(cmd_action);
000034  8004              STRH     r4,[r0,#0]
;;;1215   			bbpreg->offset = cpu_to_le16((u16) offval->offset);
000036  680d              LDR      r5,[r1,#0]
000038  8045              STRH     r5,[r0,#2]
;;;1216   			bbpreg->value = (u8) offval->value;
00003a  684d              LDR      r5,[r1,#4]
00003c  7105              STRB     r5,[r0,#4]
;;;1217   
;;;1218   			break;
00003e  e00a              B        |L22.86|
                  |L22.64|
;;;1219   		}
;;;1220   
;;;1221   	case CMD_RF_REG_ACCESS:
;;;1222   		{
;;;1223   			struct cmd_ds_rf_reg_access *rfreg;
;;;1224   
;;;1225   			cmdptr->size =
000040  2514              MOVS     r5,#0x14
000042  805d              STRH     r5,[r3,#2]
;;;1226   			    cpu_to_le16(sizeof
;;;1227   					     (struct cmd_ds_rf_reg_access) +
;;;1228   					     S_DS_GEN);
;;;1229   			rfreg =
000044  f1030008          ADD      r0,r3,#8
;;;1230   			    (struct cmd_ds_rf_reg_access *)&cmdptr->params.
;;;1231   			    rfreg;
;;;1232   
;;;1233   			rfreg->action = cpu_to_le16(cmd_action);
000048  8004              STRH     r4,[r0,#0]
;;;1234   			rfreg->offset = cpu_to_le16((u16) offval->offset);
00004a  680d              LDR      r5,[r1,#0]
00004c  8045              STRH     r5,[r0,#2]
;;;1235   			rfreg->value = (u8) offval->value;
00004e  684d              LDR      r5,[r1,#4]
000050  7105              STRB     r5,[r0,#4]
;;;1236   
;;;1237   			break;
000052  e000              B        |L22.86|
                  |L22.84|
;;;1238   		}
;;;1239   
;;;1240   	default:
;;;1241   		break;
000054  bf00              NOP      
                  |L22.86|
000056  bf00              NOP                            ;1199
;;;1242   	}
;;;1243   
;;;1244   	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;1245   	return 0;
000058  2000              MOVS     r0,#0
;;;1246   }
00005a  bd30              POP      {r4,r5,pc}
;;;1247   
                          ENDP


                          AREA ||i.lbs_complete_command||, CODE, READONLY, ALIGN=2

                  lbs_complete_command PROC
;;;571    
;;;572    void lbs_complete_command(struct lbs_private *priv, struct cmd_ctrl_node *cmd,
000000  b570              PUSH     {r4-r6,lr}
;;;573    			  int result)
;;;574    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;575    	if (cmd == priv->cur_cmd)
000008  6fe8              LDR      r0,[r5,#0x7c]
00000a  42a0              CMP      r0,r4
00000c  d101              BNE      |L23.18|
;;;576    		priv->cur_cmd_retcode = result;
00000e  f8c56080          STR      r6,[r5,#0x80]
                  |L23.18|
;;;577    
;;;578    	cmd->result = result;
000012  60a6              STR      r6,[r4,#8]
;;;579    	cmd->cmdwaitqwoken = 1;
000014  2001              MOVS     r0,#1
000016  8320              STRH     r0,[r4,#0x18]
;;;580    	//wake_up_interruptible(&cmd->cmdwait_q);//唤醒当前命令的处理，进行善后工作
;;;581    
;;;582    	if (!cmd->callback || cmd->callback == lbs_cmd_async_callback)//没有回调或者是异步回调就直接清除命令，表示命令执行完成
000018  68e0              LDR      r0,[r4,#0xc]
00001a  b118              CBZ      r0,|L23.36|
00001c  4905              LDR      r1,|L23.52|
00001e  68e0              LDR      r0,[r4,#0xc]
000020  4288              CMP      r0,r1
000022  d103              BNE      |L23.44|
                  |L23.36|
;;;583    		__lbs_cleanup_and_insert_cmd(priv, cmd);//清除命令
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __lbs_cleanup_and_insert_cmd
                  |L23.44|
;;;584    	priv->cur_cmd = NULL;
00002c  2000              MOVS     r0,#0
00002e  67e8              STR      r0,[r5,#0x7c]
;;;585    }
000030  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

000032  0000              DCW      0x0000
                  |L23.52|
                          DCD      lbs_cmd_async_callback

                          AREA ||i.lbs_execute_next_command||, CODE, READONLY, ALIGN=2

                  lbs_execute_next_command PROC
;;;959     */
;;;960    int lbs_execute_next_command(struct lbs_private *priv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;961    {
000004  4604              MOV      r4,r0
;;;962    	struct cmd_ctrl_node *cmdnode = NULL;
000006  2500              MOVS     r5,#0
;;;963    	struct cmd_header *cmd;
;;;964    //	unsigned long flags;
;;;965    	struct cmd_ds_802_11_ps_mode *psm;
;;;966    	int ret = 0;
000008  46a8              MOV      r8,r5
;;;967    
;;;968    	/* Debug group is LBS_DEB_THREAD and not LBS_DEB_HOST, because the
;;;969    	 * only caller to us is lbs_thread() and we get even when a
;;;970    	 * data packet is received */
;;;971    	lbs_deb_cmd_enter("enter lbs_execute_next_command\n");
;;;972    
;;;973    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;974    
;;;975    	if (priv->cur_cmd) {
00000a  6fe0              LDR      r0,[r4,#0x7c]
00000c  b110              CBZ      r0,|L24.20|
;;;976    		lbs_pr_alert( "EXEC_NEXT_CMD: already processing command!\n");
;;;977    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;978    		ret = -1;
00000e  f04f38ff          MOV      r8,#0xffffffff
;;;979    		goto done;
000012  e068              B        |L24.230|
                  |L24.20|
;;;980    	}
;;;981    
;;;982    	if (!list_empty(&priv->cmdpendingq)) {
000014  f104008c          ADD      r0,r4,#0x8c
000018  6801              LDR      r1,[r0,#0]
00001a  4281              CMP      r1,r0
00001c  d101              BNE      |L24.34|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L24.36|
                  |L24.34|
000022  2100              MOVS     r1,#0
                  |L24.36|
000024  b911              CBNZ     r1,|L24.44|
;;;983    		cmdnode = list_first_entry(&priv->cmdpendingq,
000026  f8d4008c          LDR      r0,[r4,#0x8c]
00002a  4605              MOV      r5,r0
                  |L24.44|
;;;984    					   struct cmd_ctrl_node, list);//取出命令node
;;;985    	}
;;;986    
;;;987    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;988    
;;;989    	if (cmdnode) {
00002c  b3cd              CBZ      r5,|L24.162|
;;;990    		cmd = cmdnode->cmdbuf;
00002e  696e              LDR      r6,[r5,#0x14]
;;;991    
;;;992    		if (is_command_allowed_in_ps(le16_to_cpu(cmd->command))) {//power save模式下能执行的命令也就rssi
000030  8830              LDRH     r0,[r6,#0]
000032  f7fffffe          BL       is_command_allowed_in_ps
000036  b150              CBZ      r0,|L24.78|
;;;993    			if ((priv->psstate == PS_STATE_SLEEP) ||
000038  f8d401f0          LDR      r0,[r4,#0x1f0]
00003c  2803              CMP      r0,#3
00003e  d003              BEQ      |L24.72|
;;;994    			    (priv->psstate == PS_STATE_PRE_SLEEP)) {
000040  f8d401f0          LDR      r0,[r4,#0x1f0]
000044  2802              CMP      r0,#2
000046  d144              BNE      |L24.210|
                  |L24.72|
;;;995    				lbs_deb_host(
;;;996    				       "EXEC_NEXT_CMD: cannot send cmd 0x%04x in psstate %d\n",
;;;997    				       le16_to_cpu(cmd->command),
;;;998    				       priv->psstate);
;;;999    				ret = -1;
000048  f04f38ff          MOV      r8,#0xffffffff
;;;1000   				goto done;
00004c  e04b              B        |L24.230|
                  |L24.78|
;;;1001   			}
;;;1002   			lbs_deb_host("EXEC_NEXT_CMD: OK to send command "
;;;1003   				     "0x%04x in psstate %d\n",
;;;1004   				     le16_to_cpu(cmd->command), priv->psstate);
;;;1005   		} else if (priv->psstate != PS_STATE_FULL_POWER) {
00004e  f8d401f0          LDR      r0,[r4,#0x1f0]
000052  b338              CBZ      r0,|L24.164|
;;;1006   			/*
;;;1007   			 * 1. Non-PS command:
;;;1008   			 * Queue it. set needtowakeup to TRUE if current state
;;;1009   			 * is SLEEP, otherwise call lbs_ps_wakeup to send Exit_PS.
;;;1010   			 * 2. PS command but not Exit_PS:
;;;1011   			 * Ignore it.
;;;1012   			 * 3. PS command Exit_PS:
;;;1013   			 * Set needtowakeup to TRUE if current state is SLEEP,
;;;1014   			 * otherwise send this command down to firmware
;;;1015   			 * immediately.
;;;1016   			 */
;;;1017   			if (cmd->command != cpu_to_le16(CMD_802_11_PS_MODE)) {
000054  8830              LDRH     r0,[r6,#0]
000056  2821              CMP      r0,#0x21
000058  d013              BEQ      |L24.130|
;;;1018   				/*  Prepare to send Exit PS,
;;;1019   				 *  this non PS command will be sent later */
;;;1020   				if ((priv->psstate == PS_STATE_SLEEP)
00005a  f8d401f0          LDR      r0,[r4,#0x1f0]
00005e  2803              CMP      r0,#3
000060  d003              BEQ      |L24.106|
;;;1021   				    || (priv->psstate == PS_STATE_PRE_SLEEP)
000062  f8d401f0          LDR      r0,[r4,#0x1f0]
000066  2802              CMP      r0,#2
000068  d103              BNE      |L24.114|
                  |L24.106|
;;;1022   				    ) {//睡眠就算了，只是置为标志
;;;1023   					/* w/ new scheme, it will not reach here.
;;;1024   					   since it is blocked in main_thread. */
;;;1025   					priv->needtowakeup = 1;
00006a  2001              MOVS     r0,#1
00006c  f88401f4          STRB     r0,[r4,#0x1f4]
000070  e004              B        |L24.124|
                  |L24.114|
;;;1026   				} else{
;;;1027   					//lbs_ps_wakeup(priv, 0);//低功耗模式下的唤醒
;;;1028   					printk("power down mode,cann't exec cmd!\n");
000072  a01e              ADR      r0,|L24.236|
000074  f7fffffe          BL       __2printf
;;;1029   					try_bug(0);
000078  bf00              NOP      
                  |L24.122|
00007a  e7fe              B        |L24.122|
                  |L24.124|
;;;1030   					}	
;;;1031   
;;;1032   				ret = 0;
00007c  f04f0800          MOV      r8,#0
;;;1033   				goto done;
000080  e031              B        |L24.230|
                  |L24.130|
;;;1034   			} else {
;;;1035   				/*
;;;1036   				 * PS command. Ignore it if it is not Exit_PS.
;;;1037   				 * otherwise send it down immediately.
;;;1038   				 */
;;;1039   				 psm = (void *)&cmd[1];
000082  f1060708          ADD      r7,r6,#8
;;;1040   
;;;1041   				lbs_deb_host(
;;;1042   				       "EXEC_NEXT_CMD: PS cmd, action 0x%02x\n",
;;;1043   				       psm->action);
;;;1044   				if (psm->action !=
000086  8838              LDRH     r0,[r7,#0]
000088  2831              CMP      r0,#0x31
00008a  d00c              BEQ      |L24.166|
;;;1045   				    cpu_to_le16(CMD_SUBCMD_EXIT_PS)) {
;;;1046   					lbs_deb_host(
;;;1047   					       "EXEC_NEXT_CMD: ignore ENTER_PS cmd\n");
;;;1048   					list_del(&cmdnode->list);
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       list_del
;;;1049   					//spin_lock_irqsave(&priv->driver_lock, flags);
;;;1050   					lbs_complete_command(priv, cmdnode, 0);
000092  2200              MOVS     r2,#0
000094  4629              MOV      r1,r5
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       lbs_complete_command
;;;1051   					//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;1052   
;;;1053   					ret = 0;
00009c  f04f0800          MOV      r8,#0
;;;1054   					goto done;
0000a0  e021              B        |L24.230|
                  |L24.162|
0000a2  e01d              B        |L24.224|
                  |L24.164|
0000a4  e015              B        |L24.210|
                  |L24.166|
;;;1055   				}
;;;1056   
;;;1057   				if ((priv->psstate == PS_STATE_SLEEP) ||
0000a6  f8d401f0          LDR      r0,[r4,#0x1f0]
0000aa  2803              CMP      r0,#3
0000ac  d003              BEQ      |L24.182|
;;;1058   				    (priv->psstate == PS_STATE_PRE_SLEEP)) {
0000ae  f8d401f0          LDR      r0,[r4,#0x1f0]
0000b2  2802              CMP      r0,#2
0000b4  d10d              BNE      |L24.210|
                  |L24.182|
;;;1059   					lbs_deb_host(
;;;1060   					       "EXEC_NEXT_CMD: ignore EXIT_PS cmd in sleep\n");
;;;1061   					list_del(&cmdnode->list);
0000b6  4628              MOV      r0,r5
0000b8  f7fffffe          BL       list_del
;;;1062   					//spin_lock_irqsave(&priv->driver_lock, flags);
;;;1063   					lbs_complete_command(priv, cmdnode, 0);
0000bc  2200              MOVS     r2,#0
0000be  4629              MOV      r1,r5
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       lbs_complete_command
;;;1064   					//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;1065   					priv->needtowakeup = 1;
0000c6  2001              MOVS     r0,#1
0000c8  f88401f4          STRB     r0,[r4,#0x1f4]
;;;1066   
;;;1067   					ret = 0;
0000cc  f04f0800          MOV      r8,#0
;;;1068   					goto done;
0000d0  e009              B        |L24.230|
                  |L24.210|
;;;1069   				}
;;;1070   
;;;1071   				lbs_deb_host(
;;;1072   				       "EXEC_NEXT_CMD: sending EXIT_PS\n");
;;;1073   			}
;;;1074   		}
;;;1075   		list_del(&cmdnode->list);
0000d2  4628              MOV      r0,r5
0000d4  f7fffffe          BL       list_del
;;;1076   		lbs_deb_host("EXEC_NEXT_CMD: sending command 0x%04x\n",
;;;1077   			    le16_to_cpu(cmd->command));
;;;1078   		lbs_submit_command(priv, cmdnode);//真正将命令写入网卡的函数
0000d8  4629              MOV      r1,r5
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       lbs_submit_command
                  |L24.224|
;;;1079   	} 
;;;1080   #ifdef SUPPORT_POWER_SLEEP
;;;1081   	else {
;;;1082   		/*
;;;1083   		 * check if in power save mode, if yes, put the device back
;;;1084   		 * to PS mode
;;;1085   		 */
;;;1086   		if ((priv->psmode != LBS802_11POWERMODECAM) &&
;;;1087   		    (priv->psstate == PS_STATE_FULL_POWER) &&
;;;1088   		    ((priv->connect_status == LBS_CONNECTED) ||
;;;1089   		    (priv->mesh_connect_status == LBS_CONNECTED))) {
;;;1090   			if (priv->secinfo.WPAenabled ||
;;;1091   			    priv->secinfo.WPA2enabled) {
;;;1092   				/* check for valid WPA group keys */
;;;1093   				if (priv->wpa_mcast_key.len ||
;;;1094   				    priv->wpa_unicast_key.len) {
;;;1095   					lbs_deb_host(
;;;1096   					       "EXEC_NEXT_CMD: WPA enabled and GTK_SET"
;;;1097   					       " go back to PS_SLEEP");
;;;1098   					//lbs_ps_sleep(priv, 0);
;;;1099   					try_bug(0);
;;;1100   				}
;;;1101   			} else {
;;;1102   				lbs_deb_host(
;;;1103   				       "EXEC_NEXT_CMD: cmdpendingq empty, "
;;;1104   				       "go back to PS_SLEEP");
;;;1105   				//lbs_ps_sleep(priv, 0);
;;;1106   				try_bug(0);
;;;1107   			}
;;;1108   		}
;;;1109   	}
;;;1110   #endif
;;;1111   
;;;1112   	ret = 0;
0000e0  f04f0800          MOV      r8,#0
;;;1113   done:
0000e4  bf00              NOP      
                  |L24.230|
;;;1114   	 lbs_deb_cmd_leave(LBS_DEB_THREAD);
;;;1115   	return ret;
0000e6  4640              MOV      r0,r8
;;;1116   }
0000e8  e8bd81f0          POP      {r4-r8,pc}
;;;1117   
                          ENDP

                  |L24.236|
0000ec  706f7765          DCB      "power down mode,cann't exec cmd!\n",0
0000f0  7220646f
0000f4  776e206d
0000f8  6f64652c
0000fc  63616e6e
000100  27742065
000104  78656320
000108  636d6421
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||i.lbs_get_channel||, CODE, READONLY, ALIGN=1

                  lbs_get_channel PROC
;;;1612    */
;;;1613   int lbs_get_channel(struct lbs_private *priv)
000000  b530              PUSH     {r4,r5,lr}
;;;1614   {
000002  b08d              SUB      sp,sp,#0x34
000004  4605              MOV      r5,r0
;;;1615   	struct cmd_ds_802_11_rf_channel cmd;
;;;1616   	int ret = 0;
000006  2400              MOVS     r4,#0
;;;1617   
;;;1618   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1619   
;;;1620   	memset(&cmd, 0, sizeof(cmd));
000008  2130              MOVS     r1,#0x30
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;1621   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000010  2030              MOVS     r0,#0x30
000012  f8ad0006          STRH     r0,[sp,#6]
;;;1622   	cmd.action = cpu_to_le16(CMD_OPT_802_11_RF_CHANNEL_GET);
000016  2000              MOVS     r0,#0
000018  f8ad000c          STRH     r0,[sp,#0xc]
;;;1623   
;;;1624   	ret = lbs_cmd_with_response(priv, CMD_802_11_RF_CHANNEL, &cmd);
00001c  aa01              ADD      r2,sp,#4
00001e  211d              MOVS     r1,#0x1d
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       lbs_cmd_with_response
000026  4604              MOV      r4,r0
;;;1625   	if (ret)
000028  b104              CBZ      r4,|L25.44|
;;;1626   		goto out;
00002a  e002              B        |L25.50|
                  |L25.44|
;;;1627   
;;;1628   	ret = le16_to_cpu(cmd.channel);
00002c  f8bd400e          LDRH     r4,[sp,#0xe]
;;;1629   	lbs_deb_cmd("current radio channel is %d\n", ret);
;;;1630   
;;;1631   out:
000030  bf00              NOP      
                  |L25.50|
;;;1632   	lbs_deb_cmd_leave_args(LBS_DEB_CMD, ret);
;;;1633   	return ret;
000032  4620              MOV      r0,r4
;;;1634   }
000034  b00d              ADD      sp,sp,#0x34
000036  bd30              POP      {r4,r5,pc}
;;;1635   
                          ENDP


                          AREA ||i.lbs_get_cmd_ctrl_node||, CODE, READONLY, ALIGN=1

                  lbs_get_cmd_ctrl_node PROC
;;;66      */
;;;67     static struct cmd_ctrl_node *lbs_get_cmd_ctrl_node(struct lbs_private *priv)
000000  4601              MOV      r1,r0
;;;68     {
;;;69     	struct cmd_ctrl_node *tempnode;
;;;70     //	unsigned long flags;
;;;71     
;;;72     	//lbs_deb_cmd_enter(LBS_DEB_HOST);
;;;73     
;;;74     	if (!priv)
000002  b909              CBNZ     r1,|L26.8|
;;;75     		return NULL;
000004  2000              MOVS     r0,#0
                  |L26.6|
;;;76     	//lbs_deb_cmd_leave(LBS_DEB_HOST);
;;;77     	return tempnode;
;;;78     }
000006  4770              BX       lr
                  |L26.8|
000008  4610              MOV      r0,r2                 ;77
00000a  e7fc              B        |L26.6|
;;;79     
                          ENDP


                          AREA ||i.lbs_get_tx_power||, CODE, READONLY, ALIGN=1

                  lbs_get_tx_power PROC
;;;228     */
;;;229    int lbs_get_tx_power(struct lbs_private *priv, s16 *curlevel, s16 *minlevel,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;230    		     s16 *maxlevel)
;;;231    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;232    	struct cmd_ds_802_11_rf_tx_power cmd;//每个cmd前面会嵌套一个cmd_header结构
;;;233    	int ret;
;;;234    
;;;235    	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;236    
;;;237    	memset(&cmd, 0, sizeof(cmd));
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  9001              STR      r0,[sp,#4]
000012  9002              STR      r0,[sp,#8]
000014  9003              STR      r0,[sp,#0xc]
;;;238    	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000016  200e              MOVS     r0,#0xe
000018  f8ad0002          STRH     r0,[sp,#2]
;;;239    	cmd.action = cpu_to_le16(CMD_ACT_GET);
00001c  2000              MOVS     r0,#0
00001e  f8ad0008          STRH     r0,[sp,#8]
;;;240    
;;;241    	ret = lbs_cmd_with_response(priv, CMD_802_11_RF_TX_POWER, &cmd);
000022  466a              MOV      r2,sp
000024  211e              MOVS     r1,#0x1e
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       lbs_cmd_with_response
00002c  4607              MOV      r7,r0
;;;242    	if (ret == 0) {
00002e  b95f              CBNZ     r7,|L27.72|
;;;243    		*curlevel = le16_to_cpu(cmd.curlevel);
000030  f8bd000a          LDRH     r0,[sp,#0xa]
000034  b200              SXTH     r0,r0
000036  8030              STRH     r0,[r6,#0]
;;;244    		if (minlevel)
000038  b114              CBZ      r4,|L27.64|
;;;245    			*minlevel = cmd.minlevel;
00003a  f99d000d          LDRSB    r0,[sp,#0xd]
00003e  8020              STRH     r0,[r4,#0]
                  |L27.64|
;;;246    		if (maxlevel)
000040  b115              CBZ      r5,|L27.72|
;;;247    			*maxlevel = cmd.maxlevel;
000042  f99d000c          LDRSB    r0,[sp,#0xc]
000046  8028              STRH     r0,[r5,#0]
                  |L27.72|
;;;248    	}
;;;249    
;;;250    	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;251    	return ret;
000048  4638              MOV      r0,r7
;;;252    }
00004a  b004              ADD      sp,sp,#0x10
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;253    
                          ENDP


                          AREA ||i.lbs_prepare_and_send_command||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  lbs_prepare_and_send_command PROC
;;;1394    */
;;;1395   int lbs_prepare_and_send_command(struct lbs_private *priv,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1396   			  u16 cmd_no,
;;;1397   			  u16 cmd_action,
;;;1398   			  u16 wait_option, u32 cmd_oid, void *pdata_buf)
;;;1399   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  f8dda044          LDR      r10,[sp,#0x44]
;;;1400   	int ret = 0;
000010  2700              MOVS     r7,#0
;;;1401   	struct cmd_ctrl_node *cmdnode;
;;;1402   	struct cmd_ds_command *cmdptr;
;;;1403    //	unsigned long flags;
;;;1404   	unsigned long time_out=1000;
000012  f44f707a          MOV      r0,#0x3e8
000016  9002              STR      r0,[sp,#8]
;;;1405   	struct if_sdio_card *card=priv->card;
000018  f8d5b028          LDR      r11,[r5,#0x28]
;;;1406   	
;;;1407   	 lbs_deb_cmd_enter(LBS_DEB_HOST);
;;;1408   
;;;1409   	if (!priv) {
00001c  b90d              CBNZ     r5,|L28.34|
;;;1410   		lbs_deb_host("PREP_CMD: priv is NULL\n");
;;;1411   		ret = -1;
00001e  1e7f              SUBS     r7,r7,#1
;;;1412   		goto done;
000020  e10d              B        |L28.574|
                  |L28.34|
;;;1413   	}
;;;1414   
;;;1415   	if (priv->surpriseremoved) {
000022  f89501ec          LDRB     r0,[r5,#0x1ec]
000026  b110              CBZ      r0,|L28.46|
;;;1416   		lbs_deb_host("PREP_CMD: card removed\n");
;;;1417   		ret = -1;
000028  f04f37ff          MOV      r7,#0xffffffff
;;;1418   		goto done;
00002c  e107              B        |L28.574|
                  |L28.46|
;;;1419   	}
;;;1420   
;;;1421   	cmdnode = lbs_get_cmd_ctrl_node(priv);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       lbs_get_cmd_ctrl_node
000034  4606              MOV      r6,r0
;;;1422   
;;;1423   	if (cmdnode == NULL) {
000036  b92e              CBNZ     r6,|L28.68|
;;;1424   		lbs_deb_host("PREP_CMD: cmdnode is NULL\n");
;;;1425   
;;;1426   		/* Wake up main thread to execute next command */
;;;1427   		//wake_up_interruptible(&priv->waitq);
;;;1428   		lbs_thread(priv);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       lbs_thread
;;;1429   		ret = -1;
00003e  f04f37ff          MOV      r7,#0xffffffff
;;;1430   		goto done;
000042  e0fc              B        |L28.574|
                  |L28.68|
;;;1431   	}
;;;1432   
;;;1433   	cmdnode->callback = NULL;
000044  2000              MOVS     r0,#0
000046  60f0              STR      r0,[r6,#0xc]
;;;1434   	cmdnode->callback_arg = (unsigned long)pdata_buf;
000048  f8c6a010          STR      r10,[r6,#0x10]
;;;1435   
;;;1436   	cmdptr = (struct cmd_ds_command *)cmdnode->cmdbuf;
00004c  6974              LDR      r4,[r6,#0x14]
;;;1437   
;;;1438   	lbs_deb_host("PREP_CMD: command 0x%04x\n", cmd_no);
;;;1439   
;;;1440   	/* Set sequence number, command and INT option */
;;;1441   	priv->seqnum++;
00004e  f8350f74          LDRH     r0,[r5,#0x74]!
000052  1c40              ADDS     r0,r0,#1
000054  8028              STRH     r0,[r5,#0]
;;;1442   	cmdptr->seqnum = cpu_to_le16(priv->seqnum);
000056  f8350974          LDRH     r0,[r5],#-0x74
00005a  80a0              STRH     r0,[r4,#4]
;;;1443   
;;;1444   	cmdptr->command = cpu_to_le16(cmd_no);
00005c  f8a48000          STRH     r8,[r4,#0]
;;;1445   	cmdptr->result = 0;
000060  2000              MOVS     r0,#0
000062  80e0              STRH     r0,[r4,#6]
;;;1446   
;;;1447   	switch (cmd_no) {
000064  f1b80f4e          CMP      r8,#0x4e
000068  d063              BEQ      |L28.306|
00006a  dc17              BGT      |L28.156|
00006c  f1b80f1f          CMP      r8,#0x1f
000070  d040              BEQ      |L28.244|
000072  dc09              BGT      |L28.136|
000074  f1b80f19          CMP      r8,#0x19
000078  d02b              BEQ      |L28.210|
00007a  f1b80f1a          CMP      r8,#0x1a
00007e  d029              BEQ      |L28.212|
000080  f1b80f1b          CMP      r8,#0x1b
000084  d170              BNE      |L28.360|
000086  e026              B        |L28.214|
                  |L28.136|
000088  f1b80f21          CMP      r8,#0x21
00008c  d01b              BEQ      |L28.198|
00008e  f1b80f3c          CMP      r8,#0x3c
000092  d035              BEQ      |L28.256|
000094  f1b80f3d          CMP      r8,#0x3d
000098  d17b              BNE      |L28.402|
00009a  e032              B        |L28.258|
                  |L28.156|
00009c  f1b80f95          CMP      r8,#0x95
0000a0  d063              BEQ      |L28.362|
0000a2  dc09              BGT      |L28.184|
0000a4  f1b80f72          CMP      r8,#0x72
0000a8  d037              BEQ      |L28.282|
0000aa  f1b80f80          CMP      r8,#0x80
0000ae  d063              BEQ      |L28.376|
0000b0  f1b80f87          CMP      r8,#0x87
0000b4  d16d              BNE      |L28.402|
0000b6  e050              B        |L28.346|
                  |L28.184|
0000b8  f1b80f98          CMP      r8,#0x98
0000bc  d013              BEQ      |L28.230|
0000be  f1b80fb0          CMP      r8,#0xb0
0000c2  d166              BNE      |L28.402|
0000c4  e05e              B        |L28.388|
                  |L28.198|
;;;1448   	case CMD_802_11_PS_MODE:
;;;1449   		ret = lbs_cmd_802_11_ps_mode(cmdptr, cmd_action);
0000c6  4649              MOV      r1,r9
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       lbs_cmd_802_11_ps_mode
0000ce  4607              MOV      r7,r0
;;;1450   		break;
0000d0  e066              B        |L28.416|
                  |L28.210|
;;;1451   
;;;1452   	case CMD_MAC_REG_ACCESS:
;;;1453   	case CMD_BBP_REG_ACCESS:
0000d2  bf00              NOP      
                  |L28.212|
;;;1454   	case CMD_RF_REG_ACCESS:
0000d4  bf00              NOP      
                  |L28.214|
;;;1455   		ret = lbs_cmd_reg_access(cmdptr, cmd_action, pdata_buf);
0000d6  4652              MOV      r2,r10
0000d8  f00901ff          AND      r1,r9,#0xff
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       lbs_cmd_reg_access
0000e2  4607              MOV      r7,r0
;;;1456   		break;
0000e4  e05c              B        |L28.416|
                  |L28.230|
;;;1457   
;;;1458   	case CMD_802_11_MONITOR_MODE:
;;;1459   		ret = lbs_cmd_802_11_monitor_mode(cmdptr,
0000e6  4652              MOV      r2,r10
0000e8  4649              MOV      r1,r9
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       lbs_cmd_802_11_monitor_mode
0000f0  4607              MOV      r7,r0
;;;1460   				          cmd_action, pdata_buf);
;;;1461   		break;
0000f2  e055              B        |L28.416|
                  |L28.244|
;;;1462   
;;;1463   	case CMD_802_11_RSSI:
;;;1464   		ret = lbs_cmd_802_11_rssi(priv, cmdptr);
0000f4  4621              MOV      r1,r4
0000f6  4628              MOV      r0,r5
0000f8  f7fffffe          BL       lbs_cmd_802_11_rssi
0000fc  4607              MOV      r7,r0
;;;1465   		break;
0000fe  e04f              B        |L28.416|
                  |L28.256|
;;;1466   
;;;1467   	case CMD_802_11_SET_AFC:
;;;1468   	case CMD_802_11_GET_AFC:
000100  bf00              NOP      
                  |L28.258|
;;;1469   
;;;1470   		cmdptr->command = cpu_to_le16(cmd_no);
000102  f8a48000          STRH     r8,[r4,#0]
;;;1471   		cmdptr->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_afc) +
000106  2012              MOVS     r0,#0x12
000108  8060              STRH     r0,[r4,#2]
;;;1472   					   S_DS_GEN);
;;;1473   
;;;1474   		memmove(&cmdptr->params.afc,
00010a  2206              MOVS     r2,#6
00010c  4651              MOV      r1,r10
00010e  f1040008          ADD      r0,r4,#8
000112  f7fffffe          BL       __aeabi_memmove
;;;1475   			pdata_buf, sizeof(struct cmd_ds_802_11_afc));
;;;1476   
;;;1477   		ret = 0;
000116  2700              MOVS     r7,#0
;;;1478   		goto done;
000118  e091              B        |L28.574|
                  |L28.282|
;;;1479   #ifdef MASK_DEBUG
;;;1480   	case CMD_802_11D_DOMAIN_INFO:
;;;1481   		ret = lbs_cmd_802_11d_domain_info(priv, cmdptr,
;;;1482   						   cmd_no, cmd_action);
;;;1483   		break;
;;;1484   #endif
;;;1485   	case CMD_802_11_TPC_CFG:
;;;1486   		cmdptr->command = cpu_to_le16(CMD_802_11_TPC_CFG);
00011a  2072              MOVS     r0,#0x72
00011c  8020              STRH     r0,[r4,#0]
;;;1487   		cmdptr->size =
00011e  201b              MOVS     r0,#0x1b
000120  8060              STRH     r0,[r4,#2]
;;;1488   		    cpu_to_le16(sizeof(struct cmd_ds_802_11_tpc_cfg) +
;;;1489   				     S_DS_GEN);
;;;1490   
;;;1491   		memmove(&cmdptr->params.tpccfg,
000122  220f              MOVS     r2,#0xf
000124  4651              MOV      r1,r10
000126  f1040008          ADD      r0,r4,#8
00012a  f7fffffe          BL       __aeabi_memmove
;;;1492   			pdata_buf, sizeof(struct cmd_ds_802_11_tpc_cfg));
;;;1493   
;;;1494   		ret = 0;
00012e  2700              MOVS     r7,#0
;;;1495   		break;
000130  e036              B        |L28.416|
                  |L28.306|
;;;1496   	case CMD_802_11_LED_GPIO_CTRL:
;;;1497   		{
;;;1498   			struct mrvl_ie_ledgpio *gpio =
000132  f104000c          ADD      r0,r4,#0xc
000136  9001              STR      r0,[sp,#4]
;;;1499   			    (struct mrvl_ie_ledgpio*)
;;;1500   			    cmdptr->params.ledgpio.data;
;;;1501   
;;;1502   			memmove(&cmdptr->params.ledgpio,
000138  f44f7282          MOV      r2,#0x104
00013c  4651              MOV      r1,r10
00013e  1f00              SUBS     r0,r0,#4
000140  f7fffffe          BL       __aeabi_memmove
;;;1503   				pdata_buf,
;;;1504   				sizeof(struct cmd_ds_802_11_led_ctrl));
;;;1505   
;;;1506   			cmdptr->command =
000144  204e              MOVS     r0,#0x4e
000146  8020              STRH     r0,[r4,#0]
;;;1507   			    cpu_to_le16(CMD_802_11_LED_GPIO_CTRL);
;;;1508   
;;;1509   #define ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN 8
;;;1510   			cmdptr->size =
000148  9801              LDR      r0,[sp,#4]
00014a  8840              LDRH     r0,[r0,#2]
00014c  3014              ADDS     r0,r0,#0x14
00014e  8060              STRH     r0,[r4,#2]
;;;1511   			    cpu_to_le16(le16_to_cpu(gpio->header.len)
;;;1512   				+ S_DS_GEN
;;;1513   				+ ACTION_NUMLED_TLVTYPE_LEN_FIELDS_LEN);
;;;1514   			gpio->header.len = gpio->header.len;
000150  9801              LDR      r0,[sp,#4]
000152  8841              LDRH     r1,[r0,#2]
000154  8041              STRH     r1,[r0,#2]
;;;1515   
;;;1516   			ret = 0;
000156  2700              MOVS     r7,#0
;;;1517   			break;
000158  e022              B        |L28.416|
                  |L28.346|
;;;1518   		}
;;;1519   
;;;1520   	case CMD_BT_ACCESS:
;;;1521   		ret = lbs_cmd_bt_access(cmdptr, cmd_action, pdata_buf);
00015a  4652              MOV      r2,r10
00015c  4649              MOV      r1,r9
00015e  4620              MOV      r0,r4
000160  f7fffffe          BL       lbs_cmd_bt_access
000164  4607              MOV      r7,r0
;;;1522   		break;
000166  e01b              B        |L28.416|
                  |L28.360|
000168  e013              B        |L28.402|
                  |L28.362|
;;;1523   
;;;1524   	case CMD_FWT_ACCESS:
;;;1525   		ret = lbs_cmd_fwt_access(cmdptr, cmd_action, pdata_buf);
00016a  4652              MOV      r2,r10
00016c  4649              MOV      r1,r9
00016e  4620              MOV      r0,r4
000170  f7fffffe          BL       lbs_cmd_fwt_access
000174  4607              MOV      r7,r0
;;;1526   		break;
000176  e013              B        |L28.416|
                  |L28.376|
;;;1527   
;;;1528   	case CMD_GET_TSF:
;;;1529   		cmdptr->command = cpu_to_le16(CMD_GET_TSF);
000178  2080              MOVS     r0,#0x80
00017a  8020              STRH     r0,[r4,#0]
;;;1530   		cmdptr->size = cpu_to_le16(sizeof(struct cmd_ds_get_tsf) +
00017c  2014              MOVS     r0,#0x14
00017e  8060              STRH     r0,[r4,#2]
;;;1531   					   S_DS_GEN);
;;;1532   		ret = 0;
000180  2700              MOVS     r7,#0
;;;1533   		break;
000182  e00d              B        |L28.416|
                  |L28.388|
;;;1534   	case CMD_802_11_BEACON_CTRL:
;;;1535   		ret = lbs_cmd_bcn_ctrl(priv, cmdptr, cmd_action);
000184  464a              MOV      r2,r9
000186  4621              MOV      r1,r4
000188  4628              MOV      r0,r5
00018a  f7fffffe          BL       lbs_cmd_bcn_ctrl
00018e  4607              MOV      r7,r0
;;;1536   		break;
000190  e006              B        |L28.416|
                  |L28.402|
;;;1537   	default:
;;;1538   		lbs_pr_err("PREP_CMD: unknown command 0x%04x\n", cmd_no);
000192  4641              MOV      r1,r8
000194  a02c              ADR      r0,|L28.584|
000196  f7fffffe          BL       __2printf
;;;1539   		ret = -1;
00019a  f04f37ff          MOV      r7,#0xffffffff
;;;1540   		break;
00019e  bf00              NOP      
                  |L28.416|
0001a0  bf00              NOP                            ;1450
;;;1541   	}
;;;1542   
;;;1543   	/* return error, since the command preparation failed */
;;;1544   	if (ret != 0) {
0001a2  b137              CBZ      r7,|L28.434|
;;;1545   		lbs_deb_host("PREP_CMD: command preparation failed\n");
;;;1546   		lbs_cleanup_and_insert_cmd(priv, cmdnode);
0001a4  4631              MOV      r1,r6
0001a6  4628              MOV      r0,r5
0001a8  f7fffffe          BL       lbs_cleanup_and_insert_cmd
;;;1547   		ret = -1;
0001ac  f04f37ff          MOV      r7,#0xffffffff
;;;1548   		goto done;
0001b0  e045              B        |L28.574|
                  |L28.434|
;;;1549   	}
;;;1550   
;;;1551   	cmdnode->cmdwaitqwoken = 0;
0001b2  2000              MOVS     r0,#0
0001b4  8330              STRH     r0,[r6,#0x18]
;;;1552   
;;;1553   	lbs_queue_cmd(priv, cmdnode);
0001b6  4631              MOV      r1,r6
0001b8  4628              MOV      r0,r5
0001ba  f7fffffe          BL       lbs_queue_cmd
;;;1554   	//wake_up_interruptible(&priv->waitq);//唤醒主线程
;;;1555   	lbs_thread(priv);
0001be  4628              MOV      r0,r5
0001c0  f7fffffe          BL       lbs_thread
;;;1556   	
;;;1557   	if (wait_option & CMD_OPTION_WAITFORRSP) {
0001c4  9806              LDR      r0,[sp,#0x18]
0001c6  f0100f02          TST      r0,#2
0001ca  d030              BEQ      |L28.558|
;;;1558   		lbs_deb_host("PREP_CMD: wait for response\n");
;;;1559   		//might_sleep();
;;;1560   		/*wait_event_interruptible(cmdnode->cmdwait_q,
;;;1561   					 cmdnode->cmdwaitqwoken);*/
;;;1562   	while(1){
0001cc  e029              B        |L28.546|
                  |L28.462|
;;;1563   		
;;;1564   		ret=pool_sdio_interrupt(card->func);
0001ce  f8db0000          LDR      r0,[r11,#0]
0001d2  f7fffffe          BL       pool_sdio_interrupt
0001d6  4607              MOV      r7,r0
;;;1565   		if(ret<0){
0001d8  2f00              CMP      r7,#0
0001da  da04              BGE      |L28.486|
;;;1566   			lbs_pr_err("read interrupt error!\n");
0001dc  a023              ADR      r0,|L28.620|
0001de  f7fffffe          BL       __2printf
;;;1567   			try_bug(0);
0001e2  bf00              NOP      
                  |L28.484|
0001e4  e7fe              B        |L28.484|
                  |L28.486|
;;;1568   		}
;;;1569   		else if(ret&IF_SDIO_H_INT_DNLD)
0001e6  f0170f02          TST      r7,#2
0001ea  d004              BEQ      |L28.502|
;;;1570   				if_sdio_interrupt(card->func);
0001ec  f8db0000          LDR      r0,[r11,#0]
0001f0  f7fffffe          BL       if_sdio_interrupt
0001f4  e015              B        |L28.546|
                  |L28.502|
;;;1571   		else if(ret&IF_SDIO_H_INT_UPLD){//读到数据中断
0001f6  f0170f01          TST      r7,#1
0001fa  d004              BEQ      |L28.518|
;;;1572   			if_sdio_interrupt(card->func);
0001fc  f8db0000          LDR      r0,[r11,#0]
000200  f7fffffe          BL       if_sdio_interrupt
;;;1573   			break;
000204  e00e              B        |L28.548|
                  |L28.518|
;;;1574   		}
;;;1575   		else if(time_after(jiffies,&time_out)){
000206  a902              ADD      r1,sp,#8
000208  2000              MOVS     r0,#0
00020a  f7fffffe          BL       time_after
00020e  b140              CBZ      r0,|L28.546|
;;;1576   			priv->cmd_timed_out=1;
000210  2001              MOVS     r0,#1
000212  f8c500ac          STR      r0,[r5,#0xac]
;;;1577   			 lbs_thread(priv);//处理超时
000216  4628              MOV      r0,r5
000218  f7fffffe          BL       lbs_thread
;;;1578   			 ret=-ETIME;
00021c  f06f0748          MVN      r7,#0x48
;;;1579   			 break;
000220  e000              B        |L28.548|
                  |L28.546|
000222  e7d4              B        |L28.462|
                  |L28.548|
000224  bf00              NOP                            ;1573
;;;1580   			}
;;;1581   		}
;;;1582   	 
;;;1583   	while(!cmdnode->cmdwaitqwoken);//等待命令处理完成		
000226  bf00              NOP      
                  |L28.552|
000228  8b30              LDRH     r0,[r6,#0x18]
00022a  2800              CMP      r0,#0
00022c  d0fc              BEQ      |L28.552|
                  |L28.558|
;;;1584   		
;;;1585   	}
;;;1586   
;;;1587   	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;1588   	if (priv->cur_cmd_retcode) {
00022e  f8d50080          LDR      r0,[r5,#0x80]
000232  b118              CBZ      r0,|L28.572|
;;;1589   		lbs_deb_host("PREP_CMD: command failed with return code %d\n",
;;;1590   		       priv->cur_cmd_retcode);
;;;1591   		priv->cur_cmd_retcode = 0;
000234  2000              MOVS     r0,#0
000236  f8c50080          STR      r0,[r5,#0x80]
;;;1592   		ret = -1;
00023a  1e47              SUBS     r7,r0,#1
                  |L28.572|
;;;1593   	}
;;;1594   	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;1595   
;;;1596   done:
00023c  bf00              NOP      
                  |L28.574|
;;;1597   	lbs_deb_cmd_leave_args(LBS_DEB_HOST, ret);
;;;1598   	return ret;
00023e  4638              MOV      r0,r7
;;;1599   }
000240  b007              ADD      sp,sp,#0x1c
000242  e8bd8ff0          POP      {r4-r11,pc}
;;;1600   
                          ENDP

000246  0000              DCW      0x0000
                  |L28.584|
000248  50524550          DCB      "PREP_CMD: unknown command 0x%04x\n",0
00024c  5f434d44
000250  3a20756e
000254  6b6e6f77
000258  6e20636f
00025c  6d6d616e
000260  64203078
000264  25303478
000268  0a00    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L28.620|
00026c  72656164          DCB      "read interrupt error!\n",0
000270  20696e74
000274  65727275
000278  70742065
00027c  72726f72
000280  210a00  
000283  00                DCB      0

                          AREA ||i.lbs_process_command_response||, CODE, READONLY, ALIGN=1

                  lbs_process_command_response PROC
;;;782    
;;;783    int lbs_process_command_response(struct lbs_private *priv, u8 *data, u32 len)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;784    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;785    	uint16_t respcmd, curcmd;
;;;786    	struct cmd_header *resp;
;;;787    	int ret = 0;
000008  f04f0b00          MOV      r11,#0
;;;788    //	unsigned long flags;
;;;789    	uint16_t result;
;;;790    
;;;791    	 lbs_deb_cmd_enter("enter lbs_process_command_response!\n");
;;;792    
;;;793    	//mutex_lock(&priv->lock);
;;;794    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;795    
;;;796    	if (!priv->cur_cmd) {
00000c  6fe0              LDR      r0,[r4,#0x7c]
00000e  b910              CBNZ     r0,|L29.22|
;;;797    		lbs_deb_host("CMD_RESP: cur_cmd is NULL\n");
;;;798    		ret = -1;
000010  f04f3bff          MOV      r11,#0xffffffff
;;;799    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;800    		goto done;
000014  e093              B        |L29.318|
                  |L29.22|
;;;801    	}
;;;802    
;;;803    	resp = (void *)data;
000016  463d              MOV      r5,r7
;;;804    	curcmd = le16_to_cpu(priv->cur_cmd->cmdbuf->command);
000018  6fe0              LDR      r0,[r4,#0x7c]
00001a  6940              LDR      r0,[r0,#0x14]
00001c  f8b09000          LDRH     r9,[r0,#0]
;;;805    	respcmd = le16_to_cpu(resp->command);
000020  882e              LDRH     r6,[r5,#0]
;;;806    	result = le16_to_cpu(resp->result);
000022  f8b58006          LDRH     r8,[r5,#6]
;;;807    
;;;808    	lbs_deb_cmd("CMD_RESP: response 0x%04x, seq %d, size %d\n",
;;;809    		     respcmd, le16_to_cpu(resp->seqnum), len);
;;;810    	//lbs_deb_hex(LBS_DEB_CMD, "CMD_RESP", (void *) resp, len);
;;;811    
;;;812    	if (resp->seqnum != priv->cur_cmd->cmdbuf->seqnum) {//当前序列和响应序列不一致说明出错
000026  88a8              LDRH     r0,[r5,#4]
000028  6fe1              LDR      r1,[r4,#0x7c]
00002a  6949              LDR      r1,[r1,#0x14]
00002c  8889              LDRH     r1,[r1,#4]
00002e  4288              CMP      r0,r1
000030  d002              BEQ      |L29.56|
;;;813    		lbs_pr_info("Received CMD_RESP with invalid sequence %d (expected %d)\n",
;;;814    			    le16_to_cpu(resp->seqnum), le16_to_cpu(priv->cur_cmd->cmdbuf->seqnum));
;;;815    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;816    		ret = -1;
000032  f04f3bff          MOV      r11,#0xffffffff
;;;817    		goto done;
000036  e082              B        |L29.318|
                  |L29.56|
;;;818    	}
;;;819    	if (respcmd != CMD_RET(curcmd) &&
000038  f4494000          ORR      r0,r9,#0x8000
00003c  42b0              CMP      r0,r6
00003e  d009              BEQ      |L29.84|
;;;820    	    respcmd != CMD_RET_802_11_ASSOCIATE && curcmd != CMD_802_11_ASSOCIATE) {
000040  f5a64000          SUB      r0,r6,#0x8000
000044  3812              SUBS     r0,r0,#0x12
000046  d005              BEQ      |L29.84|
000048  f1b90f50          CMP      r9,#0x50
00004c  d002              BEQ      |L29.84|
;;;821    		lbs_pr_info("Invalid CMD_RESP %x to command %x!\n", respcmd, curcmd);
;;;822    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;823    		ret = -1;
00004e  f04f3bff          MOV      r11,#0xffffffff
;;;824    		goto done;
000052  e074              B        |L29.318|
                  |L29.84|
;;;825    	}
;;;826    
;;;827    	if (resp->result == cpu_to_le16(0x0004)) {
000054  88e8              LDRH     r0,[r5,#6]
000056  2804              CMP      r0,#4
000058  d102              BNE      |L29.96|
;;;828    		/* 0x0004 means -EAGAIN. Drop the response, let it time out
;;;829    		   and be resubmitted */
;;;830    		lbs_pr_info("Firmware returns DEFER to command %x. Will let it time out...\n",
;;;831    			    le16_to_cpu(resp->command));
;;;832    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;833    		ret = -1;
00005a  f04f3bff          MOV      r11,#0xffffffff
;;;834    		goto done;
00005e  e06e              B        |L29.318|
                  |L29.96|
;;;835    	}
;;;836    
;;;837    	/* Now we got response from FW, cancel the command timer */
;;;838    	//del_timer(&priv->command_timer);//删除超时定时器
;;;839    	priv->cmd_timed_out = 0;
000060  2000              MOVS     r0,#0
000062  f8c400ac          STR      r0,[r4,#0xac]
;;;840    	if (priv->nr_retries) {
000066  f8d400a8          LDR      r0,[r4,#0xa8]
00006a  b110              CBZ      r0,|L29.114|
;;;841    		lbs_pr_info("Received result %x to command %x after %d retries\n",
;;;842    			    result, curcmd, priv->nr_retries);
;;;843    		priv->nr_retries = 0;
00006c  2000              MOVS     r0,#0
00006e  f8c400a8          STR      r0,[r4,#0xa8]
                  |L29.114|
;;;844    	}
;;;845    
;;;846    	/* Store the response code to cur_cmd_retcode. */
;;;847    	priv->cur_cmd_retcode = result;
000072  f8c48080          STR      r8,[r4,#0x80]
;;;848    	//以下是关于低功耗的处理单独列出来
;;;849    	if (respcmd == CMD_RET(CMD_802_11_PS_MODE)) {//如果发送的命令是ps，就是power save模式
000076  f5a64000          SUB      r0,r6,#0x8000
00007a  3821              SUBS     r0,r0,#0x21
00007c  d12d              BNE      |L29.218|
;;;850    		struct cmd_ds_802_11_ps_mode *psmode = (void *) &resp[1];
00007e  f1050008          ADD      r0,r5,#8
000082  9000              STR      r0,[sp,#0]
;;;851    		u16 action = le16_to_cpu(psmode->action);
000084  9800              LDR      r0,[sp,#0]
000086  f8b0a000          LDRH     r10,[r0,#0]
;;;852    
;;;853    		lbs_deb_host(
;;;854    		       "CMD_RESP: PS_MODE cmd reply result 0x%x, action 0x%x\n",
;;;855    		       result, action);
;;;856    
;;;857    		if (result) {//CMD_802_11_PS_MODE命令失败
00008a  f1b80f00          CMP      r8,#0
00008e  d00a              BEQ      |L29.166|
;;;858    			lbs_deb_host("CMD_RESP: PS command failed with 0x%x\n",
;;;859    				    result);
;;;860    			/*
;;;861    			 * We should not re-try enter-ps command in
;;;862    			 * ad-hoc mode. It takes place in
;;;863    			 * lbs_execute_next_command().
;;;864    			 */
;;;865    			if (priv->mode == IW_MODE_ADHOC &&
000090  f89400e9          LDRB     r0,[r4,#0xe9]
000094  2801              CMP      r0,#1
000096  d118              BNE      |L29.202|
;;;866    			    action == CMD_SUBCMD_ENTER_PS)
000098  f1ba0f30          CMP      r10,#0x30
00009c  d115              BNE      |L29.202|
;;;867    				priv->psmode = LBS802_11POWERMODECAM;
00009e  2000              MOVS     r0,#0
0000a0  f8a401ee          STRH     r0,[r4,#0x1ee]
0000a4  e011              B        |L29.202|
                  |L29.166|
;;;868    		} else if (action == CMD_SUBCMD_ENTER_PS) {
0000a6  f1ba0f30          CMP      r10,#0x30
0000aa  d106              BNE      |L29.186|
;;;869    			priv->needtowakeup = 0;
0000ac  2000              MOVS     r0,#0
0000ae  f88401f4          STRB     r0,[r4,#0x1f4]
;;;870    			priv->psstate = PS_STATE_AWAKE;
0000b2  2001              MOVS     r0,#1
0000b4  f8c401f0          STR      r0,[r4,#0x1f0]
;;;871    
;;;872    			lbs_deb_host("CMD_RESP: ENTER_PS command response\n");
;;;873    			if (priv->connect_status != LBS_CONNECTED) {//进入低功耗模式之前必须保持网络连接
0000b8  e007              B        |L29.202|
                  |L29.186|
;;;874    				/*
;;;875    				 * When Deauth Event received before Enter_PS command
;;;876    				 * response, We need to wake up the firmware.
;;;877    				 */
;;;878    				lbs_deb_host(
;;;879    				       "disconnected, invoking lbs_ps_wakeup\n");
;;;880    
;;;881    				/*spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;882    				mutex_unlock(&priv->lock);
;;;883    				lbs_ps_wakeup(priv, 0);//退出低功耗模式
;;;884    				mutex_lock(&priv->lock);
;;;885    				spin_lock_irqsave(&priv->driver_lock, flags);*/
;;;886    			}
;;;887    		} else if (action == CMD_SUBCMD_EXIT_PS) {
0000ba  f1ba0f31          CMP      r10,#0x31
0000be  d104              BNE      |L29.202|
;;;888    			priv->needtowakeup = 0;
0000c0  2000              MOVS     r0,#0
0000c2  f88401f4          STRB     r0,[r4,#0x1f4]
;;;889    			priv->psstate = PS_STATE_FULL_POWER;
0000c6  f8c401f0          STR      r0,[r4,#0x1f0]
                  |L29.202|
;;;890    			lbs_deb_host("CMD_RESP: EXIT_PS command response\n");
;;;891    		} else {
;;;892    			lbs_deb_host("CMD_RESP: PS action 0x%X\n", action);
;;;893    		}
;;;894    
;;;895    		lbs_complete_command(priv, priv->cur_cmd, result);//唤醒命令等待队列，并清除命令
0000ca  4642              MOV      r2,r8
0000cc  4620              MOV      r0,r4
0000ce  6fe1              LDR      r1,[r4,#0x7c]
0000d0  f7fffffe          BL       lbs_complete_command
;;;896    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;897    
;;;898    		ret = 0;
0000d4  f04f0b00          MOV      r11,#0
;;;899    		goto done;
0000d8  e031              B        |L29.318|
                  |L29.218|
;;;900    	}
;;;901    
;;;902    	/* If the command is not successful, cleanup and return failure */
;;;903    	if ((result != 0 || !(respcmd & 0x8000))) {//出错处理
0000da  f1b80f00          CMP      r8,#0
0000de  d102              BNE      |L29.230|
0000e0  f4164f00          TST      r6,#0x8000
0000e4  d111              BNE      |L29.266|
                  |L29.230|
;;;904    		lbs_deb_host("CMD_RESP: error 0x%04x in command reply 0x%04x\n",
;;;905    		       result, respcmd);
;;;906    		/*
;;;907    		 * Handling errors here
;;;908    		 */
;;;909    		switch (respcmd) {
0000e6  f5a64000          SUB      r0,r6,#0x8000
0000ea  3803              SUBS     r0,#3
0000ec  d002              BEQ      |L29.244|
0000ee  2802              CMP      r0,#2
0000f0  d102              BNE      |L29.248|
0000f2  e000              B        |L29.246|
                  |L29.244|
;;;910    		case CMD_RET(CMD_GET_HW_SPEC):
;;;911    		case CMD_RET(CMD_802_11_RESET):
0000f4  bf00              NOP      
                  |L29.246|
;;;912    			lbs_deb_host("CMD_RESP: reset failed\n");
;;;913    			break;
0000f6  bf00              NOP      
                  |L29.248|
0000f8  bf00              NOP      
;;;914    
;;;915    		}
;;;916    		lbs_complete_command(priv, priv->cur_cmd, result);
0000fa  4642              MOV      r2,r8
0000fc  4620              MOV      r0,r4
0000fe  6fe1              LDR      r1,[r4,#0x7c]
000100  f7fffffe          BL       lbs_complete_command
;;;917    		//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;918    
;;;919    		ret = -1;
000104  f04f3bff          MOV      r11,#0xffffffff
;;;920    		goto done;
000108  e019              B        |L29.318|
                  |L29.266|
;;;921    	}
;;;922    
;;;923    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;924    
;;;925    	if (priv->cur_cmd && priv->cur_cmd->callback) {
00010a  6fe0              LDR      r0,[r4,#0x7c]
00010c  b150              CBZ      r0,|L29.292|
00010e  6fe0              LDR      r0,[r4,#0x7c]
000110  68c0              LDR      r0,[r0,#0xc]
000112  b138              CBZ      r0,|L29.292|
;;;926    		ret = priv->cur_cmd->callback(priv, priv->cur_cmd->callback_arg,
000114  6fe0              LDR      r0,[r4,#0x7c]
000116  462a              MOV      r2,r5
000118  e9d03103          LDRD     r3,r1,[r0,#0xc]
00011c  4620              MOV      r0,r4
00011e  4798              BLX      r3
000120  4683              MOV      r11,r0
000122  e004              B        |L29.302|
                  |L29.292|
;;;927    				resp);
;;;928    		//如果命令带有回调函数，调用回调函数。
;;;929    		//一般对应是对固件的操作，如读mac等和固件相关的操作
;;;930    		//典型的如lbs_cmd_with_response，会将响应的数据通过回调拷贝到相应的数据区
;;;931    	} else
;;;932    		ret = handle_cmd_response(priv, resp);//没有回调函数的会调用默认的处理方法
000124  4629              MOV      r1,r5
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       handle_cmd_response
00012c  4683              MOV      r11,r0
                  |L29.302|
;;;933    
;;;934    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;935    
;;;936    	if (priv->cur_cmd) {
00012e  6fe0              LDR      r0,[r4,#0x7c]
000130  b120              CBZ      r0,|L29.316|
;;;937    		/* Clean up and Put current command back to cmdfreeq */
;;;938    		lbs_complete_command(priv, priv->cur_cmd, result);
000132  4642              MOV      r2,r8
000134  4620              MOV      r0,r4
000136  6fe1              LDR      r1,[r4,#0x7c]
000138  f7fffffe          BL       lbs_complete_command
                  |L29.316|
;;;939    	}
;;;940    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;941    
;;;942    done:
00013c  bf00              NOP      
                  |L29.318|
;;;943    	//mutex_unlock(&priv->lock);
;;;944    	lbs_deb_cmd_leave_args("leave lbs_process_command_response(ret=%d)\n", ret);
;;;945    	return ret;
00013e  4658              MOV      r0,r11
;;;946    }
000140  e8bd8ff8          POP      {r3-r11,pc}
;;;947    
                          ENDP


                          AREA ||i.lbs_queue_cmd||, CODE, READONLY, ALIGN=1

                  lbs_queue_cmd PROC
;;;84     
;;;85     static void lbs_queue_cmd(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;86     			  struct cmd_ctrl_node *cmdnode)
;;;87     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;88     //	unsigned long flags;
;;;89     	int addtail = 1;
000008  2701              MOVS     r7,#1
;;;90     
;;;91     	//lbs_deb_cmd_enter(LBS_DEB_HOST);
;;;92     
;;;93     	if (!cmdnode) {
00000a  b904              CBNZ     r4,|L30.14|
;;;94     		lbs_deb_host("QUEUE_CMD: cmdnode is NULL\n");
;;;95     		goto done;
00000c  e016              B        |L30.60|
                  |L30.14|
;;;96     	}
;;;97     	if (!cmdnode->cmdbuf->size) {
00000e  6960              LDR      r0,[r4,#0x14]
000010  8840              LDRH     r0,[r0,#2]
000012  b900              CBNZ     r0,|L30.22|
;;;98     		lbs_deb_host("DNLD_CMD: cmd size is zero\n");
;;;99     		goto done;
000014  e012              B        |L30.60|
                  |L30.22|
;;;100    	}
;;;101    	cmdnode->result = 0;
000016  2000              MOVS     r0,#0
000018  60a0              STR      r0,[r4,#8]
;;;102    	//以上是cmdnode的部分常规性检查
;;;103    	/* Exit_PS command needs to be queued in the header always. */
;;;104    	//PS_mode发送命令时必须检查的内容
;;;105    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;106    
;;;107    	if (addtail)
00001a  b12f              CBZ      r7,|L30.40|
;;;108    		list_add_tail(&cmdnode->list, &priv->cmdpendingq);//加入到命令挂起链表尾部，主服务线程在执行next command是会遍历cmdpending链表
00001c  f105018c          ADD      r1,r5,#0x8c
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       list_add_tail
000026  e008              B        |L30.58|
                  |L30.40|
;;;109    	else
;;;110    		list_add(&cmdnode->list, &priv->cmdpendingq);
000028  f105068c          ADD      r6,r5,#0x8c
00002c  4631              MOV      r1,r6
00002e  4620              MOV      r0,r4
000030  6832              LDR      r2,[r6,#0]
000032  f7fffffe          BL       __list_add
000036  bf00              NOP      
000038  bf00              NOP      
                  |L30.58|
;;;111    
;;;112    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;113    
;;;114    	lbs_deb_host("QUEUE_CMD: inserted command 0x%04x into cmdpendingq\n",
;;;115    		     le16_to_cpu(cmdnode->cmdbuf->command));
;;;116    
;;;117    done:
00003a  bf00              NOP      
                  |L30.60|
;;;118    	//lbs_deb_cmd_leave(LBS_DEB_HOST);
;;;119    	return;
;;;120    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;121    
                          ENDP


                          AREA ||i.lbs_remove_wep_keys||, CODE, READONLY, ALIGN=1

                  lbs_remove_wep_keys PROC
;;;2102   
;;;2103   int lbs_remove_wep_keys(struct lbs_private *priv)
000000  b530              PUSH     {r4,r5,lr}
;;;2104   {
000002  b095              SUB      sp,sp,#0x54
000004  4604              MOV      r4,r0
;;;2105       struct cmd_ds_802_11_set_wep cmd;
;;;2106       int ret;
;;;2107   
;;;2108       lbs_deb_enter(LBS_DEB_CFG80211);
;;;2109   
;;;2110       memset(&cmd, 0, sizeof(cmd));
000006  2150              MOVS     r1,#0x50
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;2111       cmd.hdr.size = cpu_to_le16(sizeof(cmd));
00000e  2050              MOVS     r0,#0x50
000010  f8ad0006          STRH     r0,[sp,#6]
;;;2112       cmd.keyindex = cpu_to_le16(/*priv->wep_tx_key*/0);
000014  2000              MOVS     r0,#0
000016  f8ad000e          STRH     r0,[sp,#0xe]
;;;2113       cmd.action = cpu_to_le16(CMD_ACT_REMOVE);
00001a  2004              MOVS     r0,#4
00001c  f8ad000c          STRH     r0,[sp,#0xc]
;;;2114   
;;;2115       ret = lbs_cmd_with_response(priv, CMD_802_11_SET_WEP, &cmd);
000020  aa01              ADD      r2,sp,#4
000022  2113              MOVS     r1,#0x13
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       lbs_cmd_with_response
00002a  4605              MOV      r5,r0
;;;2116   
;;;2117       lbs_deb_leave(LBS_DEB_CFG80211);
;;;2118       return ret;
00002c  4628              MOV      r0,r5
;;;2119   }
00002e  b015              ADD      sp,sp,#0x54
000030  bd30              POP      {r4,r5,pc}
;;;2120   
                          ENDP


                          AREA ||i.lbs_ret_802_11_bcn_ctrl||, CODE, READONLY, ALIGN=1

                  lbs_ret_802_11_bcn_ctrl PROC
;;;677    
;;;678    static int lbs_ret_802_11_bcn_ctrl(struct lbs_private * priv,
000000  4602              MOV      r2,r0
;;;679    					struct cmd_ds_command *resp)
;;;680    {
000002  460b              MOV      r3,r1
;;;681    	struct cmd_ds_802_11_beacon_control *bcn_ctrl =
000004  f1030108          ADD      r1,r3,#8
;;;682    	    &resp->params.bcn_ctrl;
;;;683    
;;;684    	//lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;685    
;;;686    	if (bcn_ctrl->action == CMD_ACT_GET) {
000008  8808              LDRH     r0,[r1,#0]
00000a  b928              CBNZ     r0,|L32.24|
;;;687    		priv->beacon_enable = (u8) le16_to_cpu(bcn_ctrl->beacon_enable);
00000c  8848              LDRH     r0,[r1,#2]
00000e  f8820106          STRB     r0,[r2,#0x106]
;;;688    		priv->beacon_period = le16_to_cpu(bcn_ctrl->beacon_period);
000012  8888              LDRH     r0,[r1,#4]
000014  f8a20104          STRH     r0,[r2,#0x104]
                  |L32.24|
;;;689    	}
;;;690    
;;;691    	//lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;692    	return 0;
000018  2000              MOVS     r0,#0
;;;693    }
00001a  4770              BX       lr
;;;694    
                          ENDP


                          AREA ||i.lbs_ret_802_11_rssi||, CODE, READONLY, ALIGN=1

                  lbs_ret_802_11_rssi PROC
;;;647    
;;;648    static int lbs_ret_802_11_rssi(struct lbs_private *priv,
000000  b530              PUSH     {r4,r5,lr}
;;;649    				struct cmd_ds_command *resp)
;;;650    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;651    	struct cmd_ds_802_11_rssi_rsp *rssirsp = &resp->params.rssirsp;
000006  f1030108          ADD      r1,r3,#8
;;;652    
;;;653    	//lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;654    
;;;655    	/* store the non average value */
;;;656    	priv->SNR[TYPE_BEACON][TYPE_NOAVG] = get_unaligned_le16((__le16 *)&rssirsp->SNR);
00000a  8808              LDRH     r0,[r1,#0]
00000c  f8a202ee          STRH     r0,[r2,#0x2ee]
;;;657    	priv->NF[TYPE_BEACON][TYPE_NOAVG] = get_unaligned_le16((__le16 *)&rssirsp->noisefloor);
000010  8848              LDRH     r0,[r1,#2]
000012  f8a202f6          STRH     r0,[r2,#0x2f6]
;;;658    
;;;659    	priv->SNR[TYPE_BEACON][TYPE_AVG] = get_unaligned_le16((__le16 *)&rssirsp->avgSNR);
000016  888c              LDRH     r4,[r1,#4]
000018  f44f703c          MOV      r0,#0x2f0
00001c  5284              STRH     r4,[r0,r2]
;;;660    	priv->NF[TYPE_BEACON][TYPE_AVG] = get_unaligned_le16((__le16 *)&rssirsp->avgnoisefloor);
00001e  88cc              LDRH     r4,[r1,#6]
000020  f44f703e          MOV      r0,#0x2f8
000024  5284              STRH     r4,[r0,r2]
;;;661    
;;;662    	priv->RSSI[TYPE_BEACON][TYPE_NOAVG] =
000026  f8b202ee          LDRH     r0,[r2,#0x2ee]
00002a  f8b242f6          LDRH     r4,[r2,#0x2f6]
00002e  4264              RSBS     r4,r4,#0
000030  4420              ADD      r0,r0,r4
000032  f88202fe          STRB     r0,[r2,#0x2fe]
;;;663    	    CAL_RSSI(priv->SNR[TYPE_BEACON][TYPE_NOAVG],
;;;664    		     priv->NF[TYPE_BEACON][TYPE_NOAVG]);
;;;665    
;;;666    	priv->RSSI[TYPE_BEACON][TYPE_AVG] =
000036  f44f703c          MOV      r0,#0x2f0
00003a  5a80              LDRH     r0,[r0,r2]
00003c  2464              MOVS     r4,#0x64
00003e  fb90f4f4          SDIV     r4,r0,r4
000042  f44f703e          MOV      r0,#0x2f8
000046  5a80              LDRH     r0,[r0,r2]
000048  2564              MOVS     r5,#0x64
00004a  fb90f0f5          SDIV     r0,r0,r5
00004e  4240              RSBS     r0,r0,#0
000050  4420              ADD      r0,r0,r4
000052  b2c4              UXTB     r4,r0
000054  f24020ff          MOV      r0,#0x2ff
000058  5484              STRB     r4,[r0,r2]
;;;667    	    CAL_RSSI(priv->SNR[TYPE_BEACON][TYPE_AVG] / AVG_SCALE,
;;;668    		     priv->NF[TYPE_BEACON][TYPE_AVG] / AVG_SCALE);
;;;669    
;;;670    	lbs_deb_cmd("RSSI: beacon %d, avg %d\n",
;;;671    	       priv->RSSI[TYPE_BEACON][TYPE_NOAVG],
;;;672    	       priv->RSSI[TYPE_BEACON][TYPE_AVG]);
;;;673    
;;;674    	//lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;675    	return 0;
00005a  2000              MOVS     r0,#0
;;;676    }
00005c  bd30              POP      {r4,r5,pc}
;;;677    
                          ENDP


                          AREA ||i.lbs_ret_reg_access||, CODE, READONLY, ALIGN=1

                  lbs_ret_reg_access PROC
;;;587    
;;;588    static int lbs_ret_reg_access(struct lbs_private *priv,//读取mac、baseband、rf寄存器的值
000000  b570              PUSH     {r4-r6,lr}
;;;589    			       u16 type, struct cmd_ds_command *resp)
;;;590    {
000002  4603              MOV      r3,r0
;;;591    	int ret = 0;
000004  2400              MOVS     r4,#0
;;;592    
;;;593    	lbs_deb_cmd_enter("enter lbs_ret_reg_access\n");
;;;594    
;;;595    	switch (type) {
000006  f5a14000          SUB      r0,r1,#0x8000
00000a  3819              SUBS     r0,r0,#0x19
00000c  d004              BEQ      |L34.24|
00000e  2801              CMP      r0,#1
000010  d009              BEQ      |L34.38|
000012  2802              CMP      r0,#2
000014  d115              BNE      |L34.66|
000016  e00d              B        |L34.52|
                  |L34.24|
;;;596    	case CMD_RET(CMD_MAC_REG_ACCESS):
;;;597    		{
;;;598    			struct cmd_ds_mac_reg_access *reg = &resp->params.macreg;//响应的数据
000018  f1020008          ADD      r0,r2,#8
;;;599    
;;;600    			priv->offsetvalue.offset = (u32)le16_to_cpu(reg->offset);
00001c  8845              LDRH     r5,[r0,#2]
00001e  659d              STR      r5,[r3,#0x58]
;;;601    			priv->offsetvalue.value = le32_to_cpu(reg->value);
000020  6846              LDR      r6,[r0,#4]
000022  65de              STR      r6,[r3,#0x5c]
;;;602    			break;
000024  e010              B        |L34.72|
                  |L34.38|
;;;603    		}
;;;604    
;;;605    	case CMD_RET(CMD_BBP_REG_ACCESS):
;;;606    		{
;;;607    			struct cmd_ds_bbp_reg_access *reg = &resp->params.bbpreg;
000026  f1020008          ADD      r0,r2,#8
;;;608    
;;;609    			priv->offsetvalue.offset = (u32)le16_to_cpu(reg->offset);
00002a  8845              LDRH     r5,[r0,#2]
00002c  659d              STR      r5,[r3,#0x58]
;;;610    			priv->offsetvalue.value = reg->value;
00002e  7906              LDRB     r6,[r0,#4]
000030  65de              STR      r6,[r3,#0x5c]
;;;611    			break;
000032  e009              B        |L34.72|
                  |L34.52|
;;;612    		}
;;;613    
;;;614    	case CMD_RET(CMD_RF_REG_ACCESS):
;;;615    		{
;;;616    			struct cmd_ds_rf_reg_access *reg = &resp->params.rfreg;
000034  f1020008          ADD      r0,r2,#8
;;;617    
;;;618    			priv->offsetvalue.offset = (u32)le16_to_cpu(reg->offset);
000038  8845              LDRH     r5,[r0,#2]
00003a  659d              STR      r5,[r3,#0x58]
;;;619    			priv->offsetvalue.value = reg->value;
00003c  7906              LDRB     r6,[r0,#4]
00003e  65de              STR      r6,[r3,#0x5c]
;;;620    			break;
000040  e002              B        |L34.72|
                  |L34.66|
;;;621    		}
;;;622    
;;;623    	default:
;;;624    		ret = -1;
000042  f04f34ff          MOV      r4,#0xffffffff
000046  bf00              NOP                            ;595
                  |L34.72|
000048  bf00              NOP                            ;602
;;;625    	}
;;;626    
;;;627    	lbs_deb_cmd_leave_args("leave lbs_ret_reg_access(ret=%d)", ret);
;;;628    	return ret;
00004a  4620              MOV      r0,r4
;;;629    }
00004c  bd70              POP      {r4-r6,pc}
;;;630    
                          ENDP


                          AREA ||i.lbs_set_channel||, CODE, READONLY, ALIGN=1

                  lbs_set_channel PROC
;;;1661    */
;;;1662   int lbs_set_channel(struct lbs_private *priv, u8 channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1663   {
000002  b08c              SUB      sp,sp,#0x30
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;1664   	struct cmd_ds_802_11_rf_channel cmd;
;;;1665   	int ret = 0;
000008  2500              MOVS     r5,#0
;;;1666   
;;;1667   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1668   
;;;1669   	memset(&cmd, 0, sizeof(cmd));
00000a  2130              MOVS     r1,#0x30
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;1670   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000012  2030              MOVS     r0,#0x30
000014  f8ad0002          STRH     r0,[sp,#2]
;;;1671   	cmd.action = cpu_to_le16(CMD_OPT_802_11_RF_CHANNEL_SET);
000018  2001              MOVS     r0,#1
00001a  f8ad0008          STRH     r0,[sp,#8]
;;;1672   	cmd.channel = cpu_to_le16(channel);
00001e  f8ad400a          STRH     r4,[sp,#0xa]
;;;1673   
;;;1674   	ret = lbs_cmd_with_response(priv, CMD_802_11_RF_CHANNEL, &cmd);
000022  466a              MOV      r2,sp
000024  211d              MOVS     r1,#0x1d
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       lbs_cmd_with_response
00002c  4605              MOV      r5,r0
;;;1675   	if (ret)
00002e  b105              CBZ      r5,|L35.50|
;;;1676   		goto out;
000030  e004              B        |L35.60|
                  |L35.50|
;;;1677   
;;;1678   	priv->curbssparams.channel = (uint8_t) le16_to_cpu(cmd.channel);
000032  f8bd000a          LDRH     r0,[sp,#0xa]
000036  f88600d9          STRB     r0,[r6,#0xd9]
;;;1679   	lbs_deb_cmd("channel switch from %d to %d\n", old_channel,
;;;1680   		priv->curbssparams.channel);
;;;1681   
;;;1682   out:
00003a  bf00              NOP      
                  |L35.60|
;;;1683   	lbs_deb_cmd_leave_args(LBS_DEB_CMD,  ret);
;;;1684   	return ret;
00003c  4628              MOV      r0,r5
;;;1685   }
00003e  b00c              ADD      sp,sp,#0x30
000040  bd70              POP      {r4-r6,pc}
;;;1686   
                          ENDP


                          AREA ||i.lbs_set_key_material||, CODE, READONLY, ALIGN=1

                  lbs_set_key_material PROC
;;;2130   
;;;2131   int lbs_set_key_material(struct lbs_private *priv,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;2132   				int key_type,
;;;2133   				int key_info,
;;;2134   				u8 *key, u16 key_len)
;;;2135   {
000004  b08d              SUB      sp,sp,#0x34
000006  4680              MOV      r8,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
00000c  461c              MOV      r4,r3
00000e  9d14              LDR      r5,[sp,#0x50]
;;;2136   	struct cmd_key_material cmd;
;;;2137   	int ret;
;;;2138   
;;;2139   	lbs_deb_enter(LBS_DEB_CFG80211);
;;;2140   
;;;2141   	/*
;;;2142   	 * Example for WPA (TKIP):
;;;2143   	 *
;;;2144   	 * cmd       5e 00
;;;2145   	 * size      34 00
;;;2146   	 * sequence  xx xx
;;;2147   	 * result    00 00
;;;2148   	 * action    01 00
;;;2149   	 * TLV type  00 01    key param
;;;2150   	 * length    00 26
;;;2151   	 * key type  01 00    TKIP
;;;2152   	 * key info  06 00    UNICAST | ENABLED
;;;2153   	 * key len   20 00
;;;2154   	 * key       32 bytes
;;;2155   	 */
;;;2156   	memset(&cmd, 0, sizeof(cmd));
000010  2134              MOVS     r1,#0x34
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       __aeabi_memclr4
;;;2157   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000018  2034              MOVS     r0,#0x34
00001a  f8ad0002          STRH     r0,[sp,#2]
;;;2158   	cmd.action = cpu_to_le16(CMD_ACT_SET);
00001e  2001              MOVS     r0,#1
000020  f8ad0008          STRH     r0,[sp,#8]
;;;2159   	cmd.param.type = cpu_to_le16(TLV_TYPE_KEY_MATERIAL);
000024  0200              LSLS     r0,r0,#8
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;2160   	cmd.param.length = cpu_to_le16(sizeof(cmd.param) - 4);
00002a  2126              MOVS     r1,#0x26
00002c  f8ad100c          STRH     r1,[sp,#0xc]
;;;2161   	cmd.param.keytypeid = cpu_to_le16(key_type);
000030  b2b1              UXTH     r1,r6
000032  f8ad100e          STRH     r1,[sp,#0xe]
;;;2162   	cmd.param.keyinfo = cpu_to_le16(key_info);
000036  b2b9              UXTH     r1,r7
000038  f8ad1010          STRH     r1,[sp,#0x10]
;;;2163   	cmd.param.keylen = cpu_to_le16(key_len);
00003c  f8ad5012          STRH     r5,[sp,#0x12]
;;;2164   	if (key && key_len)
000040  b12c              CBZ      r4,|L36.78|
000042  b125              CBZ      r5,|L36.78|
;;;2165   		memcpy(cmd.param.key, key, key_len);
000044  462a              MOV      r2,r5
000046  4621              MOV      r1,r4
000048  a805              ADD      r0,sp,#0x14
00004a  f7fffffe          BL       __aeabi_memcpy
                  |L36.78|
;;;2166   	ret = lbs_cmd_with_response(priv, CMD_802_11_KEY_MATERIAL, &cmd);
00004e  466a              MOV      r2,sp
000050  215e              MOVS     r1,#0x5e
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       lbs_cmd_with_response
000058  4681              MOV      r9,r0
;;;2167   	lbs_deb_leave(LBS_DEB_CFG80211);
;;;2168   
;;;2169   	return ret;
00005a  4648              MOV      r0,r9
;;;2170   }
00005c  b00d              ADD      sp,sp,#0x34
00005e  e8bd83f0          POP      {r4-r9,pc}
;;;2171   
                          ENDP


                          AREA ||i.lbs_set_mac_control||, CODE, READONLY, ALIGN=1

                  lbs_set_mac_control PROC
;;;254    
;;;255    void lbs_set_mac_control(struct lbs_private *priv)
000000  b53e              PUSH     {r1-r5,lr}
;;;256    {
000002  4604              MOV      r4,r0
;;;257    	struct cmd_ds_mac_control cmd;
;;;258    
;;;259    	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;260    
;;;261    	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000004  200c              MOVS     r0,#0xc
000006  f8ad0002          STRH     r0,[sp,#2]
;;;262    	cmd.action = cpu_to_le16(priv->mac_control);
00000a  f8b401da          LDRH     r0,[r4,#0x1da]
00000e  f8ad0008          STRH     r0,[sp,#8]
;;;263    	cmd.reserved = 0;
000012  2000              MOVS     r0,#0
000014  f8ad000a          STRH     r0,[sp,#0xa]
;;;264    
;;;265    	lbs_cmd_async(priv, CMD_MAC_CONTROL, &cmd.hdr, sizeof(cmd));//与lbs_cmd_with_response区别主要是不用等待响应，因此也不用睡眠
000018  230c              MOVS     r3,#0xc
00001a  466a              MOV      r2,sp
00001c  2128              MOVS     r1,#0x28
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       lbs_cmd_async
;;;266    
;;;267    	lbs_deb_cmd_leave(LBS_DEB_CMD);
;;;268    }
000024  bd3e              POP      {r1-r5,pc}
;;;269    
                          ENDP


                          AREA ||i.lbs_set_radio||, CODE, READONLY, ALIGN=1

                  lbs_set_radio PROC
;;;1885   
;;;1886   int lbs_set_radio(struct lbs_private *priv, u8 preamble, u8 radio_on)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1887   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1888   	struct cmd_ds_802_11_radio_control cmd;
;;;1889   	int ret = -EINVAL;
000008  f06f0715          MVN      r7,#0x15
;;;1890   
;;;1891   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;1892   
;;;1893   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
00000c  200c              MOVS     r0,#0xc
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;1894   	cmd.action = cpu_to_le16(CMD_ACT_SET);
000012  2001              MOVS     r0,#1
000014  f8ad0008          STRH     r0,[sp,#8]
;;;1895   
;;;1896   	/* Only v8 and below support setting the preamble */
;;;1897   	if (priv->fwrelease < 0x09000000) {
000018  6ea0              LDR      r0,[r4,#0x68]
00001a  f1b06f10          CMP      r0,#0x9000000
00001e  d212              BCS      |L38.70|
;;;1898   		switch (preamble) {
000020  b165              CBZ      r5,|L38.60|
000022  2d02              CMP      r5,#2
000024  d002              BEQ      |L38.44|
000026  2d04              CMP      r5,#4
000028  d10b              BNE      |L38.66|
00002a  e006              B        |L38.58|
                  |L38.44|
;;;1899   		case RADIO_PREAMBLE_SHORT:
;;;1900   			if (!(priv->capability & WLAN_CAPABILITY_SHORT_PREAMBLE))
00002c  f8b40108          LDRH     r0,[r4,#0x108]
000030  f0100f20          TST      r0,#0x20
000034  d100              BNE      |L38.56|
;;;1901   				goto out;
000036  e020              B        |L38.122|
                  |L38.56|
;;;1902   			/* Fall through */
;;;1903   		case RADIO_PREAMBLE_AUTO:
000038  bf00              NOP      
                  |L38.58|
;;;1904   		case RADIO_PREAMBLE_LONG:
00003a  bf00              NOP      
                  |L38.60|
;;;1905   			cmd.control = cpu_to_le16(preamble);
00003c  f8ad500a          STRH     r5,[sp,#0xa]
;;;1906   			break;
000040  e000              B        |L38.68|
                  |L38.66|
;;;1907   		default:
;;;1908   			goto out;
000042  e01a              B        |L38.122|
                  |L38.68|
000044  bf00              NOP                            ;1906
                  |L38.70|
;;;1909   		}
;;;1910   	}
;;;1911   
;;;1912   	if (radio_on)
000046  b136              CBZ      r6,|L38.86|
;;;1913   		cmd.control |= cpu_to_le16(0x1);
000048  f8bd000a          LDRH     r0,[sp,#0xa]
00004c  f0400001          ORR      r0,r0,#1
000050  f8ad000a          STRH     r0,[sp,#0xa]
000054  e008              B        |L38.104|
                  |L38.86|
;;;1914   	else {
;;;1915   		cmd.control &= cpu_to_le16(~0x1);
000056  f8bd000a          LDRH     r0,[sp,#0xa]
00005a  f0200001          BIC      r0,r0,#1
00005e  f8ad000a          STRH     r0,[sp,#0xa]
;;;1916   		priv->txpower_cur = 0;
000062  2000              MOVS     r0,#0
000064  f8a401e6          STRH     r0,[r4,#0x1e6]
                  |L38.104|
;;;1917   	}
;;;1918   
;;;1919   	lbs_deb_cmd("RADIO_CONTROL: radio %s, preamble %d\n",
;;;1920   		    radio_on ? "ON" : "OFF", preamble);
;;;1921   
;;;1922   	priv->radio_on = radio_on;
000068  f8846316          STRB     r6,[r4,#0x316]
;;;1923   
;;;1924   	ret = lbs_cmd_with_response(priv, CMD_802_11_RADIO_CONTROL, &cmd);
00006c  466a              MOV      r2,sp
00006e  211c              MOVS     r1,#0x1c
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       lbs_cmd_with_response
000076  4607              MOV      r7,r0
;;;1925   
;;;1926   out:
000078  bf00              NOP      
                  |L38.122|
;;;1927   	lbs_deb_cmd_leave_args(LBS_DEB_CMD, ret);
;;;1928   	return ret;
00007a  4638              MOV      r0,r7
;;;1929   }
00007c  bdfe              POP      {r1-r7,pc}
;;;1930   
                          ENDP


                          AREA ||i.lbs_set_snmp_mib||, CODE, READONLY, ALIGN=1

                  lbs_set_snmp_mib PROC
;;;2034    */
;;;2035   int lbs_set_snmp_mib(struct lbs_private *priv, u32 oid, u16 val)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2036   {
000002  b0a5              SUB      sp,sp,#0x94
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;2037   	struct cmd_ds_802_11_snmp_mib cmd;
;;;2038   	int ret;
;;;2039   
;;;2040   	lbs_deb_cmd_enter(LBS_DEB_CMD);
;;;2041   
;;;2042   	memset(&cmd, 0, sizeof (cmd));
00000a  2190              MOVS     r1,#0x90
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       __aeabi_memclr4
;;;2043   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000012  208e              MOVS     r0,#0x8e
000014  f8ad0006          STRH     r0,[sp,#6]
;;;2044   	cmd.action = cpu_to_le16(CMD_ACT_SET);
000018  2001              MOVS     r0,#1
00001a  f8ad000c          STRH     r0,[sp,#0xc]
;;;2045   	cmd.oid = cpu_to_le16((u16) oid);
00001e  b2a0              UXTH     r0,r4
000020  f8ad000e          STRH     r0,[sp,#0xe]
;;;2046   
;;;2047   	switch (oid) {
000024  2c0a              CMP      r4,#0xa
000026  d21c              BCS      |L39.98|
000028  e8dff004          TBB      [pc,r4]
00002c  051b1b1b          DCB      0x05,0x1b,0x1b,0x1b
000030  1b131415          DCB      0x1b,0x13,0x14,0x15
000034  1211              DCB      0x12,0x11
;;;2048   	case SNMP_MIB_OID_BSS_TYPE:
;;;2049   		cmd.bufsize = cpu_to_le16(sizeof(u8));
000036  2001              MOVS     r0,#1
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;2050   		cmd.value[0] = (val == IW_MODE_ADHOC) ? 2 : 1;
00003c  2d01              CMP      r5,#1
00003e  d101              BNE      |L39.68|
000040  2002              MOVS     r0,#2
000042  e000              B        |L39.70|
                  |L39.68|
000044  2001              MOVS     r0,#1
                  |L39.70|
000046  b2c0              UXTB     r0,r0
000048  f88d0012          STRB     r0,[sp,#0x12]
;;;2051   		break;
00004c  e00c              B        |L39.104|
;;;2052   	case SNMP_MIB_OID_11D_ENABLE:
;;;2053   	case SNMP_MIB_OID_FRAG_THRESHOLD:
00004e  bf00              NOP      
;;;2054   	case SNMP_MIB_OID_RTS_THRESHOLD:
000050  bf00              NOP      
;;;2055   	case SNMP_MIB_OID_SHORT_RETRY_LIMIT:
000052  bf00              NOP      
;;;2056   	case SNMP_MIB_OID_LONG_RETRY_LIMIT:
000054  bf00              NOP      
;;;2057   		cmd.bufsize = cpu_to_le16(sizeof(u16));
000056  2002              MOVS     r0,#2
000058  f8ad0010          STRH     r0,[sp,#0x10]
;;;2058   		*((__le16 *)(&cmd.value)) = cpu_to_le16(val);
00005c  f8ad5012          STRH     r5,[sp,#0x12]
;;;2059   		break;
000060  e002              B        |L39.104|
                  |L39.98|
;;;2060   	default:
;;;2061   		lbs_deb_cmd("SNMP_CMD: (set) unhandled OID 0x%x\n", oid);
;;;2062   		ret = -EINVAL;
000062  f06f0615          MVN      r6,#0x15
;;;2063   		goto out;
000066  e007              B        |L39.120|
                  |L39.104|
000068  bf00              NOP                            ;2051
;;;2064   	}
;;;2065   
;;;2066   	lbs_deb_cmd("SNMP_CMD: (set) oid 0x%x, oid size 0x%x, value 0x%x\n",
;;;2067   		    le16_to_cpu(cmd.oid), le16_to_cpu(cmd.bufsize), val);
;;;2068   
;;;2069   	ret = lbs_cmd_with_response(priv, CMD_802_11_SNMP_MIB, &cmd);
00006a  aa01              ADD      r2,sp,#4
00006c  2116              MOVS     r1,#0x16
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       lbs_cmd_with_response
000074  4606              MOV      r6,r0
;;;2070   
;;;2071   out:
000076  bf00              NOP      
                  |L39.120|
;;;2072   	lbs_deb_cmd_leave_args(LBS_DEB_CMD, ret);
;;;2073   	return ret;
000078  4630              MOV      r0,r6
;;;2074   }
00007a  b025              ADD      sp,sp,#0x94
00007c  bdf0              POP      {r4-r7,pc}
;;;2075   int __inline lbs_cmd(struct lbs_private *priv, uint16_t cmdnr, struct void_cmd_head* cmd,
                          ENDP


                          AREA ||i.lbs_submit_command||, CODE, READONLY, ALIGN=1

                  lbs_submit_command PROC
;;;123    
;;;124    static void lbs_submit_command(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;125    			       struct cmd_ctrl_node *cmdnode)
;;;126    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;127    //	unsigned long flags;
;;;128    	struct cmd_header *cmd;
;;;129    	uint16_t cmdsize;
;;;130    //	int timeo = 3 * HZ;
;;;131    	int ret;
;;;132    
;;;133    	 lbs_deb_cmd_enter(LBS_DEB_HOST);
;;;134    
;;;135    	cmd = cmdnode->cmdbuf;//获取命令码
000008  696e              LDR      r6,[r5,#0x14]
;;;136    
;;;137    	//spin_lock_irqsave(&priv->driver_lock, flags);
;;;138    	priv->cur_cmd = cmdnode;
00000a  67e5              STR      r5,[r4,#0x7c]
;;;139    	priv->cur_cmd_retcode = 0;
00000c  2000              MOVS     r0,#0
00000e  f8c40080          STR      r0,[r4,#0x80]
;;;140    	//spin_unlock_irqrestore(&priv->driver_lock, flags);
;;;141    
;;;142    	cmdsize = le16_to_cpu(cmd->size);
000012  8877              LDRH     r7,[r6,#2]
;;;143    	/* These commands take longer */
;;;144    /*	if (command == CMD_802_11_SCAN || command == CMD_802_11_ASSOCIATE)
;;;145    		timeo = 5 * HZ;	  */
;;;146    
;;;147    	//lbs_deb_hex(LBS_DEB_CMD, "DNLD_CMD", (void *) cmdnode->cmdbuf, cmdsize);
;;;148    	//调用将命令写入设备 if_sdio_host_to_card
;;;149    	ret = priv->hw_host_to_card(priv, MVMS_CMD, (u8 *) cmd, cmdsize);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f8d4c054          LDR      r12,[r4,#0x54]
000020  47e0              BLX      r12
000022  4680              MOV      r8,r0
;;;150    
;;;151    	if (ret) {
;;;152    		lbs_pr_info("DNLD_CMD: hw_host_to_card failed: %d\n", ret);
;;;153    		/* Let the timer kick in and retry, and potentially reset
;;;154    		   the whole thing if the condition persists */
;;;155    	//	timeo = HZ/4;
;;;156    	}
;;;157    
;;;158    	/* Setup the timer after transmit command */
;;;159    	//mod_timer(&priv->command_timer, jiffies + timeo);
;;;160    
;;;161    	 lbs_deb_cmd_leave(LBS_DEB_HOST);
;;;162    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;163    
                          ENDP


                          AREA ||i.lbs_update_channel||, CODE, READONLY, ALIGN=1

                  lbs_update_channel PROC
;;;1635   
;;;1636   int lbs_update_channel(struct lbs_private *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;1637   {
000002  4605              MOV      r5,r0
;;;1638   	int ret;
;;;1639   
;;;1640   	/* the channel in f/w could be out of sync; get the current channel */
;;;1641   	lbs_deb_cmd_enter(LBS_DEB_ASSOC);
;;;1642   
;;;1643   	ret = lbs_get_channel(priv);//获取当前信道的通道号
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       lbs_get_channel
00000a  4604              MOV      r4,r0
;;;1644   	if (ret > 0) {
00000c  2c00              CMP      r4,#0
00000e  dd02              BLE      |L41.22|
;;;1645   		priv->curbssparams.channel = ret;
000010  f88540d9          STRB     r4,[r5,#0xd9]
;;;1646   		ret = 0;
000014  2400              MOVS     r4,#0
                  |L41.22|
;;;1647   	}
;;;1648   	lbs_deb_cmd_leave_args(LBS_DEB_ASSOC, ret);
;;;1649   	return ret;
000016  4620              MOV      r0,r4
;;;1650   }
000018  bd70              POP      {r4-r6,pc}
;;;1651   
                          ENDP


                          AREA ||i.lbs_update_hw_spec||, CODE, READONLY, ALIGN=2

                  lbs_update_hw_spec PROC
;;;293     */
;;;294    int lbs_update_hw_spec(struct lbs_private *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
;;;296    	struct cmd_ds_get_hw_spec cmd;
;;;297    	//cmd_ds_get_hw_spec定义get_hw_spec命令的响应结构，具体的内容结构中有详细说明
;;;298    	int ret = -1;
000006  f04f36ff          MOV      r6,#0xffffffff
;;;299    	u32 i;
;;;300    
;;;301    	 lbs_deb_cmd_enter("enter lbs_update_hw_spec!\n");
;;;302    
;;;303    	memset(&cmd, 0, sizeof(cmd));
00000a  2130              MOVS     r1,#0x30
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;304    	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000012  202e              MOVS     r0,#0x2e
000014  f8ad0002          STRH     r0,[sp,#2]
;;;305    	memcpy(cmd.permanentaddr, priv->current_addr, ETH_ALEN);
000018  f8d4110a          LDR      r1,[r4,#0x10a]
00001c  9104              STR      r1,[sp,#0x10]
00001e  f8b4010e          LDRH     r0,[r4,#0x10e]
000022  f8ad0014          STRH     r0,[sp,#0x14]
;;;306    	//发送命令获取硬件的spec，完成命令的响应数据存放子在cmd中
;;;307    	 ret=lbs_cmd_with_response(priv,CMD_GET_HW_SPEC,(void *)&cmd);
000026  466a              MOV      r2,sp
000028  2103              MOVS     r1,#3
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       lbs_cmd_with_response
000030  4606              MOV      r6,r0
;;;308    	if (ret)
000032  b106              CBZ      r6,|L42.54|
;;;309    		goto out;
000034  e067              B        |L42.262|
                  |L42.54|
;;;310    	
;;;311    
;;;312    	priv->fwcapinfo = le32_to_cpu(cmd.fwcapinfo);
000036  f8dd002a          LDR      r0,[sp,#0x2a]
00003a  66e0              STR      r0,[r4,#0x6c]
;;;313    
;;;314    	/* The firmware release is in an interesting format: the patch
;;;315    	 * level is in the most significant nibble ... so fix that: */
;;;316    	priv->fwrelease = le32_to_cpu(cmd.fwrelease);
00003c  f8dd001a          LDR      r0,[sp,#0x1a]
000040  66a0              STR      r0,[r4,#0x68]
;;;317    	priv->fwrelease = (priv->fwrelease << 8) |
000042  6ea1              LDR      r1,[r4,#0x68]
000044  0e08              LSRS     r0,r1,#24
000046  f361201f          BFI      r0,r1,#8,#24
00004a  66a0              STR      r0,[r4,#0x68]
;;;318    		(priv->fwrelease >> 24 & 0xff);
;;;319    
;;;320    	/* Some firmware capabilities:
;;;321    	 * CF card    firmware 5.0.16p0:   cap 0x00000303
;;;322    	 * USB dongle firmware 5.110.17p2: cap 0x00000303
;;;323    	 */
;;;324    	lbs_pr_info("%2x:%2x:%2x:%2x:%2x:%2x, fw %u.%u.%up%u, cap 0x%08x\n",
;;;325    		cmd.permanentaddr[0],
;;;326    		cmd.permanentaddr[1],
;;;327    		cmd.permanentaddr[2],
;;;328    		cmd.permanentaddr[3],
;;;329    		cmd.permanentaddr[4],
;;;330    		cmd.permanentaddr[5],
;;;331    		priv->fwrelease >> 24 & 0xff,
;;;332    		priv->fwrelease >> 16 & 0xff,
;;;333    		priv->fwrelease >>  8 & 0xff,
;;;334    		priv->fwrelease       & 0xff,
;;;335    		priv->fwcapinfo);
;;;336    	lbs_deb_cmd("GET_HW_SPEC: hardware interface 0x%x, hardware spec 0x%04x\n",
;;;337    		    cmd.hwifversion, cmd.version);
;;;338    
;;;339    	/* Determine mesh_fw_ver from fwrelease and fwcapinfo */
;;;340    	/* 5.0.16p0 9.0.0.p0 is known to NOT support any mesh */
;;;341    	/* 5.110.22 have mesh command with 0xa3 command id */
;;;342    	/* 10.0.0.p0 FW brings in mesh config command with different id */
;;;343    	/* Check FW version MSB and initialize mesh_fw_ver */
;;;344    	if (MRVL_FW_MAJOR_REV(priv->fwrelease) == MRVL_FW_V5)
00004c  2105              MOVS     r1,#5
00004e  6ea0              LDR      r0,[r4,#0x68]
000050  ebb16f10          CMP      r1,r0,LSR #24
000054  d104              BNE      |L42.96|
;;;345    		priv->mesh_fw_ver = MESH_FW_OLD;
000056  2101              MOVS     r1,#1
000058  f44f5085          MOV      r0,#0x10a0
00005c  5101              STR      r1,[r0,r4]
00005e  e011              B        |L42.132|
                  |L42.96|
;;;346    	else if ((MRVL_FW_MAJOR_REV(priv->fwrelease) >= MRVL_FW_V10) &&
000060  210a              MOVS     r1,#0xa
000062  6ea0              LDR      r0,[r4,#0x68]
000064  ebb16f10          CMP      r1,r0,LSR #24
000068  d808              BHI      |L42.124|
;;;347    		(priv->fwcapinfo & MESH_CAPINFO_ENABLE_MASK))
00006a  6ee0              LDR      r0,[r4,#0x6c]
00006c  f4103f80          TST      r0,#0x10000
000070  d004              BEQ      |L42.124|
;;;348    		priv->mesh_fw_ver = MESH_FW_NEW;
000072  2102              MOVS     r1,#2
000074  f44f5085          MOV      r0,#0x10a0
000078  5101              STR      r1,[r0,r4]
00007a  e003              B        |L42.132|
                  |L42.124|
;;;349    	else
;;;350    		priv->mesh_fw_ver = MESH_NONE;
00007c  2100              MOVS     r1,#0
00007e  f44f5085          MOV      r0,#0x10a0
000082  5101              STR      r1,[r0,r4]
                  |L42.132|
;;;351    
;;;352    	/* Clamp region code to 8-bit since FW spec indicates that it should
;;;353    	 * only ever be 8-bit, even though the field size is 16-bit.  Some firmware
;;;354    	 * returns non-zero high 8 bits here.
;;;355    	 *
;;;356    	 * Firmware version 4.0.102 used in CF8381 has region code shifted.  We
;;;357    	 * need to check for this problem and handle it properly.
;;;358    	 */
;;;359    	if (MRVL_FW_MAJOR_REV(priv->fwrelease) == MRVL_FW_V4)
000084  2104              MOVS     r1,#4
000086  6ea0              LDR      r0,[r4,#0x68]
000088  ebb16f10          CMP      r1,r0,LSR #24
00008c  d105              BNE      |L42.154|
;;;360    		priv->regioncode = (le16_to_cpu(cmd.regioncode) >> 8) & 0xFF;
00008e  f8bd0016          LDRH     r0,[sp,#0x16]
000092  0a00              LSRS     r0,r0,#8
000094  f8a401e4          STRH     r0,[r4,#0x1e4]
000098  e004              B        |L42.164|
                  |L42.154|
;;;361    	else
;;;362    		priv->regioncode = le16_to_cpu(cmd.regioncode) & 0xFF;
00009a  f8bd0016          LDRH     r0,[sp,#0x16]
00009e  b2c0              UXTB     r0,r0
0000a0  f8a401e4          STRH     r0,[r4,#0x1e4]
                  |L42.164|
;;;363    	//以上内容是通过读取固件版本信息确定网卡的一些mesh和区域信息
;;;364    	for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
0000a4  2500              MOVS     r5,#0
0000a6  e008              B        |L42.186|
                  |L42.168|
;;;365    		/* use the region code to search for the index */
;;;366    		if (priv->regioncode == lbs_region_code_to_index[i])
0000a8  f8b401e4          LDRH     r0,[r4,#0x1e4]
0000ac  4917              LDR      r1,|L42.268|
0000ae  f8311015          LDRH     r1,[r1,r5,LSL #1]
0000b2  4288              CMP      r0,r1
0000b4  d100              BNE      |L42.184|
;;;367    			break;
0000b6  e002              B        |L42.190|
                  |L42.184|
0000b8  1c6d              ADDS     r5,r5,#1              ;364
                  |L42.186|
0000ba  2d06              CMP      r5,#6                 ;364
0000bc  d3f4              BCC      |L42.168|
                  |L42.190|
0000be  bf00              NOP      
;;;368    	}
;;;369    
;;;370    	/* if it's unidentified region code, use the default (USA) */
;;;371    	if (i >= MRVDRV_MAX_REGION_CODE) {
0000c0  2d06              CMP      r5,#6
0000c2  d302              BCC      |L42.202|
;;;372    		priv->regioncode = 0x10;
0000c4  2010              MOVS     r0,#0x10
0000c6  f8a401e4          STRH     r0,[r4,#0x1e4]
                  |L42.202|
;;;373    		lbs_pr_info("unidentified region code; using the default (USA)\n");
;;;374    	}
;;;375    
;;;376    	if (priv->current_addr[0] == 0xff)
0000ca  f894010a          LDRB     r0,[r4,#0x10a]
0000ce  28ff              CMP      r0,#0xff
0000d0  d105              BNE      |L42.222|
;;;377    		//获取到网卡固件内部的mac地址，以此作为网卡当前的mac地址
;;;378    		memmove(priv->current_addr, cmd.permanentaddr, ETH_ALEN);
0000d2  2206              MOVS     r2,#6
0000d4  a904              ADD      r1,sp,#0x10
0000d6  f5047085          ADD      r0,r4,#0x10a
0000da  f7fffffe          BL       __aeabi_memmove
                  |L42.222|
;;;379    	
;;;380    	//memcpy(priv->dev->dev_addr, priv->current_addr, ETH_ALEN);
;;;381    	//if (priv->mesh_dev)
;;;382    	//	memcpy(priv->mesh_dev->dev_addr, priv->current_addr, ETH_ALEN);
;;;383    
;;;384    
;;;385    
;;;386    	if (lbs_set_regiontable(priv, priv->regioncode, 0)) {//根据区域码获取网卡的信道表
0000de  f8b401e4          LDRH     r0,[r4,#0x1e4]
0000e2  b2c1              UXTB     r1,r0
0000e4  2200              MOVS     r2,#0
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       lbs_set_regiontable
0000ec  b110              CBZ      r0,|L42.244|
;;;387    		ret = -1;
0000ee  f04f36ff          MOV      r6,#0xffffffff
;;;388    		goto out;
0000f2  e008              B        |L42.262|
                  |L42.244|
;;;389    	}
;;;390    
;;;391    	if (lbs_set_universaltable(priv, 0)) {
0000f4  2100              MOVS     r1,#0
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       lbs_set_universaltable
0000fc  b110              CBZ      r0,|L42.260|
;;;392    		ret = -1;
0000fe  f04f36ff          MOV      r6,#0xffffffff
;;;393    		goto out;
000102  e000              B        |L42.262|
                  |L42.260|
;;;394    	}
;;;395    
;;;396    out:
000104  bf00              NOP      
                  |L42.262|
;;;397    	 lbs_deb_cmd_leave("leave lbs_update_hw_spec\n");
;;;398    	return ret;
000106  4630              MOV      r0,r6
;;;399    }
000108  b00c              ADD      sp,sp,#0x30
00010a  bd70              POP      {r4-r6,pc}
;;;400    
                          ENDP

                  |L42.268|
                          DCD      lbs_region_code_to_index

                          AREA ||i.list_add_tail||, CODE, READONLY, ALIGN=1

                  list_add_tail PROC
;;;83      */
;;;84     static __inline void list_add_tail(struct list_head *new, struct list_head *head)
000000  b570              PUSH     {r4-r6,lr}
;;;85     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;86     	__list_add(new, head->prev, head);
000006  4622              MOV      r2,r4
000008  4628              MOV      r0,r5
00000a  6861              LDR      r1,[r4,#4]
00000c  f7fffffe          BL       __list_add
;;;87     }
000010  bd70              POP      {r4-r6,pc}
;;;88     
                          ENDP


                          AREA ||i.list_del||, CODE, READONLY, ALIGN=1

                  list_del PROC
;;;108    #ifndef CONFIG_DEBUG_LIST
;;;109    static __inline void list_del(struct list_head *entry)
000000  e9d01200          LDRD     r1,r2,[r0,#0]
;;;110    {
;;;111    	__list_del(entry->prev, entry->next);
000004  604a              STR      r2,[r1,#4]
000006  6011              STR      r1,[r2,#0]
000008  bf00              NOP      
;;;112    	entry->next = entry;
00000a  6000              STR      r0,[r0,#0]
;;;113    	entry->prev = entry;
00000c  6040              STR      r0,[r0,#4]
;;;114    }
00000e  4770              BX       lr
;;;115    #else
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.set_one_wpa_key||, CODE, READONLY, ALIGN=1

                  set_one_wpa_key PROC
;;;1780   }
;;;1781   static void set_one_wpa_key(struct MrvlIEtype_keyParamSet *keyparam,
000000  b570              PUSH     {r4-r6,lr}
;;;1782                               struct enc_key *key)
;;;1783   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1784   	lbs_deb_enter(LBS_DEB_CMD);
;;;1785   
;;;1786   	if (key->flags & KEY_INFO_WPA_ENABLED)
000006  8868              LDRH     r0,[r5,#2]
000008  f0100f04          TST      r0,#4
00000c  d003              BEQ      |L46.22|
;;;1787   		keyparam->keyinfo |= cpu_to_le16(KEY_INFO_WPA_ENABLED);
00000e  88e0              LDRH     r0,[r4,#6]
000010  f0400004          ORR      r0,r0,#4
000014  80e0              STRH     r0,[r4,#6]
                  |L46.22|
;;;1788   	if (key->flags & KEY_INFO_WPA_UNICAST)
000016  8868              LDRH     r0,[r5,#2]
000018  f0100f02          TST      r0,#2
00001c  d003              BEQ      |L46.38|
;;;1789   		keyparam->keyinfo |= cpu_to_le16(KEY_INFO_WPA_UNICAST);
00001e  88e0              LDRH     r0,[r4,#6]
000020  f0400002          ORR      r0,r0,#2
000024  80e0              STRH     r0,[r4,#6]
                  |L46.38|
;;;1790   	if (key->flags & KEY_INFO_WPA_MCAST)
000026  8868              LDRH     r0,[r5,#2]
000028  f0100f01          TST      r0,#1
00002c  d003              BEQ      |L46.54|
;;;1791   		keyparam->keyinfo |= cpu_to_le16(KEY_INFO_WPA_MCAST);
00002e  88e0              LDRH     r0,[r4,#6]
000030  f0400001          ORR      r0,r0,#1
000034  80e0              STRH     r0,[r4,#6]
                  |L46.54|
;;;1792   
;;;1793   	keyparam->type = cpu_to_le16(TLV_TYPE_KEY_MATERIAL);
000036  f44f7080          MOV      r0,#0x100
00003a  8020              STRH     r0,[r4,#0]
;;;1794   	keyparam->keytypeid = cpu_to_le16(key->type);
00003c  88a8              LDRH     r0,[r5,#4]
00003e  80a0              STRH     r0,[r4,#4]
;;;1795   	keyparam->keylen = cpu_to_le16(key->len);
000040  8828              LDRH     r0,[r5,#0]
000042  8120              STRH     r0,[r4,#8]
;;;1796   	memcpy(keyparam->key, key->key, key->len);
000044  882a              LDRH     r2,[r5,#0]
000046  1da9              ADDS     r1,r5,#6
000048  f104000a          ADD      r0,r4,#0xa
00004c  f7fffffe          BL       __aeabi_memcpy
;;;1797   
;;;1798   	/* Length field doesn't include the {type,length} header */
;;;1799   	keyparam->length = cpu_to_le16(sizeof(*keyparam) - 4);
000050  2026              MOVS     r0,#0x26
000052  8060              STRH     r0,[r4,#2]
;;;1800   	lbs_deb_leave(LBS_DEB_CMD);
;;;1801   }
000054  bd70              POP      {r4-r6,pc}
;;;1802   
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L47.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L47.32|
                  |L47.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L47.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L47.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L47.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L47.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L47.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L47.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L47.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  gmarvel_cmdarray
                          %        28
                  gmarvel_cmdbuffer
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  40404040          DCB      0x40,0x40,0x40,0x40
000004  40404040          DCB      0x40,0x40,0x40,0x40
000008  40404040          DCB      0x40,0x40,0x40,0x40
00000c  40232323          DCB      0x40,0x23,0x23,0x23
000010  23232323          DCB      0x23,0x23,0x23,0x23
000014  23232323          DCB      0x23,0x23,0x23,0x23
000018  23232323          DCB      0x23,0x23,0x23,0x23
00001c  23232323          DCB      0x23,0x23,0x23,0x23
000020  23232323          DCB      0x23,0x23,0x23,0x23
000024  23232323          DCB      0x23,0x23,0x23,0x23
000028  23232323          DCB      0x23,0x23,0x23,0x23
00002c  23232323          DCB      0x23,0x23,0x23,0x23
000030  23232323          DCB      0x23,0x23,0x23,0x23
000034  23232323          DCB      0x23,0x23,0x23,0x23
000038  23232072          DCB      0x23,0x23,0x20,0x72
00003c  65207768          DCB      0x65,0x20,0x77,0x68
000040  696c650d          DCB      0x69,0x6c,0x65,0x0d
000044  0a00              DCB      0x0a,0x00

                          AREA ||i.lbs_cmd_with_response||, COMGROUP=lbs_cmd_with_response, CODE, READONLY, ALIGN=2

                  lbs_cmd_with_response PROC
;;;2084   
;;;2085   int __inline lbs_cmd_with_response(struct lbs_private *priv, uint16_t cmdnr,void *cmd)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;2086   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;2087   	return lbs_cmd(priv, cmdnr, (struct void_cmd_head*)cmd, lbs_cmd_copyback, (unsigned long) (cmd));
00000a  4d06              LDR      r5,|L266.36|
00000c  f8b48002          LDRH     r8,[r4,#2]
000010  4643              MOV      r3,r8
000012  4622              MOV      r2,r4
000014  4639              MOV      r1,r7
000016  4630              MOV      r0,r6
000018  e9cd5400          STRD     r5,r4,[sp,#0]
00001c  f7fffffe          BL       __lbs_cmd
;;;2088   }
000020  e8bd81fc          POP      {r2-r8,pc}
;;;2089   
                          ENDP

                  |L266.36|
                          DCD      lbs_cmd_copyback
