; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\aes-omac1.o --depend=.\obj\aes-omac1.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\aes-omac1.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto\aes-omac1.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.gf_mulx||, CODE, READONLY, ALIGN=1

                  gf_mulx PROC
;;;21     
;;;22     static void gf_mulx(u8 *pad)
000000  b510              PUSH     {r4,lr}
;;;23     {
;;;24     	int i, carry;
;;;25     
;;;26     	carry = pad[0] & 0x80;
000002  7803              LDRB     r3,[r0,#0]
000004  f0030280          AND      r2,r3,#0x80
;;;27     	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
000008  2100              MOVS     r1,#0
00000a  e007              B        |L2.28|
                  |L2.12|
;;;28     		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
00000c  5c43              LDRB     r3,[r0,r1]
00000e  005c              LSLS     r4,r3,#1
000010  1c4b              ADDS     r3,r1,#1
000012  5cc3              LDRB     r3,[r0,r3]
000014  ea4413e3          ORR      r3,r4,r3,ASR #7
000018  5443              STRB     r3,[r0,r1]
00001a  1c49              ADDS     r1,r1,#1              ;27
                  |L2.28|
00001c  290f              CMP      r1,#0xf               ;27
00001e  dbf5              BLT      |L2.12|
;;;29     	pad[AES_BLOCK_SIZE - 1] <<= 1;
000020  7bc3              LDRB     r3,[r0,#0xf]
000022  065b              LSLS     r3,r3,#25
000024  0e1b              LSRS     r3,r3,#24
000026  73c3              STRB     r3,[r0,#0xf]
;;;30     	if (carry)
000028  b11a              CBZ      r2,|L2.50|
;;;31     		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
00002a  7bc3              LDRB     r3,[r0,#0xf]
00002c  f0830387          EOR      r3,r3,#0x87
000030  73c3              STRB     r3,[r0,#0xf]
                  |L2.50|
;;;32     }
000032  bd10              POP      {r4,pc}
;;;33     
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L3.30|
00001a  2001              MOVS     r0,#1
                  |L3.28|
;;;495    }
00001c  4770              BX       lr
                  |L3.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L3.28|
;;;496    
                          ENDP


                          AREA ||i.omac1_aes_128||, CODE, READONLY, ALIGN=1

                  omac1_aes_128 PROC
;;;120     */
;;;121    int omac1_aes_128(const u8 *key, const u8 *data, size_t data_len, u8 *mac)
000000  b53f              PUSH     {r0-r5,lr}
;;;122    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  461d              MOV      r5,r3
;;;123    	return omac1_aes_128_vector(key, 1, &data, &data_len, mac);
000008  ab03              ADD      r3,sp,#0xc
00000a  aa02              ADD      r2,sp,#8
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  9500              STR      r5,[sp,#0]
000012  f7fffffe          BL       omac1_aes_128_vector
;;;124    }
000016  b005              ADD      sp,sp,#0x14
000018  bd30              POP      {r4,r5,pc}
                          ENDP


                          AREA ||i.omac1_aes_128_vector||, CODE, READONLY, ALIGN=1

                  omac1_aes_128_vector PROC
;;;47      */
;;;48     int omac1_aes_128_vector(const u8 *key, size_t num_elem,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;49     			 const u8 *addr[], const size_t *len, u8 *mac)
;;;50     {
000004  b089              SUB      sp,sp,#0x24
000006  4691              MOV      r9,r2
000008  4698              MOV      r8,r3
;;;51     	void *ctx;
;;;52     	u8 cbc[AES_BLOCK_SIZE], pad[AES_BLOCK_SIZE];
;;;53     	const u8 *pos, *end;
;;;54     	size_t i, e, left, total_len;
;;;55     
;;;56     	ctx = aes_encrypt_init(key, 16);
00000a  2110              MOVS     r1,#0x10
00000c  9809              LDR      r0,[sp,#0x24]
00000e  f7fffffe          BL       aes_encrypt_init
000012  9008              STR      r0,[sp,#0x20]
;;;57     	if (ctx == NULL)
000014  9808              LDR      r0,[sp,#0x20]
000016  b920              CBNZ     r0,|L5.34|
;;;58     		return -1;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L5.28|
;;;59     	os_memset(cbc, 0, AES_BLOCK_SIZE);
;;;60     
;;;61     	total_len = 0;
;;;62     	for (e = 0; e < num_elem; e++)
;;;63     		total_len += len[e];
;;;64     	left = total_len;
;;;65     
;;;66     	e = 0;
;;;67     	pos = addr[0];
;;;68     	end = pos + len[0];
;;;69     
;;;70     	while (left >= AES_BLOCK_SIZE) {
;;;71     		for (i = 0; i < AES_BLOCK_SIZE; i++) {
;;;72     			cbc[i] ^= *pos++;
;;;73     			if (pos >= end) {
;;;74     				e++;
;;;75     				pos = addr[e];
;;;76     				end = pos + len[e];
;;;77     			}
;;;78     		}
;;;79     		if (left > AES_BLOCK_SIZE)
;;;80     			aes_encrypt(ctx, cbc, cbc);
;;;81     		left -= AES_BLOCK_SIZE;
;;;82     	}
;;;83     
;;;84     	os_memset(pad, 0, AES_BLOCK_SIZE);
;;;85     	aes_encrypt(ctx, pad, pad);
;;;86     	gf_mulx(pad);
;;;87     
;;;88     	if (left || total_len == 0) {
;;;89     		for (i = 0; i < left; i++) {
;;;90     			cbc[i] ^= *pos++;
;;;91     			if (pos >= end) {
;;;92     				e++;
;;;93     				pos = addr[e];
;;;94     				end = pos + len[e];
;;;95     			}
;;;96     		}
;;;97     		cbc[left] ^= 0x80;
;;;98     		gf_mulx(pad);
;;;99     	}
;;;100    
;;;101    	for (i = 0; i < AES_BLOCK_SIZE; i++)
;;;102    		pad[i] ^= cbc[i];
;;;103    	aes_encrypt(ctx, pad, mac);
;;;104    	aes_encrypt_deinit(ctx);
;;;105    	return 0;
;;;106    }
00001c  b00d              ADD      sp,sp,#0x34
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.34|
000022  2210              MOVS     r2,#0x10              ;59
000024  2100              MOVS     r1,#0                 ;59
000026  a804              ADD      r0,sp,#0x10           ;59
000028  f7fffffe          BL       os_memset
00002c  f04f0a00          MOV      r10,#0                ;61
000030  2600              MOVS     r6,#0                 ;62
000032  e003              B        |L5.60|
                  |L5.52|
000034  f8580026          LDR      r0,[r8,r6,LSL #2]     ;63
000038  4482              ADD      r10,r10,r0            ;63
00003a  1c76              ADDS     r6,r6,#1              ;62
                  |L5.60|
00003c  980a              LDR      r0,[sp,#0x28]         ;62
00003e  4286              CMP      r6,r0                 ;62
000040  d3f8              BCC      |L5.52|
000042  4657              MOV      r7,r10                ;64
000044  2600              MOVS     r6,#0                 ;66
000046  f8d95000          LDR      r5,[r9,#0]            ;67
00004a  f8d80000          LDR      r0,[r8,#0]            ;68
00004e  eb000b05          ADD      r11,r0,r5             ;68
000052  e01c              B        |L5.142|
                  |L5.84|
000054  2400              MOVS     r4,#0                 ;71
000056  e010              B        |L5.122|
                  |L5.88|
000058  f8150b01          LDRB     r0,[r5],#1            ;72
00005c  a904              ADD      r1,sp,#0x10           ;72
00005e  5d09              LDRB     r1,[r1,r4]            ;72
000060  4048              EORS     r0,r0,r1              ;72
000062  a904              ADD      r1,sp,#0x10           ;72
000064  5508              STRB     r0,[r1,r4]            ;72
000066  455d              CMP      r5,r11                ;73
000068  d306              BCC      |L5.120|
00006a  1c76              ADDS     r6,r6,#1              ;74
00006c  f8595026          LDR      r5,[r9,r6,LSL #2]     ;75
000070  f8580026          LDR      r0,[r8,r6,LSL #2]     ;76
000074  eb000b05          ADD      r11,r0,r5             ;76
                  |L5.120|
000078  1c64              ADDS     r4,r4,#1              ;71
                  |L5.122|
00007a  2c10              CMP      r4,#0x10              ;71
00007c  d3ec              BCC      |L5.88|
00007e  2f10              CMP      r7,#0x10              ;79
000080  d904              BLS      |L5.140|
000082  aa04              ADD      r2,sp,#0x10           ;80
000084  a904              ADD      r1,sp,#0x10           ;80
000086  9808              LDR      r0,[sp,#0x20]         ;80
000088  f7fffffe          BL       aes_encrypt
                  |L5.140|
00008c  3f10              SUBS     r7,r7,#0x10           ;81
                  |L5.142|
00008e  2f10              CMP      r7,#0x10              ;70
000090  d2e0              BCS      |L5.84|
000092  2210              MOVS     r2,#0x10              ;84
000094  2100              MOVS     r1,#0                 ;84
000096  4668              MOV      r0,sp                 ;84
000098  f7fffffe          BL       os_memset
00009c  466a              MOV      r2,sp                 ;85
00009e  4669              MOV      r1,sp                 ;85
0000a0  9808              LDR      r0,[sp,#0x20]         ;85
0000a2  f7fffffe          BL       aes_encrypt
0000a6  4668              MOV      r0,sp                 ;86
0000a8  f7fffffe          BL       gf_mulx
0000ac  b917              CBNZ     r7,|L5.180|
0000ae  f1ba0f00          CMP      r10,#0                ;88
0000b2  d11d              BNE      |L5.240|
                  |L5.180|
0000b4  2400              MOVS     r4,#0                 ;89
0000b6  e010              B        |L5.218|
                  |L5.184|
0000b8  f8150b01          LDRB     r0,[r5],#1            ;90
0000bc  a904              ADD      r1,sp,#0x10           ;90
0000be  5d09              LDRB     r1,[r1,r4]            ;90
0000c0  4048              EORS     r0,r0,r1              ;90
0000c2  a904              ADD      r1,sp,#0x10           ;90
0000c4  5508              STRB     r0,[r1,r4]            ;90
0000c6  455d              CMP      r5,r11                ;91
0000c8  d306              BCC      |L5.216|
0000ca  1c76              ADDS     r6,r6,#1              ;92
0000cc  f8595026          LDR      r5,[r9,r6,LSL #2]     ;93
0000d0  f8580026          LDR      r0,[r8,r6,LSL #2]     ;94
0000d4  eb000b05          ADD      r11,r0,r5             ;94
                  |L5.216|
0000d8  1c64              ADDS     r4,r4,#1              ;89
                  |L5.218|
0000da  42bc              CMP      r4,r7                 ;89
0000dc  d3ec              BCC      |L5.184|
0000de  a804              ADD      r0,sp,#0x10           ;97
0000e0  5dc0              LDRB     r0,[r0,r7]            ;97
0000e2  f0800080          EOR      r0,r0,#0x80           ;97
0000e6  a904              ADD      r1,sp,#0x10           ;97
0000e8  55c8              STRB     r0,[r1,r7]            ;97
0000ea  4668              MOV      r0,sp                 ;98
0000ec  f7fffffe          BL       gf_mulx
                  |L5.240|
0000f0  2400              MOVS     r4,#0                 ;101
0000f2  e007              B        |L5.260|
                  |L5.244|
0000f4  f81d0004          LDRB     r0,[sp,r4]            ;102
0000f8  a904              ADD      r1,sp,#0x10           ;102
0000fa  5d09              LDRB     r1,[r1,r4]            ;102
0000fc  4048              EORS     r0,r0,r1              ;102
0000fe  f80d0004          STRB     r0,[sp,r4]            ;102
000102  1c64              ADDS     r4,r4,#1              ;101
                  |L5.260|
000104  2c10              CMP      r4,#0x10              ;101
000106  d3f5              BCC      |L5.244|
000108  4669              MOV      r1,sp                 ;103
00010a  9a16              LDR      r2,[sp,#0x58]         ;103
00010c  9808              LDR      r0,[sp,#0x20]         ;103
00010e  f7fffffe          BL       aes_encrypt
000112  9808              LDR      r0,[sp,#0x20]         ;104
000114  f7fffffe          BL       aes_encrypt_deinit
000118  2000              MOVS     r0,#0                 ;105
00011a  e77f              B        |L5.28|
;;;107    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L10.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L10.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L10.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L10.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L13.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L13.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L13.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L13.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L19.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L19.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP

