; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\sdio.o --depend=.\obj\sdio.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\sdio.crf ..\sdio\src\sdio.c]
                          THUMB

                          AREA ||i._mmc_select_card||, CODE, READONLY, ALIGN=1

                  _mmc_select_card PROC
;;;367    
;;;368    static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
000002  b08c              SUB      sp,sp,#0x30
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;370    	int err;
;;;371    	struct mmc_command cmd;
;;;372    
;;;373    	//BUG_ON(!host);
;;;374    
;;;375    	memset(&cmd, 0, sizeof(struct mmc_command));
000008  212c              MOVS     r1,#0x2c
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;376    
;;;377    	cmd.opcode = MMC_SELECT_CARD;
000010  2007              MOVS     r0,#7
000012  9001              STR      r0,[sp,#4]
;;;378    
;;;379    	if (card) {
000014  b12c              CBZ      r4,|L1.34|
;;;380    		cmd.arg = card->rca << 16;
000016  6860              LDR      r0,[r4,#4]
000018  0400              LSLS     r0,r0,#16
00001a  9002              STR      r0,[sp,#8]
;;;381    		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
00001c  2015              MOVS     r0,#0x15
00001e  9007              STR      r0,[sp,#0x1c]
000020  e002              B        |L1.40|
                  |L1.34|
;;;382    	} else {
;;;383    		cmd.arg = 0;
000022  2000              MOVS     r0,#0
000024  9002              STR      r0,[sp,#8]
;;;384    		cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
000026  9007              STR      r0,[sp,#0x1c]
                  |L1.40|
;;;385    	}
;;;386    
;;;387    	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
000028  2203              MOVS     r2,#3
00002a  a901              ADD      r1,sp,#4
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       mmc_wait_for_cmd
000032  4605              MOV      r5,r0
;;;388    	if (err)
000034  b115              CBZ      r5,|L1.60|
;;;389    		return err;
000036  4628              MOV      r0,r5
                  |L1.56|
;;;390    
;;;391    	return 0;
;;;392    }
000038  b00c              ADD      sp,sp,#0x30
00003a  bd70              POP      {r4-r6,pc}
                  |L1.60|
00003c  2000              MOVS     r0,#0                 ;391
00003e  e7fb              B        |L1.56|
;;;393    int mmc_select_card(struct mmc_card *card)
                          ENDP


                          AREA ||i.align_power2||, CODE, READONLY, ALIGN=1

                  align_power2 PROC
;;;792     */
;;;793    static u16 align_power2(u16 size)
000000  4601              MOV      r1,r0
;;;794    {
;;;795    	u16 i=1;
000002  2001              MOVS     r0,#1
;;;796    	while((i<size)&&(i<512)){
000004  e001              B        |L2.10|
                  |L2.6|
;;;797    		i<<=1;
000006  0442              LSLS     r2,r0,#17
000008  0c10              LSRS     r0,r2,#16
                  |L2.10|
00000a  4288              CMP      r0,r1                 ;796
00000c  da02              BGE      |L2.20|
00000e  f5b07f00          CMP      r0,#0x200             ;796
000012  dbf8              BLT      |L2.6|
                  |L2.20|
;;;798    	}
;;;799    	return i;			
;;;800    }
000014  4770              BX       lr
;;;801    
                          ENDP


                          AREA ||i.mmc_attach_sdio||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  mmc_attach_sdio PROC
;;;533     */
;;;534    int mmc_attach_sdio(struct mmc_host *host, u32 ocr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;535    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;536    	int err;
;;;537    	int i, funcs;
;;;538    	struct mmc_card *card;
;;;539    
;;;540    	/*BUG_ON(!host);
;;;541    	WARN_ON(!host->claimed);
;;;542    
;;;543    	mmc_attach_bus(host, &mmc_sdio_ops);*/
;;;544    
;;;545    	/*
;;;546    	 * Sanity check the voltages that the card claims to
;;;547    	 * support.
;;;548    	 */
;;;549    	if (ocr & 0x7F) {
000008  f0170f7f          TST      r7,#0x7f
00000c  d005              BEQ      |L3.26|
;;;550    		printk(KERN_WARNING "%s: card claims to support voltages "
00000e  a12e              ADR      r1,|L3.200|
000010  482f              LDR      r0,|L3.208|
000012  f7fffffe          BL       __2printf
;;;551    		       "below the defined range. These will be ignored.\n",
;;;552    		       mmc_hostname(host));
;;;553    		ocr &= ~0x7F;
000016  f027077f          BIC      r7,r7,#0x7f
                  |L3.26|
;;;554    	}
;;;555    
;;;556    	host->ocr = mmc_select_voltage(host, ocr);
00001a  4639              MOV      r1,r7
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       mmc_select_voltage
000022  63e8              STR      r0,[r5,#0x3c]
;;;557    
;;;558    	/*
;;;559    	 * Can we support the voltage(s) of the card(s)?
;;;560    	 */
;;;561    	if (!host->ocr) {
000024  6be8              LDR      r0,[r5,#0x3c]
000026  b910              CBNZ     r0,|L3.46|
;;;562    		err = -EINVAL;
000028  f06f0415          MVN      r4,#0x15
;;;563    		goto err;
00002c  e045              B        |L3.186|
                  |L3.46|
;;;564    	}
;;;565    	/*
;;;566    	 * Detect and init the card.
;;;567    	 */
;;;568    	err = mmc_sdio_init_card(host, host->ocr, NULL);
00002e  2200              MOVS     r2,#0
000030  4628              MOV      r0,r5
000032  6be9              LDR      r1,[r5,#0x3c]
000034  f7fffffe          BL       mmc_sdio_init_card
000038  4604              MOV      r4,r0
;;;569    	if (err)
00003a  b104              CBZ      r4,|L3.62|
;;;570    		goto err;
00003c  e03d              B        |L3.186|
                  |L3.62|
;;;571    	card = host->card;
00003e  f8d59054          LDR      r9,[r5,#0x54]
;;;572    
;;;573    	/*
;;;574    	 * The number of functions on the card is encoded inside
;;;575    	 * the ocr.
;;;576    	 */
;;;577    	card->sdio_funcs = funcs = (ocr & 0x70000000) >> 28;//最多7个功能
000042  f3c77802          UBFX     r8,r7,#28,#3
000046  f8c98090          STR      r8,[r9,#0x90]
;;;578    	pr_debug("SD support %d function \n",funcs);
;;;579    	
;;;580    	/*
;;;581    	 * If needed, disconnect card detection pull-up resistor.
;;;582    	 */
;;;583    	err = sdio_disable_cd(card);
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       sdio_disable_cd
000050  4604              MOV      r4,r0
;;;584    	if (err)
000052  b104              CBZ      r4,|L3.86|
;;;585    		goto remove;
000054  e02d              B        |L3.178|
                  |L3.86|
;;;586    	
;;;587    	/*
;;;588    	 * Initialize (but don't add) all present functions.
;;;589    	 */
;;;590            printk("Device function count = %d \r\n", funcs);
000056  4641              MOV      r1,r8
000058  a01e              ADR      r0,|L3.212|
00005a  f7fffffe          BL       __2printf
;;;591    	for (i = 0;i < funcs;i++) {
00005e  2600              MOVS     r6,#0
000060  e007              B        |L3.114|
                  |L3.98|
;;;592    		err = sdio_init_func(host->card, i + 1);
000062  1c71              ADDS     r1,r6,#1
000064  6d68              LDR      r0,[r5,#0x54]
000066  f7fffffe          BL       sdio_init_func
00006a  4604              MOV      r4,r0
;;;593    		if (err)
00006c  b104              CBZ      r4,|L3.112|
;;;594    			goto remove;
00006e  e020              B        |L3.178|
                  |L3.112|
000070  1c76              ADDS     r6,r6,#1              ;591
                  |L3.114|
000072  4546              CMP      r6,r8                 ;591
000074  dbf5              BLT      |L3.98|
;;;595    	}
;;;596            printk("Device function inital [ok]!\r\n");
000076  a01f              ADR      r0,|L3.244|
000078  f7fffffe          BL       __2printf
;;;597    
;;;598    	//mmc_release_host(host);
;;;599    
;;;600    	/*
;;;601    	 * First add the card to the driver model...
;;;602    	 */
;;;603    	err = mmc_add_card(host->card);
00007c  6d68              LDR      r0,[r5,#0x54]
00007e  f7fffffe          BL       mmc_add_card
000082  4604              MOV      r4,r0
;;;604    	if (err)
000084  b104              CBZ      r4,|L3.136|
;;;605    		goto remove_added;
000086  e010              B        |L3.170|
                  |L3.136|
;;;606    	/*
;;;607    	 * ...then the SDIO functions.
;;;608    	 */
;;;609    	for (i = 0;i < funcs;i++) {
000088  2600              MOVS     r6,#0
00008a  e009              B        |L3.160|
                  |L3.140|
;;;610    		err = sdio_add_func(host->card->sdio_func[i]);
00008c  6d69              LDR      r1,[r5,#0x54]
00008e  31ac              ADDS     r1,r1,#0xac
000090  f8510026          LDR      r0,[r1,r6,LSL #2]
000094  f7fffffe          BL       sdio_add_func
000098  4604              MOV      r4,r0
;;;611    		if (err)
00009a  b104              CBZ      r4,|L3.158|
;;;612    			goto remove_added;
00009c  e005              B        |L3.170|
                  |L3.158|
00009e  1c76              ADDS     r6,r6,#1              ;609
                  |L3.160|
0000a0  4546              CMP      r6,r8                 ;609
0000a2  dbf3              BLT      |L3.140|
;;;613    	}
;;;614    
;;;615    	return 0;
0000a4  2000              MOVS     r0,#0
                  |L3.166|
;;;616    
;;;617    
;;;618    remove_added:
;;;619    	printk("Remove without lock if the device has been added.\n");
;;;620    remove:
;;;621    	printk("And with lock if it hasn't been added.\n");	
;;;622    err:
;;;623    	printk(KERN_ERR "%s: error %d whilst initialising SDIO card\n",
;;;624    		mmc_hostname(host), err);
;;;625    	return err;
;;;626    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
                  |L3.170|
0000aa  a01a              ADR      r0,|L3.276|
0000ac  f7fffffe          BL       __2printf
0000b0  bf00              NOP                            ;620
                  |L3.178|
0000b2  a025              ADR      r0,|L3.328|
0000b4  f7fffffe          BL       __2printf
0000b8  bf00              NOP                            ;622
                  |L3.186|
0000ba  4622              MOV      r2,r4                 ;623
0000bc  a102              ADR      r1,|L3.200|
0000be  a02c              ADR      r0,|L3.368|
0000c0  f7fffffe          BL       __2printf
0000c4  4620              MOV      r0,r4                 ;625
0000c6  e7ee              B        |L3.166|
;;;627    
                          ENDP

                  |L3.200|
0000c8  77696669          DCB      "wifi",0
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L3.208|
                          DCD      ||.constdata||
                  |L3.212|
0000d4  44657669          DCB      "Device function count = %d \r\n",0
0000d8  63652066
0000dc  756e6374
0000e0  696f6e20
0000e4  636f756e
0000e8  74203d20
0000ec  2564200d
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L3.244|
0000f4  44657669          DCB      "Device function inital [ok]!\r\n",0
0000f8  63652066
0000fc  756e6374
000100  696f6e20
000104  696e6974
000108  616c205b
00010c  6f6b5d21
000110  0d0a00  
000113  00                DCB      0
                  |L3.276|
000114  52656d6f          DCB      "Remove without lock if the device has been added.\n",0
000118  76652077
00011c  6974686f
000120  7574206c
000124  6f636b20
000128  69662074
00012c  68652064
000130  65766963
000134  65206861
000138  73206265
00013c  656e2061
000140  64646564
000144  2e0a00  
000147  00                DCB      0
                  |L3.328|
000148  416e6420          DCB      "And with lock if it hasn't been added.\n",0
00014c  77697468
000150  206c6f63
000154  6b206966
000158  20697420
00015c  6861736e
000160  27742062
000164  65656e20
000168  61646465
00016c  642e0a00
                  |L3.368|
000170  25733a20          DCB      "%s: error %d whilst initialising SDIO card\n",0
000174  6572726f
000178  72202564
00017c  20776869
000180  6c737420
000184  696e6974
000188  69616c69
00018c  73696e67
000190  20534449
000194  4f206361
000198  72640a00

                          AREA ||i.mmc_io_rw_direct||, CODE, READONLY, ALIGN=1

                  mmc_io_rw_direct PROC
;;;118    
;;;119    int mmc_io_rw_direct(struct mmc_card *card, int write, unsigned fn,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;120    	unsigned addr, u8 in, u8* out)
;;;121    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4691              MOV      r9,r2
00000c  461f              MOV      r7,r3
00000e  e9dda514          LDRD     r10,r5,[sp,#0x50]
;;;122    	struct mmc_command cmd;
;;;123    	int err;
;;;124    /*	BUG_ON(!card);
;;;125    	BUG_ON(fn > 7);*/
;;;126    
;;;127    	/* sanity check */
;;;128    	if (addr & ~0x1FFFF)
000012  0c78              LSRS     r0,r7,#17
000014  0440              LSLS     r0,r0,#17
000016  d004              BEQ      |L4.34|
;;;129    		return -EINVAL;
000018  f06f0015          MVN      r0,#0x15
                  |L4.28|
;;;130    
;;;131    	memset(&cmd, 0, sizeof(struct mmc_command));
;;;132    
;;;133    	cmd.opcode = SD_IO_RW_DIRECT;
;;;134    	cmd.arg = write ? 0x80000000 : 0x00000000;
;;;135    	cmd.arg |= fn << 28;
;;;136    	cmd.arg |= (write && out) ? 0x08000000 : 0x00000000;
;;;137    	cmd.arg |= addr << 9;
;;;138    	cmd.arg |= in;
;;;139    	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
;;;140    
;;;141    	err = mmc_wait_for_cmd(card->host, &cmd, 0);
;;;142    	if (err)
;;;143    		return err;
;;;144    
;;;145    	if (mmc_host_is_spi(card->host)) {
;;;146    		/* host driver already reported errors */
;;;147    	} else {
;;;148    		if (cmd.resp[0] & R5_ERROR)
;;;149    			return -EIO;
;;;150    		if (cmd.resp[0] & R5_FUNCTION_NUMBER)
;;;151    			return -EINVAL;
;;;152    		if (cmd.resp[0] & R5_OUT_OF_RANGE)
;;;153    			return -ERANGE;
;;;154    	}
;;;155    
;;;156    	if (out) {
;;;157    		if (mmc_host_is_spi(card->host))
;;;158    			*out = (cmd.resp[0] >> 8) & 0xFF;
;;;159    		else
;;;160    			*out = cmd.resp[0] & 0xFF;
;;;161    	}
;;;162    	//sdio_deb_leave;
;;;163    	return 0;
;;;164    }
00001c  b00c              ADD      sp,sp,#0x30
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L4.34|
000022  212c              MOVS     r1,#0x2c              ;131
000024  a801              ADD      r0,sp,#4              ;131
000026  f7fffffe          BL       __aeabi_memclr4
00002a  2034              MOVS     r0,#0x34              ;133
00002c  9001              STR      r0,[sp,#4]            ;133
00002e  b10e              CBZ      r6,|L4.52|
000030  0740              LSLS     r0,r0,#29             ;134
000032  e000              B        |L4.54|
                  |L4.52|
000034  2000              MOVS     r0,#0                 ;134
                  |L4.54|
000036  9002              STR      r0,[sp,#8]            ;134
000038  9802              LDR      r0,[sp,#8]            ;135
00003a  ea407009          ORR      r0,r0,r9,LSL #28      ;135
00003e  9002              STR      r0,[sp,#8]            ;135
000040  b11e              CBZ      r6,|L4.74|
000042  b115              CBZ      r5,|L4.74|
000044  f04f6000          MOV      r0,#0x8000000         ;136
000048  e000              B        |L4.76|
                  |L4.74|
00004a  2000              MOVS     r0,#0                 ;136
                  |L4.76|
00004c  9902              LDR      r1,[sp,#8]            ;136
00004e  4308              ORRS     r0,r0,r1              ;136
000050  9002              STR      r0,[sp,#8]            ;136
000052  9802              LDR      r0,[sp,#8]            ;137
000054  ea402047          ORR      r0,r0,r7,LSL #9       ;137
000058  9002              STR      r0,[sp,#8]            ;137
00005a  9802              LDR      r0,[sp,#8]            ;138
00005c  ea40000a          ORR      r0,r0,r10             ;138
000060  9002              STR      r0,[sp,#8]            ;138
000062  f2401095          MOV      r0,#0x195             ;139
000066  9007              STR      r0,[sp,#0x1c]         ;139
000068  2200              MOVS     r2,#0                 ;141
00006a  a901              ADD      r1,sp,#4              ;141
00006c  6820              LDR      r0,[r4,#0]            ;141
00006e  f7fffffe          BL       mmc_wait_for_cmd
000072  4680              MOV      r8,r0                 ;141
000074  f1b80f00          CMP      r8,#0                 ;142
000078  d001              BEQ      |L4.126|
00007a  4640              MOV      r0,r8                 ;143
00007c  e7ce              B        |L4.28|
                  |L4.126|
00007e  6820              LDR      r0,[r4,#0]            ;145
000080  6940              LDR      r0,[r0,#0x14]         ;145
000082  f0100f10          TST      r0,#0x10              ;145
000086  d114              BNE      |L4.178|
000088  9803              LDR      r0,[sp,#0xc]          ;148
00008a  f4106f00          TST      r0,#0x800             ;148
00008e  d002              BEQ      |L4.150|
000090  f06f0004          MVN      r0,#4                 ;149
000094  e7c2              B        |L4.28|
                  |L4.150|
000096  9803              LDR      r0,[sp,#0xc]          ;150
000098  f4107f00          TST      r0,#0x200             ;150
00009c  d002              BEQ      |L4.164|
00009e  f06f0015          MVN      r0,#0x15              ;151
0000a2  e7bb              B        |L4.28|
                  |L4.164|
0000a4  9803              LDR      r0,[sp,#0xc]          ;152
0000a6  f4107f80          TST      r0,#0x100             ;152
0000aa  d002              BEQ      |L4.178|
0000ac  f06f0021          MVN      r0,#0x21              ;153
0000b0  e7b4              B        |L4.28|
                  |L4.178|
0000b2  b155              CBZ      r5,|L4.202|
0000b4  6820              LDR      r0,[r4,#0]            ;157
0000b6  6940              LDR      r0,[r0,#0x14]         ;157
0000b8  f0100f10          TST      r0,#0x10              ;157
0000bc  d003              BEQ      |L4.198|
0000be  9803              LDR      r0,[sp,#0xc]          ;158
0000c0  0a00              LSRS     r0,r0,#8              ;158
0000c2  7028              STRB     r0,[r5,#0]            ;158
0000c4  e001              B        |L4.202|
                  |L4.198|
0000c6  9803              LDR      r0,[sp,#0xc]          ;160
0000c8  7028              STRB     r0,[r5,#0]            ;160
                  |L4.202|
0000ca  2000              MOVS     r0,#0                 ;163
0000cc  e7a6              B        |L4.28|
;;;165    
                          ENDP


                          AREA ||i.mmc_io_rw_extended||, CODE, READONLY, ALIGN=1

                  mmc_io_rw_extended PROC
;;;890    
;;;891    int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;892    	unsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)
;;;893    {
000004  b09b              SUB      sp,sp,#0x6c
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  4691              MOV      r9,r2
00000c  4698              MOV      r8,r3
00000e  e9ddab24          LDRD     r10,r11,[sp,#0x90]
000012  e9dd5626          LDRD     r5,r6,[sp,#0x98]
;;;894    	struct mmc_request mrq;
;;;895    	struct mmc_command cmd;
;;;896    	struct mmc_data data;
;;;897    	//struct scatterlist sg;
;;;898    //	unsigned char *sg;
;;;899    
;;;900    	/*BUG_ON(!card);
;;;901    	BUG_ON(fn > 7);
;;;902    	BUG_ON(blocks == 1 && blksz > 512);
;;;903    	WARN_ON(blocks == 0);
;;;904    	WARN_ON(blksz == 0);*/
;;;905    
;;;906    	/* sanity check */
;;;907    	if (addr & ~0x1FFFF)
000016  ea4f4058          LSR      r0,r8,#17
00001a  ea5f4040          LSLS.W   r0,r0,#17
00001e  d004              BEQ      |L5.42|
;;;908    		return -EINVAL;
000020  f06f0015          MVN      r0,#0x15
                  |L5.36|
;;;909    
;;;910    	memset(&mrq, 0, sizeof(struct mmc_request));
;;;911    	memset(&cmd, 0, sizeof(struct mmc_command));
;;;912    	memset(&data, 0, sizeof(struct mmc_data));
;;;913    
;;;914    	mrq.cmd = &cmd;
;;;915    	mrq.data = &data;
;;;916    
;;;917    	cmd.opcode = SD_IO_RW_EXTENDED;
;;;918    	cmd.arg = write ? 0x80000000 : 0x00000000;
;;;919    	cmd.arg |= fn << 28;
;;;920    	cmd.arg |= incr_addr ? 0x04000000 : 0x00000000;
;;;921    	cmd.arg |= addr << 9;
;;;922    	if (blocks == 1 && blksz <= 512)
;;;923    		cmd.arg |= (blksz == 512) ? 0 : blksz;	/* byte mode */
;;;924    	else
;;;925    		cmd.arg |= 0x08000000 | blocks;		/* block mode */
;;;926    	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
;;;927    
;;;928    	data.blksz = blksz;
;;;929    	data.blocks = blocks;
;;;930    	data.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
;;;931    	/*realy save data */
;;;932    	//data.sg = &sg;
;;;933    	//data.sg_len = 1;
;;;934    	//sg_init_one(&sg, buf, blksz * blocks);
;;;935    	//修改以后的缓存
;;;936    	data.sg=buf;
;;;937    	data.sg_len = blksz * blocks;
;;;938    
;;;939    	mmc_set_data_timeout(&data, card);
;;;940    
;;;941    	mmc_wait_for_req(card->host, &mrq);
;;;942    
;;;943    	if (cmd.error)
;;;944    		return cmd.error;
;;;945    	if (data.error)
;;;946    		return data.error;
;;;947    
;;;948    	if (mmc_host_is_spi(card->host)) {
;;;949    		/* host driver already reported errors */
;;;950    	} else {
;;;951    		if (cmd.resp[0] & R5_ERROR)
;;;952    			return -EIO;
;;;953    		if (cmd.resp[0] & R5_FUNCTION_NUMBER)
;;;954    			return -EINVAL;
;;;955    		if (cmd.resp[0] & R5_OUT_OF_RANGE)
;;;956    			return -ERANGE;
;;;957    	}
;;;958    
;;;959    	return 0;
;;;960    }
000024  b01b              ADD      sp,sp,#0x6c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.42|
00002a  2114              MOVS     r1,#0x14              ;910
00002c  a816              ADD      r0,sp,#0x58           ;910
00002e  f7fffffe          BL       __aeabi_memclr4
000032  212c              MOVS     r1,#0x2c              ;911
000034  a80b              ADD      r0,sp,#0x2c           ;911
000036  f7fffffe          BL       __aeabi_memclr4
00003a  212c              MOVS     r1,#0x2c              ;912
00003c  4668              MOV      r0,sp                 ;912
00003e  f7fffffe          BL       __aeabi_memclr4
000042  a80b              ADD      r0,sp,#0x2c           ;914
000044  9016              STR      r0,[sp,#0x58]         ;914
000046  f8cdd05c          STR      sp,[sp,#0x5c]         ;915
00004a  2035              MOVS     r0,#0x35              ;917
00004c  900b              STR      r0,[sp,#0x2c]         ;917
00004e  b10f              CBZ      r7,|L5.84|
000050  07c0              LSLS     r0,r0,#31             ;918
000052  e000              B        |L5.86|
                  |L5.84|
000054  2000              MOVS     r0,#0                 ;918
                  |L5.86|
000056  900c              STR      r0,[sp,#0x30]         ;918
000058  980c              LDR      r0,[sp,#0x30]         ;919
00005a  ea407009          ORR      r0,r0,r9,LSL #28      ;919
00005e  900c              STR      r0,[sp,#0x30]         ;919
000060  980c              LDR      r0,[sp,#0x30]         ;920
000062  f1ba0f00          CMP      r10,#0                ;920
000066  d002              BEQ      |L5.110|
000068  f04f6180          MOV      r1,#0x4000000         ;920
00006c  e000              B        |L5.112|
                  |L5.110|
00006e  2100              MOVS     r1,#0                 ;920
                  |L5.112|
000070  4308              ORRS     r0,r0,r1              ;920
000072  900c              STR      r0,[sp,#0x30]         ;920
000074  980c              LDR      r0,[sp,#0x30]         ;921
000076  ea402048          ORR      r0,r0,r8,LSL #9       ;921
00007a  900c              STR      r0,[sp,#0x30]         ;921
00007c  2d01              CMP      r5,#1                 ;922
00007e  d10c              BNE      |L5.154|
000080  f5b67f00          CMP      r6,#0x200             ;922
000084  d809              BHI      |L5.154|
000086  980c              LDR      r0,[sp,#0x30]         ;923
000088  f5b67f00          CMP      r6,#0x200             ;923
00008c  d101              BNE      |L5.146|
00008e  2100              MOVS     r1,#0                 ;923
000090  e000              B        |L5.148|
                  |L5.146|
000092  4631              MOV      r1,r6                 ;923
                  |L5.148|
000094  4308              ORRS     r0,r0,r1              ;923
000096  900c              STR      r0,[sp,#0x30]         ;923
000098  e004              B        |L5.164|
                  |L5.154|
00009a  f0456100          ORR      r1,r5,#0x8000000      ;925
00009e  980c              LDR      r0,[sp,#0x30]         ;925
0000a0  4308              ORRS     r0,r0,r1              ;925
0000a2  900c              STR      r0,[sp,#0x30]         ;925
                  |L5.164|
0000a4  f24010b5          MOV      r0,#0x1b5             ;926
0000a8  9011              STR      r0,[sp,#0x44]         ;926
0000aa  9602              STR      r6,[sp,#8]            ;928
0000ac  9503              STR      r5,[sp,#0xc]          ;929
0000ae  b117              CBZ      r7,|L5.182|
0000b0  f44f7080          MOV      r0,#0x100             ;930
0000b4  e001              B        |L5.186|
                  |L5.182|
0000b6  f44f7000          MOV      r0,#0x200             ;930
                  |L5.186|
0000ba  9005              STR      r0,[sp,#0x14]         ;930
0000bc  f8cdb028          STR      r11,[sp,#0x28]        ;936
0000c0  fb06f005          MUL      r0,r6,r5              ;937
0000c4  9009              STR      r0,[sp,#0x24]         ;937
0000c6  4621              MOV      r1,r4                 ;939
0000c8  4668              MOV      r0,sp                 ;939
0000ca  f7fffffe          BL       mmc_set_data_timeout
0000ce  a916              ADD      r1,sp,#0x58           ;941
0000d0  6820              LDR      r0,[r4,#0]            ;941
0000d2  f7fffffe          BL       mmc_wait_for_req
0000d6  9813              LDR      r0,[sp,#0x4c]         ;943
0000d8  b108              CBZ      r0,|L5.222|
0000da  9813              LDR      r0,[sp,#0x4c]         ;944
0000dc  e7a2              B        |L5.36|
                  |L5.222|
0000de  9804              LDR      r0,[sp,#0x10]         ;945
0000e0  b108              CBZ      r0,|L5.230|
0000e2  9804              LDR      r0,[sp,#0x10]         ;946
0000e4  e79e              B        |L5.36|
                  |L5.230|
0000e6  6820              LDR      r0,[r4,#0]            ;948
0000e8  6940              LDR      r0,[r0,#0x14]         ;948
0000ea  f0100f10          TST      r0,#0x10              ;948
0000ee  d114              BNE      |L5.282|
0000f0  980d              LDR      r0,[sp,#0x34]         ;951
0000f2  f4106f00          TST      r0,#0x800             ;951
0000f6  d002              BEQ      |L5.254|
0000f8  f06f0004          MVN      r0,#4                 ;952
0000fc  e792              B        |L5.36|
                  |L5.254|
0000fe  980d              LDR      r0,[sp,#0x34]         ;953
000100  f4107f00          TST      r0,#0x200             ;953
000104  d002              BEQ      |L5.268|
000106  f06f0015          MVN      r0,#0x15              ;954
00010a  e78b              B        |L5.36|
                  |L5.268|
00010c  980d              LDR      r0,[sp,#0x34]         ;955
00010e  f4107f80          TST      r0,#0x100             ;955
000112  d002              BEQ      |L5.282|
000114  f06f0021          MVN      r0,#0x21              ;956
000118  e784              B        |L5.36|
                  |L5.282|
00011a  2000              MOVS     r0,#0                 ;959
00011c  e782              B        |L5.36|
;;;961    
                          ENDP


                          AREA ||i.mmc_sdio_init_card||, CODE, READONLY, ALIGN=2

                  mmc_sdio_init_card PROC
;;;406     */
;;;407    static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;408    			      struct mmc_card *oldcard)
;;;409    {
000002  4606              MOV      r6,r0
000004  4617              MOV      r7,r2
;;;410    	struct mmc_card *card;
;;;411    	int err;
;;;412    	/*
;;;413    	BUG_ON(!host);
;;;414    	WARN_ON(!host->claimed);*/
;;;415    
;;;416    	/*
;;;417    	 * Inform the card of the voltage
;;;418    	 */
;;;419    	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
000006  aa01              ADD      r2,sp,#4
000008  4630              MOV      r0,r6
00000a  6bf1              LDR      r1,[r6,#0x3c]
00000c  f7fffffe          BL       mmc_send_io_op_cond
000010  4604              MOV      r4,r0
;;;420    	if (err)
000012  b104              CBZ      r4,|L6.22|
;;;421    		goto err;
000014  e04c              B        |L6.176|
                  |L6.22|
;;;422    
;;;423    	/*
;;;424    	 * For SPI, enable CRC as appropriate.
;;;425    	 */
;;;426    	/*if (mmc_host_is_spi(host)) {
;;;427    		err = mmc_spi_set_crc(host, use_spi_crc);
;;;428    		if (err)
;;;429    			goto err;
;;;430    	}*/
;;;431    
;;;432    	/*
;;;433    	 * Allocate card structure.
;;;434    	 */
;;;435    	card = mmc_alloc_card(host);//静态分配不用判断分配失败
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       mmc_alloc_card
00001c  4605              MOV      r5,r0
;;;436    /*	if (IS_ERR(card)) {
;;;437    		err = PTR_ERR(card);
;;;438    		goto err;
;;;439    	}*/
;;;440    
;;;441    	card->type = MMC_TYPE_SDIO;
00001e  2002              MOVS     r0,#2
000020  60a8              STR      r0,[r5,#8]
;;;442    
;;;443    	/*
;;;444    	 * For native busses:  set card RCA and quit open drain mode.
;;;445    	 */
;;;446    	if (!mmc_host_is_spi(host)) {
000022  6970              LDR      r0,[r6,#0x14]
000024  f0100f10          TST      r0,#0x10
000028  d10a              BNE      |L6.64|
;;;447    		err = mmc_send_relative_addr(host, &card->rca);
00002a  1d29              ADDS     r1,r5,#4
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       mmc_send_relative_addr
000032  4604              MOV      r4,r0
;;;448    		if (err)
000034  b104              CBZ      r4,|L6.56|
;;;449    			goto remove;
000036  e037              B        |L6.168|
                  |L6.56|
;;;450    
;;;451    		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
000038  2102              MOVS     r1,#2
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       mmc_set_bus_mode
                  |L6.64|
;;;452    	}
;;;453    
;;;454    	/*
;;;455    	 * Select card, as all following commands rely on that.
;;;456    	 */
;;;457    	if (!mmc_host_is_spi(host)) {
000040  6970              LDR      r0,[r6,#0x14]
000042  f0100f10          TST      r0,#0x10
000046  d105              BNE      |L6.84|
;;;458    		err = mmc_select_card(card);
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       mmc_select_card
00004e  4604              MOV      r4,r0
;;;459    		if (err)
000050  b104              CBZ      r4,|L6.84|
;;;460    			goto remove;
000052  e029              B        |L6.168|
                  |L6.84|
;;;461    	}
;;;462    
;;;463    	/*
;;;464    	 * Read the common registers.
;;;465    	 */
;;;466    	err = sdio_read_cccr(card);
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       sdio_read_cccr
00005a  4604              MOV      r4,r0
;;;467    	if (err)
00005c  b104              CBZ      r4,|L6.96|
;;;468    		goto remove;
00005e  e023              B        |L6.168|
                  |L6.96|
;;;469    
;;;470    	/*
;;;471    	 * Read the common CIS tuples.
;;;472    	 */
;;;473    	err = sdio_read_common_cis(card);//很重要的一个函数，读取通用CIS信息，后面wifi会使用相关的内容
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       sdio_read_common_cis
000066  4604              MOV      r4,r0
;;;474    	if (err)
000068  b104              CBZ      r4,|L6.108|
;;;475    		goto remove;
00006a  e01d              B        |L6.168|
                  |L6.108|
;;;476    /*
;;;477    	if (oldcard) {//
;;;478    		int same = (card->cis.vendor == oldcard->cis.vendor &&
;;;479    			    card->cis.device == oldcard->cis.device);
;;;480    		mmc_remove_card(card);
;;;481    		if (!same) {
;;;482    			err = -ENOENT;
;;;483    			goto err;
;;;484    		}
;;;485    		card = oldcard;
;;;486    		return 0;
;;;487    	}*/
;;;488    
;;;489    	/*
;;;490    	 * Switch to high-speed (if supported).
;;;491    	 */
;;;492    	err = sdio_enable_hs(card);
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       sdio_enable_hs
000072  4604              MOV      r4,r0
;;;493    	if (err)
000074  b104              CBZ      r4,|L6.120|
;;;494    		goto remove;
000076  e017              B        |L6.168|
                  |L6.120|
;;;495    
;;;496    	/*
;;;497    	 * Change to the card's maximum speed.
;;;498    	 */
;;;499    	if (mmc_card_highspeed(card)) {
000078  68e8              LDR      r0,[r5,#0xc]
00007a  f0100f04          TST      r0,#4
00007e  d004              BEQ      |L6.138|
;;;500    		/*
;;;501    		 * The SDIO specification doesn't mention how
;;;502    		 * the CIS transfer speed register relates to
;;;503    		 * high-speed, but it seems that 50 MHz is
;;;504    		 * mandatory.
;;;505    		 */
;;;506    		mmc_set_clock(host,50000000);
000080  490c              LDR      r1,|L6.180|
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       mmc_set_clock
000088  e004              B        |L6.148|
                  |L6.138|
;;;507    	} else {
;;;508    		mmc_set_clock(host, card->cis.max_dtr);
00008a  20a8              MOVS     r0,#0xa8
00008c  5941              LDR      r1,[r0,r5]
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       mmc_set_clock
                  |L6.148|
;;;509    	}
;;;510    
;;;511    	/*
;;;512    	 * Switch to wider bus (if supported).
;;;513    	 */
;;;514    	err = sdio_enable_wide(card);
000094  4628              MOV      r0,r5
000096  f7fffffe          BL       sdio_enable_wide
00009a  4604              MOV      r4,r0
;;;515    	if (err)
00009c  b104              CBZ      r4,|L6.160|
;;;516    		goto remove;
00009e  e003              B        |L6.168|
                  |L6.160|
;;;517    
;;;518    	if (!oldcard)
0000a0  b907              CBNZ     r7,|L6.164|
;;;519    		host->card = card;
0000a2  6575              STR      r5,[r6,#0x54]
                  |L6.164|
;;;520    	return 0;
0000a4  2000              MOVS     r0,#0
                  |L6.166|
;;;521    
;;;522    remove:
;;;523    /*	if (!oldcard)
;;;524    		mmc_remove_card(card);*/
;;;525    		printk("sdio init card failed!\n");
;;;526    
;;;527    err:
;;;528    	return err;
;;;529    }
0000a6  bdfe              POP      {r1-r7,pc}
                  |L6.168|
0000a8  a003              ADR      r0,|L6.184|
0000aa  f7fffffe          BL       __2printf
0000ae  bf00              NOP                            ;527
                  |L6.176|
0000b0  4620              MOV      r0,r4                 ;528
0000b2  e7f8              B        |L6.166|
;;;530    
                          ENDP

                  |L6.180|
                          DCD      0x02faf080
                  |L6.184|
0000b8  7364696f          DCB      "sdio init card failed!\n",0
0000bc  20696e69
0000c0  74206361
0000c4  72642066
0000c8  61696c65
0000cc  64210a00

                          AREA ||i.mmc_select_card||, CODE, READONLY, ALIGN=1

                  mmc_select_card PROC
;;;392    }
;;;393    int mmc_select_card(struct mmc_card *card)
000000  b510              PUSH     {r4,lr}
;;;394    {
000002  4604              MOV      r4,r0
;;;395    	//BUG_ON(!card);
;;;396    
;;;397    	return _mmc_select_card(card->host, card);
000004  4621              MOV      r1,r4
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       _mmc_select_card
;;;398    }
00000c  bd10              POP      {r4,pc}
;;;399    
                          ENDP


                          AREA ||i.mmc_send_if_cond||, CODE, READONLY, ALIGN=2

                  mmc_send_if_cond PROC
;;;65     
;;;66     int mmc_send_if_cond(struct mmc_host *host, u32 ocr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;67     {
000002  b08b              SUB      sp,sp,#0x2c
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;68     	struct mmc_command cmd;
;;;69     	int err;
;;;70     	static const u8 test_pattern = 0xAA;
;;;71     	u8 result_pattern;
;;;72     
;;;73     	/*
;;;74     	 * To support SD 2.0 cards, we must always invoke SD_SEND_IF_COND
;;;75     	 * before SD_APP_OP_COND. This command will harmlessly fail for
;;;76     	 * SD 1.0 cards.
;;;77     	 */
;;;78     	cmd.opcode = SD_SEND_IF_COND;
000008  2008              MOVS     r0,#8
00000a  9000              STR      r0,[sp,#0]
;;;79     	cmd.arg = ((ocr & 0xFF8000) != 0) << 8 | test_pattern;
00000c  4813              LDR      r0,|L8.92|
00000e  4207              TST      r7,r0
000010  d001              BEQ      |L8.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L8.24|
                  |L8.22|
000016  2000              MOVS     r0,#0
                  |L8.24|
000018  21aa              MOVS     r1,#0xaa
00001a  ea412000          ORR      r0,r1,r0,LSL #8
00001e  9001              STR      r0,[sp,#4]
;;;80     	cmd.flags = MMC_RSP_SPI_R7 | MMC_RSP_R7 | MMC_CMD_BCR;
000020  f24020f5          MOV      r0,#0x2f5
000024  9006              STR      r0,[sp,#0x18]
;;;81     
;;;82     	err = mmc_wait_for_cmd(host, &cmd, 0);
000026  2200              MOVS     r2,#0
000028  4669              MOV      r1,sp
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       mmc_wait_for_cmd
000030  4605              MOV      r5,r0
;;;83     	if (err)
000032  b115              CBZ      r5,|L8.58|
;;;84     		return err;
000034  4628              MOV      r0,r5
                  |L8.54|
;;;85     
;;;86     	if (mmc_host_is_spi(host))
;;;87     		result_pattern = cmd.resp[1] & 0xFF;
;;;88     	else
;;;89     		result_pattern = cmd.resp[0] & 0xFF;
;;;90     
;;;91     	if (result_pattern != test_pattern)
;;;92     		return -EIO;
;;;93     
;;;94     	return 0;
;;;95     }
000036  b00b              ADD      sp,sp,#0x2c
000038  bdf0              POP      {r4-r7,pc}
                  |L8.58|
00003a  6970              LDR      r0,[r6,#0x14]         ;86
00003c  f0100f10          TST      r0,#0x10              ;86
000040  d002              BEQ      |L8.72|
000042  9803              LDR      r0,[sp,#0xc]          ;87
000044  b2c4              UXTB     r4,r0                 ;87
000046  e001              B        |L8.76|
                  |L8.72|
000048  9802              LDR      r0,[sp,#8]            ;89
00004a  b2c4              UXTB     r4,r0                 ;89
                  |L8.76|
00004c  2caa              CMP      r4,#0xaa              ;91
00004e  d002              BEQ      |L8.86|
000050  f06f0004          MVN      r0,#4                 ;92
000054  e7ef              B        |L8.54|
                  |L8.86|
000056  2000              MOVS     r0,#0                 ;94
000058  e7ed              B        |L8.54|
;;;96     int mmc_send_relative_addr(struct mmc_host *host, unsigned int *rca)
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      0x00ff8000

                          AREA ||i.mmc_send_io_op_cond||, CODE, READONLY, ALIGN=1

                  mmc_send_io_op_cond PROC
;;;15     
;;;16     int mmc_send_io_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;17     {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
;;;18     	struct mmc_command cmd;
;;;19     	int i, err = 0;
00000c  2700              MOVS     r7,#0
;;;20     
;;;21     	//BUG_ON(!host);
;;;22     
;;;23     	memset(&cmd, 0, sizeof(struct mmc_command));
00000e  212c              MOVS     r1,#0x2c
000010  a801              ADD      r0,sp,#4
000012  f7fffffe          BL       __aeabi_memclr4
;;;24     
;;;25     	cmd.opcode = SD_IO_SEND_OP_COND;
000016  2005              MOVS     r0,#5
000018  9001              STR      r0,[sp,#4]
;;;26     	cmd.arg = ocr;
00001a  9502              STR      r5,[sp,#8]
;;;27     	cmd.flags = MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR;
00001c  f24020e1          MOV      r0,#0x2e1
000020  9007              STR      r0,[sp,#0x1c]
;;;28     
;;;29     	for (i = 100; i; i--) {
000022  f04f0864          MOV      r8,#0x64
000026  e01e              B        |L9.102|
                  |L9.40|
;;;30     		err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
000028  2203              MOVS     r2,#3
00002a  a901              ADD      r1,sp,#4
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       mmc_wait_for_cmd
000032  4607              MOV      r7,r0
;;;31     		if (err)
000034  b107              CBZ      r7,|L9.56|
;;;32     			break;
000036  e019              B        |L9.108|
                  |L9.56|
;;;33     
;;;34     		/* if we're just probing, do a single pass */
;;;35     		if (ocr == 0)
000038  b905              CBNZ     r5,|L9.60|
;;;36     			break;
00003a  e017              B        |L9.108|
                  |L9.60|
;;;37     
;;;38     		/* otherwise wait until reset completes */
;;;39     		if (mmc_host_is_spi(host)) {
00003c  6960              LDR      r0,[r4,#0x14]
00003e  f0100f10          TST      r0,#0x10
000042  d004              BEQ      |L9.78|
;;;40     			/*
;;;41     			 * Both R1_SPI_IDLE and MMC_CARD_BUSY indicate
;;;42     			 * an initialized card under SPI, but some cards
;;;43     			 * (Marvell's) only behave when looking at this
;;;44     			 * one.
;;;45     			 */
;;;46     			if (cmd.resp[1] & MMC_CARD_BUSY)
000044  9804              LDR      r0,[sp,#0x10]
000046  f0104f00          TST      r0,#0x80000000
00004a  d005              BEQ      |L9.88|
;;;47     				break;
00004c  e00e              B        |L9.108|
                  |L9.78|
;;;48     		} else {
;;;49     			if (cmd.resp[0] & MMC_CARD_BUSY)
00004e  9803              LDR      r0,[sp,#0xc]
000050  f0104f00          TST      r0,#0x80000000
000054  d000              BEQ      |L9.88|
;;;50     				break;
000056  e009              B        |L9.108|
                  |L9.88|
;;;51     		}
;;;52     
;;;53     		err = -ETIMEDOUT;
000058  f06f073b          MVN      r7,#0x3b
;;;54     
;;;55     		mmc_delay(10);
00005c  200a              MOVS     r0,#0xa
00005e  f7fffffe          BL       mmc_delay
000062  f1a80801          SUB      r8,r8,#1              ;29
                  |L9.102|
000066  f1b80f00          CMP      r8,#0                 ;29
00006a  d1dd              BNE      |L9.40|
                  |L9.108|
00006c  bf00              NOP                            ;32
;;;56     	}
;;;57     
;;;58     	if (rocr)
00006e  b136              CBZ      r6,|L9.126|
;;;59     		*rocr = cmd.resp[mmc_host_is_spi(host) ? 1 : 0];
000070  6960              LDR      r0,[r4,#0x14]
000072  f3c01100          UBFX     r1,r0,#4,#1
000076  a803              ADD      r0,sp,#0xc
000078  f8500021          LDR      r0,[r0,r1,LSL #2]
00007c  6030              STR      r0,[r6,#0]
                  |L9.126|
;;;60     
;;;61     	return err;
00007e  4638              MOV      r0,r7
;;;62     }
000080  b00c              ADD      sp,sp,#0x30
000082  e8bd81f0          POP      {r4-r8,pc}
;;;63     
                          ENDP


                          AREA ||i.mmc_send_relative_addr||, CODE, READONLY, ALIGN=1

                  mmc_send_relative_addr PROC
;;;95     }
;;;96     int mmc_send_relative_addr(struct mmc_host *host, unsigned int *rca)
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
000002  b08c              SUB      sp,sp,#0x30
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;98     	int err;
;;;99     	struct mmc_command cmd;
;;;100    
;;;101    	/*BUG_ON(!host);
;;;102    	BUG_ON(!rca);*/
;;;103    
;;;104    	memset(&cmd, 0, sizeof(struct mmc_command));
000008  212c              MOVS     r1,#0x2c
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;105    
;;;106    	cmd.opcode = SD_SEND_RELATIVE_ADDR;
000010  2003              MOVS     r0,#3
000012  9001              STR      r0,[sp,#4]
;;;107    	cmd.arg = 0;
000014  2000              MOVS     r0,#0
000016  9002              STR      r0,[sp,#8]
;;;108    	cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;
000018  2075              MOVS     r0,#0x75
00001a  9007              STR      r0,[sp,#0x1c]
;;;109    
;;;110    	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
00001c  2203              MOVS     r2,#3
00001e  a901              ADD      r1,sp,#4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       mmc_wait_for_cmd
000026  4605              MOV      r5,r0
;;;111    	if (err)
000028  b115              CBZ      r5,|L10.48|
;;;112    		return err;
00002a  4628              MOV      r0,r5
                  |L10.44|
;;;113    
;;;114    	*rca = cmd.resp[0] >> 16;
;;;115    
;;;116    	return 0;
;;;117    }
00002c  b00c              ADD      sp,sp,#0x30
00002e  bd70              POP      {r4-r6,pc}
                  |L10.48|
000030  9803              LDR      r0,[sp,#0xc]          ;114
000032  0c00              LSRS     r0,r0,#16             ;114
000034  6020              STR      r0,[r4,#0]            ;114
000036  2000              MOVS     r0,#0                 ;116
000038  e7f8              B        |L10.44|
;;;118    
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.process_sdio_pending_irqs||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  process_sdio_pending_irqs PROC
;;;627    
;;;628    static int process_sdio_pending_irqs(struct mmc_card *card)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;629    {
000004  4680              MOV      r8,r0
;;;630    	int i, ret, count;
;;;631    	unsigned char pending;
;;;632    	struct sdio_func *func;
;;;633    	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
000006  ab02              ADD      r3,sp,#8
000008  2200              MOVS     r2,#0
00000a  e9cd2300          STRD     r2,r3,[sp,#0]
00000e  2305              MOVS     r3,#5
000010  4611              MOV      r1,r2
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       mmc_io_rw_direct
000018  4607              MOV      r7,r0
;;;634    	if (ret) {
00001a  b137              CBZ      r7,|L12.42|
;;;635    		printk(KERN_DEBUG "error %d reading SDIO_CCCR_INTx\n",ret);
00001c  4639              MOV      r1,r7
00001e  a017              ADR      r0,|L12.124|
000020  f7fffffe          BL       __2printf
;;;636    		return ret;
000024  4638              MOV      r0,r7
                  |L12.38|
;;;637    	}
;;;638    
;;;639    	count = 0;
;;;640    	for (i = 1; i <= 7; i++) {
;;;641    		if (pending & (1 << i)) {
;;;642    			func = card->sdio_func[i - 1];
;;;643    			if (!func) {
;;;644    				printk(KERN_WARNING "pending IRQ for "
;;;645    					"non-existant function\n");
;;;646    				ret = -EINVAL;
;;;647    			} else if (func->irq_handler) {
;;;648    				func->irq_handler(func);
;;;649    				count++;
;;;650    			} else {
;;;651    				printk(KERN_WARNING "pending IRQ with no handler\n");
;;;652    				ret = -EINVAL;
;;;653    			}
;;;654    		}
;;;655    	}
;;;656    
;;;657    	if (count)
;;;658    		return count;
;;;659    
;;;660    	return ret;
;;;661    }
000026  e8bd83fe          POP      {r1-r9,pc}
                  |L12.42|
00002a  2600              MOVS     r6,#0                 ;639
00002c  2401              MOVS     r4,#1                 ;640
00002e  e01e              B        |L12.110|
                  |L12.48|
000030  2001              MOVS     r0,#1                 ;641
000032  40a0              LSLS     r0,r0,r4              ;641
000034  f89d1008          LDRB     r1,[sp,#8]            ;641
000038  4208              TST      r0,r1                 ;641
00003a  d017              BEQ      |L12.108|
00003c  1e60              SUBS     r0,r4,#1              ;642
00003e  f10801ac          ADD      r1,r8,#0xac           ;642
000042  f8515020          LDR      r5,[r1,r0,LSL #2]     ;642
000046  b92d              CBNZ     r5,|L12.84|
000048  a015              ADR      r0,|L12.160|
00004a  f7fffffe          BL       __2printf
00004e  f06f0715          MVN      r7,#0x15              ;646
000052  e00b              B        |L12.108|
                  |L12.84|
000054  68a8              LDR      r0,[r5,#8]            ;647
000056  b120              CBZ      r0,|L12.98|
000058  4628              MOV      r0,r5                 ;648
00005a  68a9              LDR      r1,[r5,#8]            ;648
00005c  4788              BLX      r1                    ;648
00005e  1c76              ADDS     r6,r6,#1              ;649
000060  e004              B        |L12.108|
                  |L12.98|
000062  a019              ADR      r0,|L12.200|
000064  f7fffffe          BL       __2printf
000068  f06f0715          MVN      r7,#0x15              ;652
                  |L12.108|
00006c  1c64              ADDS     r4,r4,#1              ;640
                  |L12.110|
00006e  2c07              CMP      r4,#7                 ;640
000070  ddde              BLE      |L12.48|
000072  b10e              CBZ      r6,|L12.120|
000074  4630              MOV      r0,r6                 ;658
000076  e7d6              B        |L12.38|
                  |L12.120|
000078  4638              MOV      r0,r7                 ;660
00007a  e7d4              B        |L12.38|
;;;662    
                          ENDP

                  |L12.124|
00007c  6572726f          DCB      "error %d reading SDIO_CCCR_INTx\n",0
000080  72202564
000084  20726561
000088  64696e67
00008c  20534449
000090  4f5f4343
000094  43525f49
000098  4e54780a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L12.160|
0000a0  70656e64          DCB      "pending IRQ for non-existant function\n",0
0000a4  696e6720
0000a8  49525120
0000ac  666f7220
0000b0  6e6f6e2d
0000b4  65786973
0000b8  74616e74
0000bc  2066756e
0000c0  6374696f
0000c4  6e0a00  
0000c7  00                DCB      0
                  |L12.200|
0000c8  70656e64          DCB      "pending IRQ with no handler\n",0
0000cc  696e6720
0000d0  49525120
0000d4  77697468
0000d8  206e6f20
0000dc  68616e64
0000e0  6c65720a
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.sdio_align_size||, CODE, READONLY, ALIGN=1

                  sdio_align_size PROC
;;;803    
;;;804    unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;805    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;806    	unsigned int orig_sz;
;;;807    	unsigned int blk_sz, byte_sz;
;;;808    	unsigned chunk_sz;
;;;809    	orig_sz = sz;
000008  462f              MOV      r7,r5
;;;810    
;;;811    	/*
;;;812    	 * Do a first check with the controller, in case it
;;;813    	 * wants to increase the size up to a point where it
;;;814    	 * might need more than one block.
;;;815    	 */
;;;816    	sz = ((sz + 3) / 4) * 4;// mmc_align_data_size(func->card, sz);//必须4字节对齐
00000a  1ce8              ADDS     r0,r5,#3
00000c  0880              LSRS     r0,r0,#2
00000e  0085              LSLS     r5,r0,#2
;;;817    
;;;818    	/*
;;;819    	 * If we can still do this with just a byte transfer, then
;;;820    	 * we're done.
;;;821    	 */
;;;822    	if (sz <= sdio_max_byte_size(func)){//如果长度小于一个块长的话，直接返回
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       sdio_max_byte_size
000016  42a8              CMP      r0,r5
000018  d302              BCC      |L13.32|
;;;823    		
;;;824    		//power=align_power2(sz);//找到一个对齐方式
;;;825    		//return power;
;;;826    		return sz;
00001a  4628              MOV      r0,r5
                  |L13.28|
;;;827    	}
;;;828    
;;;829    	if (func->card->cccr.multi_block) {
;;;830    		/*
;;;831    		 * Check if the transfer is already block aligned
;;;832    		 */
;;;833    		if ((sz % func->cur_blksize) == 0)
;;;834    			return sz;
;;;835    
;;;836    		/*
;;;837    		 * Realign it so that it can be done with one request,
;;;838    		 * and recheck if the controller still likes it.
;;;839    		 */
;;;840    		blk_sz = ((sz + func->cur_blksize - 1) /
;;;841    			func->cur_blksize) * func->cur_blksize;//按当前尺寸对齐
;;;842    		blk_sz = mmc_align_data_size(func->card, blk_sz);
;;;843    
;;;844    		/*
;;;845    		 * This value is only good if it is still just
;;;846    		 * one request.
;;;847    		 */
;;;848    		if ((blk_sz % func->cur_blksize) == 0)
;;;849    			return blk_sz;
;;;850    
;;;851    		/*
;;;852    		 * We failed to do one request, but at least try to
;;;853    		 * pad the remainder properly.
;;;854    		 */
;;;855    	/*	byte_sz = mmc_align_data_size(func->card,
;;;856    				sz % func->cur_blksize);
;;;857    		if (byte_sz <= sdio_max_byte_size(func)) {
;;;858    			blk_sz = sz / func->cur_blksize;
;;;859    			return blk_sz * func->cur_blksize + byte_sz;
;;;860    		}*/
;;;861    
;;;862    	}
;;;863    	else {
;;;864    		/*
;;;865    		 * We need multiple requests, so first check that the
;;;866    		 * controller can handle the chunk size;
;;;867    		 */
;;;868    		chunk_sz = mmc_align_data_size(func->card,
;;;869    				sdio_max_byte_size(func));
;;;870    		if (chunk_sz == sdio_max_byte_size(func)) {
;;;871    			/*
;;;872    			 * Fix up the size of the remainder (if any)
;;;873    			 */
;;;874    			byte_sz = orig_sz % chunk_sz;
;;;875    			if (byte_sz) {
;;;876    				byte_sz = mmc_align_data_size(func->card,
;;;877    						byte_sz);
;;;878    			}
;;;879    
;;;880    			return (orig_sz / chunk_sz) * chunk_sz + byte_sz;
;;;881    		}
;;;882    	}
;;;883    	/*
;;;884    	 * The controller is simply incapable of transferring the size
;;;885    	 * we want in decent manner, so just return the original size.
;;;886    	 */
;;;887    	return orig_sz;
;;;888    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L13.32|
000020  6820              LDR      r0,[r4,#0]            ;829
000022  f8d0009c          LDR      r0,[r0,#0x9c]         ;829
000026  f3c00000          UBFX     r0,r0,#0,#1           ;829
00002a  b1e0              CBZ      r0,|L13.102|
00002c  69e0              LDR      r0,[r4,#0x1c]         ;833
00002e  fbb5f1f0          UDIV     r1,r5,r0              ;833
000032  fb005011          MLS      r0,r0,r1,r5           ;833
000036  b908              CBNZ     r0,|L13.60|
000038  4628              MOV      r0,r5                 ;834
00003a  e7ef              B        |L13.28|
                  |L13.60|
00003c  69e0              LDR      r0,[r4,#0x1c]         ;840
00003e  4428              ADD      r0,r0,r5              ;840
000040  1e40              SUBS     r0,r0,#1              ;840
000042  69e1              LDR      r1,[r4,#0x1c]         ;840
000044  fbb0f0f1          UDIV     r0,r0,r1              ;840
000048  fb00f901          MUL      r9,r0,r1              ;840
00004c  4649              MOV      r1,r9                 ;842
00004e  6820              LDR      r0,[r4,#0]            ;842
000050  f7fffffe          BL       mmc_align_data_size
000054  4681              MOV      r9,r0                 ;842
000056  69e0              LDR      r0,[r4,#0x1c]         ;848
000058  fbb9f1f0          UDIV     r1,r9,r0              ;848
00005c  fb009011          MLS      r0,r0,r1,r9           ;848
000060  bb00              CBNZ     r0,|L13.164|
000062  4648              MOV      r0,r9                 ;849
000064  e7da              B        |L13.28|
                  |L13.102|
000066  4620              MOV      r0,r4                 ;868
000068  f7fffffe          BL       sdio_max_byte_size
00006c  4682              MOV      r10,r0                ;868
00006e  4651              MOV      r1,r10                ;868
000070  6820              LDR      r0,[r4,#0]            ;868
000072  f7fffffe          BL       mmc_align_data_size
000076  4606              MOV      r6,r0                 ;868
000078  4620              MOV      r0,r4                 ;870
00007a  f7fffffe          BL       sdio_max_byte_size
00007e  42b0              CMP      r0,r6                 ;870
000080  d110              BNE      |L13.164|
000082  fbb7f0f6          UDIV     r0,r7,r6              ;874
000086  fb067810          MLS      r8,r6,r0,r7           ;874
00008a  f1b80f00          CMP      r8,#0                 ;875
00008e  d004              BEQ      |L13.154|
000090  4641              MOV      r1,r8                 ;876
000092  6820              LDR      r0,[r4,#0]            ;876
000094  f7fffffe          BL       mmc_align_data_size
000098  4680              MOV      r8,r0                 ;876
                  |L13.154|
00009a  fbb7f0f6          UDIV     r0,r7,r6              ;880
00009e  fb008006          MLA      r0,r0,r6,r8           ;880
0000a2  e7bb              B        |L13.28|
                  |L13.164|
0000a4  4638              MOV      r0,r7                 ;887
0000a6  e7b9              B        |L13.28|
;;;889    
                          ENDP


                          AREA ||i.sdio_disable_cd||, CODE, READONLY, ALIGN=1

                  sdio_disable_cd PROC
;;;289     */
;;;290    static int sdio_disable_cd(struct mmc_card *card)
000000  b53e              PUSH     {r1-r5,lr}
;;;291    {
000002  4605              MOV      r5,r0
;;;292    	int ret;
;;;293    	u8 ctrl;
;;;294    
;;;295    	if (!card->cccr.disable_cd)
000004  209c              MOVS     r0,#0x9c
000006  5940              LDR      r0,[r0,r5]
000008  f3c01040          UBFX     r0,r0,#5,#1
00000c  b908              CBNZ     r0,|L14.18|
;;;296    		return 0;
00000e  2000              MOVS     r0,#0
                  |L14.16|
;;;297    
;;;298    	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
;;;299    	if (ret)
;;;300    		return ret;
;;;301    
;;;302    	ctrl |= SDIO_BUS_CD_DISABLE;
;;;303    
;;;304    	return mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
;;;305    }
000010  bd3e              POP      {r1-r5,pc}
                  |L14.18|
000012  ab02              ADD      r3,sp,#8              ;298
000014  2200              MOVS     r2,#0                 ;298
000016  e9cd2300          STRD     r2,r3,[sp,#0]         ;298
00001a  2307              MOVS     r3,#7                 ;298
00001c  4611              MOV      r1,r2                 ;298
00001e  4628              MOV      r0,r5                 ;298
000020  f7fffffe          BL       mmc_io_rw_direct
000024  4604              MOV      r4,r0                 ;298
000026  b10c              CBZ      r4,|L14.44|
000028  4620              MOV      r0,r4                 ;300
00002a  e7f1              B        |L14.16|
                  |L14.44|
00002c  f89d0008          LDRB     r0,[sp,#8]            ;302
000030  f0400080          ORR      r0,r0,#0x80           ;302
000034  9002              STR      r0,[sp,#8]            ;302
000036  2300              MOVS     r3,#0                 ;304
000038  f89d2008          LDRB     r2,[sp,#8]            ;304
00003c  e9cd2300          STRD     r2,r3,[sp,#0]         ;304
000040  2307              MOVS     r3,#7                 ;304
000042  2200              MOVS     r2,#0                 ;304
000044  2101              MOVS     r1,#1                 ;304
000046  4628              MOV      r0,r5                 ;304
000048  f7fffffe          BL       mmc_io_rw_direct
00004c  e7e0              B        |L14.16|
;;;306    
                          ENDP


                          AREA ||i.sdio_enable_hs||, CODE, READONLY, ALIGN=1

                  sdio_enable_hs PROC
;;;311     */
;;;312    static int sdio_enable_hs(struct mmc_card *card)
000000  b53e              PUSH     {r1-r5,lr}
;;;313    {
000002  4604              MOV      r4,r0
;;;314    	int ret;
;;;315    	u8 speed;
;;;316    
;;;317    	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f0100f04          TST      r0,#4
00000c  d101              BNE      |L15.18|
;;;318    		return 0;
00000e  2000              MOVS     r0,#0
                  |L15.16|
;;;319    
;;;320    	if (!card->cccr.high_speed)
;;;321    		return 0;
;;;322    
;;;323    	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
;;;324    	if (ret)
;;;325    		return ret;
;;;326    
;;;327    	speed |= SDIO_SPEED_EHS;
;;;328    
;;;329    	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
;;;330    	if (ret)
;;;331    		return ret;
;;;332    
;;;333    	mmc_card_set_highspeed(card);
;;;334    	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
;;;335    
;;;336    	return 0;
;;;337    }
000010  bd3e              POP      {r1-r5,pc}
                  |L15.18|
000012  209c              MOVS     r0,#0x9c              ;320
000014  5900              LDR      r0,[r0,r4]            ;320
000016  f3c01000          UBFX     r0,r0,#4,#1           ;320
00001a  b908              CBNZ     r0,|L15.32|
00001c  2000              MOVS     r0,#0                 ;321
00001e  e7f7              B        |L15.16|
                  |L15.32|
000020  ab02              ADD      r3,sp,#8              ;323
000022  2200              MOVS     r2,#0                 ;323
000024  e9cd2300          STRD     r2,r3,[sp,#0]         ;323
000028  2313              MOVS     r3,#0x13              ;323
00002a  4611              MOV      r1,r2                 ;323
00002c  4620              MOV      r0,r4                 ;323
00002e  f7fffffe          BL       mmc_io_rw_direct
000032  4605              MOV      r5,r0                 ;323
000034  b10d              CBZ      r5,|L15.58|
000036  4628              MOV      r0,r5                 ;325
000038  e7ea              B        |L15.16|
                  |L15.58|
00003a  f89d0008          LDRB     r0,[sp,#8]            ;327
00003e  f0400002          ORR      r0,r0,#2              ;327
000042  9002              STR      r0,[sp,#8]            ;327
000044  2300              MOVS     r3,#0                 ;329
000046  f89d2008          LDRB     r2,[sp,#8]            ;329
00004a  e9cd2300          STRD     r2,r3,[sp,#0]         ;329
00004e  2313              MOVS     r3,#0x13              ;329
000050  2200              MOVS     r2,#0                 ;329
000052  2101              MOVS     r1,#1                 ;329
000054  4620              MOV      r0,r4                 ;329
000056  f7fffffe          BL       mmc_io_rw_direct
00005a  4605              MOV      r5,r0                 ;329
00005c  b10d              CBZ      r5,|L15.98|
00005e  4628              MOV      r0,r5                 ;331
000060  e7d6              B        |L15.16|
                  |L15.98|
000062  68e0              LDR      r0,[r4,#0xc]          ;333
000064  f0400004          ORR      r0,r0,#4              ;333
000068  60e0              STR      r0,[r4,#0xc]          ;333
00006a  2102              MOVS     r1,#2                 ;334
00006c  6820              LDR      r0,[r4,#0]            ;334
00006e  f7fffffe          BL       mmc_set_timing
000072  2000              MOVS     r0,#0                 ;336
000074  e7cc              B        |L15.16|
;;;338    
                          ENDP


                          AREA ||i.sdio_enable_wide||, CODE, READONLY, ALIGN=1

                  sdio_enable_wide PROC
;;;340    
;;;341    static int sdio_enable_wide(struct mmc_card *card)
000000  b53e              PUSH     {r1-r5,lr}
;;;342    {
000002  4604              MOV      r4,r0
;;;343    	int ret;
;;;344    	u8 ctrl;
;;;345    
;;;346    	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f0100f01          TST      r0,#1
00000c  d101              BNE      |L16.18|
;;;347    		return 0;
00000e  2000              MOVS     r0,#0
                  |L16.16|
;;;348    
;;;349    	if (card->cccr.low_speed && !card->cccr.wide_bus)
;;;350    		return 0;
;;;351    
;;;352    	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
;;;353    	if (ret)
;;;354    		return ret;
;;;355    
;;;356    	ctrl |= SDIO_BUS_WIDTH_4BIT;
;;;357    
;;;358    	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
;;;359    	if (ret)
;;;360    		return ret;
;;;361    
;;;362    	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
;;;363    
;;;364    	return 0;
;;;365    }
000010  bd3e              POP      {r1-r5,pc}
                  |L16.18|
000012  209c              MOVS     r0,#0x9c              ;349
000014  5900              LDR      r0,[r0,r4]            ;349
000016  f3c00040          UBFX     r0,r0,#1,#1           ;349
00001a  b130              CBZ      r0,|L16.42|
00001c  209c              MOVS     r0,#0x9c              ;349
00001e  5900              LDR      r0,[r0,r4]            ;349
000020  f3c00080          UBFX     r0,r0,#2,#1           ;349
000024  b908              CBNZ     r0,|L16.42|
000026  2000              MOVS     r0,#0                 ;350
000028  e7f2              B        |L16.16|
                  |L16.42|
00002a  ab02              ADD      r3,sp,#8              ;352
00002c  2200              MOVS     r2,#0                 ;352
00002e  e9cd2300          STRD     r2,r3,[sp,#0]         ;352
000032  2307              MOVS     r3,#7                 ;352
000034  4611              MOV      r1,r2                 ;352
000036  4620              MOV      r0,r4                 ;352
000038  f7fffffe          BL       mmc_io_rw_direct
00003c  4605              MOV      r5,r0                 ;352
00003e  b10d              CBZ      r5,|L16.68|
000040  4628              MOV      r0,r5                 ;354
000042  e7e5              B        |L16.16|
                  |L16.68|
000044  f89d0008          LDRB     r0,[sp,#8]            ;356
000048  f0400002          ORR      r0,r0,#2              ;356
00004c  9002              STR      r0,[sp,#8]            ;356
00004e  2300              MOVS     r3,#0                 ;358
000050  f89d2008          LDRB     r2,[sp,#8]            ;358
000054  e9cd2300          STRD     r2,r3,[sp,#0]         ;358
000058  2307              MOVS     r3,#7                 ;358
00005a  2200              MOVS     r2,#0                 ;358
00005c  2101              MOVS     r1,#1                 ;358
00005e  4620              MOV      r0,r4                 ;358
000060  f7fffffe          BL       mmc_io_rw_direct
000064  4605              MOV      r5,r0                 ;358
000066  b10d              CBZ      r5,|L16.108|
000068  4628              MOV      r0,r5                 ;360
00006a  e7d1              B        |L16.16|
                  |L16.108|
00006c  2102              MOVS     r1,#2                 ;362
00006e  6820              LDR      r0,[r4,#0]            ;362
000070  f7fffffe          BL       mmc_set_bus_width
000074  2000              MOVS     r0,#0                 ;364
000076  e7cb              B        |L16.16|
;;;366    
                          ENDP


                          AREA ||i.sdio_init_func||, CODE, READONLY, ALIGN=1

                  sdio_init_func PROC
;;;195    
;;;196    static int sdio_init_func(struct mmc_card *card, unsigned int fn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;197    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;198    	int ret;
;;;199    	struct sdio_func *func;
;;;200    
;;;201    	//BUG_ON(fn > SDIO_MAX_FUNCS);
;;;202    
;;;203    	func = sdio_alloc_func(card);
000008  4638              MOV      r0,r7
00000a  f7fffffe          BL       sdio_alloc_func
00000e  4606              MOV      r6,r0
;;;204    /*	if (IS_ERR(func))
;;;205    		return PTR_ERR(func);*/
;;;206    
;;;207    	func->num = fn;
000010  60f4              STR      r4,[r6,#0xc]
;;;208    
;;;209    	ret = sdio_read_fbr(func);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       sdio_read_fbr
000018  4605              MOV      r5,r0
;;;210    	if (ret)
00001a  b105              CBZ      r5,|L17.30|
;;;211    		goto fail;
00001c  e00d              B        |L17.58|
                  |L17.30|
;;;212    
;;;213    	ret = sdio_read_func_cis(func);//读取function的cis
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       sdio_read_func_cis
000024  4605              MOV      r5,r0
;;;214    	if (ret)
000026  b105              CBZ      r5,|L17.42|
;;;215    		goto fail;
000028  e007              B        |L17.58|
                  |L17.42|
;;;216    	 pr_debug("function vendor=0x%x	device=0x%x\n",func->vendor,func->device);
;;;217    	card->sdio_func[fn - 1] = func;
00002a  1e60              SUBS     r0,r4,#1
00002c  f10701ac          ADD      r1,r7,#0xac
000030  f8416020          STR      r6,[r1,r0,LSL #2]
;;;218    
;;;219    	return 0;
000034  2000              MOVS     r0,#0
                  |L17.54|
;;;220    
;;;221    fail:
;;;222    	/*
;;;223    	 * It is okay to remove the function here even though we hold
;;;224    	 * the host lock as we haven't registered the device yet.
;;;225    	 */
;;;226    	//sdio_remove_func(func);
;;;227    	return ret;
;;;228    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L17.58|
00003a  4628              MOV      r0,r5                 ;227
00003c  e7fb              B        |L17.54|
;;;229    static int sdio_read_cccr(struct mmc_card *card)
                          ENDP


                          AREA ||i.sdio_io_rw_ext_helper||, CODE, READONLY, ALIGN=1

                  sdio_io_rw_ext_helper PROC
;;;1027    * IO_RW_EXTENDED commands. */
;;;1028   int sdio_io_rw_ext_helper(struct sdio_func *func, int write,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1029   	unsigned addr, int incr_addr, u8 *buf, unsigned size)
;;;1030   {
000004  f6ad4d1c          SUB      sp,sp,#0xc1c
000008  4604              MOV      r4,r0
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
00000e  f8dd5c54          LDR      r5,[sp,#0xc54]
;;;1031   	u8 alig_bug_buf[3*1024];//作为数据的缓冲区
;;;1032   	unsigned remainder = size;
000012  462e              MOV      r6,r5
;;;1033   	u8 *pbuf=buf;
000014  f8ddac50          LDR      r10,[sp,#0xc50]
;;;1034   	unsigned max_blocks;
;;;1035   	unsigned blocks;
;;;1036   	int ret;
;;;1037   	if(write){
000018  f8dd0c20          LDR      r0,[sp,#0xc20]
00001c  b138              CBZ      r0,|L18.46|
;;;1038   		memcpy(alig_bug_buf,buf,size);
00001e  462a              MOV      r2,r5
000020  a807              ADD      r0,sp,#0x1c
000022  f8dd1c50          LDR      r1,[sp,#0xc50]
000026  f7fffffe          BL       __aeabi_memcpy
;;;1039   		pbuf=alig_bug_buf;
00002a  f10d0a1c          ADD      r10,sp,#0x1c
                  |L18.46|
;;;1040   	}
;;;1041   	/* Do the bulk of the transfer using block mode (if supported). */
;;;1042   	if (func->card->cccr.multi_block && (size > sdio_max_byte_size(func))) {
00002e  6820              LDR      r0,[r4,#0]
000030  f8d0009c          LDR      r0,[r0,#0x9c]
000034  f3c00000          UBFX     r0,r0,#0,#1
000038  b3f0              CBZ      r0,|L18.184|
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       sdio_max_byte_size
000040  42a8              CMP      r0,r5
000042  d24c              BCS      |L18.222|
;;;1043   		/* Blocks per command is limited by host count, host transfer
;;;1044   		 * size (we only use a single sg entry) and the maximum for
;;;1045   		 * IO_RW_EXTENDED of 511 blocks. */
;;;1046   		max_blocks = min(func->card->host->max_blk_count,
000044  6820              LDR      r0,[r4,#0]
000046  6800              LDR      r0,[r0,#0]
000048  6980              LDR      r0,[r0,#0x18]
00004a  69e1              LDR      r1,[r4,#0x1c]
00004c  fbb0f0f1          UDIV     r0,r0,r1
000050  6821              LDR      r1,[r4,#0]
000052  6809              LDR      r1,[r1,#0]
000054  6ac9              LDR      r1,[r1,#0x2c]
000056  4288              CMP      r0,r1
000058  d903              BLS      |L18.98|
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  6ac0              LDR      r0,[r0,#0x2c]
000060  e005              B        |L18.110|
                  |L18.98|
000062  6820              LDR      r0,[r4,#0]
000064  6800              LDR      r0,[r0,#0]
000066  6980              LDR      r0,[r0,#0x18]
000068  69e1              LDR      r1,[r4,#0x1c]
00006a  fbb0f0f1          UDIV     r0,r0,r1
                  |L18.110|
00006e  4683              MOV      r11,r0
;;;1047   			func->card->host->max_seg_size / func->cur_blksize);
;;;1048   		max_blocks = min(max_blocks, 511);
000070  f5bb7fff          CMP      r11,#0x1fe
000074  d801              BHI      |L18.122|
000076  4658              MOV      r0,r11
000078  e001              B        |L18.126|
                  |L18.122|
00007a  f24010ff          MOV      r0,#0x1ff
                  |L18.126|
00007e  4683              MOV      r11,r0
;;;1049   
;;;1050   		while (remainder > func->cur_blksize) {
000080  e02a              B        |L18.216|
                  |L18.130|
;;;1051   			blocks = remainder / func->cur_blksize;
000082  69e0              LDR      r0,[r4,#0x1c]
000084  fbb6f0f0          UDIV     r0,r6,r0
000088  9006              STR      r0,[sp,#0x18]
;;;1052   			if (blocks > max_blocks)
00008a  9806              LDR      r0,[sp,#0x18]
00008c  4558              CMP      r0,r11
00008e  d901              BLS      |L18.148|
;;;1053   				blocks = max_blocks;
000090  f8cdb018          STR      r11,[sp,#0x18]
                  |L18.148|
;;;1054   			size = blocks * func->cur_blksize;
000094  69e0              LDR      r0,[r4,#0x1c]
000096  9906              LDR      r1,[sp,#0x18]
000098  fb00f501          MUL      r5,r0,r1
;;;1055   
;;;1056   			ret = mmc_io_rw_extended(func->card, write,
00009c  69e3              LDR      r3,[r4,#0x1c]
00009e  9a06              LDR      r2,[sp,#0x18]
0000a0  e9cd8a00          STRD     r8,r10,[sp,#0]
0000a4  e9cd2302          STRD     r2,r3,[sp,#8]
0000a8  463b              MOV      r3,r7
0000aa  68e2              LDR      r2,[r4,#0xc]
0000ac  6820              LDR      r0,[r4,#0]
0000ae  f8dd1c20          LDR      r1,[sp,#0xc20]
0000b2  f7fffffe          BL       mmc_io_rw_extended
0000b6  e000              B        |L18.186|
                  |L18.184|
0000b8  e011              B        |L18.222|
                  |L18.186|
0000ba  4681              MOV      r9,r0
;;;1057   				func->num, addr, incr_addr, pbuf,
;;;1058   				blocks, func->cur_blksize);
;;;1059   			if (ret)
0000bc  f1b90f00          CMP      r9,#0
0000c0  d004              BEQ      |L18.204|
;;;1060   				return ret;
0000c2  4648              MOV      r0,r9
                  |L18.196|
;;;1061   
;;;1062   			remainder -= size;
;;;1063   			pbuf += size;
;;;1064   			if (incr_addr)
;;;1065   				addr += size;
;;;1066   		}
;;;1067   	}
;;;1068   
;;;1069   	/* Write the remainder using byte mode. */
;;;1070   	while (remainder > 0) {
;;;1071   		u16 tmp;
;;;1072   		size = min(remainder, sdio_max_byte_size(func));
;;;1073   		tmp=align_power2(size);	//必须按标准长度对齐
;;;1074   		pr_debug("really size=%d(%d)\n",size,tmp);
;;;1075   		
;;;1076   		ret = mmc_io_rw_extended(func->card, write, func->num, addr,
;;;1077   			 incr_addr,pbuf, 1, tmp);
;;;1078   		if (ret)
;;;1079   			return ret;
;;;1080   		remainder -= size;
;;;1081   		pbuf += size;
;;;1082   		if (incr_addr)
;;;1083   			addr += size;
;;;1084   	}
;;;1085   	return 0;
;;;1086   }
0000c4  f60d4d2c          ADD      sp,sp,#0xc2c
0000c8  e8bd8ff0          POP      {r4-r11,pc}
                  |L18.204|
0000cc  1b76              SUBS     r6,r6,r5              ;1062
0000ce  44aa              ADD      r10,r10,r5            ;1063
0000d0  f1b80f00          CMP      r8,#0                 ;1064
0000d4  d000              BEQ      |L18.216|
0000d6  442f              ADD      r7,r7,r5              ;1065
                  |L18.216|
0000d8  69e0              LDR      r0,[r4,#0x1c]         ;1050
0000da  42b0              CMP      r0,r6                 ;1050
0000dc  d3d1              BCC      |L18.130|
                  |L18.222|
0000de  e028              B        |L18.306|
                  |L18.224|
0000e0  4620              MOV      r0,r4                 ;1072
0000e2  f7fffffe          BL       sdio_max_byte_size
0000e6  42b0              CMP      r0,r6                 ;1072
0000e8  d901              BLS      |L18.238|
0000ea  4630              MOV      r0,r6                 ;1072
0000ec  e002              B        |L18.244|
                  |L18.238|
0000ee  4620              MOV      r0,r4                 ;1072
0000f0  f7fffffe          BL       sdio_max_byte_size
                  |L18.244|
0000f4  4605              MOV      r5,r0                 ;1072
0000f6  b2a8              UXTH     r0,r5                 ;1073
0000f8  f7fffffe          BL       align_power2
0000fc  9005              STR      r0,[sp,#0x14]         ;1073
0000fe  2201              MOVS     r2,#1                 ;1076
000100  9b05              LDR      r3,[sp,#0x14]         ;1076
000102  e9cd8a00          STRD     r8,r10,[sp,#0]        ;1076
000106  e9cd2302          STRD     r2,r3,[sp,#8]         ;1076
00010a  463b              MOV      r3,r7                 ;1076
00010c  68e2              LDR      r2,[r4,#0xc]          ;1076
00010e  6820              LDR      r0,[r4,#0]            ;1076
000110  f8dd1c20          LDR      r1,[sp,#0xc20]        ;1076
000114  f7fffffe          BL       mmc_io_rw_extended
000118  4681              MOV      r9,r0                 ;1076
00011a  f1b90f00          CMP      r9,#0                 ;1078
00011e  d001              BEQ      |L18.292|
000120  4648              MOV      r0,r9                 ;1079
000122  e7cf              B        |L18.196|
                  |L18.292|
000124  1b76              SUBS     r6,r6,r5              ;1080
000126  44aa              ADD      r10,r10,r5            ;1081
000128  f1b80f00          CMP      r8,#0                 ;1082
00012c  d000              BEQ      |L18.304|
00012e  442f              ADD      r7,r7,r5              ;1083
                  |L18.304|
000130  bf00              NOP                            ;1084
                  |L18.306|
000132  2e00              CMP      r6,#0                 ;1070
000134  d1d4              BNE      |L18.224|
000136  2000              MOVS     r0,#0                 ;1085
000138  e7c4              B        |L18.196|
;;;1087   
                          ENDP


                          AREA ||i.sdio_irq_thread||, CODE, READONLY, ALIGN=1

                  sdio_irq_thread PROC
;;;663    
;;;664    int sdio_irq_thread(void *_host)
000000  b570              PUSH     {r4-r6,lr}
;;;665    {
000002  4604              MOV      r4,r0
;;;666    	struct mmc_host *host = _host;
000004  4625              MOV      r5,r4
;;;667    	//struct sched_param param = { .sched_priority = 1 };
;;;668    //	unsigned long period, idle_period;
;;;669    	int ret;
;;;670    
;;;671    		/*
;;;672    		 * We claim the host here on drivers behalf for a couple
;;;673    		 * reasons:
;;;674    		 *
;;;675    		 * 1) it is already needed to retrieve the CCCR_INTx;
;;;676    		 * 2) we want the driver(s) to clear the IRQ condition ASAP;
;;;677    		 * 3) we need to control the abort condition locally.
;;;678    		 *
;;;679    		 * Just like traditional hard IRQ handlers, we expect SDIO
;;;680    		 * IRQ handlers to be quick and to the point, so that the
;;;681    		 * holding of the host lock does not cover too much work
;;;682    		 * that doesn't require that lock to be held.
;;;683    		 */
;;;684    		ret = process_sdio_pending_irqs(host->card);
000006  6d68              LDR      r0,[r5,#0x54]
000008  f7fffffe          BL       process_sdio_pending_irqs
00000c  4606              MOV      r6,r0
;;;685    		/*
;;;686    		 * Adaptive polling frequency based on the assumption
;;;687    		 * that an interrupt will be closely followed by more.
;;;688    		 * This has a substantial benefit for network devices.
;;;689    		 */
;;;690    	/*	if (!(host->caps & MMC_CAP_SDIO_IRQ)) {
;;;691    			if (ret > 0)
;;;692    				period /= 2;
;;;693    			else {
;;;694    				period++;
;;;695    				if (period > idle_period)
;;;696    					period = idle_period;
;;;697    			}
;;;698    		}*/
;;;699    		if (host->caps & MMC_CAP_SDIO_IRQ)
00000e  6968              LDR      r0,[r5,#0x14]
000010  f0100f08          TST      r0,#8
000014  d004              BEQ      |L19.32|
;;;700    			host->ops->enable_sdio_irq(host, 1);
000016  6868              LDR      r0,[r5,#4]
000018  2101              MOVS     r1,#1
00001a  6982              LDR      r2,[r0,#0x18]
00001c  4628              MOV      r0,r5
00001e  4790              BLX      r2
                  |L19.32|
;;;701    		/*	if (host->caps & MMC_CAP_SDIO_IRQ)
;;;702    			host->ops->enable_sdio_irq(host, 0);*/
;;;703    
;;;704    	pr_debug("%s: IRQ thread exiting with code %d\n",
;;;705    		 mmc_hostname(host), ret);
;;;706    
;;;707    	return ret;
000020  4630              MOV      r0,r6
;;;708    }
000022  bd70              POP      {r4-r6,pc}
;;;709    
                          ENDP


                          AREA ||i.sdio_max_byte_size||, CODE, READONLY, ALIGN=1

                  sdio_max_byte_size PROC
;;;770     */
;;;771    static __inline unsigned int sdio_max_byte_size(struct sdio_func *func)
000000  4601              MOV      r1,r0
;;;772    {
;;;773    	unsigned mval =min(func->card->host->max_seg_size,
000002  6808              LDR      r0,[r1,#0]
000004  6800              LDR      r0,[r0,#0]
000006  6980              LDR      r0,[r0,#0x18]
000008  680b              LDR      r3,[r1,#0]
00000a  681b              LDR      r3,[r3,#0]
00000c  6a9b              LDR      r3,[r3,#0x28]
00000e  4298              CMP      r0,r3
000010  d203              BCS      |L20.26|
000012  6808              LDR      r0,[r1,#0]
000014  6800              LDR      r0,[r0,#0]
000016  6980              LDR      r0,[r0,#0x18]
000018  e002              B        |L20.32|
                  |L20.26|
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  6a80              LDR      r0,[r0,#0x28]
                  |L20.32|
000020  4602              MOV      r2,r0
;;;774    			    func->card->host->max_blk_size);
;;;775    	mval = min(mval, func->max_blksize);
000022  6988              LDR      r0,[r1,#0x18]
000024  4290              CMP      r0,r2
000026  d901              BLS      |L20.44|
000028  4610              MOV      r0,r2
00002a  e000              B        |L20.46|
                  |L20.44|
00002c  6988              LDR      r0,[r1,#0x18]
                  |L20.46|
00002e  4602              MOV      r2,r0
;;;776    	return min(mval, 512u); /* maximum size for byte mode */
000030  f5b27f00          CMP      r2,#0x200
000034  d201              BCS      |L20.58|
000036  4610              MOV      r0,r2
                  |L20.56|
;;;777    }
000038  4770              BX       lr
                  |L20.58|
00003a  f44f7000          MOV      r0,#0x200             ;776
00003e  e7fb              B        |L20.56|
;;;778    
                          ENDP


                          AREA ||i.sdio_read_cccr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sdio_read_cccr PROC
;;;228    }
;;;229    static int sdio_read_cccr(struct mmc_card *card)
000000  b5fe              PUSH     {r1-r7,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231    	int ret;
;;;232    	int cccr_vsn;
;;;233    	unsigned char data;
;;;234    
;;;235    	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
000004  f1040080          ADD      r0,r4,#0x80
000008  2100              MOVS     r1,#0
00000a  6141              STR      r1,[r0,#0x14]
00000c  6181              STR      r1,[r0,#0x18]
00000e  61c1              STR      r1,[r0,#0x1c]
;;;236    
;;;237    	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);
000010  ab02              ADD      r3,sp,#8
000012  2200              MOVS     r2,#0
000014  e9cd2300          STRD     r2,r3,[sp,#0]
000018  4613              MOV      r3,r2
00001a  4611              MOV      r1,r2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       mmc_io_rw_direct
000022  4605              MOV      r5,r0
;;;238    	if (ret)
000024  b105              CBZ      r5,|L21.40|
;;;239    		goto out;
000026  e077              B        |L21.280|
                  |L21.40|
;;;240    
;;;241    	cccr_vsn = data & 0x0f;
000028  f89d0008          LDRB     r0,[sp,#8]
00002c  f000060f          AND      r6,r0,#0xf
;;;242    
;;;243    	if (cccr_vsn > SDIO_CCCR_REV_1_20) {
000030  2e02              CMP      r6,#2
000032  dd07              BLE      |L21.68|
;;;244    		printk(KERN_ERR "%s: unrecognised CCCR structure version %d\n",
000034  4632              MOV      r2,r6
000036  a139              ADR      r1,|L21.284|
000038  a03a              ADR      r0,|L21.292|
00003a  f7fffffe          BL       __2printf
;;;245    			mmc_hostname(card->host), cccr_vsn);
;;;246    		return -EINVAL;
00003e  f06f0015          MVN      r0,#0x15
                  |L21.66|
;;;247    	}
;;;248    
;;;249    	card->cccr.sdio_vsn = (data & 0xf0) >> 4;
;;;250    
;;;251    	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CAPS, 0, &data);
;;;252    	if (ret)
;;;253    		goto out;
;;;254    
;;;255    	if (data & SDIO_CCCR_CAP_SMB)
;;;256    		card->cccr.multi_block = 1;
;;;257    	if (data & SDIO_CCCR_CAP_LSC)
;;;258    		card->cccr.low_speed = 1;
;;;259    	if (data & SDIO_CCCR_CAP_4BLS)
;;;260    		card->cccr.wide_bus = 1;
;;;261    
;;;262    	if (cccr_vsn >= SDIO_CCCR_REV_1_10) {
;;;263    		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_POWER, 0, &data);
;;;264    		if (ret)
;;;265    			goto out;
;;;266    
;;;267    		if (data & SDIO_POWER_SMPC)
;;;268    			card->cccr.high_power = 1;
;;;269    	}
;;;270    
;;;271    	if (cccr_vsn >= SDIO_CCCR_REV_1_20) {
;;;272    		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &data);
;;;273    		if (ret)
;;;274    			goto out;
;;;275    
;;;276    		if (data & SDIO_SPEED_SHS)
;;;277    			card->cccr.high_speed = 1;
;;;278    	}
;;;279    
;;;280    out:
;;;281    	return ret;
;;;282    }
000042  bdfe              POP      {r1-r7,pc}
                  |L21.68|
000044  f89d0008          LDRB     r0,[sp,#8]            ;249
000048  0900              LSRS     r0,r0,#4              ;249
00004a  f8c40094          STR      r0,[r4,#0x94]         ;249
00004e  ab02              ADD      r3,sp,#8              ;251
000050  2200              MOVS     r2,#0                 ;251
000052  e9cd2300          STRD     r2,r3,[sp,#0]         ;251
000056  2308              MOVS     r3,#8                 ;251
000058  4611              MOV      r1,r2                 ;251
00005a  4620              MOV      r0,r4                 ;251
00005c  f7fffffe          BL       mmc_io_rw_direct
000060  4605              MOV      r5,r0                 ;251
000062  b105              CBZ      r5,|L21.102|
000064  e058              B        |L21.280|
                  |L21.102|
000066  f89d0008          LDRB     r0,[sp,#8]            ;255
00006a  f0100f02          TST      r0,#2                 ;255
00006e  d006              BEQ      |L21.126|
000070  209c              MOVS     r0,#0x9c              ;256
000072  5900              LDR      r0,[r0,r4]            ;256
000074  f0200001          BIC      r0,r0,#1              ;256
000078  1c40              ADDS     r0,r0,#1              ;256
00007a  219c              MOVS     r1,#0x9c              ;256
00007c  5108              STR      r0,[r1,r4]            ;256
                  |L21.126|
00007e  f89d0008          LDRB     r0,[sp,#8]            ;257
000082  f0100f40          TST      r0,#0x40              ;257
000086  d006              BEQ      |L21.150|
000088  209c              MOVS     r0,#0x9c              ;258
00008a  5900              LDR      r0,[r0,r4]            ;258
00008c  f0200002          BIC      r0,r0,#2              ;258
000090  1c80              ADDS     r0,r0,#2              ;258
000092  219c              MOVS     r1,#0x9c              ;258
000094  5108              STR      r0,[r1,r4]            ;258
                  |L21.150|
000096  f89d0008          LDRB     r0,[sp,#8]            ;259
00009a  f0100f80          TST      r0,#0x80              ;259
00009e  d006              BEQ      |L21.174|
0000a0  209c              MOVS     r0,#0x9c              ;260
0000a2  5900              LDR      r0,[r0,r4]            ;260
0000a4  f0200004          BIC      r0,r0,#4              ;260
0000a8  1d00              ADDS     r0,r0,#4              ;260
0000aa  219c              MOVS     r1,#0x9c              ;260
0000ac  5108              STR      r0,[r1,r4]            ;260
                  |L21.174|
0000ae  2e01              CMP      r6,#1                 ;262
0000b0  db17              BLT      |L21.226|
0000b2  ab02              ADD      r3,sp,#8              ;263
0000b4  2200              MOVS     r2,#0                 ;263
0000b6  e9cd2300          STRD     r2,r3,[sp,#0]         ;263
0000ba  2312              MOVS     r3,#0x12              ;263
0000bc  4611              MOV      r1,r2                 ;263
0000be  4620              MOV      r0,r4                 ;263
0000c0  f7fffffe          BL       mmc_io_rw_direct
0000c4  4605              MOV      r5,r0                 ;263
0000c6  b105              CBZ      r5,|L21.202|
0000c8  e026              B        |L21.280|
                  |L21.202|
0000ca  f89d0008          LDRB     r0,[sp,#8]            ;267
0000ce  f0100f01          TST      r0,#1                 ;267
0000d2  d006              BEQ      |L21.226|
0000d4  209c              MOVS     r0,#0x9c              ;268
0000d6  5900              LDR      r0,[r0,r4]            ;268
0000d8  f0200008          BIC      r0,r0,#8              ;268
0000dc  3008              ADDS     r0,r0,#8              ;268
0000de  219c              MOVS     r1,#0x9c              ;268
0000e0  5108              STR      r0,[r1,r4]            ;268
                  |L21.226|
0000e2  2e02              CMP      r6,#2                 ;271
0000e4  db17              BLT      |L21.278|
0000e6  ab02              ADD      r3,sp,#8              ;272
0000e8  2200              MOVS     r2,#0                 ;272
0000ea  e9cd2300          STRD     r2,r3,[sp,#0]         ;272
0000ee  2313              MOVS     r3,#0x13              ;272
0000f0  4611              MOV      r1,r2                 ;272
0000f2  4620              MOV      r0,r4                 ;272
0000f4  f7fffffe          BL       mmc_io_rw_direct
0000f8  4605              MOV      r5,r0                 ;272
0000fa  b105              CBZ      r5,|L21.254|
0000fc  e00c              B        |L21.280|
                  |L21.254|
0000fe  f89d0008          LDRB     r0,[sp,#8]            ;276
000102  f0100f01          TST      r0,#1                 ;276
000106  d006              BEQ      |L21.278|
000108  209c              MOVS     r0,#0x9c              ;277
00010a  5900              LDR      r0,[r0,r4]            ;277
00010c  f0200010          BIC      r0,r0,#0x10           ;277
000110  3010              ADDS     r0,r0,#0x10           ;277
000112  219c              MOVS     r1,#0x9c              ;277
000114  5108              STR      r0,[r1,r4]            ;277
                  |L21.278|
000116  bf00              NOP                            ;280
                  |L21.280|
000118  4628              MOV      r0,r5                 ;281
00011a  e792              B        |L21.66|
;;;283    
                          ENDP

                  |L21.284|
00011c  77696669          DCB      "wifi",0
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L21.292|
000124  25733a20          DCB      "%s: unrecognised CCCR structure version %d\n",0
000128  756e7265
00012c  636f676e
000130  69736564
000134  20434343
000138  52207374
00013c  72756374
000140  75726520
000144  76657273
000148  696f6e20
00014c  25640a00

                          AREA ||i.sdio_read_fbr||, CODE, READONLY, ALIGN=1

                  sdio_read_fbr PROC
;;;170    
;;;171    static int sdio_read_fbr(struct sdio_func *func)
000000  b53e              PUSH     {r1-r5,lr}
;;;172    {
000002  4604              MOV      r4,r0
;;;173    	int ret;
;;;174    	unsigned char data;
;;;175    
;;;176    	ret = mmc_io_rw_direct(func->card, 0, 0,
000004  ab02              ADD      r3,sp,#8
000006  2200              MOVS     r2,#0
000008  e9cd2300          STRD     r2,r3,[sp,#0]
00000c  68e1              LDR      r1,[r4,#0xc]
00000e  eb022301          ADD      r3,r2,r1,LSL #8
000012  4611              MOV      r1,r2
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       mmc_io_rw_direct
00001a  4605              MOV      r5,r0
;;;177    		SDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);
;;;178    	if (ret)
00001c  b105              CBZ      r5,|L22.32|
;;;179    		goto out;
00001e  e01c              B        |L22.90|
                  |L22.32|
;;;180    
;;;181    	data &= 0x0f;
000020  f89d0008          LDRB     r0,[sp,#8]
000024  f000000f          AND      r0,r0,#0xf
000028  9002              STR      r0,[sp,#8]
;;;182    
;;;183    	if (data == 0x0f) {
00002a  f89d0008          LDRB     r0,[sp,#8]
00002e  280f              CMP      r0,#0xf
000030  d10f              BNE      |L22.82|
;;;184    		ret = mmc_io_rw_direct(func->card, 0, 0,
000032  ab02              ADD      r3,sp,#8
000034  2200              MOVS     r2,#0
000036  e9cd2300          STRD     r2,r3,[sp,#0]
00003a  2201              MOVS     r2,#1
00003c  68e1              LDR      r1,[r4,#0xc]
00003e  eb022301          ADD      r3,r2,r1,LSL #8
000042  2200              MOVS     r2,#0
000044  4611              MOV      r1,r2
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       mmc_io_rw_direct
00004c  4605              MOV      r5,r0
;;;185    			SDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF_EXT, 0, &data);
;;;186    		if (ret)
00004e  b105              CBZ      r5,|L22.82|
;;;187    			goto out;
000050  e003              B        |L22.90|
                  |L22.82|
;;;188    	}
;;;189    
;;;190    	func->class = data;
000052  f89d0008          LDRB     r0,[sp,#8]
000056  7420              STRB     r0,[r4,#0x10]
;;;191    
;;;192    out:
000058  bf00              NOP      
                  |L22.90|
;;;193    	return ret;
00005a  4628              MOV      r0,r5
;;;194    }
00005c  bd3e              POP      {r1-r5,pc}
;;;195    
                          ENDP


                          AREA ||i.sdio_readb||, CODE, READONLY, ALIGN=1

                  sdio_readb PROC
;;;724     */
;;;725    u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)
000000  b5fe              PUSH     {r1-r7,lr}
;;;726    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;727    	int ret;
;;;728    	u8 val;
;;;729    
;;;730    	//BUG_ON(!func);
;;;731    
;;;732    	if (err_ret)
000008  b10c              CBZ      r4,|L23.14|
;;;733    		*err_ret = 0;
00000a  2000              MOVS     r0,#0
00000c  6020              STR      r0,[r4,#0]
                  |L23.14|
;;;734    
;;;735    	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, 0, &val);
00000e  ab02              ADD      r3,sp,#8
000010  2200              MOVS     r2,#0
000012  e9cd2300          STRD     r2,r3,[sp,#0]
000016  463b              MOV      r3,r7
000018  2100              MOVS     r1,#0
00001a  68f2              LDR      r2,[r6,#0xc]
00001c  6830              LDR      r0,[r6,#0]
00001e  f7fffffe          BL       mmc_io_rw_direct
000022  4605              MOV      r5,r0
;;;736    	if (ret) {
000024  b11d              CBZ      r5,|L23.46|
;;;737    		if (err_ret)
000026  b104              CBZ      r4,|L23.42|
;;;738    			*err_ret = ret;
000028  6025              STR      r5,[r4,#0]
                  |L23.42|
;;;739    		return 0xFF;
00002a  20ff              MOVS     r0,#0xff
                  |L23.44|
;;;740    	}
;;;741    
;;;742    	return val;
;;;743    }
00002c  bdfe              POP      {r1-r7,pc}
                  |L23.46|
00002e  f89d0008          LDRB     r0,[sp,#8]            ;742
000032  e7fb              B        |L23.44|
;;;744    
                          ENDP


                          AREA ||i.sdio_writeb||, CODE, READONLY, ALIGN=1

                  sdio_writeb PROC
;;;755     */
;;;756    void sdio_writeb(struct sdio_func *func, u8 b, unsigned int addr, int *err_ret)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;757    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;758    	int ret;
;;;759    
;;;760    	//BUG_ON(!func);
;;;761    	ret = mmc_io_rw_direct(func->card, 1, func->num, addr, b, NULL);
00000c  2300              MOVS     r3,#0
00000e  e9cd6300          STRD     r6,r3,[sp,#0]
000012  463b              MOV      r3,r7
000014  2101              MOVS     r1,#1
000016  68e2              LDR      r2,[r4,#0xc]
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       mmc_io_rw_direct
00001e  4680              MOV      r8,r0
;;;762    	if (err_ret)
000020  b10d              CBZ      r5,|L24.38|
;;;763    		*err_ret = ret;
000022  f8c58000          STR      r8,[r5,#0]
                  |L24.38|
;;;764    }
000026  e8bd81fc          POP      {r2-r8,pc}
;;;765    
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L25.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L25.32|
                  |L25.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L25.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L25.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L25.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L25.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L25.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L25.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L25.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  25733a20          DCB      0x25,0x73,0x3a,0x20
000004  63617264          DCB      0x63,0x61,0x72,0x64
000008  20636c61          DCB      0x20,0x63,0x6c,0x61
00000c  696d7320          DCB      0x69,0x6d,0x73,0x20
000010  746f2073          DCB      0x74,0x6f,0x20,0x73
000014  7570706f          DCB      0x75,0x70,0x70,0x6f
000018  72742076          DCB      0x72,0x74,0x20,0x76
00001c  6f6c7461          DCB      0x6f,0x6c,0x74,0x61
000020  67657320          DCB      0x67,0x65,0x73,0x20
000024  62656c6f          DCB      0x62,0x65,0x6c,0x6f
000028  77207468          DCB      0x77,0x20,0x74,0x68
00002c  65206465          DCB      0x65,0x20,0x64,0x65
000030  66696e65          DCB      0x66,0x69,0x6e,0x65
000034  64207261          DCB      0x64,0x20,0x72,0x61
000038  6e67652e          DCB      0x6e,0x67,0x65,0x2e
00003c  20546865          DCB      0x20,0x54,0x68,0x65
000040  73652077          DCB      0x73,0x65,0x20,0x77
000044  696c6c20          DCB      0x69,0x6c,0x6c,0x20
000048  62652069          DCB      0x62,0x65,0x20,0x69
00004c  676e6f72          DCB      0x67,0x6e,0x6f,0x72
000050  65642e0a          DCB      0x65,0x64,0x2e,0x0a
000054  00                DCB      0x00
