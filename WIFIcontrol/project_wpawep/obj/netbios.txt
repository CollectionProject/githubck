; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\netbios.o --depend=.\obj\netbios.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\netbios.crf ..\lwIP\src\core\netbios.c]
                          THUMB

                          AREA ||i.ip_addr_copy||, CODE, READONLY, ALIGN=1

                  ip_addr_copy PROC
;;;52     
;;;53     void ip_addr_copy(struct ip_addr *dst,struct ip_addr *sst)
000000  680a              LDR      r2,[r1,#0]
;;;54     {
;;;55     	*dst=*sst;
000002  6002              STR      r2,[r0,#0]
;;;56     }
000004  4770              BX       lr
;;;57     
                          ENDP


                          AREA ||i.netbios_init||, CODE, READONLY, ALIGN=2

                  netbios_init PROC
;;;340    
;;;341    void netbios_init(void)
000000  b510              PUSH     {r4,lr}
;;;342    {
;;;343      struct udp_pcb *pcb;
;;;344    
;;;345      LWIP_ASSERT("NetBIOS name is too long!", strlen(NETBIOS_LWIP_NAME) < NETBIOS_NAME_LEN);
;;;346    
;;;347      pcb = udp_new();
000002  f7fffffe          BL       udp_new
000006  4604              MOV      r4,r0
;;;348      if (pcb != NULL) {
000008  b16c              CBZ      r4,|L2.38|
;;;349        /* we have to be allowed to send broadcast packets! */
;;;350        pcb->so_options |= SOF_BROADCAST;
00000a  8920              LDRH     r0,[r4,#8]
00000c  f0400020          ORR      r0,r0,#0x20
000010  8120              STRH     r0,[r4,#8]
;;;351        udp_bind(pcb, IP_ADDR_ANY, NETBIOS_PORT);
000012  2289              MOVS     r2,#0x89
000014  4904              LDR      r1,|L2.40|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       udp_bind
;;;352        udp_recv(pcb, netbios_recv, pcb);
00001c  4622              MOV      r2,r4
00001e  4903              LDR      r1,|L2.44|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       udp_recv
                  |L2.38|
;;;353      }
;;;354    }
000026  bd10              POP      {r4,pc}
;;;355    #endif /* LWIP_UDP */
                          ENDP

                  |L2.40|
                          DCD      ip_addr_any
                  |L2.44|
                          DCD      netbios_recv

                          AREA ||i.netbios_name_decoding||, CODE, READONLY, ALIGN=1

                  netbios_name_decoding PROC
;;;174    static int
;;;175    netbios_name_decoding( char *name_enc, char *name_dec, int name_dec_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;176    {
000004  4603              MOV      r3,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;177      char *pname;
;;;178      char  cname;
;;;179      char  cnbname;
;;;180      int   index = 0;
00000a  2600              MOVS     r6,#0
;;;181    
;;;182      LWIP_UNUSED_ARG(name_dec_len);
;;;183    
;;;184      /* Start decoding netbios name. */
;;;185      pname  = name_enc;
00000c  461a              MOV      r2,r3
;;;186      for (;;) {
00000e  bf00              NOP      
                  |L3.16|
;;;187        /* Every two characters of the first level-encoded name
;;;188         * turn into one character in the decoded name. */
;;;189        cname = *pname;
000010  7811              LDRB     r1,[r2,#0]
;;;190        if (cname == '\0')
000012  b901              CBNZ     r1,|L3.22|
;;;191          break;    /* no more characters */
000014  e031              B        |L3.122|
                  |L3.22|
;;;192        if (cname == '.')
000016  292e              CMP      r1,#0x2e
000018  d100              BNE      |L3.28|
;;;193          break;    /* scope ID follows */
00001a  e02e              B        |L3.122|
                  |L3.28|
;;;194        if (cname < 'A' || cname > 'Z') {
00001c  2941              CMP      r1,#0x41
00001e  db01              BLT      |L3.36|
000020  295a              CMP      r1,#0x5a
000022  dd03              BLE      |L3.44|
                  |L3.36|
;;;195          /* Not legal. */
;;;196          return -1;
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L3.40|
;;;197        }
;;;198        cname -= 'A';
;;;199        cnbname = cname << 4;
;;;200        pname++;
;;;201    
;;;202        cname = *pname;
;;;203        if (cname == '\0' || cname == '.') {
;;;204          /* No more characters in the name - but we're in
;;;205           * the middle of a pair.  Not legal. */
;;;206          return -1;
;;;207        }
;;;208        if (cname < 'A' || cname > 'Z') {
;;;209          /* Not legal. */
;;;210          return -1;
;;;211        }
;;;212        cname -= 'A';
;;;213        cnbname |= cname;
;;;214        pname++;
;;;215    
;;;216        /* Do we have room to store the character? */
;;;217        if (index < NETBIOS_NAME_LEN) {
;;;218          /* Yes - store the character. */
;;;219          name_dec[index++] = (cnbname!=' '?cnbname:'\0');
;;;220        }
;;;221      }
;;;222    
;;;223      return 0;
;;;224    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L3.44|
00002c  f1a10041          SUB      r0,r1,#0x41           ;198
000030  b2c1              UXTB     r1,r0                 ;198
000032  0708              LSLS     r0,r1,#28             ;199
000034  0e05              LSRS     r5,r0,#24             ;199
000036  1c52              ADDS     r2,r2,#1              ;200
000038  7811              LDRB     r1,[r2,#0]            ;202
00003a  b109              CBZ      r1,|L3.64|
00003c  292e              CMP      r1,#0x2e              ;203
00003e  d102              BNE      |L3.70|
                  |L3.64|
000040  f04f30ff          MOV      r0,#0xffffffff        ;206
000044  e7f0              B        |L3.40|
                  |L3.70|
000046  2941              CMP      r1,#0x41              ;208
000048  db01              BLT      |L3.78|
00004a  295a              CMP      r1,#0x5a              ;208
00004c  dd02              BLE      |L3.84|
                  |L3.78|
00004e  f04f30ff          MOV      r0,#0xffffffff        ;210
000052  e7e9              B        |L3.40|
                  |L3.84|
000054  f1a10041          SUB      r0,r1,#0x41           ;212
000058  b2c1              UXTB     r1,r0                 ;212
00005a  430d              ORRS     r5,r5,r1              ;213
00005c  1c52              ADDS     r2,r2,#1              ;214
00005e  2e10              CMP      r6,#0x10              ;217
000060  dad6              BGE      |L3.16|
000062  2d20              CMP      r5,#0x20              ;219
000064  d001              BEQ      |L3.106|
000066  4628              MOV      r0,r5                 ;219
000068  e000              B        |L3.108|
                  |L3.106|
00006a  2000              MOVS     r0,#0                 ;219
                  |L3.108|
00006c  f00008ff          AND      r8,r0,#0xff           ;219
000070  4630              MOV      r0,r6                 ;219
000072  1c76              ADDS     r6,r6,#1              ;219
000074  f8048000          STRB     r8,[r4,r0]            ;219
000078  e7ca              B        |L3.16|
                  |L3.122|
00007a  bf00              NOP                            ;191
00007c  2000              MOVS     r0,#0                 ;223
00007e  e7d3              B        |L3.40|
;;;225    
                          ENDP


                          AREA ||i.netbios_recv||, CODE, READONLY, ALIGN=2

                  netbios_recv PROC
;;;278    static void
;;;279    netbios_recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;280    {
000004  b085              SUB      sp,sp,#0x14
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
00000a  469a              MOV      r10,r3
00000c  f8ddb038          LDR      r11,[sp,#0x38]
;;;281      LWIP_UNUSED_ARG(arg);
;;;282      /* if packet is valid */
;;;283      if (p != NULL) {
000010  b3f7              CBZ      r7,|L4.144|
;;;284        char   netbios_name[NETBIOS_NAME_LEN+1];
;;;285        struct netbios_hdr*      netbios_hdr      = (struct netbios_hdr*)p->payload;
000012  687d              LDR      r5,[r7,#4]
;;;286        struct netbios_name_hdr* netbios_name_hdr = (struct netbios_name_hdr*)(netbios_hdr+1);
000014  f105060c          ADD      r6,r5,#0xc
;;;287        
;;;288        /* we only answer if we got a default interface */
;;;289        if (netif_default != NULL) {
000018  483d              LDR      r0,|L4.272|
00001a  6800              LDR      r0,[r0,#0]  ; netif_default
00001c  b3c8              CBZ      r0,|L4.146|
;;;290          /* @todo: do we need to check answerRRs/authorityRRs/additionalRRs? */
;;;291          /* if the packet is a NetBIOS name query question */
;;;292          if (((netbios_hdr->flags & PP_NTOHS(NETB_HFLAG_OPCODE)) == PP_NTOHS(NETB_HFLAG_OPCODE_NAME_QUERY)) &&
00001e  f44f40f0          MOV      r0,#0x7800
000022  f7fffffe          BL       ntohs
000026  8869              LDRH     r1,[r5,#2]
000028  ea000401          AND      r4,r0,r1
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       ntohs
000032  4284              CMP      r4,r0
000034  d164              BNE      |L4.256|
;;;293              ((netbios_hdr->flags & PP_NTOHS(NETB_HFLAG_RESPONSE)) == 0) &&
000036  f44f4000          MOV      r0,#0x8000
00003a  f7fffffe          BL       ntohs
00003e  8869              LDRH     r1,[r5,#2]
000040  4208              TST      r0,r1
000042  d15d              BNE      |L4.256|
;;;294               (netbios_hdr->questions == PP_NTOHS(1))) {
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       ntohs
00004a  88a9              LDRH     r1,[r5,#4]
00004c  4288              CMP      r0,r1
00004e  d157              BNE      |L4.256|
;;;295            /* decode the NetBIOS name */
;;;296            netbios_name_decoding( (char*)(netbios_name_hdr->encname), netbios_name, sizeof(netbios_name));
000050  2211              MOVS     r2,#0x11
000052  4669              MOV      r1,sp
000054  1c70              ADDS     r0,r6,#1
000056  f7fffffe          BL       netbios_name_decoding
;;;297            /* if the packet is for us */
;;;298            if (NETBIOS_STRCMP(netbios_name, NETBIOS_LWIP_NAME) == 0) {
00005a  a12e              ADR      r1,|L4.276|
00005c  4668              MOV      r0,sp
00005e  f7fffffe          BL       strcmp
000062  b9b0              CBNZ     r0,|L4.146|
;;;299              struct pbuf *q;
;;;300              struct netbios_resp *resp;
;;;301    
;;;302              q = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct netbios_resp), PBUF_RAM);
000064  2200              MOVS     r2,#0
000066  213e              MOVS     r1,#0x3e
000068  4610              MOV      r0,r2
00006a  f7fffffe          BL       pbuf_alloc
00006e  4680              MOV      r8,r0
;;;303              if (q != NULL) {
000070  f1b80f00          CMP      r8,#0
000074  d043              BEQ      |L4.254|
;;;304                resp = (struct netbios_resp*)q->payload;
000076  f8d84004          LDR      r4,[r8,#4]
;;;305    
;;;306                /* prepare NetBIOS header response */
;;;307                resp->resp_hdr.trans_id      = netbios_hdr->trans_id;
00007a  8828              LDRH     r0,[r5,#0]
00007c  8020              STRH     r0,[r4,#0]
;;;308                resp->resp_hdr.flags         = PP_HTONS(NETB_HFLAG_RESPONSE |
00007e  f44f4005          MOV      r0,#0x8500
000082  f7fffffe          BL       htons
000086  8060              STRH     r0,[r4,#2]
;;;309                                                     NETB_HFLAG_OPCODE_NAME_QUERY |
;;;310                                                     NETB_HFLAG_AUTHORATIVE |
;;;311                                                     NETB_HFLAG_RECURS_DESIRED);
;;;312                resp->resp_hdr.questions     = 0;
000088  2000              MOVS     r0,#0
00008a  80a0              STRH     r0,[r4,#4]
;;;313                resp->resp_hdr.answerRRs     = PP_HTONS(1);
00008c  2001              MOVS     r0,#1
00008e  e001              B        |L4.148|
                  |L4.144|
000090  e03a              B        |L4.264|
                  |L4.146|
000092  e035              B        |L4.256|
                  |L4.148|
000094  f7fffffe          BL       htons
000098  80e0              STRH     r0,[r4,#6]
;;;314                resp->resp_hdr.authorityRRs  = 0;
00009a  2000              MOVS     r0,#0
00009c  8120              STRH     r0,[r4,#8]
;;;315                resp->resp_hdr.additionalRRs = 0;
00009e  8160              STRH     r0,[r4,#0xa]
;;;316    
;;;317                /* prepare NetBIOS header datas */
;;;318                MEMCPY( resp->resp_name.encname, netbios_name_hdr->encname, sizeof(netbios_name_hdr->encname));
0000a0  2221              MOVS     r2,#0x21
0000a2  1c71              ADDS     r1,r6,#1
0000a4  f104000d          ADD      r0,r4,#0xd
0000a8  f7fffffe          BL       __aeabi_memcpy
;;;319                resp->resp_name.nametype     = netbios_name_hdr->nametype;
0000ac  7830              LDRB     r0,[r6,#0]
0000ae  7320              STRB     r0,[r4,#0xc]
;;;320                resp->resp_name.type         = netbios_name_hdr->type;
0000b0  8c71              LDRH     r1,[r6,#0x22]
0000b2  f104000c          ADD      r0,r4,#0xc
0000b6  85e1              STRH     r1,[r4,#0x2e]
;;;321                resp->resp_name.cls          = netbios_name_hdr->cls;
0000b8  8cb1              LDRH     r1,[r6,#0x24]
0000ba  8621              STRH     r1,[r4,#0x30]
;;;322                resp->resp_name.ttl          = PP_HTONL(NETBIOS_NAME_TTL);
0000bc  4817              LDR      r0,|L4.284|
0000be  f7fffffe          BL       htonl
0000c2  f8c40032          STR      r0,[r4,#0x32]
;;;323                resp->resp_name.datalen      = PP_HTONS(sizeof(resp->resp_name.flags)+sizeof(resp->resp_name.addr));
0000c6  2006              MOVS     r0,#6
0000c8  f7fffffe          BL       htons
0000cc  f104010c          ADD      r1,r4,#0xc
0000d0  86e0              STRH     r0,[r4,#0x36]
;;;324                resp->resp_name.flags        = PP_HTONS(NETB_NFLAG_NODETYPE_BNODE);
0000d2  2000              MOVS     r0,#0
0000d4  f7fffffe          BL       htons
0000d8  f104010c          ADD      r1,r4,#0xc
0000dc  8720              STRH     r0,[r4,#0x38]
;;;325                ip_addr_copy(&resp->resp_name.addr, &netif_default->ip_addr);
0000de  480c              LDR      r0,|L4.272|
0000e0  6801              LDR      r1,[r0,#0]  ; netif_default
0000e2  1d09              ADDS     r1,r1,#4
0000e4  f104003a          ADD      r0,r4,#0x3a
0000e8  f7fffffe          BL       ip_addr_copy
;;;326    
;;;327                /* send the NetBIOS response */
;;;328                udp_sendto(upcb, q, addr, port);
0000ec  465b              MOV      r3,r11
0000ee  4652              MOV      r2,r10
0000f0  4641              MOV      r1,r8
0000f2  4648              MOV      r0,r9
0000f4  f7fffffe          BL       udp_sendto
;;;329                
;;;330                /* free the "reference" pbuf */
;;;331                pbuf_free(q);
0000f8  4640              MOV      r0,r8
0000fa  f7fffffe          BL       pbuf_free
                  |L4.254|
;;;332              }
;;;333            }
0000fe  bf00              NOP      
                  |L4.256|
;;;334          }
;;;335        }
;;;336        /* free the pbuf */
;;;337        pbuf_free(p);
000100  4638              MOV      r0,r7
000102  f7fffffe          BL       pbuf_free
;;;338      }
000106  bf00              NOP      
                  |L4.264|
;;;339    }
000108  b005              ADD      sp,sp,#0x14
00010a  e8bd8ff0          POP      {r4-r11,pc}
;;;340    
                          ENDP

00010e  0000              DCW      0x0000
                  |L4.272|
                          DCD      netif_default
                  |L4.276|
000114  4d415256          DCB      "MARVEL",0
000118  454c00  
00011b  00                DCB      0
                  |L4.284|
                          DCD      0x000493e0
