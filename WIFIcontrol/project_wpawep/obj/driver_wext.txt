; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\driver_wext.o --depend=.\obj\driver_wext.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\driver_wext.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\drivers\driver_wext.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.drv_event_assoc||, CODE, READONLY, ALIGN=1

                  drv_event_assoc PROC
;;;2460   
;;;2461   static inline void drv_event_assoc(void *ctx, const u8 *addr, const u8 *ie,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2462   				   size_t ielen)
;;;2463   {
000002  b09b              SUB      sp,sp,#0x6c
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;2464   	union wpa_event_data event;
;;;2465   	os_memset(&event, 0, sizeof(event));
00000c  2168              MOVS     r1,#0x68
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;2466   	event.assoc_info.req_ies = ie;
000014  9501              STR      r5,[sp,#4]
;;;2467   	event.assoc_info.req_ies_len = ielen;
000016  9602              STR      r6,[sp,#8]
;;;2468   	event.assoc_info.addr = addr;
000018  9408              STR      r4,[sp,#0x20]
;;;2469   	wpa_supplicant_event(ctx, EVENT_ASSOC, &event);
00001a  aa01              ADD      r2,sp,#4
00001c  2100              MOVS     r1,#0
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       wpa_supplicant_event
;;;2470   }
000024  b01b              ADD      sp,sp,#0x6c
000026  bdf0              POP      {r4-r7,pc}
;;;2471   
                          ENDP


                          AREA ||i.drv_event_disassoc||, CODE, READONLY, ALIGN=1

                  drv_event_disassoc PROC
;;;2471   
;;;2472   static inline void drv_event_disassoc(void *ctx, const u8 *addr)
000000  b530              PUSH     {r4,r5,lr}
;;;2473   {
000002  b09b              SUB      sp,sp,#0x6c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;2474   	union wpa_event_data event;
;;;2475   	os_memset(&event, 0, sizeof(event));
000008  2168              MOVS     r1,#0x68
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;2476   	event.disassoc_info.addr = addr;
000010  9401              STR      r4,[sp,#4]
;;;2477   	wpa_supplicant_event(ctx, EVENT_DISASSOC, &event);
000012  aa01              ADD      r2,sp,#4
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       wpa_supplicant_event
;;;2478   }
00001c  b01b              ADD      sp,sp,#0x6c
00001e  bd30              POP      {r4,r5,pc}
;;;2479   
                          ENDP


                          AREA ||i.drv_event_eapol_rx||, CODE, READONLY, ALIGN=1

                  drv_event_eapol_rx PROC
;;;2479   
;;;2480   static inline void drv_event_eapol_rx(void *ctx, const u8 *src, const u8 *data,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2481   				      size_t data_len)
;;;2482   {
000002  b09b              SUB      sp,sp,#0x6c
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;2483   	union wpa_event_data event;
;;;2484   	os_memset(&event, 0, sizeof(event));
00000c  2168              MOVS     r1,#0x68
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;2485   	event.eapol_rx.src = src;
000014  9401              STR      r4,[sp,#4]
;;;2486   	event.eapol_rx.data = data;
000016  9502              STR      r5,[sp,#8]
;;;2487   	event.eapol_rx.data_len = data_len;
000018  9603              STR      r6,[sp,#0xc]
;;;2488   	wpa_supplicant_event(ctx, EVENT_EAPOL_RX, &event);
00001a  aa01              ADD      r2,sp,#4
00001c  211a              MOVS     r1,#0x1a
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       wpa_supplicant_event
;;;2489   }
000024  b01b              ADD      sp,sp,#0x6c
000026  bdf0              POP      {r4-r7,pc}
;;;2490   
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L5.30|
00001a  2001              MOVS     r0,#1
                  |L5.28|
;;;495    }
00001c  4770              BX       lr
                  |L5.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L5.28|
;;;496    
                          ENDP


                          AREA ||i.wext_19_iw_point||, CODE, READONLY, ALIGN=1

                  wext_19_iw_point PROC
;;;1245   
;;;1246   static int wext_19_iw_point(struct wpa_driver_wext_data *drv, u16 cmd)
000000  4602              MOV      r2,r0
;;;1247   {
;;;1248   	return drv->we_version_compiled > 18 &&
000002  6ed0              LDR      r0,[r2,#0x6c]
000004  2812              CMP      r0,#0x12
000006  dd0b              BLE      |L6.32|
;;;1249   		(cmd == SIOCGIWESSID || cmd == SIOCGIWENCODE ||
000008  f5a1400b          SUB      r0,r1,#0x8b00
00000c  381b              SUBS     r0,r0,#0x1b
00000e  d005              BEQ      |L6.28|
000010  3810              SUBS     r0,r0,#0x10
000012  d003              BEQ      |L6.28|
;;;1250   		 cmd == IWEVGENIE || cmd == IWEVCUSTOM);
000014  38da              SUBS     r0,r0,#0xda
000016  d001              BEQ      |L6.28|
000018  1cc0              ADDS     r0,r0,#3
00001a  d101              BNE      |L6.32|
                  |L6.28|
00001c  2001              MOVS     r0,#1                 ;1248
                  |L6.30|
;;;1251   }
00001e  4770              BX       lr
                  |L6.32|
000020  2000              MOVS     r0,#0                 ;1248
000022  e7fc              B        |L6.30|
;;;1252   
                          ENDP


                          AREA ||i.wext_get_scan_custom||, CODE, READONLY, ALIGN=2

                  wext_get_scan_custom PROC
;;;1184   
;;;1185   static void wext_get_scan_custom(struct iw_event *iwe,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1186   				 struct wext_scan_data *res, char *custom,
;;;1187   				 char *end)
;;;1188   {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
;;;1189   	size_t clen;
;;;1190   	u8 *tmp;
;;;1191   
;;;1192   	clen = iwe->u.data.length;
00000c  f8b97008          LDRH     r7,[r9,#8]
;;;1193   	if (custom + clen > end)
000010  19e8              ADDS     r0,r5,r7
000012  4550              CMP      r0,r10
000014  d901              BLS      |L7.26|
                  |L7.22|
;;;1194   		return;
;;;1195   
;;;1196   	if (clen > 7 && os_strncmp(custom, "wpa_ie=", 7) == 0) {
;;;1197   		char *spos;
;;;1198   		int bytes;
;;;1199   		spos = custom + 7;
;;;1200   		bytes = custom + clen - spos;
;;;1201   		if (bytes & 1 || bytes == 0)
;;;1202   			return;
;;;1203   		bytes /= 2;
;;;1204   		tmp = os_realloc(res->ie, res->ie_len + bytes);
;;;1205   		if (tmp == NULL)
;;;1206   			return;
;;;1207   		res->ie = tmp;
;;;1208   		if (hexstr2bin(spos, tmp + res->ie_len, bytes) < 0)
;;;1209   			return;
;;;1210   		res->ie_len += bytes;
;;;1211   	} else if (clen > 7 && os_strncmp(custom, "rsn_ie=", 7) == 0) {
;;;1212   		char *spos;
;;;1213   		int bytes;
;;;1214   		spos = custom + 7;
;;;1215   		bytes = custom + clen - spos;
;;;1216   		if (bytes & 1 || bytes == 0)
;;;1217   			return;
;;;1218   		bytes /= 2;
;;;1219   		tmp = os_realloc(res->ie, res->ie_len + bytes);
;;;1220   		if (tmp == NULL)
;;;1221   			return;
;;;1222   		res->ie = tmp;
;;;1223   		if (hexstr2bin(spos, tmp + res->ie_len, bytes) < 0)
;;;1224   			return;
;;;1225   		res->ie_len += bytes;
;;;1226   	} else if (clen > 4 && os_strncmp(custom, "tsf=", 4) == 0) {
;;;1227   		char *spos;
;;;1228   		int bytes;
;;;1229   		u8 bin[8];
;;;1230   		spos = custom + 4;
;;;1231   		bytes = custom + clen - spos;
;;;1232   		if (bytes != 16) {
;;;1233   			wpa_printf(MSG_INFO, "Invalid TSF length (%d)", bytes);
;;;1234   			return;
;;;1235   		}
;;;1236   		bytes /= 2;
;;;1237   		if (hexstr2bin(spos, bin, bytes) < 0) {
;;;1238   			wpa_printf(MSG_DEBUG, "WEXT: Invalid TSF value");
;;;1239   			return;
;;;1240   		}
;;;1241   		res->res.tsf += WPA_GET_BE64(bin);
;;;1242   	}
;;;1243   }
000016  e8bd9ffc          POP      {r2-r12,pc}
                  |L7.26|
00001a  2f07              CMP      r7,#7                 ;1196
00001c  d92d              BLS      |L7.122|
00001e  2207              MOVS     r2,#7                 ;1196
000020  a14d              ADR      r1,|L7.344|
000022  4628              MOV      r0,r5                 ;1196
000024  f7fffffe          BL       os_strncmp
000028  bb38              CBNZ     r0,|L7.122|
00002a  f1050b07          ADD      r11,r5,#7             ;1199
00002e  19e8              ADDS     r0,r5,r7              ;1200
000030  eba0080b          SUB      r8,r0,r11             ;1200
000034  f0180f01          TST      r8,#1                 ;1201
000038  d102              BNE      |L7.64|
00003a  f1b80f00          CMP      r8,#0                 ;1201
00003e  d100              BNE      |L7.66|
                  |L7.64|
000040  e7e9              B        |L7.22|
                  |L7.66|
000042  4640              MOV      r0,r8                 ;1203
000044  eb0871d8          ADD      r1,r8,r8,LSR #31      ;1203
000048  ea4f0861          ASR      r8,r1,#1              ;1203
00004c  6b62              LDR      r2,[r4,#0x34]         ;1204
00004e  eb020108          ADD      r1,r2,r8              ;1204
000052  6b20              LDR      r0,[r4,#0x30]         ;1204
000054  f7fffffe          BL       os_realloc
000058  4606              MOV      r6,r0                 ;1204
00005a  b906              CBNZ     r6,|L7.94|
00005c  e7db              B        |L7.22|
                  |L7.94|
00005e  6326              STR      r6,[r4,#0x30]         ;1207
000060  6b60              LDR      r0,[r4,#0x34]         ;1208
000062  1981              ADDS     r1,r0,r6              ;1208
000064  4642              MOV      r2,r8                 ;1208
000066  4658              MOV      r0,r11                ;1208
000068  f7fffffe          BL       hexstr2bin
00006c  2800              CMP      r0,#0                 ;1208
00006e  da00              BGE      |L7.114|
000070  e7d1              B        |L7.22|
                  |L7.114|
000072  6b60              LDR      r0,[r4,#0x34]         ;1210
000074  4440              ADD      r0,r0,r8              ;1210
000076  6360              STR      r0,[r4,#0x34]         ;1210
000078  e06b              B        |L7.338|
                  |L7.122|
00007a  2f07              CMP      r7,#7                 ;1211
00007c  d92d              BLS      |L7.218|
00007e  2207              MOVS     r2,#7                 ;1211
000080  a137              ADR      r1,|L7.352|
000082  4628              MOV      r0,r5                 ;1211
000084  f7fffffe          BL       os_strncmp
000088  bb38              CBNZ     r0,|L7.218|
00008a  f1050b07          ADD      r11,r5,#7             ;1214
00008e  19e8              ADDS     r0,r5,r7              ;1215
000090  eba0080b          SUB      r8,r0,r11             ;1215
000094  f0180f01          TST      r8,#1                 ;1216
000098  d102              BNE      |L7.160|
00009a  f1b80f00          CMP      r8,#0                 ;1216
00009e  d100              BNE      |L7.162|
                  |L7.160|
0000a0  e7b9              B        |L7.22|
                  |L7.162|
0000a2  4640              MOV      r0,r8                 ;1218
0000a4  eb0871d8          ADD      r1,r8,r8,LSR #31      ;1218
0000a8  ea4f0861          ASR      r8,r1,#1              ;1218
0000ac  6b62              LDR      r2,[r4,#0x34]         ;1219
0000ae  eb020108          ADD      r1,r2,r8              ;1219
0000b2  6b20              LDR      r0,[r4,#0x30]         ;1219
0000b4  f7fffffe          BL       os_realloc
0000b8  4606              MOV      r6,r0                 ;1219
0000ba  b906              CBNZ     r6,|L7.190|
0000bc  e7ab              B        |L7.22|
                  |L7.190|
0000be  6326              STR      r6,[r4,#0x30]         ;1222
0000c0  6b60              LDR      r0,[r4,#0x34]         ;1223
0000c2  1981              ADDS     r1,r0,r6              ;1223
0000c4  4642              MOV      r2,r8                 ;1223
0000c6  4658              MOV      r0,r11                ;1223
0000c8  f7fffffe          BL       hexstr2bin
0000cc  2800              CMP      r0,#0                 ;1223
0000ce  da00              BGE      |L7.210|
0000d0  e7a1              B        |L7.22|
                  |L7.210|
0000d2  6b60              LDR      r0,[r4,#0x34]         ;1225
0000d4  4440              ADD      r0,r0,r8              ;1225
0000d6  6360              STR      r0,[r4,#0x34]         ;1225
0000d8  e03b              B        |L7.338|
                  |L7.218|
0000da  2f04              CMP      r7,#4                 ;1226
0000dc  d939              BLS      |L7.338|
0000de  2204              MOVS     r2,#4                 ;1226
0000e0  a121              ADR      r1,|L7.360|
0000e2  4628              MOV      r0,r5                 ;1226
0000e4  f7fffffe          BL       os_strncmp
0000e8  bb98              CBNZ     r0,|L7.338|
0000ea  f1050b04          ADD      r11,r5,#4             ;1230
0000ee  19e8              ADDS     r0,r5,r7              ;1231
0000f0  eba0080b          SUB      r8,r0,r11             ;1231
0000f4  f1b80f10          CMP      r8,#0x10              ;1232
0000f8  d005              BEQ      |L7.262|
0000fa  4642              MOV      r2,r8                 ;1233
0000fc  a11c              ADR      r1,|L7.368|
0000fe  2000              MOVS     r0,#0                 ;1233
000100  f7fffffe          BL       wpa_printf
000104  e787              B        |L7.22|
                  |L7.262|
000106  4640              MOV      r0,r8                 ;1236
000108  eb0871d8          ADD      r1,r8,r8,LSR #31      ;1236
00010c  ea4f0861          ASR      r8,r1,#1              ;1236
000110  4642              MOV      r2,r8                 ;1237
000112  4669              MOV      r1,sp                 ;1237
000114  4658              MOV      r0,r11                ;1237
000116  f7fffffe          BL       hexstr2bin
00011a  2800              CMP      r0,#0                 ;1237
00011c  da04              BGE      |L7.296|
00011e  a11a              ADR      r1,|L7.392|
000120  2000              MOVS     r0,#0                 ;1238
000122  f7fffffe          BL       wpa_printf
000126  e776              B        |L7.22|
                  |L7.296|
000128  2000              MOVS     r0,#0                 ;1241
00012a  4300              ORRS     r0,r0,r0              ;1241
00012c  f89d1004          LDRB     r1,[sp,#4]            ;1241
000130  ea406001          ORR      r0,r0,r1,LSL #24      ;1241
000134  f89d1005          LDRB     r1,[sp,#5]            ;1241
000138  ea404001          ORR      r0,r0,r1,LSL #16      ;1241
00013c  f89d1006          LDRB     r1,[sp,#6]            ;1241
000140  ea402001          ORR      r0,r0,r1,LSL #8       ;1241
000144  f89d1007          LDRB     r1,[sp,#7]            ;1241
000148  4308              ORRS     r0,r0,r1              ;1241
00014a  6a21              LDR      r1,[r4,#0x20]         ;1241
00014c  4408              ADD      r0,r0,r1              ;1241
00014e  6220              STR      r0,[r4,#0x20]         ;1241
000150  bf00              NOP                            ;1242
                  |L7.338|
000152  bf00              NOP      
000154  e75f              B        |L7.22|
;;;1244   
                          ENDP

000156  0000              DCW      0x0000
                  |L7.344|
000158  7770615f          DCB      "wpa_ie=",0
00015c  69653d00
                  |L7.352|
000160  72736e5f          DCB      "rsn_ie=",0
000164  69653d00
                  |L7.360|
000168  7473663d          DCB      "tsf=",0
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L7.368|
000170  496e7661          DCB      "Invalid TSF length (%d)",0
000174  6c696420
000178  54534620
00017c  6c656e67
000180  74682028
000184  25642900
                  |L7.392|
000188  57455854          DCB      "WEXT: Invalid TSF value",0
00018c  3a20496e
000190  76616c69
000194  64205453
000198  46207661
00019c  6c756500

                          AREA ||i.wext_get_scan_encode||, CODE, READONLY, ALIGN=1

                  wext_get_scan_encode PROC
;;;1119   
;;;1120   static void wext_get_scan_encode(struct iw_event *iwe,
000000  8942              LDRH     r2,[r0,#0xa]
;;;1121   				 struct wext_scan_data *res)
;;;1122   {
;;;1123   	if (!(iwe->u.data.flags & IW_ENCODE_DISABLED))
000002  f4124f00          TST      r2,#0x8000
000006  d103              BNE      |L8.16|
;;;1124   		res->res.caps |= IEEE80211_CAP_PRIVACY;
000008  8a4a              LDRH     r2,[r1,#0x12]
00000a  f0420210          ORR      r2,r2,#0x10
00000e  824a              STRH     r2,[r1,#0x12]
                  |L8.16|
;;;1125   }
000010  4770              BX       lr
;;;1126   
                          ENDP


                          AREA ||i.wext_get_scan_freq||, CODE, READONLY, ALIGN=2

                  wext_get_scan_freq PROC
;;;1061   
;;;1062   static void wext_get_scan_freq(struct iw_event *iwe,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1063   			       struct wext_scan_data *res)
;;;1064   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1065   	int divi = 1000000, i;
000008  4f20              LDR      r7,|L9.140|
;;;1066   
;;;1067   	if (iwe->u.freq.e == 0) {
00000a  8920              LDRH     r0,[r4,#8]
00000c  b9b8              CBNZ     r0,|L9.62|
;;;1068   		/*
;;;1069   		 * Some drivers do not report frequency, but a channel.
;;;1070   		 * Try to map this to frequency by assuming they are using
;;;1071   		 * IEEE 802.11b/g.  But don't overwrite a previously parsed
;;;1072   		 * frequency if the driver sends both frequency and channel,
;;;1073   		 * since the driver may be sending an A-band channel that we
;;;1074   		 * don't handle here.
;;;1075   		 */
;;;1076   
;;;1077   		if (res->res.freq)
00000e  68e8              LDR      r0,[r5,#0xc]
000010  b108              CBZ      r0,|L9.22|
                  |L9.18|
;;;1078   			return;
;;;1079   
;;;1080   		if (iwe->u.freq.m >= 1 && iwe->u.freq.m <= 13) {
;;;1081   			res->res.freq = 2407 + 5 * iwe->u.freq.m;
;;;1082   			return;
;;;1083   		} else if (iwe->u.freq.m == 14) {
;;;1084   			res->res.freq = 2484;
;;;1085   			return;
;;;1086   		}
;;;1087   	}
;;;1088   
;;;1089   	if (iwe->u.freq.e > 6) {
;;;1090   		wpa_printf(MSG_DEBUG, "Invalid freq in scan results (BSSID="
;;;1091   			   MACSTR " m=%d e=%d)",
;;;1092   			   MAC2STR(res->res.bssid), iwe->u.freq.m,
;;;1093   			   iwe->u.freq.e);
;;;1094   		return;
;;;1095   	}
;;;1096   
;;;1097   	for (i = 0; i < iwe->u.freq.e; i++)
;;;1098   		divi /= 10;
;;;1099   	res->res.freq = iwe->u.freq.m / divi;
;;;1100   }
000012  b007              ADD      sp,sp,#0x1c
000014  bdf0              POP      {r4-r7,pc}
                  |L9.22|
000016  6860              LDR      r0,[r4,#4]            ;1080
000018  2801              CMP      r0,#1                 ;1080
00001a  db09              BLT      |L9.48|
00001c  6860              LDR      r0,[r4,#4]            ;1080
00001e  280d              CMP      r0,#0xd               ;1080
000020  dc06              BGT      |L9.48|
000022  6860              LDR      r0,[r4,#4]            ;1081
000024  eb000080          ADD      r0,r0,r0,LSL #2       ;1081
000028  f6001067          ADD      r0,r0,#0x967          ;1081
00002c  60e8              STR      r0,[r5,#0xc]          ;1081
00002e  e7f0              B        |L9.18|
                  |L9.48|
000030  6860              LDR      r0,[r4,#4]            ;1083
000032  280e              CMP      r0,#0xe               ;1083
000034  d103              BNE      |L9.62|
000036  f64010b4          MOV      r0,#0x9b4             ;1084
00003a  60e8              STR      r0,[r5,#0xc]          ;1084
00003c  e7e9              B        |L9.18|
                  |L9.62|
00003e  f9b40008          LDRSH    r0,[r4,#8]            ;1089
000042  2806              CMP      r0,#6                 ;1089
000044  dd11              BLE      |L9.106|
000046  f9b43008          LDRSH    r3,[r4,#8]            ;1090
00004a  7a69              LDRB     r1,[r5,#9]            ;1090
00004c  7a28              LDRB     r0,[r5,#8]            ;1090
00004e  6862              LDR      r2,[r4,#4]            ;1090
000050  ae02              ADD      r6,sp,#8              ;1090
000052  c60f              STM      r6!,{r0-r3}           ;1090
000054  79eb              LDRB     r3,[r5,#7]            ;1090
000056  79aa              LDRB     r2,[r5,#6]            ;1090
000058  e9cd2300          STRD     r2,r3,[sp,#0]         ;1090
00005c  796b              LDRB     r3,[r5,#5]            ;1090
00005e  792a              LDRB     r2,[r5,#4]            ;1090
000060  490b              LDR      r1,|L9.144|
000062  2000              MOVS     r0,#0                 ;1090
000064  f7fffffe          BL       wpa_printf
000068  e7d3              B        |L9.18|
                  |L9.106|
00006a  2600              MOVS     r6,#0                 ;1097
00006c  e003              B        |L9.118|
                  |L9.110|
00006e  200a              MOVS     r0,#0xa               ;1098
000070  fb97f7f0          SDIV     r7,r7,r0              ;1098
000074  1c76              ADDS     r6,r6,#1              ;1097
                  |L9.118|
000076  f9b40008          LDRSH    r0,[r4,#8]            ;1097
00007a  42b0              CMP      r0,r6                 ;1097
00007c  dcf7              BGT      |L9.110|
00007e  6860              LDR      r0,[r4,#4]            ;1099
000080  fb90f0f7          SDIV     r0,r0,r7              ;1099
000084  60e8              STR      r0,[r5,#0xc]          ;1099
000086  bf00              NOP      
000088  e7c3              B        |L9.18|
;;;1101   
                          ENDP

00008a  0000              DCW      0x0000
                  |L9.140|
                          DCD      0x000f4240
                  |L9.144|
                          DCD      ||.constdata||+0x440

                          AREA ||i.wext_get_scan_iwevgenie||, CODE, READONLY, ALIGN=2

                  wext_get_scan_iwevgenie PROC
;;;1158   
;;;1159   static void wext_get_scan_iwevgenie(struct iw_event *iwe,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1160   				    struct wext_scan_data *res, char *custom,
;;;1161   				    char *end)
;;;1162   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;1163   	char *genie, *gpos, *gend;
;;;1164   	u8 *tmp;
;;;1165   
;;;1166   	if (iwe->u.data.length == 0)
00000c  f8b80008          LDRH     r0,[r8,#8]
000010  b908              CBNZ     r0,|L10.22|
                  |L10.18|
;;;1167   		return;
;;;1168   
;;;1169   	gpos = genie = custom;
;;;1170   	gend = genie + iwe->u.data.length;
;;;1171   	if (gend > end) {
;;;1172   		wpa_printf(MSG_INFO, "IWEVGENIE overflow");
;;;1173   		return;
;;;1174   	}
;;;1175   
;;;1176   	tmp = os_realloc(res->ie, res->ie_len + gend - gpos);
;;;1177   	if (tmp == NULL)
;;;1178   		return;
;;;1179   	os_memcpy(tmp + res->ie_len, gpos, gend - gpos);
;;;1180   	res->ie = tmp;
;;;1181   	res->ie_len += gend - gpos;
;;;1182   }
000012  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.22|
000016  464d              MOV      r5,r9                 ;1169
000018  46cb              MOV      r11,r9                ;1169
00001a  f8b80008          LDRH     r0,[r8,#8]            ;1170
00001e  465d              MOV      r5,r11                ;1170
000020  eb00060b          ADD      r6,r0,r11             ;1170
000024  4556              CMP      r6,r10                ;1171
000026  d904              BLS      |L10.50|
000028  a10d              ADR      r1,|L10.96|
00002a  2000              MOVS     r0,#0                 ;1172
00002c  f7fffffe          BL       wpa_printf
000030  e7ef              B        |L10.18|
                  |L10.50|
000032  6b62              LDR      r2,[r4,#0x34]         ;1176
000034  4432              ADD      r2,r2,r6              ;1176
000036  1b51              SUBS     r1,r2,r5              ;1176
000038  6b20              LDR      r0,[r4,#0x30]         ;1176
00003a  f7fffffe          BL       os_realloc
00003e  4607              MOV      r7,r0                 ;1176
000040  b907              CBNZ     r7,|L10.68|
000042  e7e6              B        |L10.18|
                  |L10.68|
000044  1b72              SUBS     r2,r6,r5              ;1179
000046  6b61              LDR      r1,[r4,#0x34]         ;1179
000048  19c8              ADDS     r0,r1,r7              ;1179
00004a  4629              MOV      r1,r5                 ;1179
00004c  f7fffffe          BL       __aeabi_memcpy
000050  6327              STR      r7,[r4,#0x30]         ;1180
000052  1b71              SUBS     r1,r6,r5              ;1181
000054  6b60              LDR      r0,[r4,#0x34]         ;1181
000056  4408              ADD      r0,r0,r1              ;1181
000058  6360              STR      r0,[r4,#0x34]         ;1181
00005a  bf00              NOP      
00005c  e7d9              B        |L10.18|
;;;1183   
                          ENDP

00005e  0000              DCW      0x0000
                  |L10.96|
000060  49574556          DCB      "IWEVGENIE overflow",0
000064  47454e49
000068  45206f76
00006c  6572666c
000070  6f7700  
000073  00                DCB      0

                          AREA ||i.wext_get_scan_mode||, CODE, READONLY, ALIGN=1

                  wext_get_scan_mode PROC
;;;1035   
;;;1036   static void wext_get_scan_mode(struct iw_event *iwe,
000000  6842              LDR      r2,[r0,#4]
;;;1037   			       struct wext_scan_data *res)
;;;1038   {
;;;1039   	if (iwe->u.mode == IW_MODE_ADHOC)
000002  2a01              CMP      r2,#1
000004  d104              BNE      |L11.16|
;;;1040   		res->res.caps |= IEEE80211_CAP_IBSS;
000006  8a4a              LDRH     r2,[r1,#0x12]
000008  f0420202          ORR      r2,r2,#2
00000c  824a              STRH     r2,[r1,#0x12]
00000e  e009              B        |L11.36|
                  |L11.16|
;;;1041   	else if (iwe->u.mode == IW_MODE_MASTER || iwe->u.mode == IW_MODE_INFRA)
000010  6842              LDR      r2,[r0,#4]
000012  2a03              CMP      r2,#3
000014  d002              BEQ      |L11.28|
000016  6842              LDR      r2,[r0,#4]
000018  2a02              CMP      r2,#2
00001a  d103              BNE      |L11.36|
                  |L11.28|
;;;1042   		res->res.caps |= IEEE80211_CAP_ESS;
00001c  8a4a              LDRH     r2,[r1,#0x12]
00001e  f0420201          ORR      r2,r2,#1
000022  824a              STRH     r2,[r1,#0x12]
                  |L11.36|
;;;1043   }
000024  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.wext_get_scan_qual||, CODE, READONLY, ALIGN=1

                  wext_get_scan_qual PROC
;;;1102   
;;;1103   static void wext_get_scan_qual(struct iw_event *iwe,
000000  7902              LDRB     r2,[r0,#4]
;;;1104   			       struct wext_scan_data *res)
;;;1105   {
;;;1106   	res->res.qual = iwe->u.qual.qual;
000002  614a              STR      r2,[r1,#0x14]
;;;1107   	res->res.noise = iwe->u.qual.noise;
000004  7982              LDRB     r2,[r0,#6]
000006  618a              STR      r2,[r1,#0x18]
;;;1108   	res->res.level = iwe->u.qual.level;
000008  7942              LDRB     r2,[r0,#5]
00000a  61ca              STR      r2,[r1,#0x1c]
;;;1109   	if (iwe->u.qual.updated & IW_QUAL_QUAL_INVALID)
00000c  79c2              LDRB     r2,[r0,#7]
00000e  f0120f10          TST      r2,#0x10
000012  d003              BEQ      |L12.28|
;;;1110   		res->res.flags |= WPA_SCAN_QUAL_INVALID;
000014  680a              LDR      r2,[r1,#0]
000016  f0420201          ORR      r2,r2,#1
00001a  600a              STR      r2,[r1,#0]
                  |L12.28|
;;;1111   	if (iwe->u.qual.updated & IW_QUAL_LEVEL_INVALID)
00001c  79c2              LDRB     r2,[r0,#7]
00001e  f0120f20          TST      r2,#0x20
000022  d003              BEQ      |L12.44|
;;;1112   		res->res.flags |= WPA_SCAN_LEVEL_INVALID;
000024  680a              LDR      r2,[r1,#0]
000026  f0420204          ORR      r2,r2,#4
00002a  600a              STR      r2,[r1,#0]
                  |L12.44|
;;;1113   	if (iwe->u.qual.updated & IW_QUAL_NOISE_INVALID)
00002c  79c2              LDRB     r2,[r0,#7]
00002e  f0120f40          TST      r2,#0x40
000032  d003              BEQ      |L12.60|
;;;1114   		res->res.flags |= WPA_SCAN_NOISE_INVALID;
000034  680a              LDR      r2,[r1,#0]
000036  f0420202          ORR      r2,r2,#2
00003a  600a              STR      r2,[r1,#0]
                  |L12.60|
;;;1115   	if (iwe->u.qual.updated & IW_QUAL_DBM)
00003c  79c2              LDRB     r2,[r0,#7]
00003e  f0120f08          TST      r2,#8
000042  d003              BEQ      |L12.76|
;;;1116   		res->res.flags |= WPA_SCAN_LEVEL_DBM;
000044  680a              LDR      r2,[r1,#0]
000046  f0420208          ORR      r2,r2,#8
00004a  600a              STR      r2,[r1,#0]
                  |L12.76|
;;;1117   }
00004c  4770              BX       lr
;;;1118   
                          ENDP


                          AREA ||i.wext_get_scan_rate||, CODE, READONLY, ALIGN=1

                  wext_get_scan_rate PROC
;;;1127   
;;;1128   static void wext_get_scan_rate(struct iw_event *iwe,
000000  4770              BX       lr
;;;1129   			       struct wext_scan_data *res, char *pos,
;;;1130   			       char *end)
;;;1131   {
;;;1132   #if 0
;;;1133   	int maxrate;
;;;1134   	char *custom = pos + IW_EV_LCP_LEN;
;;;1135   	struct iw_param p;
;;;1136   	size_t clen;
;;;1137   
;;;1138   	clen = iwe->len;
;;;1139   	if (custom + clen > end)
;;;1140   		return;
;;;1141   	maxrate = 0;
;;;1142   	while (((ssize_t) clen) >= (ssize_t) sizeof(struct iw_param)) {
;;;1143   		/* Note: may be misaligned, make a local, aligned copy */
;;;1144   		os_memcpy(&p, custom, sizeof(struct iw_param));
;;;1145   		if (p.value > maxrate)
;;;1146   			maxrate = p.value;
;;;1147   		clen -= sizeof(struct iw_param);
;;;1148   		custom += sizeof(struct iw_param);
;;;1149   	}
;;;1150   
;;;1151   	/* Convert the maxrate from WE-style (b/s units) to
;;;1152   	 * 802.11 rates (500000 b/s units).
;;;1153   	 */
;;;1154   	res->maxrate = maxrate / 500000;
;;;1155   #endif
;;;1156   }
;;;1157   
                          ENDP


                          AREA ||i.wext_get_scan_ssid||, CODE, READONLY, ALIGN=1

                  wext_get_scan_ssid PROC
;;;1045   
;;;1046   static void wext_get_scan_ssid(struct iw_event *iwe,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1047   			       struct wext_scan_data *res, char *custom,
;;;1048   			       char *end)
;;;1049   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1050   	int ssid_len = iwe->u.essid.length;
00000c  892c              LDRH     r4,[r5,#8]
;;;1051   	if (custom + ssid_len > end)
00000e  1938              ADDS     r0,r7,r4
000010  4540              CMP      r0,r8
000012  d901              BLS      |L14.24|
                  |L14.20|
;;;1052   		return;
;;;1053   	if (iwe->u.essid.flags &&
;;;1054   	    ssid_len > 0 &&
;;;1055   	    ssid_len <= IW_ESSID_MAX_SIZE) {
;;;1056   		os_memcpy(res->ssid, custom, ssid_len);
;;;1057   		res->ssid_len = ssid_len;
;;;1058   	}
;;;1059   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L14.24|
000018  8968              LDRH     r0,[r5,#0xa]          ;1053
00001a  b150              CBZ      r0,|L14.50|
00001c  2c00              CMP      r4,#0                 ;1054
00001e  dd08              BLE      |L14.50|
000020  2c20              CMP      r4,#0x20              ;1055
000022  dc06              BGT      |L14.50|
000024  4622              MOV      r2,r4                 ;1056
000026  4639              MOV      r1,r7                 ;1056
000028  f1060038          ADD      r0,r6,#0x38           ;1056
00002c  f7fffffe          BL       __aeabi_memcpy
000030  65b4              STR      r4,[r6,#0x58]         ;1057
                  |L14.50|
000032  bf00              NOP      
000034  e7ee              B        |L14.20|
;;;1060   
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_driver_wext_add_pmkid||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_add_pmkid PROC
;;;2213   
;;;2214   static int wpa_driver_wext_add_pmkid(void *priv, const u8 *bssid,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2215   				     const u8 *pmkid)
;;;2216   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2217   	struct wpa_driver_wext_data *drv = priv;
00000a  4627              MOV      r7,r4
;;;2218   	return wpa_driver_wext_pmksa(drv, IW_PMKSA_ADD, bssid, pmkid);
00000c  4633              MOV      r3,r6
00000e  462a              MOV      r2,r5
000010  2101              MOVS     r1,#1
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       wpa_driver_wext_pmksa
;;;2219   }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;2220   
                          ENDP


                          AREA ||i.wpa_driver_wext_add_scan_entry||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_add_scan_entry PROC
;;;1253   
;;;1254   static void wpa_driver_wext_add_scan_entry(struct wpa_scan_results *res,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1255   					   struct wext_scan_data *data)
;;;1256   {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;1257   	struct wpa_scan_res **tmp;
;;;1258   	struct wpa_scan_res *r;
;;;1259   	size_t extra_len;
;;;1260   	u8 *pos, *end, *ssid_ie = NULL, *rate_ie = NULL;
000008  f04f0b00          MOV      r11,#0
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;1261   
;;;1262   	/* Figure out whether we need to fake any IEs */
;;;1263   	pos = data->ie;
000010  6b2c              LDR      r4,[r5,#0x30]
;;;1264   	end = pos + data->ie_len;
000012  6b68              LDR      r0,[r5,#0x34]
000014  eb000a04          ADD      r10,r0,r4
;;;1265   	while (pos && pos + 1 < end) {
000018  e015              B        |L18.70|
                  |L18.26|
;;;1266   		if (pos + 2 + pos[1] > end)
00001a  7861              LDRB     r1,[r4,#1]
00001c  1ca0              ADDS     r0,r4,#2
00001e  4408              ADD      r0,r0,r1
000020  4550              CMP      r0,r10
000022  d900              BLS      |L18.38|
;;;1267   			break;
000024  e013              B        |L18.78|
                  |L18.38|
;;;1268   		if (pos[0] == WLAN_EID_SSID)
000026  7820              LDRB     r0,[r4,#0]
000028  b908              CBNZ     r0,|L18.46|
;;;1269   			ssid_ie = pos;
00002a  46a3              MOV      r11,r4
00002c  e008              B        |L18.64|
                  |L18.46|
;;;1270   		else if (pos[0] == WLAN_EID_SUPP_RATES)
00002e  7820              LDRB     r0,[r4,#0]
000030  2801              CMP      r0,#1
000032  d101              BNE      |L18.56|
;;;1271   			rate_ie = pos;
000034  9400              STR      r4,[sp,#0]
000036  e003              B        |L18.64|
                  |L18.56|
;;;1272   		else if (pos[0] == WLAN_EID_EXT_SUPP_RATES)
000038  7820              LDRB     r0,[r4,#0]
00003a  2832              CMP      r0,#0x32
00003c  d100              BNE      |L18.64|
;;;1273   			rate_ie = pos;
00003e  9400              STR      r4,[sp,#0]
                  |L18.64|
;;;1274   		pos += 2 + pos[1];
000040  7860              LDRB     r0,[r4,#1]
000042  1c80              ADDS     r0,r0,#2
000044  4404              ADD      r4,r4,r0
                  |L18.70|
000046  b114              CBZ      r4,|L18.78|
000048  1c60              ADDS     r0,r4,#1              ;1265
00004a  4550              CMP      r0,r10                ;1265
00004c  d3e5              BCC      |L18.26|
                  |L18.78|
00004e  bf00              NOP                            ;1267
;;;1275   	}
;;;1276   
;;;1277   	extra_len = 0;
000050  f04f0900          MOV      r9,#0
;;;1278   	if (ssid_ie == NULL)
000054  f1bb0f00          CMP      r11,#0
000058  d102              BNE      |L18.96|
;;;1279   		extra_len += 2 + data->ssid_len;
00005a  6da8              LDR      r0,[r5,#0x58]
00005c  1c80              ADDS     r0,r0,#2
00005e  4481              ADD      r9,r9,r0
                  |L18.96|
;;;1280   	if (rate_ie == NULL && data->maxrate)
000060  9800              LDR      r0,[sp,#0]
000062  b918              CBNZ     r0,|L18.108|
000064  6de8              LDR      r0,[r5,#0x5c]
000066  b108              CBZ      r0,|L18.108|
;;;1281   		extra_len += 3;
000068  f1090903          ADD      r9,r9,#3
                  |L18.108|
;;;1282   
;;;1283   	r = os_zalloc(sizeof(*r) + extra_len + data->ie_len);
00006c  f1090130          ADD      r1,r9,#0x30
000070  6b6a              LDR      r2,[r5,#0x34]
000072  1888              ADDS     r0,r1,r2
000074  f7fffffe          BL       os_zalloc
000078  4607              MOV      r7,r0
;;;1284   	if (r == NULL)
00007a  b90f              CBNZ     r7,|L18.128|
                  |L18.124|
;;;1285   		return;
;;;1286   	os_memcpy(r, &data->res, sizeof(*r));
;;;1287   	r->ie_len = extra_len + data->ie_len;
;;;1288   	pos = (u8 *) (r + 1);
;;;1289   	if (ssid_ie == NULL) {
;;;1290   		/*
;;;1291   		 * Generate a fake SSID IE since the driver did not report
;;;1292   		 * a full IE list.
;;;1293   		 */
;;;1294   		*pos++ = WLAN_EID_SSID;
;;;1295   		*pos++ = data->ssid_len;
;;;1296   		os_memcpy(pos, data->ssid, data->ssid_len);
;;;1297   		pos += data->ssid_len;
;;;1298   	}
;;;1299   	if (rate_ie == NULL && data->maxrate) {
;;;1300   		/*
;;;1301   		 * Generate a fake Supported Rates IE since the driver did not
;;;1302   		 * report a full IE list.
;;;1303   		 */
;;;1304   		*pos++ = WLAN_EID_SUPP_RATES;
;;;1305   		*pos++ = 1;
;;;1306   		*pos++ = data->maxrate;
;;;1307   	}
;;;1308   	if (data->ie)
;;;1309   		os_memcpy(pos, data->ie, data->ie_len);
;;;1310   
;;;1311   	tmp = os_realloc(res->res,
;;;1312   			 (res->num + 1) * sizeof(struct wpa_scan_res *));
;;;1313   	if (tmp == NULL) {
;;;1314   		os_free(r);
;;;1315   		return;
;;;1316   	}
;;;1317   	tmp[res->num++] = r;
;;;1318   	res->res = tmp;
;;;1319   }
00007c  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.128|
000080  2230              MOVS     r2,#0x30              ;1286
000082  4629              MOV      r1,r5                 ;1286
000084  4638              MOV      r0,r7                 ;1286
000086  f7fffffe          BL       __aeabi_memcpy4
00008a  6b68              LDR      r0,[r5,#0x34]         ;1287
00008c  4448              ADD      r0,r0,r9              ;1287
00008e  62b8              STR      r0,[r7,#0x28]         ;1287
000090  f1070430          ADD      r4,r7,#0x30           ;1288
000094  f1bb0f00          CMP      r11,#0                ;1289
000098  d10d              BNE      |L18.182|
00009a  2000              MOVS     r0,#0                 ;1294
00009c  f8040b01          STRB     r0,[r4],#1            ;1294
0000a0  6da8              LDR      r0,[r5,#0x58]         ;1295
0000a2  f8040b01          STRB     r0,[r4],#1            ;1295
0000a6  f1050138          ADD      r1,r5,#0x38           ;1296
0000aa  4620              MOV      r0,r4                 ;1296
0000ac  6daa              LDR      r2,[r5,#0x58]         ;1296
0000ae  f7fffffe          BL       __aeabi_memcpy
0000b2  6da8              LDR      r0,[r5,#0x58]         ;1297
0000b4  4404              ADD      r4,r4,r0              ;1297
                  |L18.182|
0000b6  9800              LDR      r0,[sp,#0]            ;1299
0000b8  b948              CBNZ     r0,|L18.206|
0000ba  6de8              LDR      r0,[r5,#0x5c]         ;1299
0000bc  b138              CBZ      r0,|L18.206|
0000be  2001              MOVS     r0,#1                 ;1304
0000c0  f8040b01          STRB     r0,[r4],#1            ;1304
0000c4  f8040b01          STRB     r0,[r4],#1            ;1305
0000c8  6de8              LDR      r0,[r5,#0x5c]         ;1306
0000ca  f8040b01          STRB     r0,[r4],#1            ;1306
                  |L18.206|
0000ce  6b28              LDR      r0,[r5,#0x30]         ;1308
0000d0  b120              CBZ      r0,|L18.220|
0000d2  4620              MOV      r0,r4                 ;1309
0000d4  e9d5120c          LDRD     r1,r2,[r5,#0x30]      ;1309
0000d8  f7fffffe          BL       __aeabi_memcpy
                  |L18.220|
0000dc  6872              LDR      r2,[r6,#4]            ;1311
0000de  1c52              ADDS     r2,r2,#1              ;1311
0000e0  0091              LSLS     r1,r2,#2              ;1311
0000e2  6830              LDR      r0,[r6,#0]            ;1311
0000e4  f7fffffe          BL       os_realloc
0000e8  4680              MOV      r8,r0                 ;1311
0000ea  f1b80f00          CMP      r8,#0                 ;1313
0000ee  d103              BNE      |L18.248|
0000f0  4638              MOV      r0,r7                 ;1314
0000f2  f7fffffe          BL       os_free
0000f6  e7c1              B        |L18.124|
                  |L18.248|
0000f8  6871              LDR      r1,[r6,#4]            ;1317
0000fa  1c48              ADDS     r0,r1,#1              ;1317
0000fc  6070              STR      r0,[r6,#4]            ;1317
0000fe  f8487021          STR      r7,[r8,r1,LSL #2]     ;1317
000102  f8c68000          STR      r8,[r6,#0]            ;1318
000106  bf00              NOP      
000108  e7b8              B        |L18.124|
;;;1320   				      
                          ENDP


                          AREA ||i.wpa_driver_wext_alternative_ifindex||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_alternative_ifindex PROC
;;;2250   
;;;2251   int wpa_driver_wext_alternative_ifindex(struct wpa_driver_wext_data *drv,
000000  4602              MOV      r2,r0
;;;2252   					const char *ifname)
;;;2253   {
;;;2254   	return 0;
000002  2000              MOVS     r0,#0
;;;2255   #if 0
;;;2256   	if (ifname == NULL) {
;;;2257   		drv->ifindex2 = -1;
;;;2258   		return 0;
;;;2259   	}
;;;2260   
;;;2261   	drv->ifindex2 = if_nametoindex(ifname);
;;;2262   	if (drv->ifindex2 <= 0)
;;;2263   		return -1;
;;;2264   
;;;2265   	wpa_printf(MSG_DEBUG, "Added alternative ifindex %d (%s) for "
;;;2266   		   "wireless events", drv->ifindex2, ifname);
;;;2267   
;;;2268   	return 0;
;;;2269   #endif
;;;2270   }
000004  4770              BX       lr
;;;2271   
                          ENDP


                          AREA ||i.wpa_driver_wext_associate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_associate PROC
;;;1975   
;;;1976   int wpa_driver_wext_associate(void *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;1977   			      struct wpa_driver_associate_params *params)
;;;1978   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1979   	RUN_TEST;
000006  4b04              LDR      r3,|L20.24|
000008  4a04              LDR      r2,|L20.28|
00000a  f24071bb          MOV      r1,#0x7bb
00000e  a004              ADR      r0,|L20.32|
000010  f7fffffe          BL       __2printf
;;;1980   	return 0;
000014  2000              MOVS     r0,#0
;;;1981   #if 0
;;;1982   	struct wpa_driver_wext_data *drv = priv;
;;;1983   	int ret = 0;
;;;1984   	int allow_unencrypted_eapol;
;;;1985   	int value;
;;;1986   
;;;1987   	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
;;;1988   
;;;1989   	if (drv->cfg80211) {
;;;1990   		/*
;;;1991   		 * Stop cfg80211 from trying to associate before we are done
;;;1992   		 * with all parameters.
;;;1993   		 */
;;;1994   		wpa_driver_wext_set_ssid(drv, (u8 *) "", 0);
;;;1995   	}
;;;1996   
;;;1997   	if (wpa_driver_wext_set_drop_unencrypted(drv, params->drop_unencrypted)
;;;1998   	    < 0)
;;;1999   		ret = -1;
;;;2000   	if (wpa_driver_wext_set_auth_alg(drv, params->auth_alg) < 0)
;;;2001   		ret = -1;
;;;2002   	if (wpa_driver_wext_set_mode(drv, params->mode) < 0)
;;;2003   		ret = -1;
;;;2004   
;;;2005   	/*
;;;2006   	 * If the driver did not support SIOCSIWAUTH, fallback to
;;;2007   	 * SIOCSIWENCODE here.
;;;2008   	 */
;;;2009   	if (drv->auth_alg_fallback &&
;;;2010   	    wpa_driver_wext_auth_alg_fallback(drv, params) < 0)
;;;2011   		ret = -1;
;;;2012   
;;;2013   	if (!params->bssid &&
;;;2014   	    wpa_driver_wext_set_bssid(drv, NULL) < 0)
;;;2015   		ret = -1;
;;;2016   
;;;2017   	/* TODO: should consider getting wpa version and cipher/key_mgmt suites
;;;2018   	 * from configuration, not from here, where only the selected suite is
;;;2019   	 * available */
;;;2020   	if (wpa_driver_wext_set_gen_ie(drv, params->wpa_ie, params->wpa_ie_len)
;;;2021   	    < 0)
;;;2022   		ret = -1;
;;;2023   	if (params->wpa_ie == NULL || params->wpa_ie_len == 0)
;;;2024   		value = IW_AUTH_WPA_VERSION_DISABLED;
;;;2025   	else if (params->wpa_ie[0] == WLAN_EID_RSN)
;;;2026   		value = IW_AUTH_WPA_VERSION_WPA2;
;;;2027   	else
;;;2028   		value = IW_AUTH_WPA_VERSION_WPA;
;;;2029   	if (wpa_driver_wext_set_auth_param(drv,
;;;2030   					   IW_AUTH_WPA_VERSION, value) < 0)
;;;2031   		ret = -1;
;;;2032   	value = wpa_driver_wext_cipher2wext(params->pairwise_suite);
;;;2033   	if (wpa_driver_wext_set_auth_param(drv,
;;;2034   					   IW_AUTH_CIPHER_PAIRWISE, value) < 0)
;;;2035   		ret = -1;
;;;2036   	value = wpa_driver_wext_cipher2wext(params->group_suite);
;;;2037   	if (wpa_driver_wext_set_auth_param(drv,
;;;2038   					   IW_AUTH_CIPHER_GROUP, value) < 0)
;;;2039   		ret = -1;
;;;2040   	value = wpa_driver_wext_keymgmt2wext(params->key_mgmt_suite);
;;;2041   	if (wpa_driver_wext_set_auth_param(drv,
;;;2042   					   IW_AUTH_KEY_MGMT, value) < 0)
;;;2043   		ret = -1;
;;;2044   	value = params->key_mgmt_suite != KEY_MGMT_NONE ||
;;;2045   		params->pairwise_suite != CIPHER_NONE ||
;;;2046   		params->group_suite != CIPHER_NONE ||
;;;2047   		params->wpa_ie_len;
;;;2048   	if (wpa_driver_wext_set_auth_param(drv,
;;;2049   					   IW_AUTH_PRIVACY_INVOKED, value) < 0)
;;;2050   		ret = -1;
;;;2051   
;;;2052   	/* Allow unencrypted EAPOL messages even if pairwise keys are set when
;;;2053   	 * not using WPA. IEEE 802.1X specifies that these frames are not
;;;2054   	 * encrypted, but WPA encrypts them when pairwise keys are in use. */
;;;2055   	if (params->key_mgmt_suite == KEY_MGMT_802_1X ||
;;;2056   	    params->key_mgmt_suite == KEY_MGMT_PSK)
;;;2057   		allow_unencrypted_eapol = 0;
;;;2058   	else
;;;2059   		allow_unencrypted_eapol = 1;
;;;2060   
;;;2061   	if (wpa_driver_wext_set_psk(drv, params->psk) < 0)
;;;2062   		ret = -1;
;;;2063   	if (wpa_driver_wext_set_auth_param(drv,
;;;2064   					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
;;;2065   					   allow_unencrypted_eapol) < 0)
;;;2066   		ret = -1;
;;;2067   #ifdef CONFIG_IEEE80211W
;;;2068   	switch (params->mgmt_frame_protection) {
;;;2069   	case NO_MGMT_FRAME_PROTECTION:
;;;2070   		value = IW_AUTH_MFP_DISABLED;
;;;2071   		break;
;;;2072   	case MGMT_FRAME_PROTECTION_OPTIONAL:
;;;2073   		value = IW_AUTH_MFP_OPTIONAL;
;;;2074   		break;
;;;2075   	case MGMT_FRAME_PROTECTION_REQUIRED:
;;;2076   		value = IW_AUTH_MFP_REQUIRED;
;;;2077   		break;
;;;2078   	};
;;;2079   	if (wpa_driver_wext_set_auth_param(drv, IW_AUTH_MFP, value) < 0)
;;;2080   		ret = -1;
;;;2081   #endif /* CONFIG_IEEE80211W */
;;;2082   	if (params->freq && wpa_driver_wext_set_freq(drv, params->freq) < 0)
;;;2083   		ret = -1;
;;;2084   	if (!drv->cfg80211 &&
;;;2085   	    wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
;;;2086   		ret = -1;
;;;2087   	if (params->bssid &&
;;;2088   	    wpa_driver_wext_set_bssid(drv, params->bssid) < 0)
;;;2089   		ret = -1;
;;;2090   	if (drv->cfg80211 &&
;;;2091   	    wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
;;;2092   		ret = -1;
;;;2093   
;;;2094   	return ret;
;;;2095   #endif
;;;2096   }
000016  bd70              POP      {r4-r6,pc}
;;;2097   
                          ENDP

                  |L20.24|
                          DCD      ||.constdata||+0x348
                  |L20.28|
                          DCD      |symbol_number.229|
                  |L20.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_auth_alg_fallback||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_auth_alg_fallback PROC
;;;1929   static int
;;;1930   wpa_driver_wext_auth_alg_fallback(struct wpa_driver_wext_data *drv,
000000  4602              MOV      r2,r0
;;;1931   				  struct wpa_driver_associate_params *params)
;;;1932   {
;;;1933   	return 0;
000002  2000              MOVS     r0,#0
;;;1934   #if 0
;;;1935   	struct iwreq iwr;
;;;1936   	int ret = 0;
;;;1937   
;;;1938   	wpa_printf(MSG_DEBUG, "WEXT: Driver did not support "
;;;1939   		   "SIOCSIWAUTH for AUTH_ALG, trying SIOCSIWENCODE");
;;;1940   
;;;1941   	os_memset(&iwr, 0, sizeof(iwr));
;;;1942   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1943   	/* Just changing mode, not actual keys */
;;;1944   	iwr.u.encoding.flags = 0;
;;;1945   	iwr.u.encoding.pointer = (caddr_t) NULL;
;;;1946   	iwr.u.encoding.length = 0;
;;;1947   
;;;1948   	/*
;;;1949   	 * Note: IW_ENCODE_{OPEN,RESTRICTED} can be interpreted to mean two
;;;1950   	 * different things. Here they are used to indicate Open System vs.
;;;1951   	 * Shared Key authentication algorithm. However, some drivers may use
;;;1952   	 * them to select between open/restricted WEP encrypted (open = allow
;;;1953   	 * both unencrypted and encrypted frames; restricted = only allow
;;;1954   	 * encrypted frames).
;;;1955   	 */
;;;1956   
;;;1957   	if (!drv->use_crypt) {
;;;1958   		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
;;;1959   	} else {
;;;1960   		if (params->auth_alg & WPA_AUTH_ALG_OPEN)
;;;1961   			iwr.u.encoding.flags |= IW_ENCODE_OPEN;
;;;1962   		if (params->auth_alg & WPA_AUTH_ALG_SHARED)
;;;1963   			iwr.u.encoding.flags |= IW_ENCODE_RESTRICTED;
;;;1964   	}
;;;1965   
;;;1966   	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
;;;1967   		perror("ioctl[SIOCSIWENCODE]");
;;;1968   		ret = -1;
;;;1969   	}
;;;1970   
;;;1971   	return ret;
;;;1972   #endif
;;;1973   }
000004  4770              BX       lr
;;;1974   
                          ENDP


                          AREA ||i.wpa_driver_wext_cipher2wext||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_cipher2wext PROC
;;;1895   
;;;1896   int wpa_driver_wext_cipher2wext(int cipher)
000000  4601              MOV      r1,r0
;;;1897   {
;;;1898   	switch (cipher) {
000002  2905              CMP      r1,#5
000004  d20e              BCS      |L22.36|
000006  e8dff001          TBB      [pc,r1]
00000a  0305              DCB      0x03,0x05
00000c  07090b00          DCB      0x07,0x09,0x0b,0x00
;;;1899   	case CIPHER_NONE:
;;;1900   		return IW_AUTH_CIPHER_NONE;
000010  2001              MOVS     r0,#1
                  |L22.18|
;;;1901   	case CIPHER_WEP40:
;;;1902   		return IW_AUTH_CIPHER_WEP40;
;;;1903   	case CIPHER_TKIP:
;;;1904   		return IW_AUTH_CIPHER_TKIP;
;;;1905   	case CIPHER_CCMP:
;;;1906   		return IW_AUTH_CIPHER_CCMP;
;;;1907   	case CIPHER_WEP104:
;;;1908   		return IW_AUTH_CIPHER_WEP104;
;;;1909   	default:
;;;1910   		return 0;
;;;1911   	}
;;;1912   }
000012  4770              BX       lr
000014  2002              MOVS     r0,#2                 ;1902
000016  e7fc              B        |L22.18|
000018  2004              MOVS     r0,#4                 ;1904
00001a  e7fa              B        |L22.18|
00001c  2008              MOVS     r0,#8                 ;1906
00001e  e7f8              B        |L22.18|
000020  2010              MOVS     r0,#0x10              ;1908
000022  e7f6              B        |L22.18|
                  |L22.36|
000024  2000              MOVS     r0,#0                 ;1910
000026  e7f4              B        |L22.18|
;;;1913   
                          ENDP


                          AREA ||i.wpa_driver_wext_deauthenticate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_deauthenticate PROC
;;;1839   
;;;1840   static int wpa_driver_wext_deauthenticate(void *priv, const u8 *addr,
000000  b570              PUSH     {r4-r6,lr}
;;;1841   					  int reason_code)
;;;1842   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1843   	RUN_TEST;
000008  4b04              LDR      r3,|L23.28|
00000a  4a05              LDR      r2,|L23.32|
00000c  f2407133          MOV      r1,#0x733
000010  a004              ADR      r0,|L23.36|
000012  f7fffffe          BL       __2printf
;;;1844   	return 0;
000016  2000              MOVS     r0,#0
;;;1845   	#if 0
;;;1846   	struct wpa_driver_wext_data *drv = priv;
;;;1847   	int ret;
;;;1848   	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
;;;1849   	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
;;;1850   	wpa_driver_wext_disconnect(drv);
;;;1851   	return ret;
;;;1852   	#endif
;;;1853   }
000018  bd70              POP      {r4-r6,pc}
;;;1854   
                          ENDP

00001a  0000              DCW      0x0000
                  |L23.28|
                          DCD      ||.constdata||+0x348
                  |L23.32|
                          DCD      |symbol_number.227|
                  |L23.36|
000024  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000028  54455354
00002c  203e3e3e
000030  204c494e
000034  453a2564
000038  202c2c2c
00003c  2046554e
000040  4354494f
000044  4e3a2573
000048  202c2c2c
00004c  2046494c
000050  453a2573
000054  200d0a00

                          AREA ||i.wpa_driver_wext_deinit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_deinit PROC
;;;856     */
;;;857    void wpa_driver_wext_deinit(void *priv)
000000  b510              PUSH     {r4,lr}
;;;858    {
000002  4604              MOV      r4,r0
;;;859    	RUN_TEST;
000004  4b03              LDR      r3,|L24.20|
000006  4a04              LDR      r2,|L24.24|
000008  f240315b          MOV      r1,#0x35b
00000c  a003              ADR      r0,|L24.28|
00000e  f7fffffe          BL       __2printf
;;;860    
;;;861    #if 0
;;;862    	struct wpa_driver_wext_data *drv = priv;
;;;863    
;;;864    	wpa_driver_wext_set_auth_param(drv, IW_AUTH_WPA_ENABLED, 0);
;;;865    
;;;866    	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
;;;867    
;;;868    	/*
;;;869    	 * Clear possibly configured driver parameters in order to make it
;;;870    	 * easier to use the driver after wpa_supplicant has been terminated.
;;;871    	 */
;;;872    	wpa_driver_wext_disconnect(drv);
;;;873    
;;;874    	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
;;;875    	netlink_deinit(drv->netlink);
;;;876    
;;;877    	if (drv->mlme_sock >= 0)
;;;878    		eloop_unregister_read_sock(drv->mlme_sock);
;;;879    
;;;880    	(void) linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0);
;;;881    
;;;882    	close(drv->ioctl_sock);
;;;883    	if (drv->mlme_sock >= 0)
;;;884    		close(drv->mlme_sock);
;;;885    	os_free(drv->assoc_req_ies);
;;;886    	os_free(drv->assoc_resp_ies);
;;;887    	os_free(drv);
;;;888    #endif
;;;889    }
000012  bd10              POP      {r4,pc}
;;;890    
                          ENDP

                  |L24.20|
                          DCD      ||.constdata||+0x348
                  |L24.24|
                          DCD      |symbol_number.221|
                  |L24.28|
00001c  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000020  54455354
000024  203e3e3e
000028  204c494e
00002c  453a2564
000030  202c2c2c
000034  2046554e
000038  4354494f
00003c  4e3a2573
000040  202c2c2c
000044  2046494c
000048  453a2573
00004c  200d0a00

                          AREA ||i.wpa_driver_wext_disassociate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_disassociate PROC
;;;1855   
;;;1856   static int wpa_driver_wext_disassociate(void *priv, const u8 *addr,
000000  b570              PUSH     {r4-r6,lr}
;;;1857   					int reason_code)
;;;1858   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1859   	RUN_TEST;
000008  4b04              LDR      r3,|L25.28|
00000a  4a05              LDR      r2,|L25.32|
00000c  f2407143          MOV      r1,#0x743
000010  a004              ADR      r0,|L25.36|
000012  f7fffffe          BL       __2printf
;;;1860   	return 0;
000016  2000              MOVS     r0,#0
;;;1861   	#if 0
;;;1862   	struct wpa_driver_wext_data *drv = priv;
;;;1863   	int ret;
;;;1864   	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
;;;1865   	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DISASSOC, reason_code);
;;;1866   	wpa_driver_wext_disconnect(drv);
;;;1867   	return ret;
;;;1868   	#endif
;;;1869   }
000018  bd70              POP      {r4-r6,pc}
;;;1870   
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      ||.constdata||+0x348
                  |L25.32|
                          DCD      |symbol_number.228|
                  |L25.36|
000024  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000028  54455354
00002c  203e3e3e
000030  204c494e
000034  453a2564
000038  202c2c2c
00003c  2046554e
000040  4354494f
000044  4e3a2573
000048  202c2c2c
00004c  2046494c
000050  453a2573
000054  200d0a00

                          AREA ||i.wpa_driver_wext_disconnect||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_disconnect PROC
;;;1786   
;;;1787   static void wpa_driver_wext_disconnect(struct wpa_driver_wext_data *drv)
000000  4770              BX       lr
;;;1788   {
;;;1789   
;;;1790   #if 0
;;;1791   	struct iwreq iwr;
;;;1792   	const u8 null_bssid[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
;;;1793   	u8 ssid[32];
;;;1794   	int i;
;;;1795   
;;;1796   	/*
;;;1797   	 * Only force-disconnect when the card is in infrastructure mode,
;;;1798   	 * otherwise the driver might interpret the cleared BSSID and random
;;;1799   	 * SSID as an attempt to create a new ad-hoc network.
;;;1800   	 */
;;;1801   	os_memset(&iwr, 0, sizeof(iwr));
;;;1802   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1803   	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
;;;1804   		perror("ioctl[SIOCGIWMODE]");
;;;1805   		iwr.u.mode = IW_MODE_INFRA;
;;;1806   	}
;;;1807   
;;;1808   	if (iwr.u.mode == IW_MODE_INFRA) {
;;;1809   		if (drv->cfg80211) {
;;;1810   			/*
;;;1811   			 * cfg80211 supports SIOCSIWMLME commands, so there is
;;;1812   			 * no need for the random SSID hack, but clear the
;;;1813   			 * BSSID and SSID.
;;;1814   			 */
;;;1815   			if (wpa_driver_wext_set_bssid(drv, null_bssid) < 0 ||
;;;1816   			    wpa_driver_wext_set_ssid(drv, (u8 *) "", 0) < 0) {
;;;1817   				wpa_printf(MSG_DEBUG, "WEXT: Failed to clear "
;;;1818   					   "to disconnect");
;;;1819   			}
;;;1820   			return;
;;;1821   		}
;;;1822   		/*
;;;1823   		 * Clear the BSSID selection and set a random SSID to make sure
;;;1824   		 * the driver will not be trying to associate with something
;;;1825   		 * even if it does not understand SIOCSIWMLME commands (or
;;;1826   		 * tries to associate automatically after deauth/disassoc).
;;;1827   		 */
;;;1828   		for (i = 0; i < 32; i++)
;;;1829   			ssid[i] = rand() & 0xFF;
;;;1830   		if (wpa_driver_wext_set_bssid(drv, null_bssid) < 0 ||
;;;1831   		    wpa_driver_wext_set_ssid(drv, ssid, 32) < 0) {
;;;1832   			wpa_printf(MSG_DEBUG, "WEXT: Failed to set bogus "
;;;1833   				   "BSSID/SSID to disconnect");
;;;1834   		}
;;;1835   	}
;;;1836   #endif
;;;1837   }
;;;1838   
                          ENDP


                          AREA ||i.wpa_driver_wext_event_assoc_ies||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_event_assoc_ies PROC
;;;425    
;;;426    static void wpa_driver_wext_event_assoc_ies(struct wpa_driver_wext_data *drv)
000000  b510              PUSH     {r4,lr}
;;;427    {
000002  b09a              SUB      sp,sp,#0x68
000004  4604              MOV      r4,r0
;;;428    	union wpa_event_data data;
;;;429    
;;;430    	if (drv->assoc_req_ies == NULL && drv->assoc_resp_ies == NULL)
000006  6c20              LDR      r0,[r4,#0x40]
000008  b918              CBNZ     r0,|L27.18|
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  b908              CBNZ     r0,|L27.18|
                  |L27.14|
;;;431    		return;
;;;432    
;;;433    	os_memset(&data, 0, sizeof(data));
;;;434    	if (drv->assoc_req_ies) {
;;;435    		data.assoc_info.req_ies = drv->assoc_req_ies;
;;;436    		data.assoc_info.req_ies_len = drv->assoc_req_ies_len;
;;;437    	}
;;;438    	if (drv->assoc_resp_ies) {
;;;439    		data.assoc_info.resp_ies = drv->assoc_resp_ies;
;;;440    		data.assoc_info.resp_ies_len = drv->assoc_resp_ies_len;
;;;441    	}
;;;442    
;;;443    	wpa_supplicant_event(drv->ctx, EVENT_ASSOCINFO, &data);
;;;444    
;;;445    	os_free(drv->assoc_req_ies);
;;;446    	drv->assoc_req_ies = NULL;
;;;447    	os_free(drv->assoc_resp_ies);
;;;448    	drv->assoc_resp_ies = NULL;
;;;449    }
00000e  b01a              ADD      sp,sp,#0x68
000010  bd10              POP      {r4,pc}
                  |L27.18|
000012  2168              MOVS     r1,#0x68              ;433
000014  4668              MOV      r0,sp                 ;433
000016  f7fffffe          BL       __aeabi_memclr4
00001a  6c20              LDR      r0,[r4,#0x40]         ;434
00001c  b118              CBZ      r0,|L27.38|
00001e  6c20              LDR      r0,[r4,#0x40]         ;435
000020  9000              STR      r0,[sp,#0]            ;435
000022  6c60              LDR      r0,[r4,#0x44]         ;436
000024  9001              STR      r0,[sp,#4]            ;436
                  |L27.38|
000026  6ca0              LDR      r0,[r4,#0x48]         ;438
000028  b118              CBZ      r0,|L27.50|
00002a  6ca0              LDR      r0,[r4,#0x48]         ;439
00002c  9002              STR      r0,[sp,#8]            ;439
00002e  6ce0              LDR      r0,[r4,#0x4c]         ;440
000030  9003              STR      r0,[sp,#0xc]          ;440
                  |L27.50|
000032  466a              MOV      r2,sp                 ;443
000034  2104              MOVS     r1,#4                 ;443
000036  6820              LDR      r0,[r4,#0]            ;443
000038  f7fffffe          BL       wpa_supplicant_event
00003c  6c20              LDR      r0,[r4,#0x40]         ;445
00003e  f7fffffe          BL       os_free
000042  2000              MOVS     r0,#0                 ;446
000044  6420              STR      r0,[r4,#0x40]         ;446
000046  6ca0              LDR      r0,[r4,#0x48]         ;447
000048  f7fffffe          BL       os_free
00004c  2000              MOVS     r0,#0                 ;448
00004e  64a0              STR      r0,[r4,#0x48]         ;448
000050  bf00              NOP      
000052  e7dc              B        |L27.14|
;;;450    
                          ENDP


                          AREA ||i.wpa_driver_wext_event_link||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_link PROC
;;;573    
;;;574    static void wpa_driver_wext_event_link(struct wpa_driver_wext_data *drv,
000000  b5f0              PUSH     {r4-r7,lr}
;;;575    				       char *buf, size_t len, int del)
;;;576    {
000002  b09b              SUB      sp,sp,#0x6c
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;577    	union wpa_event_data event;
;;;578    
;;;579    	os_memset(&event, 0, sizeof(event));
00000c  2168              MOVS     r1,#0x68
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memclr4
;;;580    	if (len > sizeof(event.interface_status.ifname))
000014  2e64              CMP      r6,#0x64
000016  d900              BLS      |L28.26|
;;;581    		len = sizeof(event.interface_status.ifname) - 1;
000018  2663              MOVS     r6,#0x63
                  |L28.26|
;;;582    	os_memcpy(event.interface_status.ifname, buf, len);
00001a  4632              MOV      r2,r6
00001c  4639              MOV      r1,r7
00001e  a801              ADD      r0,sp,#4
000020  f7fffffe          BL       __aeabi_memcpy
;;;583    	event.interface_status.ievent = del ? EVENT_INTERFACE_REMOVED :
000024  b10d              CBZ      r5,|L28.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L28.44|
                  |L28.42|
;;;584    		EVENT_INTERFACE_ADDED;
00002a  2000              MOVS     r0,#0
                  |L28.44|
00002c  b2c0              UXTB     r0,r0
00002e  f88d0068          STRB     r0,[sp,#0x68]
;;;585    
;;;586    	wpa_printf(MSG_DEBUG, "RTM_%sLINK, IFLA_IFNAME: Interface '%s' %s",
000032  b10d              CBZ      r5,|L28.56|
;;;587    		   del ? "DEL" : "NEW",
;;;588    		   event.interface_status.ifname,
;;;589    		   del ? "removed" : "added");
000034  a310              ADR      r3,|L28.120|
000036  e000              B        |L28.58|
                  |L28.56|
000038  a311              ADR      r3,|L28.128|
                  |L28.58|
00003a  9300              STR      r3,[sp,#0]
00003c  b10d              CBZ      r5,|L28.66|
00003e  a012              ADR      r0,|L28.136|
000040  e000              B        |L28.68|
                  |L28.66|
000042  a012              ADR      r0,|L28.140|
                  |L28.68|
000044  4602              MOV      r2,r0                 ;587
000046  ab01              ADD      r3,sp,#4              ;587
000048  a111              ADR      r1,|L28.144|
00004a  2000              MOVS     r0,#0                 ;587
00004c  f7fffffe          BL       wpa_printf
;;;590    
;;;591    	if (os_strcmp(drv->ifname, event.interface_status.ifname) == 0) {
000050  a901              ADD      r1,sp,#4
000052  f1040010          ADD      r0,r4,#0x10
000056  f7fffffe          BL       os_strcmp
00005a  b928              CBNZ     r0,|L28.104|
;;;592    		if (del)
00005c  b115              CBZ      r5,|L28.100|
;;;593    			drv->if_removed = 1;
00005e  2001              MOVS     r0,#1
000060  63e0              STR      r0,[r4,#0x3c]
000062  e001              B        |L28.104|
                  |L28.100|
;;;594    		else
;;;595    			drv->if_removed = 0;
000064  2000              MOVS     r0,#0
000066  63e0              STR      r0,[r4,#0x3c]
                  |L28.104|
;;;596    	}
;;;597    
;;;598    	wpa_supplicant_event(drv->ctx, EVENT_INTERFACE_STATUS, &event);
000068  aa01              ADD      r2,sp,#4
00006a  2105              MOVS     r1,#5
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       wpa_supplicant_event
;;;599    }
000072  b01b              ADD      sp,sp,#0x6c
000074  bdf0              POP      {r4-r7,pc}
;;;600    
                          ENDP

000076  0000              DCW      0x0000
                  |L28.120|
000078  72656d6f          DCB      "removed",0
00007c  76656400
                  |L28.128|
000080  61646465          DCB      "added",0
000084  6400    
000086  00                DCB      0
000087  00                DCB      0
                  |L28.136|
000088  44454c00          DCB      "DEL",0
                  |L28.140|
00008c  4e455700          DCB      "NEW",0
                  |L28.144|
000090  52544d5f          DCB      "RTM_%sLINK, IFLA_IFNAME: Interface '%s' %s",0
000094  25734c49
000098  4e4b2c20
00009c  49464c41
0000a0  5f49464e
0000a4  414d453a
0000a8  20496e74
0000ac  65726661
0000b0  63652027
0000b4  25732720
0000b8  257300  
0000bb  00                DCB      0

                          AREA ||i.wpa_driver_wext_event_rtm_dellink||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_event_rtm_dellink PROC
;;;701    
;;;702    static void wpa_driver_wext_event_rtm_dellink(void *ctx, struct ifinfomsg *ifi,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;703    					      u8 *buf, size_t len)
;;;704    {
000004  4606              MOV      r6,r0
000006  468b              MOV      r11,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;705    	struct wpa_driver_wext_data *drv = ctx;
00000c  46b2              MOV      r10,r6
;;;706    	int attrlen, rta_len;
;;;707    	struct rtattr *attr;
;;;708    
;;;709    	attrlen = len;
00000e  4645              MOV      r5,r8
;;;710    	attr = (struct rtattr *) buf;
000010  463c              MOV      r4,r7
;;;711    
;;;712    	rta_len = RTA_ALIGN(sizeof(struct rtattr));
000012  f04f0904          MOV      r9,#4
;;;713    	while (RTA_OK(attr, attrlen)) {
000016  e015              B        |L29.68|
                  |L29.24|
;;;714    		if (attr->rta_type == IFLA_IFNAME) {
000018  8860              LDRH     r0,[r4,#2]
00001a  2803              CMP      r0,#3
00001c  d108              BNE      |L29.48|
;;;715    			wpa_driver_wext_event_link(drv,
00001e  8820              LDRH     r0,[r4,#0]
000020  eba00209          SUB      r2,r0,r9
000024  eb040109          ADD      r1,r4,r9
000028  2301              MOVS     r3,#1
00002a  4650              MOV      r0,r10
00002c  f7fffffe          BL       wpa_driver_wext_event_link
                  |L29.48|
;;;716    						   ((char *) attr) + rta_len,
;;;717    						   attr->rta_len - rta_len, 1);
;;;718    		}
;;;719    		attr = RTA_NEXT(attr, attrlen);
000030  8820              LDRH     r0,[r4,#0]
000032  1cc0              ADDS     r0,r0,#3
000034  f0200003          BIC      r0,r0,#3
000038  1a2d              SUBS     r5,r5,r0
00003a  8820              LDRH     r0,[r4,#0]
00003c  1cc0              ADDS     r0,r0,#3
00003e  f0200003          BIC      r0,r0,#3
000042  4404              ADD      r4,r4,r0
                  |L29.68|
000044  2d00              CMP      r5,#0                 ;713
000046  dd05              BLE      |L29.84|
000048  8820              LDRH     r0,[r4,#0]            ;713
00004a  2804              CMP      r0,#4                 ;713
00004c  d302              BCC      |L29.84|
00004e  8820              LDRH     r0,[r4,#0]            ;713
000050  42a8              CMP      r0,r5                 ;713
000052  dde1              BLE      |L29.24|
                  |L29.84|
;;;720    	}
;;;721    }
000054  e8bd9ff0          POP      {r4-r12,pc}
;;;722    
                          ENDP


                          AREA ||i.wpa_driver_wext_event_rtm_newlink||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_event_rtm_newlink PROC
;;;647    
;;;648    static void wpa_driver_wext_event_rtm_newlink(void *ctx, struct ifinfomsg *ifi,
000000  4770              BX       lr
;;;649    					      u8 *buf, size_t len)
;;;650    {
;;;651    
;;;652    #if 0
;;;653    	struct wpa_driver_wext_data *drv = ctx;
;;;654    	int attrlen, rta_len;
;;;655    	struct rtattr *attr;
;;;656    
;;;657    	if (!wpa_driver_wext_own_ifindex(drv, ifi->ifi_index, buf, len)) {
;;;658    		wpa_printf(MSG_DEBUG, "Ignore event for foreign ifindex %d",
;;;659    			   ifi->ifi_index);
;;;660    		return;
;;;661    	}
;;;662    
;;;663    	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
;;;664    		   "(%s%s%s%s)",
;;;665    		   drv->operstate, ifi->ifi_flags,
;;;666    		   (ifi->ifi_flags & IFF_UP) ? "[UP]" : "",
;;;667    		   (ifi->ifi_flags & IFF_RUNNING) ? "[RUNNING]" : "",
;;;668    		   (ifi->ifi_flags & IFF_LOWER_UP) ? "[LOWER_UP]" : "",
;;;669    		   (ifi->ifi_flags & IFF_DORMANT) ? "[DORMANT]" : "");
;;;670    	/*
;;;671    	 * Some drivers send the association event before the operup event--in
;;;672    	 * this case, lifting operstate in wpa_driver_wext_set_operstate()
;;;673    	 * fails. This will hit us when wpa_supplicant does not need to do
;;;674    	 * IEEE 802.1X authentication
;;;675    	 */
;;;676    	if (drv->operstate == 1 &&
;;;677    	    (ifi->ifi_flags & (IFF_LOWER_UP | IFF_DORMANT)) == IFF_LOWER_UP &&
;;;678    	    !(ifi->ifi_flags & IFF_RUNNING))
;;;679    		netlink_send_oper_ifla(drv->netlink, drv->ifindex,
;;;680    				       -1, IF_OPER_UP);
;;;681    
;;;682    	attrlen = len;
;;;683    	attr = (struct rtattr *) buf;
;;;684    
;;;685    	rta_len = RTA_ALIGN(sizeof(struct rtattr));
;;;686    	while (RTA_OK(attr, attrlen)) {
;;;687    		if (attr->rta_type == IFLA_WIRELESS) {
;;;688    			wpa_driver_wext_event_wireless(
;;;689    				drv, ((char *) attr) + rta_len,
;;;690    				attr->rta_len - rta_len);
;;;691    		} else if (attr->rta_type == IFLA_IFNAME) {
;;;692    			wpa_driver_wext_event_link(drv,
;;;693    						   ((char *) attr) + rta_len,
;;;694    						   attr->rta_len - rta_len, 0);
;;;695    		}
;;;696    		attr = RTA_NEXT(attr, attrlen);
;;;697    	}
;;;698    #endif
;;;699    }
;;;700    
                          ENDP


                          AREA ||i.wpa_driver_wext_event_wireless||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_wireless PROC
;;;451    
;;;452    static void wpa_driver_wext_event_wireless(struct wpa_driver_wext_data *drv,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;453    					   char *data, int len)
;;;454    {
000004  b08a              SUB      sp,sp,#0x28
000006  4605              MOV      r5,r0
000008  468a              MOV      r10,r1
;;;455    	struct iw_event iwe_buf, *iwe = &iwe_buf;
00000a  ac05              ADD      r4,sp,#0x14
;;;456    	char *pos, *end, *custom, *buf;
;;;457    
;;;458    	pos = data;
00000c  4656              MOV      r6,r10
;;;459    	end = data + len;
00000e  980c              LDR      r0,[sp,#0x30]
000010  eb0a0800          ADD      r8,r10,r0
;;;460    
;;;461    	while (pos + IW_EV_LCP_LEN <= end) {
000014  e0fa              B        |L31.524|
                  |L31.22|
;;;462    		/* Event data may be unaligned, so make a local, aligned copy
;;;463    		 * before processing. */
;;;464    		os_memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
000016  6830              LDR      r0,[r6,#0]
000018  9005              STR      r0,[sp,#0x14]
;;;465    		wpa_printf(MSG_DEBUG, "Wireless event: cmd=0x%x len=%d",
00001a  8823              LDRH     r3,[r4,#0]
00001c  8862              LDRH     r2,[r4,#2]
00001e  a17e              ADR      r1,|L31.536|
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       wpa_printf
;;;466    			   iwe->cmd, iwe->len);
;;;467    		if (iwe->len <= IW_EV_LCP_LEN)
000026  8820              LDRH     r0,[r4,#0]
000028  2804              CMP      r0,#4
00002a  d802              BHI      |L31.50|
                  |L31.44|
;;;468    			return;
;;;469    
;;;470    		custom = pos + IW_EV_POINT_LEN;
;;;471    		if (drv->we_version_compiled > 18 &&
;;;472    		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
;;;473    		     iwe->cmd == IWEVCUSTOM ||
;;;474    		     iwe->cmd == IWEVASSOCREQIE ||
;;;475    		     iwe->cmd == IWEVASSOCRESPIE ||
;;;476    		     iwe->cmd == IWEVPMKIDCAND)) {
;;;477    			/* WE-19 removed the pointer from struct iw_point */
;;;478    			char *dpos = (char *) &iwe_buf.u.data.length;
;;;479    			int dlen = dpos - (char *) &iwe_buf;
;;;480    			os_memcpy(dpos, pos + IW_EV_LCP_LEN,
;;;481    				  sizeof(struct iw_event) - dlen);
;;;482    		} else {
;;;483    			os_memcpy(&iwe_buf, pos, sizeof(struct iw_event));
;;;484    			custom += IW_EV_POINT_OFF;
;;;485    		}
;;;486    
;;;487    		switch (iwe->cmd) {
;;;488    		case SIOCGIWAP:
;;;489    			wpa_printf(MSG_DEBUG, "Wireless event: new AP: "
;;;490    				   MACSTR,
;;;491    				   MAC2STR((u8 *) iwe->u.ap_addr.sa_data));
;;;492    			if (is_zero_ether_addr(
;;;493    				    (const u8 *) iwe->u.ap_addr.sa_data) ||
;;;494    			    os_memcmp(iwe->u.ap_addr.sa_data,
;;;495    				      "\x44\x44\x44\x44\x44\x44", ETH_ALEN) ==
;;;496    			    0) {
;;;497    				os_free(drv->assoc_req_ies);
;;;498    				drv->assoc_req_ies = NULL;
;;;499    				os_free(drv->assoc_resp_ies);
;;;500    				drv->assoc_resp_ies = NULL;
;;;501    				wpa_supplicant_event(drv->ctx, EVENT_DISASSOC,
;;;502    						     NULL);
;;;503    			
;;;504    			} else {
;;;505    				wpa_driver_wext_event_assoc_ies(drv);
;;;506    				wpa_supplicant_event(drv->ctx, EVENT_ASSOC,
;;;507    						     NULL);
;;;508    			}
;;;509    			break;
;;;510    		case IWEVMICHAELMICFAILURE:
;;;511    			if (custom + iwe->u.data.length > end) {
;;;512    				wpa_printf(MSG_DEBUG, "WEXT: Invalid "
;;;513    					   "IWEVMICHAELMICFAILURE length");
;;;514    				return;
;;;515    			}
;;;516    			wpa_driver_wext_event_wireless_michaelmicfailure(
;;;517    				drv->ctx, custom, iwe->u.data.length);
;;;518    			break;
;;;519    		case IWEVCUSTOM:
;;;520    			if (custom + iwe->u.data.length > end) {
;;;521    				wpa_printf(MSG_DEBUG, "WEXT: Invalid "
;;;522    					   "IWEVCUSTOM length");
;;;523    				return;
;;;524    			}
;;;525    			buf = os_malloc(iwe->u.data.length + 1);
;;;526    			if (buf == NULL)
;;;527    				return;
;;;528    			os_memcpy(buf, custom, iwe->u.data.length);
;;;529    			buf[iwe->u.data.length] = '\0';
;;;530    			wpa_driver_wext_event_wireless_custom(drv->ctx, buf);
;;;531    			os_free(buf);
;;;532    			break;
;;;533    		case SIOCGIWSCAN:
;;;534    			drv->scan_complete_events = 1;
;;;535    			eloop_cancel_timeout(wpa_driver_wext_scan_timeout,
;;;536    					     drv, drv->ctx);
;;;537    			wpa_supplicant_event(drv->ctx, EVENT_SCAN_RESULTS,
;;;538    					     NULL);
;;;539    			break;
;;;540    		case IWEVASSOCREQIE:
;;;541    			if (custom + iwe->u.data.length > end) {
;;;542    				wpa_printf(MSG_DEBUG, "WEXT: Invalid "
;;;543    					   "IWEVASSOCREQIE length");
;;;544    				return;
;;;545    			}
;;;546    			wpa_driver_wext_event_wireless_assocreqie(
;;;547    				drv, custom, iwe->u.data.length);
;;;548    			break;
;;;549    		case IWEVASSOCRESPIE:
;;;550    			if (custom + iwe->u.data.length > end) {
;;;551    				wpa_printf(MSG_DEBUG, "WEXT: Invalid "
;;;552    					   "IWEVASSOCRESPIE length");
;;;553    				return;
;;;554    			}
;;;555    			wpa_driver_wext_event_wireless_assocrespie(
;;;556    				drv, custom, iwe->u.data.length);
;;;557    			break;
;;;558    		case IWEVPMKIDCAND:
;;;559    			if (custom + iwe->u.data.length > end) {
;;;560    				wpa_printf(MSG_DEBUG, "WEXT: Invalid "
;;;561    					   "IWEVPMKIDCAND length");
;;;562    				return;
;;;563    			}
;;;564    			wpa_driver_wext_event_wireless_pmkidcand(
;;;565    				drv, custom, iwe->u.data.length);
;;;566    			break;
;;;567    		}
;;;568    
;;;569    		pos += iwe->len;
;;;570    	}
;;;571    }
00002c  b00d              ADD      sp,sp,#0x34
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L31.50|
000032  2004              MOVS     r0,#4                 ;470
000034  f1c0000c          RSB      r0,r0,#0xc            ;470
000038  1987              ADDS     r7,r0,r6              ;470
00003a  6ee8              LDR      r0,[r5,#0x6c]         ;471
00003c  2812              CMP      r0,#0x12              ;471
00003e  dd26              BLE      |L31.142|
000040  8860              LDRH     r0,[r4,#2]            ;472
000042  f5a0410c          SUB      r1,r0,#0x8c00         ;472
000046  3906              SUBS     r1,#6                 ;472
000048  d013              BEQ      |L31.114|
00004a  8860              LDRH     r0,[r4,#2]            ;473
00004c  f5a0410c          SUB      r1,r0,#0x8c00         ;473
000050  3902              SUBS     r1,#2                 ;473
000052  d00e              BEQ      |L31.114|
000054  8860              LDRH     r0,[r4,#2]            ;474
000056  f5a0410c          SUB      r1,r0,#0x8c00         ;474
00005a  3907              SUBS     r1,#7                 ;474
00005c  d009              BEQ      |L31.114|
00005e  8860              LDRH     r0,[r4,#2]            ;475
000060  f5a0410c          SUB      r1,r0,#0x8c00         ;475
000064  3908              SUBS     r1,r1,#8              ;475
000066  d004              BEQ      |L31.114|
000068  8860              LDRH     r0,[r4,#2]            ;476
00006a  f5a0410c          SUB      r1,r0,#0x8c00         ;476
00006e  3909              SUBS     r1,r1,#9              ;476
000070  d10d              BNE      |L31.142|
                  |L31.114|
000072  f10d0b1c          ADD      r11,sp,#0x1c          ;478
000076  a805              ADD      r0,sp,#0x14           ;479
000078  ebab0000          SUB      r0,r11,r0             ;479
00007c  9004              STR      r0,[sp,#0x10]         ;479
00007e  9804              LDR      r0,[sp,#0x10]         ;480
000080  f1c00214          RSB      r2,r0,#0x14           ;480
000084  1d31              ADDS     r1,r6,#4              ;480
000086  4658              MOV      r0,r11                ;480
000088  f7fffffe          BL       __aeabi_memcpy
00008c  e006              B        |L31.156|
                  |L31.142|
00008e  2214              MOVS     r2,#0x14              ;483
000090  4631              MOV      r1,r6                 ;483
000092  a805              ADD      r0,sp,#0x14           ;483
000094  f7fffffe          BL       __aeabi_memcpy
000098  2004              MOVS     r0,#4                 ;484
00009a  4407              ADD      r7,r7,r0              ;484
                  |L31.156|
00009c  8860              LDRH     r0,[r4,#2]            ;487
00009e  f6484206          MOV      r2,#0x8c06            ;487
0000a2  1a81              SUBS     r1,r0,r2              ;487
0000a4  4290              CMP      r0,r2                 ;487
0000a6  d03f              BEQ      |L31.296|
0000a8  dc08              BGT      |L31.188|
0000aa  f5a0400b          SUB      r0,r0,#0x8b00         ;487
0000ae  3815              SUBS     r0,r0,#0x15           ;487
0000b0  d00b              BEQ      |L31.202|
0000b2  2804              CMP      r0,#4                 ;487
0000b4  d06a              BEQ      |L31.396|
0000b6  28ed              CMP      r0,#0xed              ;487
0000b8  d135              BNE      |L31.294|
0000ba  e044              B        |L31.326|
                  |L31.188|
0000bc  2901              CMP      r1,#1                 ;487
0000be  d075              BEQ      |L31.428|
0000c0  2902              CMP      r1,#2                 ;487
0000c2  d072              BEQ      |L31.426|
0000c4  2903              CMP      r1,#3                 ;487
0000c6  d12e              BNE      |L31.294|
0000c8  e08e              B        |L31.488|
                  |L31.202|
0000ca  7ae3              LDRB     r3,[r4,#0xb]          ;489
0000cc  7aa2              LDRB     r2,[r4,#0xa]          ;489
0000ce  7a61              LDRB     r1,[r4,#9]            ;489
0000d0  7a20              LDRB     r0,[r4,#8]            ;489
0000d2  e88d000f          STM      sp,{r0-r3}            ;489
0000d6  79e3              LDRB     r3,[r4,#7]            ;489
0000d8  79a2              LDRB     r2,[r4,#6]            ;489
0000da  a157              ADR      r1,|L31.568|
0000dc  2000              MOVS     r0,#0                 ;489
0000de  f7fffffe          BL       wpa_printf
0000e2  1da0              ADDS     r0,r4,#6              ;492
0000e4  f7fffffe          BL       is_zero_ether_addr
0000e8  b928              CBNZ     r0,|L31.246|
0000ea  2206              MOVS     r2,#6                 ;494
0000ec  a160              ADR      r1,|L31.624|
0000ee  1da0              ADDS     r0,r4,#6              ;494
0000f0  f7fffffe          BL       memcmp
0000f4  b978              CBNZ     r0,|L31.278|
                  |L31.246|
0000f6  6c28              LDR      r0,[r5,#0x40]         ;497
0000f8  f7fffffe          BL       os_free
0000fc  2000              MOVS     r0,#0                 ;498
0000fe  6428              STR      r0,[r5,#0x40]         ;498
000100  6ca8              LDR      r0,[r5,#0x48]         ;499
000102  f7fffffe          BL       os_free
000106  2000              MOVS     r0,#0                 ;500
000108  64a8              STR      r0,[r5,#0x48]         ;500
00010a  2200              MOVS     r2,#0                 ;501
00010c  2101              MOVS     r1,#1                 ;501
00010e  6828              LDR      r0,[r5,#0]            ;501
000110  f7fffffe          BL       wpa_supplicant_event
000114  e007              B        |L31.294|
                  |L31.278|
000116  4628              MOV      r0,r5                 ;505
000118  f7fffffe          BL       wpa_driver_wext_event_assoc_ies
00011c  2200              MOVS     r2,#0                 ;506
00011e  4611              MOV      r1,r2                 ;506
000120  6828              LDR      r0,[r5,#0]            ;506
000122  f7fffffe          BL       wpa_supplicant_event
                  |L31.294|
000126  e06e              B        |L31.518|
                  |L31.296|
000128  8920              LDRH     r0,[r4,#8]            ;511
00012a  4438              ADD      r0,r0,r7              ;511
00012c  4540              CMP      r0,r8                 ;511
00012e  d904              BLS      |L31.314|
000130  a151              ADR      r1,|L31.632|
000132  2000              MOVS     r0,#0                 ;512
000134  f7fffffe          BL       wpa_printf
000138  e778              B        |L31.44|
                  |L31.314|
00013a  8922              LDRH     r2,[r4,#8]            ;516
00013c  4639              MOV      r1,r7                 ;516
00013e  6828              LDR      r0,[r5,#0]            ;516
000140  f7fffffe          BL       wpa_driver_wext_event_wireless_michaelmicfailure
000144  e05f              B        |L31.518|
                  |L31.326|
000146  8920              LDRH     r0,[r4,#8]            ;520
000148  4438              ADD      r0,r0,r7              ;520
00014a  4540              CMP      r0,r8                 ;520
00014c  d904              BLS      |L31.344|
00014e  a155              ADR      r1,|L31.676|
000150  2000              MOVS     r0,#0                 ;521
000152  f7fffffe          BL       wpa_printf
000156  e769              B        |L31.44|
                  |L31.344|
000158  8921              LDRH     r1,[r4,#8]            ;525
00015a  1c48              ADDS     r0,r1,#1              ;525
00015c  f7fffffe          BL       os_malloc
000160  4681              MOV      r9,r0                 ;525
000162  f1b90f00          CMP      r9,#0                 ;526
000166  d100              BNE      |L31.362|
000168  e760              B        |L31.44|
                  |L31.362|
00016a  8922              LDRH     r2,[r4,#8]            ;528
00016c  4639              MOV      r1,r7                 ;528
00016e  4648              MOV      r0,r9                 ;528
000170  f7fffffe          BL       __aeabi_memcpy
000174  2100              MOVS     r1,#0                 ;529
000176  8920              LDRH     r0,[r4,#8]            ;529
000178  f8091000          STRB     r1,[r9,r0]            ;529
00017c  4649              MOV      r1,r9                 ;530
00017e  6828              LDR      r0,[r5,#0]            ;530
000180  f7fffffe          BL       wpa_driver_wext_event_wireless_custom
000184  4648              MOV      r0,r9                 ;531
000186  f7fffffe          BL       os_free
00018a  e03c              B        |L31.518|
                  |L31.396|
00018c  2001              MOVS     r0,#1                 ;534
00018e  f8c500a0          STR      r0,[r5,#0xa0]         ;534
000192  4629              MOV      r1,r5                 ;535
000194  484b              LDR      r0,|L31.708|
000196  682a              LDR      r2,[r5,#0]            ;535
000198  f7fffffe          BL       eloop_cancel_timeout
00019c  2200              MOVS     r2,#0                 ;537
00019e  2103              MOVS     r1,#3                 ;537
0001a0  6828              LDR      r0,[r5,#0]            ;537
0001a2  f7fffffe          BL       wpa_supplicant_event
0001a6  e02e              B        |L31.518|
0001a8  e000              B        |L31.428|
                  |L31.426|
0001aa  e00e              B        |L31.458|
                  |L31.428|
0001ac  8920              LDRH     r0,[r4,#8]            ;541
0001ae  4438              ADD      r0,r0,r7              ;541
0001b0  4540              CMP      r0,r8                 ;541
0001b2  d904              BLS      |L31.446|
0001b4  a144              ADR      r1,|L31.712|
0001b6  2000              MOVS     r0,#0                 ;542
0001b8  f7fffffe          BL       wpa_printf
0001bc  e736              B        |L31.44|
                  |L31.446|
0001be  8922              LDRH     r2,[r4,#8]            ;546
0001c0  4639              MOV      r1,r7                 ;546
0001c2  4628              MOV      r0,r5                 ;546
0001c4  f7fffffe          BL       wpa_driver_wext_event_wireless_assocreqie
0001c8  e01d              B        |L31.518|
                  |L31.458|
0001ca  8920              LDRH     r0,[r4,#8]            ;550
0001cc  4438              ADD      r0,r0,r7              ;550
0001ce  4540              CMP      r0,r8                 ;550
0001d0  d904              BLS      |L31.476|
0001d2  a146              ADR      r1,|L31.748|
0001d4  2000              MOVS     r0,#0                 ;551
0001d6  f7fffffe          BL       wpa_printf
0001da  e727              B        |L31.44|
                  |L31.476|
0001dc  8922              LDRH     r2,[r4,#8]            ;555
0001de  4639              MOV      r1,r7                 ;555
0001e0  4628              MOV      r0,r5                 ;555
0001e2  f7fffffe          BL       wpa_driver_wext_event_wireless_assocrespie
0001e6  e00e              B        |L31.518|
                  |L31.488|
0001e8  8920              LDRH     r0,[r4,#8]            ;559
0001ea  4438              ADD      r0,r0,r7              ;559
0001ec  4540              CMP      r0,r8                 ;559
0001ee  d904              BLS      |L31.506|
0001f0  a148              ADR      r1,|L31.788|
0001f2  2000              MOVS     r0,#0                 ;560
0001f4  f7fffffe          BL       wpa_printf
0001f8  e718              B        |L31.44|
                  |L31.506|
0001fa  8922              LDRH     r2,[r4,#8]            ;564
0001fc  4639              MOV      r1,r7                 ;564
0001fe  4628              MOV      r0,r5                 ;564
000200  f7fffffe          BL       wpa_driver_wext_event_wireless_pmkidcand
000204  bf00              NOP                            ;566
                  |L31.518|
000206  bf00              NOP                            ;509
000208  8820              LDRH     r0,[r4,#0]            ;569
00020a  4406              ADD      r6,r6,r0              ;569
                  |L31.524|
00020c  1d30              ADDS     r0,r6,#4              ;461
00020e  4540              CMP      r0,r8                 ;461
000210  f67faf01          BLS      |L31.22|
000214  bf00              NOP      
000216  e709              B        |L31.44|
;;;572    
                          ENDP

                  |L31.536|
000218  57697265          DCB      "Wireless event: cmd=0x%x len=%d",0
00021c  6c657373
000220  20657665
000224  6e743a20
000228  636d643d
00022c  30782578
000230  206c656e
000234  3d256400
                  |L31.568|
000238  57697265          DCB      "Wireless event: new AP: %02x:%02x:%02x:%02x:%02x:%02x",0
00023c  6c657373
000240  20657665
000244  6e743a20
000248  6e657720
00024c  41503a20
000250  25303278
000254  3a253032
000258  783a2530
00025c  32783a25
000260  3032783a
000264  25303278
000268  3a253032
00026c  7800    
00026e  00                DCB      0
00026f  00                DCB      0
                  |L31.624|
000270  44444444          DCB      "DDDDDD",0
000274  444400  
000277  00                DCB      0
                  |L31.632|
000278  57455854          DCB      "WEXT: Invalid IWEVMICHAELMICFAILURE length",0
00027c  3a20496e
000280  76616c69
000284  64204957
000288  45564d49
00028c  43484145
000290  4c4d4943
000294  4641494c
000298  55524520
00029c  6c656e67
0002a0  746800  
0002a3  00                DCB      0
                  |L31.676|
0002a4  57455854          DCB      "WEXT: Invalid IWEVCUSTOM length",0
0002a8  3a20496e
0002ac  76616c69
0002b0  64204957
0002b4  45564355
0002b8  53544f4d
0002bc  206c656e
0002c0  67746800
                  |L31.708|
                          DCD      wpa_driver_wext_scan_timeout
                  |L31.712|
0002c8  57455854          DCB      "WEXT: Invalid IWEVASSOCREQIE length",0
0002cc  3a20496e
0002d0  76616c69
0002d4  64204957
0002d8  45564153
0002dc  534f4352
0002e0  45514945
0002e4  206c656e
0002e8  67746800
                  |L31.748|
0002ec  57455854          DCB      "WEXT: Invalid IWEVASSOCRESPIE length",0
0002f0  3a20496e
0002f4  76616c69
0002f8  64204957
0002fc  45564153
000300  534f4352
000304  45535049
000308  45206c65
00030c  6e677468
000310  00      
000311  00                DCB      0
000312  00                DCB      0
000313  00                DCB      0
                  |L31.788|
000314  57455854          DCB      "WEXT: Invalid IWEVPMKIDCAND length",0
000318  3a20496e
00031c  76616c69
000320  64204957
000324  4556504d
000328  4b494443
00032c  414e4420
000330  6c656e67
000334  746800  
000337  00                DCB      0

                          AREA ||i.wpa_driver_wext_event_wireless_assocreqie||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_wireless_assocreqie PROC
;;;383    
;;;384    static int wpa_driver_wext_event_wireless_assocreqie(
000000  b570              PUSH     {r4-r6,lr}
;;;385    	struct wpa_driver_wext_data *drv, const char *ev, int len)
;;;386    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;387    	if (len < 0)
000008  2d00              CMP      r5,#0
00000a  da02              BGE      |L32.18|
;;;388    		return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L32.16|
;;;389    
;;;390    	wpa_hexdump(MSG_DEBUG, "AssocReq IE wireless event", (const u8 *) ev,
;;;391    		    len);
;;;392    	os_free(drv->assoc_req_ies);
;;;393    	drv->assoc_req_ies = os_malloc(len);
;;;394    	if (drv->assoc_req_ies == NULL) {
;;;395    		drv->assoc_req_ies_len = 0;
;;;396    		return -1;
;;;397    	}
;;;398    	os_memcpy(drv->assoc_req_ies, ev, len);
;;;399    	drv->assoc_req_ies_len = len;
;;;400    
;;;401    	return 0;
;;;402    }
000010  bd70              POP      {r4-r6,pc}
                  |L32.18|
000012  462b              MOV      r3,r5                 ;390
000014  4632              MOV      r2,r6                 ;390
000016  a10c              ADR      r1,|L32.72|
000018  2000              MOVS     r0,#0                 ;390
00001a  f7fffffe          BL       wpa_hexdump
00001e  6c20              LDR      r0,[r4,#0x40]         ;392
000020  f7fffffe          BL       os_free
000024  4628              MOV      r0,r5                 ;393
000026  f7fffffe          BL       os_malloc
00002a  6420              STR      r0,[r4,#0x40]         ;393
00002c  6c20              LDR      r0,[r4,#0x40]         ;394
00002e  b918              CBNZ     r0,|L32.56|
000030  2000              MOVS     r0,#0                 ;395
000032  6460              STR      r0,[r4,#0x44]         ;395
000034  1e40              SUBS     r0,r0,#1              ;396
000036  e7eb              B        |L32.16|
                  |L32.56|
000038  462a              MOV      r2,r5                 ;398
00003a  4631              MOV      r1,r6                 ;398
00003c  6c20              LDR      r0,[r4,#0x40]         ;398
00003e  f7fffffe          BL       __aeabi_memcpy
000042  6465              STR      r5,[r4,#0x44]         ;399
000044  2000              MOVS     r0,#0                 ;401
000046  e7e3              B        |L32.16|
;;;403    
                          ENDP

                  |L32.72|
000048  4173736f          DCB      "AssocReq IE wireless event",0
00004c  63526571
000050  20494520
000054  77697265
000058  6c657373
00005c  20657665
000060  6e7400  
000063  00                DCB      0

                          AREA ||i.wpa_driver_wext_event_wireless_assocrespie||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_wireless_assocrespie PROC
;;;404    
;;;405    static int wpa_driver_wext_event_wireless_assocrespie(
000000  b570              PUSH     {r4-r6,lr}
;;;406    	struct wpa_driver_wext_data *drv, const char *ev, int len)
;;;407    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;408    	if (len < 0)
000008  2d00              CMP      r5,#0
00000a  da02              BGE      |L33.18|
;;;409    		return -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L33.16|
;;;410    
;;;411    	wpa_hexdump(MSG_DEBUG, "AssocResp IE wireless event", (const u8 *) ev,
;;;412    		    len);
;;;413    	os_free(drv->assoc_resp_ies);
;;;414    	drv->assoc_resp_ies = os_malloc(len);
;;;415    	if (drv->assoc_resp_ies == NULL) {
;;;416    		drv->assoc_resp_ies_len = 0;
;;;417    		return -1;
;;;418    	}
;;;419    	os_memcpy(drv->assoc_resp_ies, ev, len);
;;;420    	drv->assoc_resp_ies_len = len;
;;;421    
;;;422    	return 0;
;;;423    }
000010  bd70              POP      {r4-r6,pc}
                  |L33.18|
000012  462b              MOV      r3,r5                 ;411
000014  4632              MOV      r2,r6                 ;411
000016  a10c              ADR      r1,|L33.72|
000018  2000              MOVS     r0,#0                 ;411
00001a  f7fffffe          BL       wpa_hexdump
00001e  6ca0              LDR      r0,[r4,#0x48]         ;413
000020  f7fffffe          BL       os_free
000024  4628              MOV      r0,r5                 ;414
000026  f7fffffe          BL       os_malloc
00002a  64a0              STR      r0,[r4,#0x48]         ;414
00002c  6ca0              LDR      r0,[r4,#0x48]         ;415
00002e  b918              CBNZ     r0,|L33.56|
000030  2000              MOVS     r0,#0                 ;416
000032  64e0              STR      r0,[r4,#0x4c]         ;416
000034  1e40              SUBS     r0,r0,#1              ;417
000036  e7eb              B        |L33.16|
                  |L33.56|
000038  462a              MOV      r2,r5                 ;419
00003a  4631              MOV      r1,r6                 ;419
00003c  6ca0              LDR      r0,[r4,#0x48]         ;419
00003e  f7fffffe          BL       __aeabi_memcpy
000042  64e5              STR      r5,[r4,#0x4c]         ;420
000044  2000              MOVS     r0,#0                 ;422
000046  e7e3              B        |L33.16|
;;;424    
                          ENDP

                  |L33.72|
000048  4173736f          DCB      "AssocResp IE wireless event",0
00004c  63526573
000050  70204945
000054  20776972
000058  656c6573
00005c  73206576
000060  656e7400

                          AREA ||i.wpa_driver_wext_event_wireless_custom||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_wireless_custom PROC
;;;261    static void
;;;262    wpa_driver_wext_event_wireless_custom(void *ctx, char *custom)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;263    {
000004  b09b              SUB      sp,sp,#0x6c
000006  4681              MOV      r9,r0
000008  460d              MOV      r5,r1
;;;264    	union wpa_event_data data;
;;;265    
;;;266    	wpa_printf(MSG_MSGDUMP, "WEXT: Custom wireless event: '%s'",
00000a  462a              MOV      r2,r5
00000c  a14b              ADR      r1,|L34.316|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       wpa_printf
;;;267    		   custom);
;;;268    
;;;269    	os_memset(&data, 0, sizeof(data));
000014  2168              MOVS     r1,#0x68
000016  a801              ADD      r0,sp,#4
000018  f7fffffe          BL       __aeabi_memclr4
;;;270    	/* Host AP driver */
;;;271    	if (os_strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
00001c  2221              MOVS     r2,#0x21
00001e  a150              ADR      r1,|L34.352|
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       os_strncmp
000026  b970              CBNZ     r0,|L34.70|
;;;272    		data.michael_mic_failure.unicast =
000028  a156              ADR      r1,|L34.388|
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       os_strstr
000030  b108              CBZ      r0,|L34.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L34.56|
                  |L34.54|
000036  2000              MOVS     r0,#0
                  |L34.56|
000038  9001              STR      r0,[sp,#4]
;;;273    			os_strstr(custom, " unicast ") != NULL;
;;;274    		/* TODO: parse parameters(?) */
;;;275    		wpa_supplicant_event(ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
00003a  aa01              ADD      r2,sp,#4
00003c  2102              MOVS     r1,#2
00003e  4648              MOV      r0,r9
000040  f7fffffe          BL       wpa_supplicant_event
000044  e078              B        |L34.312|
                  |L34.70|
;;;276    	} else if (os_strncmp(custom, "ASSOCINFO(ReqIEs=", 17) == 0) {
000046  2211              MOVS     r2,#0x11
000048  a151              ADR      r1,|L34.400|
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       os_strncmp
000050  bbc8              CBNZ     r0,|L34.198|
;;;277    		char *spos;
;;;278    		int bytes;
;;;279    		u8 *req_ies = NULL, *resp_ies = NULL;
000052  2600              MOVS     r6,#0
000054  2700              MOVS     r7,#0
;;;280    
;;;281    		spos = custom + 17;
000056  f1050811          ADD      r8,r5,#0x11
;;;282    
;;;283    		bytes = strspn(spos, "0123456789abcdefABCDEF");
00005a  a152              ADR      r1,|L34.420|
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       strspn
000062  4604              MOV      r4,r0
;;;284    		if (!bytes || (bytes & 1))
000064  b114              CBZ      r4,|L34.108|
000066  f0140f01          TST      r4,#1
00006a  d002              BEQ      |L34.114|
                  |L34.108|
;;;285    			return;
;;;286    		bytes /= 2;
;;;287    
;;;288    		req_ies = os_malloc(bytes);
;;;289    		if (req_ies == NULL ||
;;;290    		    hexstr2bin(spos, req_ies, bytes) < 0)
;;;291    			goto done;
;;;292    		data.assoc_info.req_ies = req_ies;
;;;293    		data.assoc_info.req_ies_len = bytes;
;;;294    
;;;295    		spos += bytes * 2;
;;;296    
;;;297    		data.assoc_info.resp_ies = NULL;
;;;298    		data.assoc_info.resp_ies_len = 0;
;;;299    
;;;300    		if (os_strncmp(spos, " RespIEs=", 9) == 0) {
;;;301    			spos += 9;
;;;302    
;;;303    			bytes = strspn(spos, "0123456789abcdefABCDEF");
;;;304    			if (!bytes || (bytes & 1))
;;;305    				goto done;
;;;306    			bytes /= 2;
;;;307    
;;;308    			resp_ies = os_malloc(bytes);
;;;309    			if (resp_ies == NULL ||
;;;310    			    hexstr2bin(spos, resp_ies, bytes) < 0)
;;;311    				goto done;
;;;312    			data.assoc_info.resp_ies = resp_ies;
;;;313    			data.assoc_info.resp_ies_len = bytes;
;;;314    		}
;;;315    
;;;316    		wpa_supplicant_event(ctx, EVENT_ASSOCINFO, &data);
;;;317    
;;;318    	done:
;;;319    		os_free(resp_ies);
;;;320    		os_free(req_ies);
;;;321    #ifdef CONFIG_PEERKEY
;;;322    	} else if (os_strncmp(custom, "STKSTART.request=", 17) == 0) {
;;;323    		if (hwaddr_aton(custom + 17, data.stkstart.peer)) {
;;;324    			wpa_printf(MSG_DEBUG, "WEXT: unrecognized "
;;;325    				   "STKSTART.request '%s'", custom + 17);
;;;326    			return;
;;;327    		}
;;;328    		wpa_supplicant_event(ctx, EVENT_STKSTART, &data);
;;;329    #endif /* CONFIG_PEERKEY */
;;;330    	}
;;;331    }
00006c  b01b              ADD      sp,sp,#0x6c
00006e  e8bd83f0          POP      {r4-r9,pc}
                  |L34.114|
000072  4620              MOV      r0,r4                 ;286
000074  eb0471d4          ADD      r1,r4,r4,LSR #31      ;286
000078  104c              ASRS     r4,r1,#1              ;286
00007a  4620              MOV      r0,r4                 ;288
00007c  f7fffffe          BL       os_malloc
000080  4606              MOV      r6,r0                 ;288
000082  b136              CBZ      r6,|L34.146|
000084  4622              MOV      r2,r4                 ;290
000086  4631              MOV      r1,r6                 ;290
000088  4640              MOV      r0,r8                 ;290
00008a  f7fffffe          BL       hexstr2bin
00008e  2800              CMP      r0,#0                 ;290
000090  da00              BGE      |L34.148|
                  |L34.146|
000092  e032              B        |L34.250|
                  |L34.148|
000094  9601              STR      r6,[sp,#4]            ;292
000096  9402              STR      r4,[sp,#8]            ;293
000098  eb080844          ADD      r8,r8,r4,LSL #1       ;295
00009c  2000              MOVS     r0,#0                 ;297
00009e  9003              STR      r0,[sp,#0xc]          ;297
0000a0  9004              STR      r0,[sp,#0x10]         ;298
0000a2  2209              MOVS     r2,#9                 ;300
0000a4  a145              ADR      r1,|L34.444|
0000a6  4640              MOV      r0,r8                 ;300
0000a8  f7fffffe          BL       os_strncmp
0000ac  b9f8              CBNZ     r0,|L34.238|
0000ae  f1080809          ADD      r8,r8,#9              ;301
0000b2  a13c              ADR      r1,|L34.420|
0000b4  4640              MOV      r0,r8                 ;303
0000b6  f7fffffe          BL       strspn
0000ba  4604              MOV      r4,r0                 ;303
0000bc  b114              CBZ      r4,|L34.196|
0000be  f0140f01          TST      r4,#1                 ;304
0000c2  d001              BEQ      |L34.200|
                  |L34.196|
0000c4  e019              B        |L34.250|
                  |L34.198|
0000c6  e01f              B        |L34.264|
                  |L34.200|
0000c8  4620              MOV      r0,r4                 ;306
0000ca  eb0471d4          ADD      r1,r4,r4,LSR #31      ;306
0000ce  104c              ASRS     r4,r1,#1              ;306
0000d0  4620              MOV      r0,r4                 ;308
0000d2  f7fffffe          BL       os_malloc
0000d6  4607              MOV      r7,r0                 ;308
0000d8  b137              CBZ      r7,|L34.232|
0000da  4622              MOV      r2,r4                 ;310
0000dc  4639              MOV      r1,r7                 ;310
0000de  4640              MOV      r0,r8                 ;310
0000e0  f7fffffe          BL       hexstr2bin
0000e4  2800              CMP      r0,#0                 ;310
0000e6  da00              BGE      |L34.234|
                  |L34.232|
0000e8  e007              B        |L34.250|
                  |L34.234|
0000ea  9703              STR      r7,[sp,#0xc]          ;312
0000ec  9404              STR      r4,[sp,#0x10]         ;313
                  |L34.238|
0000ee  aa01              ADD      r2,sp,#4              ;316
0000f0  2104              MOVS     r1,#4                 ;316
0000f2  4648              MOV      r0,r9                 ;316
0000f4  f7fffffe          BL       wpa_supplicant_event
0000f8  bf00              NOP                            ;318
                  |L34.250|
0000fa  4638              MOV      r0,r7                 ;319
0000fc  f7fffffe          BL       os_free
000100  4630              MOV      r0,r6                 ;320
000102  f7fffffe          BL       os_free
000106  e017              B        |L34.312|
                  |L34.264|
000108  2211              MOVS     r2,#0x11              ;322
00010a  a12f              ADR      r1,|L34.456|
00010c  4628              MOV      r0,r5                 ;322
00010e  f7fffffe          BL       os_strncmp
000112  b988              CBNZ     r0,|L34.312|
000114  a901              ADD      r1,sp,#4              ;323
000116  f1050011          ADD      r0,r5,#0x11           ;323
00011a  f7fffffe          BL       hwaddr_aton
00011e  b130              CBZ      r0,|L34.302|
000120  f1050211          ADD      r2,r5,#0x11           ;324
000124  a12d              ADR      r1,|L34.476|
000126  2000              MOVS     r0,#0                 ;324
000128  f7fffffe          BL       wpa_printf
00012c  e79e              B        |L34.108|
                  |L34.302|
00012e  aa01              ADD      r2,sp,#4              ;328
000130  2107              MOVS     r1,#7                 ;328
000132  4648              MOV      r0,r9                 ;328
000134  f7fffffe          BL       wpa_supplicant_event
                  |L34.312|
000138  bf00              NOP      
00013a  e797              B        |L34.108|
;;;332    
                          ENDP

                  |L34.316|
00013c  57455854          DCB      "WEXT: Custom wireless event: '%s'",0
000140  3a204375
000144  73746f6d
000148  20776972
00014c  656c6573
000150  73206576
000154  656e743a
000158  20272573
00015c  2700    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L34.352|
000160  4d4c4d45          DCB      "MLME-MICHAELMICFAILURE.indication",0
000164  2d4d4943
000168  4841454c
00016c  4d494346
000170  41494c55
000174  52452e69
000178  6e646963
00017c  6174696f
000180  6e00    
000182  00                DCB      0
000183  00                DCB      0
                  |L34.388|
000184  20756e69          DCB      " unicast ",0
000188  63617374
00018c  2000    
00018e  00                DCB      0
00018f  00                DCB      0
                  |L34.400|
000190  4153534f          DCB      "ASSOCINFO(ReqIEs=",0
000194  43494e46
000198  4f285265
00019c  71494573
0001a0  3d00    
0001a2  00                DCB      0
0001a3  00                DCB      0
                  |L34.420|
0001a4  30313233          DCB      "0123456789abcdefABCDEF",0
0001a8  34353637
0001ac  38396162
0001b0  63646566
0001b4  41424344
0001b8  454600  
0001bb  00                DCB      0
                  |L34.444|
0001bc  20526573          DCB      " RespIEs=",0
0001c0  70494573
0001c4  3d00    
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L34.456|
0001c8  53544b53          DCB      "STKSTART.request=",0
0001cc  54415254
0001d0  2e726571
0001d4  75657374
0001d8  3d00    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L34.476|
0001dc  57455854          DCB      "WEXT: unrecognized STKSTART.request '%s'",0
0001e0  3a20756e
0001e4  7265636f
0001e8  676e697a
0001ec  65642053
0001f0  544b5354
0001f4  4152542e
0001f8  72657175
0001fc  65737420
000200  27257327
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0

                          AREA ||i.wpa_driver_wext_event_wireless_michaelmicfailure||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_wireless_michaelmicfailure PROC
;;;333    
;;;334    static int wpa_driver_wext_event_wireless_michaelmicfailure(
000000  b5f0              PUSH     {r4-r7,lr}
;;;335    	void *ctx, const char *ev, size_t len)
;;;336    {
000002  b09f              SUB      sp,sp,#0x7c
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;337    	const struct iw_michaelmicfailure *mic;
;;;338    	union wpa_event_data data;
;;;339    
;;;340    	if (len < sizeof(*mic))
00000a  2e1c              CMP      r6,#0x1c
00000c  d203              BCS      |L35.22|
;;;341    		return -1;
00000e  f04f30ff          MOV      r0,#0xffffffff
                  |L35.18|
;;;342    
;;;343    	mic = (const struct iw_michaelmicfailure *) ev;
;;;344    
;;;345    	wpa_printf(MSG_DEBUG, "Michael MIC failure wireless event: "
;;;346    		   "flags=0x%x src_addr=" MACSTR, mic->flags,
;;;347    		   MAC2STR(mic->src_addr.sa_data));
;;;348    
;;;349    	os_memset(&data, 0, sizeof(data));
;;;350    	data.michael_mic_failure.unicast = !(mic->flags & IW_MICFAILURE_GROUP);
;;;351    	wpa_supplicant_event(ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
;;;352    
;;;353    	return 0;
;;;354    }
000012  b01f              ADD      sp,sp,#0x7c
000014  bdf0              POP      {r4-r7,pc}
                  |L35.22|
000016  4625              MOV      r5,r4                 ;343
000018  7aeb              LDRB     r3,[r5,#0xb]          ;345
00001a  7aaa              LDRB     r2,[r5,#0xa]          ;345
00001c  7a69              LDRB     r1,[r5,#9]            ;345
00001e  7a28              LDRB     r0,[r5,#8]            ;345
000020  e9cd2303          STRD     r2,r3,[sp,#0xc]       ;345
000024  e9cd0101          STRD     r0,r1,[sp,#4]         ;345
000028  79eb              LDRB     r3,[r5,#7]            ;345
00002a  462c              MOV      r4,r5                 ;345
00002c  9300              STR      r3,[sp,#0]            ;345
00002e  79ab              LDRB     r3,[r5,#6]            ;345
000030  490a              LDR      r1,|L35.92|
000032  2000              MOVS     r0,#0                 ;345
000034  682a              LDR      r2,[r5,#0]            ;345
000036  f7fffffe          BL       wpa_printf
00003a  2168              MOVS     r1,#0x68              ;349
00003c  a805              ADD      r0,sp,#0x14           ;349
00003e  f7fffffe          BL       __aeabi_memclr4
000042  2101              MOVS     r1,#1                 ;350
000044  6828              LDR      r0,[r5,#0]            ;350
000046  ea210090          BIC      r0,r1,r0,LSR #2       ;350
00004a  9005              STR      r0,[sp,#0x14]         ;350
00004c  aa05              ADD      r2,sp,#0x14           ;351
00004e  2102              MOVS     r1,#2                 ;351
000050  4638              MOV      r0,r7                 ;351
000052  f7fffffe          BL       wpa_supplicant_event
000056  2000              MOVS     r0,#0                 ;353
000058  e7db              B        |L35.18|
;;;355    
                          ENDP

00005a  0000              DCW      0x0000
                  |L35.92|
                          DCD      ||.constdata||+0x390

                          AREA ||i.wpa_driver_wext_event_wireless_pmkidcand||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_event_wireless_pmkidcand PROC
;;;356    
;;;357    static int wpa_driver_wext_event_wireless_pmkidcand(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;358    	struct wpa_driver_wext_data *drv, const char *ev, size_t len)
;;;359    {
000004  b0a0              SUB      sp,sp,#0x80
000006  4607              MOV      r7,r0
000008  460d              MOV      r5,r1
00000a  4690              MOV      r8,r2
;;;360    	const struct iw_pmkid_cand *cand;
;;;361    	union wpa_event_data data;
;;;362    	const u8 *addr;
;;;363    
;;;364    	if (len < sizeof(*cand))
00000c  f1b80f18          CMP      r8,#0x18
000010  d204              BCS      |L36.28|
;;;365    		return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L36.22|
;;;366    
;;;367    	cand = (const struct iw_pmkid_cand *) ev;
;;;368    	addr = (const u8 *) cand->bssid.sa_data;
;;;369    
;;;370    	wpa_printf(MSG_DEBUG, "PMKID candidate wireless event: "
;;;371    		   "flags=0x%x index=%d bssid=" MACSTR, cand->flags,
;;;372    		   cand->index, MAC2STR(addr));
;;;373    
;;;374    	os_memset(&data, 0, sizeof(data));
;;;375    	os_memcpy(data.pmkid_candidate.bssid, addr, ETH_ALEN);
;;;376    	data.pmkid_candidate.index = cand->index;
;;;377    	data.pmkid_candidate.preauth = cand->flags & IW_PMKID_CAND_PREAUTH;
;;;378    	wpa_supplicant_event(drv->ctx, EVENT_PMKID_CANDIDATE, &data);
;;;379    
;;;380    	return 0;
;;;381    }
000016  b020              ADD      sp,sp,#0x80
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L36.28|
00001c  462e              MOV      r6,r5                 ;367
00001e  4635              MOV      r5,r6                 ;368
000020  f106040a          ADD      r4,r6,#0xa            ;368
000024  7963              LDRB     r3,[r4,#5]            ;370
000026  7922              LDRB     r2,[r4,#4]            ;370
000028  78e1              LDRB     r1,[r4,#3]            ;370
00002a  78a0              LDRB     r0,[r4,#2]            ;370
00002c  e9cd2304          STRD     r2,r3,[sp,#0x10]      ;370
000030  e9cd0102          STRD     r0,r1,[sp,#8]         ;370
000034  7863              LDRB     r3,[r4,#1]            ;370
000036  7822              LDRB     r2,[r4,#0]            ;370
000038  e9cd2300          STRD     r2,r3,[sp,#0]         ;370
00003c  490d              LDR      r1,|L36.116|
00003e  2000              MOVS     r0,#0                 ;370
000040  e9d62300          LDRD     r2,r3,[r6,#0]         ;370
000044  f7fffffe          BL       wpa_printf
000048  2168              MOVS     r1,#0x68              ;374
00004a  a806              ADD      r0,sp,#0x18           ;374
00004c  f7fffffe          BL       __aeabi_memclr4
000050  6820              LDR      r0,[r4,#0]            ;375
000052  9006              STR      r0,[sp,#0x18]         ;375
000054  88a0              LDRH     r0,[r4,#4]            ;375
000056  f8ad001c          STRH     r0,[sp,#0x1c]         ;375
00005a  6870              LDR      r0,[r6,#4]            ;376
00005c  9008              STR      r0,[sp,#0x20]         ;376
00005e  6830              LDR      r0,[r6,#0]            ;377
000060  f0000001          AND      r0,r0,#1              ;377
000064  9009              STR      r0,[sp,#0x24]         ;377
000066  aa06              ADD      r2,sp,#0x18           ;378
000068  2106              MOVS     r1,#6                 ;378
00006a  6838              LDR      r0,[r7,#0]            ;378
00006c  f7fffffe          BL       wpa_supplicant_event
000070  2000              MOVS     r0,#0                 ;380
000072  e7d0              B        |L36.22|
;;;382    
                          ENDP

                  |L36.116|
                          DCD      ||.constdata||+0x3e8

                          AREA ||i.wpa_driver_wext_finish_drv_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_finish_drv_init PROC
;;;796    
;;;797    static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
000000  b510              PUSH     {r4,lr}
;;;798    {
000002  4604              MOV      r4,r0
;;;799    	RUN_TEST;
000004  4b04              LDR      r3,|L37.24|
000006  4a05              LDR      r2,|L37.28|
000008  f240311f          MOV      r1,#0x31f
00000c  a004              ADR      r0,|L37.32|
00000e  f7fffffe          BL       __2printf
;;;800    	return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
;;;801    #if 0
;;;802    	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0)
;;;803    		return -1;
;;;804    
;;;805    	/*
;;;806    	 * Make sure that the driver does not have any obsolete PMKID entries.
;;;807    	 */
;;;808    	wpa_driver_wext_flush_pmkid(drv);
;;;809    
;;;810    	if (wpa_driver_wext_set_mode(drv, 0) < 0) {
;;;811    		wpa_printf(MSG_DEBUG, "Could not configure driver to use "
;;;812    			   "managed mode");
;;;813    		/* Try to use it anyway */
;;;814    	}
;;;815    
;;;816    	wpa_driver_wext_get_range(drv);
;;;817    
;;;818    	/*
;;;819    	 * Unlock the driver's BSSID and force to a random SSID to clear any
;;;820    	 * previous association the driver might have when the supplicant
;;;821    	 * starts up.
;;;822    	 */
;;;823    	wpa_driver_wext_disconnect(drv);
;;;824    
;;;825    	drv->ifindex = if_nametoindex(drv->ifname);
;;;826    
;;;827    	if (os_strncmp(drv->ifname, "wlan", 4) == 0) {
;;;828    		/*
;;;829    		 * Host AP driver may use both wlan# and wifi# interface in
;;;830    		 * wireless events. Since some of the versions included WE-18
;;;831    		 * support, let's add the alternative ifindex also from
;;;832    		 * driver_wext.c for the time being. This may be removed at
;;;833    		 * some point once it is believed that old versions of the
;;;834    		 * driver are not in use anymore.
;;;835    		 */
;;;836    		char ifname2[IFNAMSIZ + 1];
;;;837    		os_strlcpy(ifname2, drv->ifname, sizeof(ifname2));
;;;838    		os_memcpy(ifname2, "wifi", 4);
;;;839    		wpa_driver_wext_alternative_ifindex(drv, ifname2);
;;;840    	}
;;;841    
;;;842    	netlink_send_oper_ifla(drv->netlink, drv->ifindex,
;;;843    			       1, IF_OPER_DORMANT);
;;;844    
;;;845    	return 0;
;;;846    #endif
;;;847    }
000016  bd10              POP      {r4,pc}
;;;848    
                          ENDP

                  |L37.24|
                          DCD      ||.constdata||+0x348
                  |L37.28|
                          DCD      |symbol_number.220|
                  |L37.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_flush_pmkid||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_flush_pmkid PROC
;;;2229   
;;;2230   static int wpa_driver_wext_flush_pmkid(void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;2231   {
000002  4604              MOV      r4,r0
;;;2232   	struct wpa_driver_wext_data *drv = priv;
000004  4625              MOV      r5,r4
;;;2233   	return wpa_driver_wext_pmksa(drv, IW_PMKSA_FLUSH, NULL, NULL);
000006  2300              MOVS     r3,#0
000008  461a              MOV      r2,r3
00000a  2103              MOVS     r1,#3
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       wpa_driver_wext_pmksa
;;;2234   }
000012  bd70              POP      {r4-r6,pc}
;;;2235   
                          ENDP


                          AREA ||i.wpa_driver_wext_get_bssid||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_get_bssid PROC
;;;81      */
;;;82     int wpa_driver_wext_get_bssid(void *priv, u8 *bssid)
000000  b570              PUSH     {r4-r6,lr}
;;;83     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;84     	RUN_TEST;
000006  4b04              LDR      r3,|L39.24|
000008  4a04              LDR      r2,|L39.28|
00000a  2154              MOVS     r1,#0x54
00000c  a004              ADR      r0,|L39.32|
00000e  f7fffffe          BL       __2printf
;;;85     	return 0;
000012  2000              MOVS     r0,#0
;;;86     #if 0
;;;87     	struct wpa_driver_wext_data *drv = priv;
;;;88     	struct iwreq iwr;
;;;89     	int ret = 0;
;;;90     
;;;91     	os_memset(&iwr, 0, sizeof(iwr));
;;;92     	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;93     
;;;94     	if (ioctl(drv->ioctl_sock, SIOCGIWAP, &iwr) < 0) {
;;;95     		perror("ioctl[SIOCGIWAP]");
;;;96     		ret = -1;
;;;97     	}
;;;98     	os_memcpy(bssid, iwr.u.ap_addr.sa_data, ETH_ALEN);
;;;99     
;;;100    	return ret;
;;;101    #endif
;;;102    }
000014  bd70              POP      {r4-r6,pc}
;;;103    
                          ENDP

000016  0000              DCW      0x0000
                  |L39.24|
                          DCD      ||.constdata||+0x348
                  |L39.28|
                          DCD      __FUNCTION__
                  |L39.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_get_capa||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_get_capa PROC
;;;2236   
;;;2237   int wpa_driver_wext_get_capa(void *priv, struct wpa_driver_capa *capa)
000000  b570              PUSH     {r4-r6,lr}
;;;2238   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2239   	RUN_TEST;
000006  4b04              LDR      r3,|L40.24|
000008  4a04              LDR      r2,|L40.28|
00000a  f64001bf          MOV      r1,#0x8bf
00000e  a004              ADR      r0,|L40.32|
000010  f7fffffe          BL       __2printf
;;;2240   	return 0;
000014  2000              MOVS     r0,#0
;;;2241   #if 0
;;;2242   	struct wpa_driver_wext_data *drv = priv;
;;;2243   	if (!drv->has_capability)
;;;2244   		return -1;
;;;2245   	os_memcpy(capa, &drv->capa, sizeof(*capa));
;;;2246   	return 0;
;;;2247   #endif
;;;2248   }
000016  bd70              POP      {r4-r6,pc}
;;;2249   
                          ENDP

                  |L40.24|
                          DCD      ||.constdata||+0x348
                  |L40.28|
                          DCD      |symbol_number.230|
                  |L40.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_get_range||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_get_range PROC
;;;1428   
;;;1429   static int wpa_driver_wext_get_range(void *priv)
000000  4601              MOV      r1,r0
;;;1430   {
;;;1431   	return 0;
000002  2000              MOVS     r0,#0
;;;1432   #if 0
;;;1433   	struct wpa_driver_wext_data *drv = priv;
;;;1434   	struct iw_range *range;
;;;1435   	struct iwreq iwr;
;;;1436   	int minlen;
;;;1437   	size_t buflen;
;;;1438   
;;;1439   	/*
;;;1440   	 * Use larger buffer than struct iw_range in order to allow the
;;;1441   	 * structure to grow in the future.
;;;1442   	 */
;;;1443   	buflen = sizeof(struct iw_range) + 500;
;;;1444   	range = os_zalloc(buflen);
;;;1445   	if (range == NULL)
;;;1446   		return -1;
;;;1447   
;;;1448   	os_memset(&iwr, 0, sizeof(iwr));
;;;1449   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1450   	iwr.u.data.pointer = (caddr_t) range;
;;;1451   	iwr.u.data.length = buflen;
;;;1452   
;;;1453   	minlen = ((char *) &range->enc_capa) - (char *) range +
;;;1454   		sizeof(range->enc_capa);
;;;1455   
;;;1456   	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
;;;1457   		perror("ioctl[SIOCGIWRANGE]");
;;;1458   		os_free(range);
;;;1459   		return -1;
;;;1460   	} else if (iwr.u.data.length >= minlen &&
;;;1461   		   range->we_version_compiled >= 18) {
;;;1462   		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
;;;1463   			   "WE(source)=%d enc_capa=0x%x",
;;;1464   			   range->we_version_compiled,
;;;1465   			   range->we_version_source,
;;;1466   			   range->enc_capa);
;;;1467   		drv->has_capability = 1;
;;;1468   		drv->we_version_compiled = range->we_version_compiled;
;;;1469   		if (range->enc_capa & IW_ENC_CAPA_WPA) {
;;;1470   			drv->capa.key_mgmt |= WPA_DRIVER_CAPA_KEY_MGMT_WPA |
;;;1471   				WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK;
;;;1472   		}
;;;1473   		if (range->enc_capa & IW_ENC_CAPA_WPA2) {
;;;1474   			drv->capa.key_mgmt |= WPA_DRIVER_CAPA_KEY_MGMT_WPA2 |
;;;1475   				WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK;
;;;1476   		}
;;;1477   		drv->capa.enc |= WPA_DRIVER_CAPA_ENC_WEP40 |
;;;1478   			WPA_DRIVER_CAPA_ENC_WEP104;
;;;1479   		if (range->enc_capa & IW_ENC_CAPA_CIPHER_TKIP)
;;;1480   			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_TKIP;
;;;1481   		if (range->enc_capa & IW_ENC_CAPA_CIPHER_CCMP)
;;;1482   			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_CCMP;
;;;1483   		if (range->enc_capa & IW_ENC_CAPA_4WAY_HANDSHAKE)
;;;1484   			drv->capa.flags |= WPA_DRIVER_FLAGS_4WAY_HANDSHAKE;
;;;1485   		drv->capa.auth = WPA_DRIVER_AUTH_OPEN |
;;;1486   			WPA_DRIVER_AUTH_SHARED |
;;;1487   			WPA_DRIVER_AUTH_LEAP;
;;;1488   		drv->capa.max_scan_ssids = 1;
;;;1489   
;;;1490   		wpa_printf(MSG_DEBUG, "  capabilities: key_mgmt 0x%x enc 0x%x "
;;;1491   			   "flags 0x%x",
;;;1492   			   drv->capa.key_mgmt, drv->capa.enc, drv->capa.flags);
;;;1493   	} else {
;;;1494   		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: too old (short) data - "
;;;1495   			   "assuming WPA is not supported");
;;;1496   	}
;;;1497   
;;;1498   	os_free(range);
;;;1499   	return 0;
;;;1500   #endif
;;;1501   }
000004  4770              BX       lr
;;;1502   
                          ENDP


                          AREA ||i.wpa_driver_wext_get_scan_results||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_get_scan_results PROC
;;;1326    */
;;;1327   struct wpa_scan_results * wpa_driver_wext_get_scan_results(void *priv)
000000  b510              PUSH     {r4,lr}
;;;1328   {
000002  4604              MOV      r4,r0
;;;1329   	RUN_TEST;
000004  4b04              LDR      r3,|L42.24|
000006  4a05              LDR      r2,|L42.28|
000008  f2405131          MOV      r1,#0x531
00000c  a004              ADR      r0,|L42.32|
00000e  f7fffffe          BL       __2printf
;;;1330   	return 0;
000012  2000              MOVS     r0,#0
;;;1331   #if 0
;;;1332   	struct wpa_driver_wext_data *drv = priv;
;;;1333   	size_t ap_num = 0, len;
;;;1334   	int first;
;;;1335   	u8 *res_buf;
;;;1336   	struct iw_event iwe_buf, *iwe = &iwe_buf;
;;;1337   	char *pos, *end, *custom;
;;;1338   	struct wpa_scan_results *res;
;;;1339   	struct wext_scan_data data;
;;;1340   
;;;1341   	res_buf = wpa_driver_wext_giwscan(drv, &len);
;;;1342   	if (res_buf == NULL)
;;;1343   		return NULL;
;;;1344   
;;;1345   	ap_num = 0;
;;;1346   	first = 1;
;;;1347   
;;;1348   	res = os_zalloc(sizeof(*res));
;;;1349   	if (res == NULL) {
;;;1350   		os_free(res_buf);
;;;1351   		return NULL;
;;;1352   	}
;;;1353   
;;;1354   	pos = (char *) res_buf;
;;;1355   	end = (char *) res_buf + len;
;;;1356   	os_memset(&data, 0, sizeof(data));
;;;1357   
;;;1358   	while (pos + IW_EV_LCP_LEN <= end) {
;;;1359   		/* Event data may be unaligned, so make a local, aligned copy
;;;1360   		 * before processing. */
;;;1361   		os_memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
;;;1362   		if (iwe->len <= IW_EV_LCP_LEN)
;;;1363   			break;
;;;1364   
;;;1365   		custom = pos + IW_EV_POINT_LEN;
;;;1366   		if (wext_19_iw_point(drv, iwe->cmd)) {
;;;1367   			/* WE-19 removed the pointer from struct iw_point */
;;;1368   			char *dpos = (char *) &iwe_buf.u.data.length;
;;;1369   			int dlen = dpos - (char *) &iwe_buf;
;;;1370   			os_memcpy(dpos, pos + IW_EV_LCP_LEN,
;;;1371   				  sizeof(struct iw_event) - dlen);
;;;1372   		} else {
;;;1373   			os_memcpy(&iwe_buf, pos, sizeof(struct iw_event));
;;;1374   			custom += IW_EV_POINT_OFF;
;;;1375   		}
;;;1376   
;;;1377   		switch (iwe->cmd) {
;;;1378   		case SIOCGIWAP:
;;;1379   			if (!first)
;;;1380   				wpa_driver_wext_add_scan_entry(res, &data);
;;;1381   			first = 0;
;;;1382   			os_free(data.ie);
;;;1383   			os_memset(&data, 0, sizeof(data));
;;;1384   			os_memcpy(data.res.bssid,
;;;1385   				  iwe->u.ap_addr.sa_data, ETH_ALEN);
;;;1386   			break;
;;;1387   		case SIOCGIWMODE:
;;;1388   			wext_get_scan_mode(iwe, &data);
;;;1389   			break;
;;;1390   		case SIOCGIWESSID:
;;;1391   			wext_get_scan_ssid(iwe, &data, custom, end);
;;;1392   			break;
;;;1393   		case SIOCGIWFREQ:
;;;1394   			wext_get_scan_freq(iwe, &data);
;;;1395   			break;
;;;1396   		case IWEVQUAL:
;;;1397   			wext_get_scan_qual(iwe, &data);
;;;1398   			break;
;;;1399   		case SIOCGIWENCODE:
;;;1400   			wext_get_scan_encode(iwe, &data);
;;;1401   			break;
;;;1402   		case SIOCGIWRATE:
;;;1403   			wext_get_scan_rate(iwe, &data, pos, end);
;;;1404   			break;
;;;1405   		case IWEVGENIE:
;;;1406   			wext_get_scan_iwevgenie(iwe, &data, custom, end);
;;;1407   			break;
;;;1408   		case IWEVCUSTOM:
;;;1409   			wext_get_scan_custom(iwe, &data, custom, end);
;;;1410   			break;
;;;1411   		}
;;;1412   
;;;1413   		pos += iwe->len;
;;;1414   	}
;;;1415   	os_free(res_buf);
;;;1416   	res_buf = NULL;
;;;1417   	if (!first)
;;;1418   		wpa_driver_wext_add_scan_entry(res, &data);
;;;1419   	os_free(data.ie);
;;;1420   
;;;1421   	wpa_printf(MSG_DEBUG, "Received %lu bytes of scan results (%lu BSSes)",
;;;1422   		   (unsigned long) len, (unsigned long) res->num);
;;;1423   
;;;1424   	return res;
;;;1425   #endif
;;;1426   }
000014  bd10              POP      {r4,pc}
;;;1427   
                          ENDP

000016  0000              DCW      0x0000
                  |L42.24|
                          DCD      ||.constdata||+0x348
                  |L42.28|
                          DCD      |symbol_number.223|
                  |L42.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_get_ssid||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_get_ssid PROC
;;;144    
;;;145    int wpa_driver_wext_get_ssid(void *priv, u8 *ssid)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;147    	RUN_TEST;
000006  4b04              LDR      r3,|L43.24|
000008  4a04              LDR      r2,|L43.28|
00000a  2193              MOVS     r1,#0x93
00000c  a004              ADR      r0,|L43.32|
00000e  f7fffffe          BL       __2printf
;;;148    	return 0;
000012  2000              MOVS     r0,#0
;;;149    
;;;150    #if 0
;;;151    	struct wpa_driver_wext_data *drv = priv;
;;;152    	struct iwreq iwr;
;;;153    	int ret = 0;
;;;154    
;;;155    	os_memset(&iwr, 0, sizeof(iwr));
;;;156    	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;157    	iwr.u.essid.pointer = (caddr_t) ssid;
;;;158    	iwr.u.essid.length = 32;
;;;159    
;;;160    	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
;;;161    		perror("ioctl[SIOCGIWESSID]");
;;;162    		ret = -1;
;;;163    	} else {
;;;164    		ret = iwr.u.essid.length;
;;;165    		if (ret > 32)
;;;166    			ret = 32;
;;;167    		/* Some drivers include nul termination in the SSID, so let's
;;;168    		 * remove it here before further processing. WE-21 changes this
;;;169    		 * to explicitly require the length _not_ to include nul
;;;170    		 * termination. */
;;;171    		if (ret > 0 && ssid[ret - 1] == '\0' &&
;;;172    		    drv->we_version_compiled < 21)
;;;173    			ret--;
;;;174    	}
;;;175    
;;;176    	return ret;
;;;177    #endif
;;;178    }
000014  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP

000016  0000              DCW      0x0000
                  |L43.24|
                          DCD      ||.constdata||+0x348
                  |L43.28|
                          DCD      |symbol_number.217|
                  |L43.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_get_version||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_get_version PROC
;;;2288   
;;;2289   int wpa_driver_wext_get_version(struct wpa_driver_wext_data *drv)
000000  4601              MOV      r1,r0
;;;2290   {
;;;2291   	return drv->we_version_compiled;
000002  6ec8              LDR      r0,[r1,#0x6c]
;;;2292   }
000004  4770              BX       lr
;;;2293   
                          ENDP


                          AREA ||i.wpa_driver_wext_giwscan||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_giwscan PROC
;;;971    
;;;972    static u8 * wpa_driver_wext_giwscan(struct wpa_driver_wext_data *drv,
000000  4602              MOV      r2,r0
;;;973    				    size_t *len)
;;;974    {
;;;975    	return 0;
000002  2000              MOVS     r0,#0
;;;976    
;;;977    #if 0
;;;978    	struct iwreq iwr;
;;;979    	u8 *res_buf;
;;;980    	size_t res_buf_len;
;;;981    
;;;982    	res_buf_len = IW_SCAN_MAX_DATA;
;;;983    	for (;;) {
;;;984    		res_buf = os_malloc(res_buf_len);
;;;985    		if (res_buf == NULL)
;;;986    			return NULL;
;;;987    		os_memset(&iwr, 0, sizeof(iwr));
;;;988    		os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;989    		iwr.u.data.pointer = res_buf;
;;;990    		iwr.u.data.length = res_buf_len;
;;;991    
;;;992    		if (ioctl(drv->ioctl_sock, SIOCGIWSCAN, &iwr) == 0)
;;;993    			break;
;;;994    
;;;995    		if (errno == E2BIG && res_buf_len < 65535) {
;;;996    			os_free(res_buf);
;;;997    			res_buf = NULL;
;;;998    			res_buf_len *= 2;
;;;999    			if (res_buf_len > 65535)
;;;1000   				res_buf_len = 65535; /* 16-bit length field */
;;;1001   			wpa_printf(MSG_DEBUG, "Scan results did not fit - "
;;;1002   				   "trying larger buffer (%lu bytes)",
;;;1003   				   (unsigned long) res_buf_len);
;;;1004   		} else {
;;;1005   			perror("ioctl[SIOCGIWSCAN]");
;;;1006   			os_free(res_buf);
;;;1007   			return NULL;
;;;1008   		}
;;;1009   	}
;;;1010   
;;;1011   	if (iwr.u.data.length > res_buf_len) {
;;;1012   		os_free(res_buf);
;;;1013   		return NULL;
;;;1014   	}
;;;1015   	*len = iwr.u.data.length;
;;;1016   
;;;1017   	return res_buf;
;;;1018   #endif
;;;1019   }
000004  4770              BX       lr
;;;1020   
                          ENDP


                          AREA ||i.wpa_driver_wext_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_init PROC
;;;730     */
;;;731    void * wpa_driver_wext_init(void *ctx, const char *ifname)
000000  b570              PUSH     {r4-r6,lr}
;;;732    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;733    
;;;734    	struct wpa_driver_wext_data *drv;
;;;735    	RUN_TEST;
000006  4b08              LDR      r3,|L46.40|
000008  4a08              LDR      r2,|L46.44|
00000a  f24021df          MOV      r1,#0x2df
00000e  a008              ADR      r0,|L46.48|
000010  f7fffffe          BL       __2printf
;;;736    	drv = os_zalloc(sizeof(*drv));
000014  20a8              MOVS     r0,#0xa8
000016  f7fffffe          BL       os_zalloc
00001a  4604              MOV      r4,r0
;;;737    	if (drv == NULL)
00001c  b90c              CBNZ     r4,|L46.34|
;;;738    		return NULL;
00001e  2000              MOVS     r0,#0
                  |L46.32|
;;;739    	drv->ctx = ctx;
;;;740    	return drv;
;;;741    #if 0
;;;742    	
;;;743    	struct netlink_config *cfg;
;;;744    	char path[128];
;;;745    	struct stat buf;
;;;746    
;;;747    	drv = os_zalloc(sizeof(*drv));
;;;748    	if (drv == NULL)
;;;749    		return NULL;
;;;750    	drv->ctx = ctx;
;;;751    	os_strlcpy(drv->ifname, ifname, sizeof(drv->ifname));
;;;752    
;;;753    	os_snprintf(path, sizeof(path), "/sys/class/net/%s/phy80211", ifname);
;;;754    	if (stat(path, &buf) == 0) {
;;;755    		wpa_printf(MSG_DEBUG, "WEXT: cfg80211-based driver detected");
;;;756    		drv->cfg80211 = 1;
;;;757    	}
;;;758    
;;;759    	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
;;;760    	if (drv->ioctl_sock < 0) {
;;;761    		perror("socket(PF_INET,SOCK_DGRAM)");
;;;762    		goto err1;
;;;763    	}
;;;764    
;;;765    	cfg = os_zalloc(sizeof(*cfg));
;;;766    	if (cfg == NULL)
;;;767    		goto err1;
;;;768    	cfg->ctx = drv;
;;;769    	cfg->newlink_cb = wpa_driver_wext_event_rtm_newlink;
;;;770    	cfg->dellink_cb = wpa_driver_wext_event_rtm_dellink;
;;;771    	drv->netlink = netlink_init(cfg);
;;;772    	if (drv->netlink == NULL) {
;;;773    		os_free(cfg);
;;;774    		goto err2;
;;;775    	}
;;;776    
;;;777    	drv->mlme_sock = -1;
;;;778    
;;;779    	if (wpa_driver_wext_finish_drv_init(drv) < 0)
;;;780    		goto err3;
;;;781    
;;;782    	wpa_driver_wext_set_auth_param(drv, IW_AUTH_WPA_ENABLED, 1);
;;;783    
;;;784    	return drv;
;;;785    
;;;786    err3:
;;;787    	netlink_deinit(drv->netlink);
;;;788    err2:
;;;789    	close(drv->ioctl_sock);
;;;790    err1:
;;;791    	os_free(drv);
;;;792    	return NULL;
;;;793    #endif
;;;794    }
000020  bd70              POP      {r4-r6,pc}
                  |L46.34|
000022  6025              STR      r5,[r4,#0]            ;739
000024  4620              MOV      r0,r4                 ;740
000026  e7fb              B        |L46.32|
;;;795    
                          ENDP

                  |L46.40|
                          DCD      ||.constdata||+0x348
                  |L46.44|
                          DCD      |symbol_number.219|
                  |L46.48|
000030  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000034  54455354
000038  203e3e3e
00003c  204c494e
000040  453a2564
000044  202c2c2c
000048  2046554e
00004c  4354494f
000050  4e3a2573
000054  202c2c2c
000058  2046494c
00005c  453a2573
000060  200d0a00

                          AREA ||i.wpa_driver_wext_keymgmt2wext||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_keymgmt2wext PROC
;;;1914   
;;;1915   int wpa_driver_wext_keymgmt2wext(int keymgmt)
000000  4601              MOV      r1,r0
;;;1916   {
;;;1917   	switch (keymgmt) {
000002  b121              CBZ      r1,|L47.14|
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L47.20|
000008  2903              CMP      r1,#3
00000a  d105              BNE      |L47.24|
00000c  e000              B        |L47.16|
                  |L47.14|
;;;1918   	case KEY_MGMT_802_1X:
;;;1919   	case KEY_MGMT_802_1X_NO_WPA:
00000e  bf00              NOP      
                  |L47.16|
;;;1920   		return IW_AUTH_KEY_MGMT_802_1X;
000010  2001              MOVS     r0,#1
                  |L47.18|
;;;1921   	case KEY_MGMT_PSK:
;;;1922   		return IW_AUTH_KEY_MGMT_PSK;
;;;1923   	default:
;;;1924   		return 0;
;;;1925   	}
;;;1926   }
000012  4770              BX       lr
                  |L47.20|
000014  2002              MOVS     r0,#2                 ;1922
000016  e7fc              B        |L47.18|
                  |L47.24|
000018  2000              MOVS     r0,#0                 ;1924
00001a  e7fa              B        |L47.18|
;;;1927   
                          ENDP


                          AREA ||i.wpa_driver_wext_mlme||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_mlme PROC
;;;1757   
;;;1758   static int wpa_driver_wext_mlme(struct wpa_driver_wext_data *drv,
000000  b510              PUSH     {r4,lr}
;;;1759   				const u8 *addr, int cmd, int reason_code)
;;;1760   {
000002  4604              MOV      r4,r0
;;;1761   	return 0;
000004  2000              MOVS     r0,#0
;;;1762   #if 0
;;;1763   	struct iwreq iwr;
;;;1764   	struct iw_mlme mlme;
;;;1765   	int ret = 0;
;;;1766   
;;;1767   	os_memset(&iwr, 0, sizeof(iwr));
;;;1768   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1769   	os_memset(&mlme, 0, sizeof(mlme));
;;;1770   	mlme.cmd = cmd;
;;;1771   	mlme.reason_code = reason_code;
;;;1772   	mlme.addr.sa_family = ARPHRD_ETHER;
;;;1773   	os_memcpy(mlme.addr.sa_data, addr, ETH_ALEN);
;;;1774   	iwr.u.data.pointer = (caddr_t) &mlme;
;;;1775   	iwr.u.data.length = sizeof(mlme);
;;;1776   
;;;1777   	if (ioctl(drv->ioctl_sock, SIOCSIWMLME, &iwr) < 0) {
;;;1778   		perror("ioctl[SIOCSIWMLME]");
;;;1779   		ret = -1;
;;;1780   	}
;;;1781   
;;;1782   	return ret;
;;;1783   #endif
;;;1784   }
000006  bd10              POP      {r4,pc}
;;;1785   
                          ENDP


                          AREA ||i.wpa_driver_wext_own_ifindex||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_own_ifindex PROC
;;;626    
;;;627    static int wpa_driver_wext_own_ifindex(struct wpa_driver_wext_data *drv,
000000  b510              PUSH     {r4,lr}
;;;628    				       int ifindex, u8 *buf, size_t len)
;;;629    {
000002  4604              MOV      r4,r0
;;;630    	return 0;
000004  2000              MOVS     r0,#0
;;;631    #if 0
;;;632    	if (drv->ifindex == ifindex || drv->ifindex2 == ifindex)
;;;633    		return 1;
;;;634    
;;;635    	if (drv->if_removed && wpa_driver_wext_own_ifname(drv, buf, len)) {
;;;636    		drv->ifindex = if_nametoindex(drv->ifname);
;;;637    		wpa_printf(MSG_DEBUG, "WEXT: Update ifindex for a removed "
;;;638    			   "interface");
;;;639    		wpa_driver_wext_finish_drv_init(drv);
;;;640    		return 1;
;;;641    	}
;;;642    
;;;643    	return 0;
;;;644    #endif
;;;645    }
000006  bd10              POP      {r4,pc}
;;;646    
                          ENDP


                          AREA ||i.wpa_driver_wext_own_ifname||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_own_ifname PROC
;;;601    
;;;602    static int wpa_driver_wext_own_ifname(struct wpa_driver_wext_data *drv,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;603    				      u8 *buf, size_t len)
;;;604    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;605    	int attrlen, rta_len;
;;;606    	struct rtattr *attr;
;;;607    
;;;608    	attrlen = len;
00000a  4645              MOV      r5,r8
;;;609    	attr = (struct rtattr *) buf;
00000c  463c              MOV      r4,r7
;;;610    
;;;611    	rta_len = RTA_ALIGN(sizeof(struct rtattr));
00000e  f04f0904          MOV      r9,#4
;;;612    	while (RTA_OK(attr, attrlen)) {
000012  e017              B        |L50.68|
                  |L50.20|
;;;613    		if (attr->rta_type == IFLA_IFNAME) {
000014  8860              LDRH     r0,[r4,#2]
000016  2803              CMP      r0,#3
000018  d10a              BNE      |L50.48|
;;;614    			if (os_strcmp(((char *) attr) + rta_len, drv->ifname)
00001a  eb040009          ADD      r0,r4,r9
00001e  f1060110          ADD      r1,r6,#0x10
000022  f7fffffe          BL       os_strcmp
000026  b910              CBNZ     r0,|L50.46|
;;;615    			    == 0)
;;;616    				return 1;
000028  2001              MOVS     r0,#1
                  |L50.42|
;;;617    			else
;;;618    				break;
;;;619    		}
;;;620    		attr = RTA_NEXT(attr, attrlen);
;;;621    	}
;;;622    
;;;623    	return 0;
;;;624    }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L50.46|
00002e  e011              B        |L50.84|
                  |L50.48|
000030  8820              LDRH     r0,[r4,#0]            ;620
000032  1cc0              ADDS     r0,r0,#3              ;620
000034  f0200003          BIC      r0,r0,#3              ;620
000038  1a2d              SUBS     r5,r5,r0              ;620
00003a  8820              LDRH     r0,[r4,#0]            ;620
00003c  1cc0              ADDS     r0,r0,#3              ;620
00003e  f0200003          BIC      r0,r0,#3              ;620
000042  4404              ADD      r4,r4,r0              ;620
                  |L50.68|
000044  2d00              CMP      r5,#0                 ;612
000046  dd05              BLE      |L50.84|
000048  8820              LDRH     r0,[r4,#0]            ;612
00004a  2804              CMP      r0,#4                 ;612
00004c  d302              BCC      |L50.84|
00004e  8820              LDRH     r0,[r4,#0]            ;612
000050  42a8              CMP      r0,r5                 ;612
000052  dddf              BLE      |L50.20|
                  |L50.84|
000054  bf00              NOP                            ;618
000056  2000              MOVS     r0,#0                 ;623
000058  e7e7              B        |L50.42|
;;;625    
                          ENDP


                          AREA ||i.wpa_driver_wext_pmksa||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_pmksa PROC
;;;2180   
;;;2181   static int wpa_driver_wext_pmksa(struct wpa_driver_wext_data *drv,
000000  b510              PUSH     {r4,lr}
;;;2182   				 u32 cmd, const u8 *bssid, const u8 *pmkid)
;;;2183   {
000002  4604              MOV      r4,r0
;;;2184   
;;;2185   	return 0;
000004  2000              MOVS     r0,#0
;;;2186   #if 0
;;;2187   	struct iwreq iwr;
;;;2188   	struct iw_pmksa pmksa;
;;;2189   	int ret = 0;
;;;2190   
;;;2191   	os_memset(&iwr, 0, sizeof(iwr));
;;;2192   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;2193   	os_memset(&pmksa, 0, sizeof(pmksa));
;;;2194   	pmksa.cmd = cmd;
;;;2195   	pmksa.bssid.sa_family = ARPHRD_ETHER;
;;;2196   	if (bssid)
;;;2197   		os_memcpy(pmksa.bssid.sa_data, bssid, ETH_ALEN);
;;;2198   	if (pmkid)
;;;2199   		os_memcpy(pmksa.pmkid, pmkid, IW_PMKID_LEN);
;;;2200   	iwr.u.data.pointer = (caddr_t) &pmksa;
;;;2201   	iwr.u.data.length = sizeof(pmksa);
;;;2202   
;;;2203   	if (ioctl(drv->ioctl_sock, SIOCSIWPMKSA, &iwr) < 0) {
;;;2204   		if (errno != EOPNOTSUPP)
;;;2205   			perror("ioctl[SIOCSIWPMKSA]");
;;;2206   		ret = -1;
;;;2207   	}
;;;2208   
;;;2209   	return ret;
;;;2210   #endif
;;;2211   }
000006  bd10              POP      {r4,pc}
;;;2212   
                          ENDP


                          AREA ||i.wpa_driver_wext_remove_pmkid||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_remove_pmkid PROC
;;;2221   
;;;2222   static int wpa_driver_wext_remove_pmkid(void *priv, const u8 *bssid,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2223   		 			const u8 *pmkid)
;;;2224   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2225   	struct wpa_driver_wext_data *drv = priv;
00000a  4627              MOV      r7,r4
;;;2226   	return wpa_driver_wext_pmksa(drv, IW_PMKSA_REMOVE, bssid, pmkid);
00000c  4633              MOV      r3,r6
00000e  462a              MOV      r2,r5
000010  2102              MOVS     r1,#2
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       wpa_driver_wext_pmksa
;;;2227   }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;2228   
                          ENDP


                          AREA ||i.wpa_driver_wext_scan||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_scan PROC
;;;913     */
;;;914    int wpa_driver_wext_scan(void *priv, struct wpa_driver_scan_params *params)
000000  4602              MOV      r2,r0
;;;915    {
;;;916    	return 0;
000002  2000              MOVS     r0,#0
;;;917    #if 0
;;;918    	struct wpa_driver_wext_data *drv = priv;
;;;919    	struct iwreq iwr;
;;;920    	int ret = 0, timeout;
;;;921    	struct iw_scan_req req;
;;;922    	const u8 *ssid = params->ssids[0].ssid;
;;;923    	size_t ssid_len = params->ssids[0].ssid_len;
;;;924    
;;;925    	if (ssid_len > IW_ESSID_MAX_SIZE) {
;;;926    		wpa_printf(MSG_DEBUG, "%s: too long SSID (%lu)",
;;;927    			   __FUNCTION__, (unsigned long) ssid_len);
;;;928    		return -1;
;;;929    	}
;;;930    
;;;931    	os_memset(&iwr, 0, sizeof(iwr));
;;;932    	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;933    
;;;934    	if (ssid && ssid_len) {
;;;935    		os_memset(&req, 0, sizeof(req));
;;;936    		req.essid_len = ssid_len;
;;;937    		req.bssid.sa_family = ARPHRD_ETHER;
;;;938    		os_memset(req.bssid.sa_data, 0xff, ETH_ALEN);
;;;939    		os_memcpy(req.essid, ssid, ssid_len);
;;;940    		iwr.u.data.pointer = (caddr_t) &req;
;;;941    		iwr.u.data.length = sizeof(req);
;;;942    		iwr.u.data.flags = IW_SCAN_THIS_ESSID;
;;;943    	}
;;;944    
;;;945    	if (ioctl(drv->ioctl_sock, SIOCSIWSCAN, &iwr) < 0) {
;;;946    		perror("ioctl[SIOCSIWSCAN]");
;;;947    		ret = -1;
;;;948    	}
;;;949    
;;;950    	/* Not all drivers generate "scan completed" wireless event, so try to
;;;951    	 * read results after a timeout. */
;;;952    	timeout = 5;
;;;953    	if (drv->scan_complete_events) {
;;;954    		/*
;;;955    		 * The driver seems to deliver SIOCGIWSCAN events to notify
;;;956    		 * when scan is complete, so use longer timeout to avoid race
;;;957    		 * conditions with scanning and following association request.
;;;958    		 */
;;;959    		timeout = 30;
;;;960    	}
;;;961    	wpa_printf(MSG_DEBUG, "Scan requested (ret=%d) - scan timeout %d "
;;;962    		   "seconds", ret, timeout);
;;;963    	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
;;;964    	eloop_register_timeout(timeout, 0, wpa_driver_wext_scan_timeout, drv,
;;;965    			       drv->ctx);
;;;966    
;;;967    	return ret;
;;;968    #endif
;;;969    }
000004  4770              BX       lr
;;;970    
                          ENDP


                          AREA ||i.wpa_driver_wext_scan_timeout||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_scan_timeout PROC
;;;899     */
;;;900    void wpa_driver_wext_scan_timeout(void *eloop_ctx, void *timeout_ctx)
000000  b570              PUSH     {r4-r6,lr}
;;;901    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;902    	RUN_TEST;
000006  4b08              LDR      r3,|L54.40|
000008  4a08              LDR      r2,|L54.44|
00000a  f2403186          MOV      r1,#0x386
00000e  a008              ADR      r0,|L54.48|
000010  f7fffffe          BL       __2printf
;;;903    	wpa_printf(MSG_DEBUG, "Scan timeout - try to get results");
000014  a113              ADR      r1,|L54.100|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       wpa_printf
;;;904    	wpa_supplicant_event(timeout_ctx, EVENT_SCAN_RESULTS, NULL);
00001c  2200              MOVS     r2,#0
00001e  2103              MOVS     r1,#3
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       wpa_supplicant_event
;;;905    }
000026  bd70              POP      {r4-r6,pc}
;;;906    
                          ENDP

                  |L54.40|
                          DCD      ||.constdata||+0x348
                  |L54.44|
                          DCD      |symbol_number.222|
                  |L54.48|
000030  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000034  54455354
000038  203e3e3e
00003c  204c494e
000040  453a2564
000044  202c2c2c
000048  2046554e
00004c  4354494f
000050  4e3a2573
000054  202c2c2c
000058  2046494c
00005c  453a2573
000060  200d0a00
                  |L54.100|
000064  5363616e          DCB      "Scan timeout - try to get results",0
000068  2074696d
00006c  656f7574
000070  202d2074
000074  72792074
000078  6f206765
00007c  74207265
000080  73756c74
000084  7300    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.wpa_driver_wext_set_auth_alg||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_auth_alg PROC
;;;2098   
;;;2099   static int wpa_driver_wext_set_auth_alg(void *priv, int auth_alg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2100   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;2101   	struct wpa_driver_wext_data *drv = priv;
000008  46b8              MOV      r8,r7
;;;2102   	int algs = 0, res;
00000a  2400              MOVS     r4,#0
;;;2103   
;;;2104   	if (auth_alg & WPA_AUTH_ALG_OPEN)
00000c  f0150f01          TST      r5,#1
000010  d001              BEQ      |L55.22|
;;;2105   		algs |= IW_AUTH_ALG_OPEN_SYSTEM;
000012  f0440401          ORR      r4,r4,#1
                  |L55.22|
;;;2106   	if (auth_alg & WPA_AUTH_ALG_SHARED)
000016  f0150f02          TST      r5,#2
00001a  d001              BEQ      |L55.32|
;;;2107   		algs |= IW_AUTH_ALG_SHARED_KEY;
00001c  f0440402          ORR      r4,r4,#2
                  |L55.32|
;;;2108   	if (auth_alg & WPA_AUTH_ALG_LEAP)
000020  f0150f04          TST      r5,#4
000024  d001              BEQ      |L55.42|
;;;2109   		algs |= IW_AUTH_ALG_LEAP;
000026  f0440404          ORR      r4,r4,#4
                  |L55.42|
;;;2110   	if (algs == 0) {
00002a  b904              CBNZ     r4,|L55.46|
;;;2111   		/* at least one algorithm should be set */
;;;2112   		algs = IW_AUTH_ALG_OPEN_SYSTEM;
00002c  2401              MOVS     r4,#1
                  |L55.46|
;;;2113   	}
;;;2114   
;;;2115   	res = wpa_driver_wext_set_auth_param(drv, IW_AUTH_80211_AUTH_ALG,
00002e  4622              MOV      r2,r4
000030  2106              MOVS     r1,#6
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       wpa_driver_wext_set_auth_param
000038  4606              MOV      r6,r0
;;;2116   					     algs);
;;;2117   	drv->auth_alg_fallback = res == -2;
00003a  1cb0              ADDS     r0,r6,#2
00003c  d101              BNE      |L55.66|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L55.68|
                  |L55.66|
000042  2000              MOVS     r0,#0
                  |L55.68|
000044  f8c80074          STR      r0,[r8,#0x74]
;;;2118   	return res;
000048  4630              MOV      r0,r6
;;;2119   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;2120   
                          ENDP


                          AREA ||i.wpa_driver_wext_set_auth_param||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_auth_param PROC
;;;48     
;;;49     int wpa_driver_wext_set_auth_param(struct wpa_driver_wext_data *drv,
000000  4603              MOV      r3,r0
;;;50     				   int idx, u32 value)
;;;51     {
;;;52     	return 0;
000002  2000              MOVS     r0,#0
;;;53     #if 0
;;;54     	struct iwreq iwr;
;;;55     	int ret = 0;
;;;56     
;;;57     	os_memset(&iwr, 0, sizeof(iwr));
;;;58     	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;59     	iwr.u.param.flags = idx & IW_AUTH_INDEX;
;;;60     	iwr.u.param.value = value;
;;;61     
;;;62     	if (ioctl(drv->ioctl_sock, SIOCSIWAUTH, &iwr) < 0) {
;;;63     		if (errno != EOPNOTSUPP) {
;;;64     			wpa_printf(MSG_DEBUG, "WEXT: SIOCSIWAUTH(param %d "
;;;65     				   "value 0x%x) failed: %s)",
;;;66     				   idx, value, strerror(errno));
;;;67     		}
;;;68     		ret = errno == EOPNOTSUPP ? -2 : -1;
;;;69     	}
;;;70     
;;;71     	return ret;
;;;72     #endif
;;;73     }
000004  4770              BX       lr
;;;74     
                          ENDP


                          AREA ||i.wpa_driver_wext_set_bssid||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_set_bssid PROC
;;;110     */
;;;111    int wpa_driver_wext_set_bssid(void *priv, const u8 *bssid)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;113    	RUN_TEST;
000006  4b04              LDR      r3,|L57.24|
000008  4a04              LDR      r2,|L57.28|
00000a  2171              MOVS     r1,#0x71
00000c  a004              ADR      r0,|L57.32|
00000e  f7fffffe          BL       __2printf
;;;114    	return 0;
000012  2000              MOVS     r0,#0
;;;115    #if 0
;;;116    	struct wpa_driver_wext_data *drv = priv;
;;;117    	struct iwreq iwr;
;;;118    	int ret = 0;
;;;119    
;;;120    	os_memset(&iwr, 0, sizeof(iwr));
;;;121    	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;122    	iwr.u.ap_addr.sa_family = ARPHRD_ETHER;
;;;123    	if (bssid)
;;;124    		os_memcpy(iwr.u.ap_addr.sa_data, bssid, ETH_ALEN);
;;;125    	else
;;;126    		os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
;;;127    
;;;128    	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
;;;129    		perror("ioctl[SIOCSIWAP]");
;;;130    		ret = -1;
;;;131    	}
;;;132    
;;;133    	return ret;
;;;134    #endif
;;;135    }
000014  bd70              POP      {r4-r6,pc}
;;;136    
                          ENDP

000016  0000              DCW      0x0000
                  |L57.24|
                          DCD      ||.constdata||+0x348
                  |L57.28|
                          DCD      |symbol_number.216|
                  |L57.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_set_countermeasures||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_set_countermeasures PROC
;;;1731   
;;;1732   static int wpa_driver_wext_set_countermeasures(void *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;1733   					       int enabled)
;;;1734   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1735   	RUN_TEST;
000006  4b04              LDR      r3,|L58.24|
000008  4a04              LDR      r2,|L58.28|
00000a  f24061c7          MOV      r1,#0x6c7
00000e  a004              ADR      r0,|L58.32|
000010  f7fffffe          BL       __2printf
;;;1736   	return 0;
000014  2000              MOVS     r0,#0
;;;1737   #if 0
;;;1738   	struct wpa_driver_wext_data *drv = priv;
;;;1739   	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
;;;1740   	return wpa_driver_wext_set_auth_param(drv,
;;;1741   					      IW_AUTH_TKIP_COUNTERMEASURES,
;;;1742   					      enabled);
;;;1743   #endif
;;;1744   }
000016  bd70              POP      {r4-r6,pc}
;;;1745   
                          ENDP

                  |L58.24|
                          DCD      ||.constdata||+0x348
                  |L58.28|
                          DCD      |symbol_number.225|
                  |L58.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_set_drop_unencrypted||, CODE, READONLY, ALIGN=2

                  wpa_driver_wext_set_drop_unencrypted PROC
;;;1746   
;;;1747   static int wpa_driver_wext_set_drop_unencrypted(void *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;1748   						int enabled)
;;;1749   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1750   	struct wpa_driver_wext_data *drv = priv;
000006  4626              MOV      r6,r4
;;;1751   	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
000008  4a05              LDR      r2,|L59.32|
00000a  a106              ADR      r1,|L59.36|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       wpa_printf
;;;1752   	drv->use_crypt = enabled;
000012  6735              STR      r5,[r6,#0x70]
;;;1753   	return wpa_driver_wext_set_auth_param(drv, IW_AUTH_DROP_UNENCRYPTED,
000014  462a              MOV      r2,r5
000016  2105              MOVS     r1,#5
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       wpa_driver_wext_set_auth_param
;;;1754   					      enabled);
;;;1755   }
00001e  bd70              POP      {r4-r6,pc}
;;;1756   
                          ENDP

                  |L59.32|
                          DCD      |symbol_number.226|
                  |L59.36|
000024  257300            DCB      "%s",0
000027  00                DCB      0

                          AREA ||i.wpa_driver_wext_set_freq||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_freq PROC
;;;237     */
;;;238    int wpa_driver_wext_set_freq(void *priv, int freq)
000000  4602              MOV      r2,r0
;;;239    {
;;;240    	return 0;
000002  2000              MOVS     r0,#0
;;;241    #if 0
;;;242    	struct wpa_driver_wext_data *drv = priv;
;;;243    	struct iwreq iwr;
;;;244    	int ret = 0;
;;;245    
;;;246    	os_memset(&iwr, 0, sizeof(iwr));
;;;247    	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;248    	iwr.u.freq.m = freq * 100000;
;;;249    	iwr.u.freq.e = 1;
;;;250    
;;;251    	if (ioctl(drv->ioctl_sock, SIOCSIWFREQ, &iwr) < 0) {
;;;252    		perror("ioctl[SIOCSIWFREQ]");
;;;253    		ret = -1;
;;;254    	}
;;;255    
;;;256    	return ret;
;;;257    #endif
;;;258    }
000004  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.wpa_driver_wext_set_gen_ie||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_gen_ie PROC
;;;1871   
;;;1872   static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
000000  4603              MOV      r3,r0
;;;1873   				      size_t ie_len)
;;;1874   {
;;;1875   	return 0;
000002  2000              MOVS     r0,#0
;;;1876   #if 0
;;;1877   	struct wpa_driver_wext_data *drv = priv;
;;;1878   	struct iwreq iwr;
;;;1879   	int ret = 0;
;;;1880   
;;;1881   	os_memset(&iwr, 0, sizeof(iwr));
;;;1882   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1883   	iwr.u.data.pointer = (caddr_t) ie;
;;;1884   	iwr.u.data.length = ie_len;
;;;1885   
;;;1886   	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
;;;1887   		perror("ioctl[SIOCSIWGENIE]");
;;;1888   		ret = -1;
;;;1889   	}
;;;1890   
;;;1891   	return ret;
;;;1892   #endif
;;;1893   }
000004  4770              BX       lr
;;;1894   
                          ENDP


                          AREA ||i.wpa_driver_wext_set_key||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_key PROC
;;;1667    */
;;;1668   int wpa_driver_wext_set_key(const char *ifname, void *priv, enum wpa_alg alg,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1669   			    const u8 *addr, int key_idx,
;;;1670   			    int set_tx, const u8 *seq, size_t seq_len,
;;;1671   			    const u8 *key, size_t key_len)
;;;1672   {
000004  4681              MOV      r9,r0
000006  ac07              ADD      r4,sp,#0x1c
000008  e89410f0          LDM      r4,{r4-r7,r12}
00000c  f8dd8030          LDR      r8,[sp,#0x30]
;;;1673   	return 0;
000010  2000              MOVS     r0,#0
;;;1674   #if 0
;;;1675   	struct wpa_driver_wext_data *drv = priv;
;;;1676   	struct iwreq iwr;
;;;1677   	int ret = 0;
;;;1678   
;;;1679   	wpa_printf(MSG_DEBUG, "%s: alg=%d key_idx=%d set_tx=%d seq_len=%lu "
;;;1680   		   "key_len=%lu",
;;;1681   		   __FUNCTION__, alg, key_idx, set_tx,
;;;1682   		   (unsigned long) seq_len, (unsigned long) key_len);
;;;1683   
;;;1684   	ret = wpa_driver_wext_set_key_ext(drv, alg, addr, key_idx, set_tx,
;;;1685   					  seq, seq_len, key, key_len);
;;;1686   	if (ret == 0)
;;;1687   		return 0;
;;;1688   
;;;1689   	if (ret == -2 &&
;;;1690   	    (alg == WPA_ALG_NONE || alg == WPA_ALG_WEP)) {
;;;1691   		wpa_printf(MSG_DEBUG, "Driver did not support "
;;;1692   			   "SIOCSIWENCODEEXT, trying SIOCSIWENCODE");
;;;1693   		ret = 0;
;;;1694   	} else {
;;;1695   		wpa_printf(MSG_DEBUG, "Driver did not support "
;;;1696   			   "SIOCSIWENCODEEXT");
;;;1697   		return ret;
;;;1698   	}
;;;1699   
;;;1700   	os_memset(&iwr, 0, sizeof(iwr));
;;;1701   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1702   	iwr.u.encoding.flags = key_idx + 1;
;;;1703   	iwr.u.encoding.flags |= IW_ENCODE_TEMP;
;;;1704   	if (alg == WPA_ALG_NONE)
;;;1705   		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
;;;1706   	iwr.u.encoding.pointer = (caddr_t) key;
;;;1707   	iwr.u.encoding.length = key_len;
;;;1708   
;;;1709   	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
;;;1710   		perror("ioctl[SIOCSIWENCODE]");
;;;1711   		ret = -1;
;;;1712   	}
;;;1713   
;;;1714   	if (set_tx && alg != WPA_ALG_NONE) {
;;;1715   		os_memset(&iwr, 0, sizeof(iwr));
;;;1716   		os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1717   		iwr.u.encoding.flags = key_idx + 1;
;;;1718   		iwr.u.encoding.flags |= IW_ENCODE_TEMP;
;;;1719   		iwr.u.encoding.pointer = (caddr_t) NULL;
;;;1720   		iwr.u.encoding.length = 0;
;;;1721   		if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
;;;1722   			perror("ioctl[SIOCSIWENCODE] (set_tx)");
;;;1723   			ret = -1;
;;;1724   		}
;;;1725   	}
;;;1726   
;;;1727   	return ret;
;;;1728   #endif
;;;1729   }
000012  e8bd83f0          POP      {r4-r9,pc}
;;;1730   
                          ENDP


                          AREA ||i.wpa_driver_wext_set_key_ext||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_set_key_ext PROC
;;;1543   
;;;1544   static int wpa_driver_wext_set_key_ext(void *priv, enum wpa_alg alg,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1545   				       const u8 *addr, int key_idx,
;;;1546   				       int set_tx, const u8 *seq,
;;;1547   				       size_t seq_len,
;;;1548   				       const u8 *key, size_t key_len)
;;;1549   {
000004  4681              MOV      r9,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
00000a  ac0a              ADD      r4,sp,#0x28
00000c  e89401f0          LDM      r4,{r4-r8}
;;;1550   	RUN_TEST;
000010  4b04              LDR      r3,|L63.36|
000012  4a05              LDR      r2,|L63.40|
000014  f240610e          MOV      r1,#0x60e
000018  a004              ADR      r0,|L63.44|
00001a  f7fffffe          BL       __2printf
;;;1551   	return 0;
00001e  2000              MOVS     r0,#0
;;;1552   #if 0
;;;1553   	struct wpa_driver_wext_data *drv = priv;
;;;1554   	struct iwreq iwr;
;;;1555   	int ret = 0;
;;;1556   	struct iw_encode_ext *ext;
;;;1557   
;;;1558   	if (seq_len > IW_ENCODE_SEQ_MAX_SIZE) {
;;;1559   		wpa_printf(MSG_DEBUG, "%s: Invalid seq_len %lu",
;;;1560   			   __FUNCTION__, (unsigned long) seq_len);
;;;1561   		return -1;
;;;1562   	}
;;;1563   
;;;1564   	ext = os_zalloc(sizeof(*ext) + key_len);
;;;1565   	if (ext == NULL)
;;;1566   		return -1;
;;;1567   	os_memset(&iwr, 0, sizeof(iwr));
;;;1568   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1569   	iwr.u.encoding.flags = key_idx + 1;
;;;1570   	iwr.u.encoding.flags |= IW_ENCODE_TEMP;
;;;1571   	if (alg == WPA_ALG_NONE)
;;;1572   		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
;;;1573   	iwr.u.encoding.pointer = (caddr_t) ext;
;;;1574   	iwr.u.encoding.length = sizeof(*ext) + key_len;
;;;1575   
;;;1576   	if (addr == NULL ||
;;;1577   	    os_memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
;;;1578   		ext->ext_flags |= IW_ENCODE_EXT_GROUP_KEY;
;;;1579   	if (set_tx)
;;;1580   		ext->ext_flags |= IW_ENCODE_EXT_SET_TX_KEY;
;;;1581   
;;;1582   	ext->addr.sa_family = ARPHRD_ETHER;
;;;1583   	if (addr)
;;;1584   		os_memcpy(ext->addr.sa_data, addr, ETH_ALEN);
;;;1585   	else
;;;1586   		os_memset(ext->addr.sa_data, 0xff, ETH_ALEN);
;;;1587   	if (key && key_len) {
;;;1588   		os_memcpy(ext + 1, key, key_len);
;;;1589   		ext->key_len = key_len;
;;;1590   	}
;;;1591   	switch (alg) {
;;;1592   	case WPA_ALG_NONE:
;;;1593   		ext->alg = IW_ENCODE_ALG_NONE;
;;;1594   		break;
;;;1595   	case WPA_ALG_WEP:
;;;1596   		ext->alg = IW_ENCODE_ALG_WEP;
;;;1597   		break;
;;;1598   	case WPA_ALG_TKIP:
;;;1599   		ext->alg = IW_ENCODE_ALG_TKIP;
;;;1600   		break;
;;;1601   	case WPA_ALG_CCMP:
;;;1602   		ext->alg = IW_ENCODE_ALG_CCMP;
;;;1603   		break;
;;;1604   	case WPA_ALG_PMK:
;;;1605   		ext->alg = IW_ENCODE_ALG_PMK;
;;;1606   		break;
;;;1607   #ifdef CONFIG_IEEE80211W
;;;1608   	case WPA_ALG_IGTK:
;;;1609   		ext->alg = IW_ENCODE_ALG_AES_CMAC;
;;;1610   		break;
;;;1611   #endif /* CONFIG_IEEE80211W */
;;;1612   	default:
;;;1613   		wpa_printf(MSG_DEBUG, "%s: Unknown algorithm %d",
;;;1614   			   __FUNCTION__, alg);
;;;1615   		os_free(ext);
;;;1616   		return -1;
;;;1617   	}
;;;1618   
;;;1619   	if (seq && seq_len) {
;;;1620   		ext->ext_flags |= IW_ENCODE_EXT_RX_SEQ_VALID;
;;;1621   		os_memcpy(ext->rx_seq, seq, seq_len);
;;;1622   	}
;;;1623   
;;;1624   	if (ioctl(drv->ioctl_sock, SIOCSIWENCODEEXT, &iwr) < 0) {
;;;1625   		ret = errno == EOPNOTSUPP ? -2 : -1;
;;;1626   		if (errno == ENODEV) {
;;;1627   			/*
;;;1628   			 * ndiswrapper seems to be returning incorrect error
;;;1629   			 * code.. */
;;;1630   			ret = -2;
;;;1631   		}
;;;1632   
;;;1633   		perror("ioctl[SIOCSIWENCODEEXT]");
;;;1634   	}
;;;1635   
;;;1636   	os_free(ext);
;;;1637   	return ret;
;;;1638   #endif
;;;1639   }
000020  e8bd9ff0          POP      {r4-r12,pc}
;;;1640   
                          ENDP

                  |L63.36|
                          DCD      ||.constdata||+0x348
                  |L63.40|
                          DCD      |symbol_number.224|
                  |L63.44|
00002c  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000030  54455354
000034  203e3e3e
000038  204c494e
00003c  453a2564
000040  202c2c2c
000044  2046554e
000048  4354494f
00004c  4e3a2573
000050  202c2c2c
000054  2046494c
000058  453a2573
00005c  200d0a00

                          AREA ||i.wpa_driver_wext_set_mode||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_mode PROC
;;;2127    */
;;;2128   int wpa_driver_wext_set_mode(void *priv, int mode)
000000  4602              MOV      r2,r0
;;;2129   {
;;;2130   	return -1;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;2131   #if 0
;;;2132   	struct wpa_driver_wext_data *drv = priv;
;;;2133   	struct iwreq iwr;
;;;2134   	int ret = -1;
;;;2135   	unsigned int new_mode = mode ? IW_MODE_ADHOC : IW_MODE_INFRA;
;;;2136   
;;;2137   	os_memset(&iwr, 0, sizeof(iwr));
;;;2138   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;2139   	iwr.u.mode = new_mode;
;;;2140   	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) == 0) {
;;;2141   		ret = 0;
;;;2142   		goto done;
;;;2143   	}
;;;2144   
;;;2145   	if (errno != EBUSY) {
;;;2146   		perror("ioctl[SIOCSIWMODE]");
;;;2147   		goto done;
;;;2148   	}
;;;2149   
;;;2150   	/* mac80211 doesn't allow mode changes while the device is up, so if
;;;2151   	 * the device isn't in the mode we're about to change to, take device
;;;2152   	 * down, try to set the mode again, and bring it back up.
;;;2153   	 */
;;;2154   	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
;;;2155   		perror("ioctl[SIOCGIWMODE]");
;;;2156   		goto done;
;;;2157   	}
;;;2158   
;;;2159   	if (iwr.u.mode == new_mode) {
;;;2160   		ret = 0;
;;;2161   		goto done;
;;;2162   	}
;;;2163   
;;;2164   	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0) == 0) {
;;;2165   		/* Try to set the mode again while the interface is down */
;;;2166   		iwr.u.mode = new_mode;
;;;2167   		if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0)
;;;2168   			perror("ioctl[SIOCSIWMODE]");
;;;2169   		else
;;;2170   			ret = 0;
;;;2171   
;;;2172   		(void) linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1);
;;;2173   	}
;;;2174   
;;;2175   done:
;;;2176   	return ret;
;;;2177   #endif
;;;2178   }
000006  4770              BX       lr
;;;2179   
                          ENDP


                          AREA ||i.wpa_driver_wext_set_operstate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_set_operstate PROC
;;;2272   
;;;2273   int wpa_driver_wext_set_operstate(void *priv, int state)
000000  b570              PUSH     {r4-r6,lr}
;;;2274   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2275   	RUN_TEST;
000006  4b04              LDR      r3,|L65.24|
000008  4a04              LDR      r2,|L65.28|
00000a  f64001e3          MOV      r1,#0x8e3
00000e  a004              ADR      r0,|L65.32|
000010  f7fffffe          BL       __2printf
;;;2276   	return 0;
000014  2000              MOVS     r0,#0
;;;2277   #if 0
;;;2278   	struct wpa_driver_wext_data *drv = priv;
;;;2279   
;;;2280   	wpa_printf(MSG_DEBUG, "%s: operstate %d->%d (%s)",
;;;2281   		   __func__, drv->operstate, state, state ? "UP" : "DORMANT");
;;;2282   	drv->operstate = state;
;;;2283   	return netlink_send_oper_ifla(drv->netlink, drv->ifindex, -1,
;;;2284   				      state ? IF_OPER_UP : IF_OPER_DORMANT);
;;;2285   #endif
;;;2286   }
000016  bd70              POP      {r4-r6,pc}
;;;2287   
                          ENDP

                  |L65.24|
                          DCD      ||.constdata||+0x348
                  |L65.28|
                          DCD      |symbol_number.231|
                  |L65.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_driver_wext_set_psk||, CODE, READONLY, ALIGN=1

                  wpa_driver_wext_set_psk PROC
;;;1503   
;;;1504   static int wpa_driver_wext_set_psk(struct wpa_driver_wext_data *drv,
000000  4602              MOV      r2,r0
;;;1505   				   const u8 *psk)
;;;1506   {
;;;1507   	return 0;
000002  2000              MOVS     r0,#0
;;;1508   #if 0
;;;1509   	struct iw_encode_ext *ext;
;;;1510   	struct iwreq iwr;
;;;1511   	int ret;
;;;1512   
;;;1513   	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
;;;1514   
;;;1515   	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_4WAY_HANDSHAKE))
;;;1516   		return 0;
;;;1517   
;;;1518   	if (!psk)
;;;1519   		return 0;
;;;1520   
;;;1521   	os_memset(&iwr, 0, sizeof(iwr));
;;;1522   	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;1523   
;;;1524   	ext = os_zalloc(sizeof(*ext) + PMK_LEN);
;;;1525   	if (ext == NULL)
;;;1526   		return -1;
;;;1527   
;;;1528   	iwr.u.encoding.pointer = (caddr_t) ext;
;;;1529   	iwr.u.encoding.length = sizeof(*ext) + PMK_LEN;
;;;1530   	ext->key_len = PMK_LEN;
;;;1531   	os_memcpy(&ext->key, psk, ext->key_len);
;;;1532   	ext->alg = IW_ENCODE_ALG_PMK;
;;;1533   
;;;1534   	ret = ioctl(drv->ioctl_sock, SIOCSIWENCODEEXT, &iwr);
;;;1535   	if (ret < 0)
;;;1536   		perror("ioctl[SIOCSIWENCODEEXT] PMK");
;;;1537   	os_free(ext);
;;;1538   
;;;1539   	return ret;
;;;1540   #endif
;;;1541   }
000004  4770              BX       lr
;;;1542   
                          ENDP


                          AREA ||i.wpa_driver_wext_set_ssid||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  wpa_driver_wext_set_ssid PROC
;;;187     */
;;;188    int wpa_driver_wext_set_ssid(void *priv, const u8 *ssid, size_t ssid_len)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;190    	RUN_TEST;
000008  4b03              LDR      r3,|L67.24|
00000a  4a04              LDR      r2,|L67.28|
00000c  21be              MOVS     r1,#0xbe
00000e  a004              ADR      r0,|L67.32|
000010  f7fffffe          BL       __2printf
;;;191    	return 0;
000014  2000              MOVS     r0,#0
;;;192    #if 0
;;;193    	struct wpa_driver_wext_data *drv = priv;
;;;194    	struct iwreq iwr;
;;;195    	int ret = 0;
;;;196    	char buf[33];
;;;197    
;;;198    	if (ssid_len > 32)
;;;199    		return -1;
;;;200    
;;;201    	os_memset(&iwr, 0, sizeof(iwr));
;;;202    	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
;;;203    	/* flags: 1 = ESSID is active, 0 = not (promiscuous) */
;;;204    	iwr.u.essid.flags = (ssid_len != 0);
;;;205    	os_memset(buf, 0, sizeof(buf));
;;;206    	os_memcpy(buf, ssid, ssid_len);
;;;207    	iwr.u.essid.pointer = (caddr_t) buf;
;;;208    	if (drv->we_version_compiled < 21) {
;;;209    		/* For historic reasons, set SSID length to include one extra
;;;210    		 * character, C string nul termination, even though SSID is
;;;211    		 * really an octet string that should not be presented as a C
;;;212    		 * string. Some Linux drivers decrement the length by one and
;;;213    		 * can thus end up missing the last octet of the SSID if the
;;;214    		 * length is not incremented here. WE-21 changes this to
;;;215    		 * explicitly require the length _not_ to include nul
;;;216    		 * termination. */
;;;217    		if (ssid_len)
;;;218    			ssid_len++;
;;;219    	}
;;;220    	iwr.u.essid.length = ssid_len;
;;;221    
;;;222    	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
;;;223    		perror("ioctl[SIOCSIWESSID]");
;;;224    		ret = -1;
;;;225    	}
;;;226    
;;;227    	return ret;
;;;228    #endif
;;;229    }
000016  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

                  |L67.24|
                          DCD      ||.constdata||+0x348
                  |L67.28|
                          DCD      |symbol_number.218|
                  |L67.32|
000020  52554e5f          DCB      "RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",0
000024  54455354
000028  203e3e3e
00002c  204c494e
000030  453a2564
000034  202c2c2c
000038  2046554e
00003c  4354494f
000040  4e3a2573
000044  202c2c2c
000048  2046494c
00004c  453a2573
000050  200d0a00

                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpa_key_mgmt_ft||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_ft PROC
;;;65     
;;;66     static inline int wpa_key_mgmt_ft(int akm)
000000  4601              MOV      r1,r0
;;;67     {
;;;68     	return akm == WPA_KEY_MGMT_FT_PSK ||
000002  2940              CMP      r1,#0x40
000004  d001              BEQ      |L70.10|
;;;69     		akm == WPA_KEY_MGMT_FT_IEEE8021X;
000006  2920              CMP      r1,#0x20
000008  d101              BNE      |L70.14|
                  |L70.10|
00000a  2001              MOVS     r0,#1                 ;68
                  |L70.12|
;;;70     }
00000c  4770              BX       lr
                  |L70.14|
00000e  2000              MOVS     r0,#0                 ;68
000010  e7fc              B        |L70.12|
;;;71     
                          ENDP


                          AREA ||i.wpa_key_mgmt_sha256||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_sha256 PROC
;;;71     
;;;72     static inline int wpa_key_mgmt_sha256(int akm)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return akm == WPA_KEY_MGMT_PSK_SHA256 ||
000002  f5b17f80          CMP      r1,#0x100
000006  d001              BEQ      |L71.12|
;;;75     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
000008  2980              CMP      r1,#0x80
00000a  d101              BNE      |L71.16|
                  |L71.12|
00000c  2001              MOVS     r0,#1                 ;74
                  |L71.14|
;;;76     }
00000e  4770              BX       lr
                  |L71.16|
000010  2000              MOVS     r0,#0                 ;74
000012  e7fc              B        |L71.14|
;;;77     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_ieee8021x||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_ieee8021x PROC
;;;51     
;;;52     static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return akm == WPA_KEY_MGMT_IEEE8021X ||
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L72.14|
;;;55     		akm == WPA_KEY_MGMT_FT_IEEE8021X ||
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L72.14|
;;;56     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
00000a  2980              CMP      r1,#0x80
00000c  d101              BNE      |L72.18|
                  |L72.14|
00000e  2001              MOVS     r0,#1                 ;54
                  |L72.16|
;;;57     }
000010  4770              BX       lr
                  |L72.18|
000012  2000              MOVS     r0,#0                 ;54
000014  e7fc              B        |L72.16|
;;;58     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_psk||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_psk PROC
;;;58     
;;;59     static inline int wpa_key_mgmt_wpa_psk(int akm)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     	return akm == WPA_KEY_MGMT_PSK ||
000002  2902              CMP      r1,#2
000004  d004              BEQ      |L73.16|
;;;62     		akm == WPA_KEY_MGMT_FT_PSK ||
000006  2940              CMP      r1,#0x40
000008  d002              BEQ      |L73.16|
;;;63     		akm == WPA_KEY_MGMT_PSK_SHA256;
00000a  f5b17f80          CMP      r1,#0x100
00000e  d101              BNE      |L73.20|
                  |L73.16|
000010  2001              MOVS     r0,#1                 ;61
                  |L73.18|
;;;64     }
000012  4770              BX       lr
                  |L73.20|
000014  2000              MOVS     r0,#0                 ;61
000016  e7fc              B        |L73.18|
;;;65     
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L74.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L74.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L74.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L74.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L77.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L77.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L77.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L77.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L83.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       __aeabi_memcpy
                  |L83.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L90.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L90.32|
                  |L90.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L90.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L90.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L90.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L90.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L90.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L90.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L90.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  wpa_driver_wext_ops
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x5
                          DCD      wpa_driver_wext_get_bssid
                          DCD      wpa_driver_wext_get_ssid
                          DCD      wpa_driver_wext_set_key
                          DCD      wpa_driver_wext_init
                          DCD      wpa_driver_wext_deinit
                          DCD      0x00000000
                          DCD      wpa_driver_wext_set_countermeasures
                          DCD      wpa_driver_wext_deauthenticate
                          DCD      wpa_driver_wext_disassociate
                          DCD      wpa_driver_wext_associate
                          DCD      wpa_driver_wext_add_pmkid
                          DCD      wpa_driver_wext_remove_pmkid
                          DCD      wpa_driver_wext_flush_pmkid
                          DCD      wpa_driver_wext_get_capa
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      wpa_driver_wext_set_operstate
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      wpa_driver_wext_get_scan_results
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      wpa_driver_wext_scan
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  __FUNCTION__
000164  7770615f          DCB      0x77,0x70,0x61,0x5f
000168  64726976          DCB      0x64,0x72,0x69,0x76
00016c  65725f77          DCB      0x65,0x72,0x5f,0x77
000170  6578745f          DCB      0x65,0x78,0x74,0x5f
000174  6765745f          DCB      0x67,0x65,0x74,0x5f
000178  62737369          DCB      0x62,0x73,0x73,0x69
00017c  6400              DCB      0x64,0x00
                  |symbol_number.216|
00017e  7770              DCB      0x77,0x70
000180  615f6472          DCB      0x61,0x5f,0x64,0x72
000184  69766572          DCB      0x69,0x76,0x65,0x72
000188  5f776578          DCB      0x5f,0x77,0x65,0x78
00018c  745f7365          DCB      0x74,0x5f,0x73,0x65
000190  745f6273          DCB      0x74,0x5f,0x62,0x73
000194  73696400          DCB      0x73,0x69,0x64,0x00
                  |symbol_number.217|
000198  7770615f          DCB      0x77,0x70,0x61,0x5f
00019c  64726976          DCB      0x64,0x72,0x69,0x76
0001a0  65725f77          DCB      0x65,0x72,0x5f,0x77
0001a4  6578745f          DCB      0x65,0x78,0x74,0x5f
0001a8  6765745f          DCB      0x67,0x65,0x74,0x5f
0001ac  73736964          DCB      0x73,0x73,0x69,0x64
0001b0  00                DCB      0x00
                  |symbol_number.218|
0001b1  777061            DCB      0x77,0x70,0x61
0001b4  5f647269          DCB      0x5f,0x64,0x72,0x69
0001b8  7665725f          DCB      0x76,0x65,0x72,0x5f
0001bc  77657874          DCB      0x77,0x65,0x78,0x74
0001c0  5f736574          DCB      0x5f,0x73,0x65,0x74
0001c4  5f737369          DCB      0x5f,0x73,0x73,0x69
0001c8  6400              DCB      0x64,0x00
                  |symbol_number.219|
0001ca  7770              DCB      0x77,0x70
0001cc  615f6472          DCB      0x61,0x5f,0x64,0x72
0001d0  69766572          DCB      0x69,0x76,0x65,0x72
0001d4  5f776578          DCB      0x5f,0x77,0x65,0x78
0001d8  745f696e          DCB      0x74,0x5f,0x69,0x6e
0001dc  697400            DCB      0x69,0x74,0x00
                  |symbol_number.220|
0001df  77                DCB      0x77
0001e0  70615f64          DCB      0x70,0x61,0x5f,0x64
0001e4  72697665          DCB      0x72,0x69,0x76,0x65
0001e8  725f7765          DCB      0x72,0x5f,0x77,0x65
0001ec  78745f66          DCB      0x78,0x74,0x5f,0x66
0001f0  696e6973          DCB      0x69,0x6e,0x69,0x73
0001f4  685f6472          DCB      0x68,0x5f,0x64,0x72
0001f8  765f696e          DCB      0x76,0x5f,0x69,0x6e
0001fc  697400            DCB      0x69,0x74,0x00
                  |symbol_number.221|
0001ff  77                DCB      0x77
000200  70615f64          DCB      0x70,0x61,0x5f,0x64
000204  72697665          DCB      0x72,0x69,0x76,0x65
000208  725f7765          DCB      0x72,0x5f,0x77,0x65
00020c  78745f64          DCB      0x78,0x74,0x5f,0x64
000210  65696e69          DCB      0x65,0x69,0x6e,0x69
000214  7400              DCB      0x74,0x00
                  |symbol_number.222|
000216  7770              DCB      0x77,0x70
000218  615f6472          DCB      0x61,0x5f,0x64,0x72
00021c  69766572          DCB      0x69,0x76,0x65,0x72
000220  5f776578          DCB      0x5f,0x77,0x65,0x78
000224  745f7363          DCB      0x74,0x5f,0x73,0x63
000228  616e5f74          DCB      0x61,0x6e,0x5f,0x74
00022c  696d656f          DCB      0x69,0x6d,0x65,0x6f
000230  757400            DCB      0x75,0x74,0x00
                  |symbol_number.223|
000233  77                DCB      0x77
000234  70615f64          DCB      0x70,0x61,0x5f,0x64
000238  72697665          DCB      0x72,0x69,0x76,0x65
00023c  725f7765          DCB      0x72,0x5f,0x77,0x65
000240  78745f67          DCB      0x78,0x74,0x5f,0x67
000244  65745f73          DCB      0x65,0x74,0x5f,0x73
000248  63616e5f          DCB      0x63,0x61,0x6e,0x5f
00024c  72657375          DCB      0x72,0x65,0x73,0x75
000250  6c747300          DCB      0x6c,0x74,0x73,0x00
                  |symbol_number.224|
000254  7770615f          DCB      0x77,0x70,0x61,0x5f
000258  64726976          DCB      0x64,0x72,0x69,0x76
00025c  65725f77          DCB      0x65,0x72,0x5f,0x77
000260  6578745f          DCB      0x65,0x78,0x74,0x5f
000264  7365745f          DCB      0x73,0x65,0x74,0x5f
000268  6b65795f          DCB      0x6b,0x65,0x79,0x5f
00026c  65787400          DCB      0x65,0x78,0x74,0x00
                  |symbol_number.225|
000270  7770615f          DCB      0x77,0x70,0x61,0x5f
000274  64726976          DCB      0x64,0x72,0x69,0x76
000278  65725f77          DCB      0x65,0x72,0x5f,0x77
00027c  6578745f          DCB      0x65,0x78,0x74,0x5f
000280  7365745f          DCB      0x73,0x65,0x74,0x5f
000284  636f756e          DCB      0x63,0x6f,0x75,0x6e
000288  7465726d          DCB      0x74,0x65,0x72,0x6d
00028c  65617375          DCB      0x65,0x61,0x73,0x75
000290  72657300          DCB      0x72,0x65,0x73,0x00
                  |symbol_number.226|
000294  7770615f          DCB      0x77,0x70,0x61,0x5f
000298  64726976          DCB      0x64,0x72,0x69,0x76
00029c  65725f77          DCB      0x65,0x72,0x5f,0x77
0002a0  6578745f          DCB      0x65,0x78,0x74,0x5f
0002a4  7365745f          DCB      0x73,0x65,0x74,0x5f
0002a8  64726f70          DCB      0x64,0x72,0x6f,0x70
0002ac  5f756e65          DCB      0x5f,0x75,0x6e,0x65
0002b0  6e637279          DCB      0x6e,0x63,0x72,0x79
0002b4  70746564          DCB      0x70,0x74,0x65,0x64
0002b8  00                DCB      0x00
                  |symbol_number.227|
0002b9  777061            DCB      0x77,0x70,0x61
0002bc  5f647269          DCB      0x5f,0x64,0x72,0x69
0002c0  7665725f          DCB      0x76,0x65,0x72,0x5f
0002c4  77657874          DCB      0x77,0x65,0x78,0x74
0002c8  5f646561          DCB      0x5f,0x64,0x65,0x61
0002cc  75746865          DCB      0x75,0x74,0x68,0x65
0002d0  6e746963          DCB      0x6e,0x74,0x69,0x63
0002d4  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.228|
0002d8  7770615f          DCB      0x77,0x70,0x61,0x5f
0002dc  64726976          DCB      0x64,0x72,0x69,0x76
0002e0  65725f77          DCB      0x65,0x72,0x5f,0x77
0002e4  6578745f          DCB      0x65,0x78,0x74,0x5f
0002e8  64697361          DCB      0x64,0x69,0x73,0x61
0002ec  73736f63          DCB      0x73,0x73,0x6f,0x63
0002f0  69617465          DCB      0x69,0x61,0x74,0x65
0002f4  00                DCB      0x00
                  |symbol_number.229|
0002f5  777061            DCB      0x77,0x70,0x61
0002f8  5f647269          DCB      0x5f,0x64,0x72,0x69
0002fc  7665725f          DCB      0x76,0x65,0x72,0x5f
000300  77657874          DCB      0x77,0x65,0x78,0x74
000304  5f617373          DCB      0x5f,0x61,0x73,0x73
000308  6f636961          DCB      0x6f,0x63,0x69,0x61
00030c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.230|
00030f  77                DCB      0x77
000310  70615f64          DCB      0x70,0x61,0x5f,0x64
000314  72697665          DCB      0x72,0x69,0x76,0x65
000318  725f7765          DCB      0x72,0x5f,0x77,0x65
00031c  78745f67          DCB      0x78,0x74,0x5f,0x67
000320  65745f63          DCB      0x65,0x74,0x5f,0x63
000324  61706100          DCB      0x61,0x70,0x61,0x00
                  |symbol_number.231|
000328  7770615f          DCB      0x77,0x70,0x61,0x5f
00032c  64726976          DCB      0x64,0x72,0x69,0x76
000330  65725f77          DCB      0x65,0x72,0x5f,0x77
000334  6578745f          DCB      0x65,0x78,0x74,0x5f
000338  7365745f          DCB      0x73,0x65,0x74,0x5f
00033c  6f706572          DCB      0x6f,0x70,0x65,0x72
000340  73746174          DCB      0x73,0x74,0x61,0x74
000344  65000000          DCB      0x65,0x00,0x00,0x00
000348  2e2e5c77          DCB      0x2e,0x2e,0x5c,0x77
00034c  70615f73          DCB      0x70,0x61,0x5f,0x73
000350  7570706c          DCB      0x75,0x70,0x70,0x6c
000354  6963616e          DCB      0x69,0x63,0x61,0x6e
000358  742d302e          DCB      0x74,0x2d,0x30,0x2e
00035c  372e335c          DCB      0x37,0x2e,0x33,0x5c
000360  7770615f          DCB      0x77,0x70,0x61,0x5f
000364  73757070          DCB      0x73,0x75,0x70,0x70
000368  6c696361          DCB      0x6c,0x69,0x63,0x61
00036c  6e742d30          DCB      0x6e,0x74,0x2d,0x30
000370  2e372e33          DCB      0x2e,0x37,0x2e,0x33
000374  5c737263          DCB      0x5c,0x73,0x72,0x63
000378  5c647269          DCB      0x5c,0x64,0x72,0x69
00037c  76657273          DCB      0x76,0x65,0x72,0x73
000380  5c647269          DCB      0x5c,0x64,0x72,0x69
000384  7665725f          DCB      0x76,0x65,0x72,0x5f
000388  77657874          DCB      0x77,0x65,0x78,0x74
00038c  2e630000          DCB      0x2e,0x63,0x00,0x00
000390  4d696368          DCB      0x4d,0x69,0x63,0x68
000394  61656c20          DCB      0x61,0x65,0x6c,0x20
000398  4d494320          DCB      0x4d,0x49,0x43,0x20
00039c  6661696c          DCB      0x66,0x61,0x69,0x6c
0003a0  75726520          DCB      0x75,0x72,0x65,0x20
0003a4  77697265          DCB      0x77,0x69,0x72,0x65
0003a8  6c657373          DCB      0x6c,0x65,0x73,0x73
0003ac  20657665          DCB      0x20,0x65,0x76,0x65
0003b0  6e743a20          DCB      0x6e,0x74,0x3a,0x20
0003b4  666c6167          DCB      0x66,0x6c,0x61,0x67
0003b8  733d3078          DCB      0x73,0x3d,0x30,0x78
0003bc  25782073          DCB      0x25,0x78,0x20,0x73
0003c0  72635f61          DCB      0x72,0x63,0x5f,0x61
0003c4  6464723d          DCB      0x64,0x64,0x72,0x3d
0003c8  25303278          DCB      0x25,0x30,0x32,0x78
0003cc  3a253032          DCB      0x3a,0x25,0x30,0x32
0003d0  783a2530          DCB      0x78,0x3a,0x25,0x30
0003d4  32783a25          DCB      0x32,0x78,0x3a,0x25
0003d8  3032783a          DCB      0x30,0x32,0x78,0x3a
0003dc  25303278          DCB      0x25,0x30,0x32,0x78
0003e0  3a253032          DCB      0x3a,0x25,0x30,0x32
0003e4  78000000          DCB      0x78,0x00,0x00,0x00
0003e8  504d4b49          DCB      0x50,0x4d,0x4b,0x49
0003ec  44206361          DCB      0x44,0x20,0x63,0x61
0003f0  6e646964          DCB      0x6e,0x64,0x69,0x64
0003f4  61746520          DCB      0x61,0x74,0x65,0x20
0003f8  77697265          DCB      0x77,0x69,0x72,0x65
0003fc  6c657373          DCB      0x6c,0x65,0x73,0x73
000400  20657665          DCB      0x20,0x65,0x76,0x65
000404  6e743a20          DCB      0x6e,0x74,0x3a,0x20
000408  666c6167          DCB      0x66,0x6c,0x61,0x67
00040c  733d3078          DCB      0x73,0x3d,0x30,0x78
000410  25782069          DCB      0x25,0x78,0x20,0x69
000414  6e646578          DCB      0x6e,0x64,0x65,0x78
000418  3d256420          DCB      0x3d,0x25,0x64,0x20
00041c  62737369          DCB      0x62,0x73,0x73,0x69
000420  643d2530          DCB      0x64,0x3d,0x25,0x30
000424  32783a25          DCB      0x32,0x78,0x3a,0x25
000428  3032783a          DCB      0x30,0x32,0x78,0x3a
00042c  25303278          DCB      0x25,0x30,0x32,0x78
000430  3a253032          DCB      0x3a,0x25,0x30,0x32
000434  783a2530          DCB      0x78,0x3a,0x25,0x30
000438  32783a25          DCB      0x32,0x78,0x3a,0x25
00043c  30327800          DCB      0x30,0x32,0x78,0x00
000440  496e7661          DCB      0x49,0x6e,0x76,0x61
000444  6c696420          DCB      0x6c,0x69,0x64,0x20
000448  66726571          DCB      0x66,0x72,0x65,0x71
00044c  20696e20          DCB      0x20,0x69,0x6e,0x20
000450  7363616e          DCB      0x73,0x63,0x61,0x6e
000454  20726573          DCB      0x20,0x72,0x65,0x73
000458  756c7473          DCB      0x75,0x6c,0x74,0x73
00045c  20284253          DCB      0x20,0x28,0x42,0x53
000460  5349443d          DCB      0x53,0x49,0x44,0x3d
000464  25303278          DCB      0x25,0x30,0x32,0x78
000468  3a253032          DCB      0x3a,0x25,0x30,0x32
00046c  783a2530          DCB      0x78,0x3a,0x25,0x30
000470  32783a25          DCB      0x32,0x78,0x3a,0x25
000474  3032783a          DCB      0x30,0x32,0x78,0x3a
000478  25303278          DCB      0x25,0x30,0x32,0x78
00047c  3a253032          DCB      0x3a,0x25,0x30,0x32
000480  78206d3d          DCB      0x78,0x20,0x6d,0x3d
000484  25642065          DCB      0x25,0x64,0x20,0x65
000488  3d256429          DCB      0x3d,0x25,0x64,0x29
00048c  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  77657874          DCB      "wext",0
000004  00      
000005  4c696e75          DCB      "Linux wireless extensions (generic)",0
000009  78207769
00000d  72656c65
000011  73732065
000015  7874656e
000019  73696f6e
00001d  73202867
000021  656e6572
000025  69632900
