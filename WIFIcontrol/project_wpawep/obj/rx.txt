; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\rx.o --depend=.\obj\rx.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\rx.crf ..\marvel\driver\src\rx.c]
                          THUMB

                          AREA ||i.lbs_process_rxed_packet||, CODE, READONLY, ALIGN=2

                  lbs_process_rxed_packet PROC
;;;52      */
;;;53     int lbs_process_rxed_packet(struct lbs_private *priv, char *buffer,u16 size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;54     {
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;55     	int ret = 0;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;56     	struct rxpackethdr *p_rx_pkt;
;;;57     	struct rxpd *p_rx_pd;
;;;58     	int hdrchop;
;;;59     	struct ethhdr *p_ethhdr;
;;;60     	const u8 rfc1042_eth_hdr[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
00000e  a11f              ADR      r1,|L1.140|
000010  c903              LDM      r1,{r0,r1}
000012  e9cd0100          STRD     r0,r1,[sp,#0]
;;;61     	struct eth_packet *rx_ethpkt=&priv->rx_pkt;//我们要的以太网数据报
000016  46d3              MOV      r11,r10
;;;62     	lbs_deb_enter(LBS_DEB_RX);
;;;63     	p_rx_pd = (struct rxpd *)buffer;//包的状态信息
000018  462e              MOV      r6,r5
;;;64     	p_rx_pkt = (struct rxpackethdr *) ((u8 *)p_rx_pd +
00001a  68b0              LDR      r0,[r6,#8]
00001c  1984              ADDS     r4,r0,r6
;;;65     		le32_to_cpu(p_rx_pd->pkt_ptr));//得到存放802.3的头信息的地址
;;;66     		
;;;67     //	lbs_deb_hex(LBS_DEB_RX, "RX Data: Before chop rxpd", buffer,
;;;68     	//	 min(size, 100));
;;;69     
;;;70     	if (size < (ETH_HLEN + 8 + sizeof(struct rxpd))) {
00001e  f1b90f2a          CMP      r9,#0x2a
000022  d205              BCS      |L1.48|
;;;71     		lbs_deb_rx("rx err: frame received with bad length\n");
000024  a01b              ADR      r0,|L1.148|
000026  f7fffffe          BL       __2printf
;;;72     		ret = 0;
00002a  2000              MOVS     r0,#0
00002c  9002              STR      r0,[sp,#8]
;;;73     		goto done;
00002e  e02a              B        |L1.134|
                  |L1.48|
;;;74     	}
;;;75     #ifdef MASK_DEBUG
;;;76     	lbs_deb_rx("rx data: skb->len - pkt_ptr = %d-%zd = %zd\n",
;;;77     		size, (size_t)le32_to_cpu(p_rx_pd->pkt_ptr),
;;;78     		size - (size_t)le32_to_cpu(p_rx_pd->pkt_ptr));
;;;79     
;;;80     	lbs_deb_hex(LBS_DEB_RX, "RX Data: Dest", p_rx_pkt->eth803_hdr.dest_addr,
;;;81     		sizeof(p_rx_pkt->eth803_hdr.dest_addr));
;;;82     	lbs_deb_hex(LBS_DEB_RX, "RX Data: Src", p_rx_pkt->eth803_hdr.src_addr,
;;;83     		sizeof(p_rx_pkt->eth803_hdr.src_addr));
;;;84     #endif
;;;85     	if (memcmp(&p_rx_pkt->rfc1042_hdr,
000030  2206              MOVS     r2,#6
000032  4669              MOV      r1,sp
000034  f104000e          ADD      r0,r4,#0xe
000038  f7fffffe          BL       memcmp
00003c  b988              CBNZ     r0,|L1.98|
;;;86     		   rfc1042_eth_hdr, sizeof(rfc1042_eth_hdr)) == 0) {//这是RFC1042中定义的SNAP头信息，比较是否是rfc1042封装的mac帧
;;;87     		/*
;;;88     		 *  Replace the 803 header and rfc1042 header (llc/snap) with an
;;;89     		 *    EthernetII header, keep the src/dst and snap_type (ethertype)
;;;90     		 *
;;;91     		 *  The firmware only passes up SNAP frames converting
;;;92     		 *    all RX Data from 802.11 to 802.2/LLC/SNAP frames.
;;;93     		 *
;;;94     		 *  To create the Ethernet II, just move the src, dst address right
;;;95     		 *    before the snap_type.
;;;96     		 */
;;;97     		 //marvel芯片给出的数据为802.11LLC层的数据包格式，有snap头，现在将其更改为802.3的
;;;98     		 //数据报格式，只要将802.11mac头信息中的源地址和目的地址复制到snap的右边即可，具体格式请参考相关标准的
;;;99     		 //mac帧格式
;;;100    		p_ethhdr = (struct ethhdr *)
00003e  f1040808          ADD      r8,r4,#8
;;;101    		    ((u8 *) & p_rx_pkt->eth803_hdr
;;;102    		     + sizeof(p_rx_pkt->eth803_hdr) + sizeof(p_rx_pkt->rfc1042_hdr)
;;;103    		     - sizeof(p_rx_pkt->eth803_hdr.dest_addr)
;;;104    		     - sizeof(p_rx_pkt->eth803_hdr.src_addr)
;;;105    		     - sizeof(p_rx_pkt->rfc1042_hdr.snap_type));//找出存放802.3 MAC的起始位置
;;;106    
;;;107    		memcpy(p_ethhdr->h_source, p_rx_pkt->eth803_hdr.src_addr,//直接覆盖,从后往前拷贝
000042  f8d40006          LDR      r0,[r4,#6]
000046  f8c80006          STR      r0,[r8,#6]
00004a  8960              LDRH     r0,[r4,#0xa]
00004c  f8a8000a          STRH     r0,[r8,#0xa]
;;;108    		       sizeof(p_ethhdr->h_source));
;;;109    		memcpy(p_ethhdr->h_dest, p_rx_pkt->eth803_hdr.dest_addr,
000050  6820              LDR      r0,[r4,#0]
000052  f8c80000          STR      r0,[r8,#0]
000056  88a0              LDRH     r0,[r4,#4]
000058  f8a80004          STRH     r0,[r8,#4]
;;;110    		       sizeof(p_ethhdr->h_dest));
;;;111    
;;;112    		/* Chop off the rxpd + the excess memory from the 802.2/llc/snap header
;;;113    		 *   that was removed
;;;114    		 */
;;;115    		hdrchop = (u8 *)p_ethhdr - (u8 *)p_rx_pd;//用于重新更改skb->data的地址，后面使用的是skb_pull
00005c  eba80706          SUB      r7,r8,r6
000060  e007              B        |L1.114|
                  |L1.98|
;;;116    	} else {
;;;117    		lbs_deb_hex(LBS_DEB_RX, "RX Data: LLC/SNAP",
000062  2308              MOVS     r3,#8
000064  f104020e          ADD      r2,r4,#0xe
000068  a114              ADR      r1,|L1.188|
00006a  0318              LSLS     r0,r3,#12
00006c  f7fffffe          BL       lbs_hex
;;;118    			(u8 *) & p_rx_pkt->rfc1042_hdr,
;;;119    			sizeof(p_rx_pkt->rfc1042_hdr));
;;;120    
;;;121    		/* Chop off the rxpd */
;;;122    		hdrchop = (u8 *)&p_rx_pkt->eth803_hdr - (u8 *)p_rx_pd;
000070  1ba7              SUBS     r7,r4,r6
                  |L1.114|
;;;123    	}
;;;124    
;;;125    	/* Chop off the leading header bytes so the skb points to the start of
;;;126    	 *   either the reconstructed EthII frame or the 802.2/llc/snap frame
;;;127    	 */
;;;128    	//skb_pull(skb, hdrchop);//去掉前面的rxtp以及802.11mac
;;;129    
;;;130    	rx_ethpkt->len=size-hdrchop;
000072  eba90007          SUB      r0,r9,r7
000076  f8ab0000          STRH     r0,[r11,#0]
;;;131    	rx_ethpkt->data=(char *)((char *)buffer+hdrchop);//这就是我们数据的真正存放地址
00007a  19e8              ADDS     r0,r5,r7
00007c  f8cb0004          STR      r0,[r11,#4]
;;;132    	//dbg_netdata("rx network data",rx_ethpkt->data,rx_ethpkt->len);
;;;133    	/* Take the data rate from the rxpd structure
;;;134    	 * only if the rate is auto
;;;135    	 */
;;;136    #if 0
;;;137    	if (priv->enablehwauto)
;;;138    		priv->cur_rate = lbs_fw_index_to_data_rate(p_rx_pd->rx_rate);//记录下当前数据传输的速率
;;;139    
;;;140    	lbs_compute_rssi(priv, p_rx_pd);//副产品，计算RSSI信号强度
;;;141    #endif
;;;142    	ret = 0;
000080  2000              MOVS     r0,#0
000082  9002              STR      r0,[sp,#8]
;;;143    done:
000084  bf00              NOP      
                  |L1.134|
;;;144    	lbs_deb_leave_args(LBS_DEB_RX, ret);
;;;145    	return ret;
000086  9802              LDR      r0,[sp,#8]
;;;146    }
000088  e8bd8ffe          POP      {r1-r11,pc}
;;;147    
                          ENDP

                  |L1.140|
00008c  aaaa0300          DCB      170,170,3,0
000090  00                DCB      0
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L1.148|
000094  72782065          DCB      "rx err: frame received with bad length\n",0
000098  72723a20
00009c  6672616d
0000a0  65207265
0000a4  63656976
0000a8  65642077
0000ac  69746820
0000b0  62616420
0000b4  6c656e67
0000b8  74680a00
                  |L1.188|
0000bc  52582044          DCB      "RX Data: LLC/SNAP",0
0000c0  6174613a
0000c4  204c4c43
0000c8  2f534e41
0000cc  5000    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.wait_for_data_end||, CODE, READONLY, ALIGN=2

                  wait_for_data_end PROC
;;;148    
;;;149    int  wait_for_data_end(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;150    {	
;;;151    	struct lbs_private *priv=pgmarvel_priv;
000002  4811              LDR      r0,|L3.72|
000004  6806              LDR      r6,[r0,#0]  ; pgmarvel_priv
;;;152    	struct if_sdio_card *card=priv->card;
000006  6ab5              LDR      r5,[r6,#0x28]
;;;153    	u8 cause;
;;;154    	int ret;
;;;155    	while(1){
000008  e01a              B        |L3.64|
                  |L3.10|
;;;156    		cause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);
00000a  466a              MOV      r2,sp
00000c  2105              MOVS     r1,#5
00000e  6828              LDR      r0,[r5,#0]
000010  f7fffffe          BL       sdio_readb
000014  4604              MOV      r4,r0
;;;157    		//读取中断状态，这个是网卡内部的中断状态寄存器,和sdio控制器的中断状态寄存器没有关系
;;;158    		if (ret){
000016  9800              LDR      r0,[sp,#0]
000018  b120              CBZ      r0,|L3.36|
;;;159    			printk("marvel interrupt error!\n");
00001a  a00c              ADR      r0,|L3.76|
00001c  f7fffffe          BL       __2printf
;;;160    			return ret;
000020  9800              LDR      r0,[sp,#0]
                  |L3.34|
;;;161    		}
;;;162    		if (cause & IF_SDIO_H_INT_DNLD){//卡响应命令产生的中断，表明卡正常接收到命令
;;;163    			sdio_writeb(card->func, ~IF_SDIO_H_INT_DNLD,IF_SDIO_H_INT_STATUS, &ret);//请中断挂起标志位
;;;164    			if (ret)
;;;165    				return ret;
;;;166    			break;
;;;167    		}
;;;168    	}
;;;169            return 0;
;;;170    }
000022  bdf8              POP      {r3-r7,pc}
                  |L3.36|
000024  f0140f02          TST      r4,#2                 ;162
000028  d00a              BEQ      |L3.64|
00002a  466b              MOV      r3,sp                 ;163
00002c  2205              MOVS     r2,#5                 ;163
00002e  21fd              MOVS     r1,#0xfd              ;163
000030  6828              LDR      r0,[r5,#0]            ;163
000032  f7fffffe          BL       sdio_writeb
000036  9800              LDR      r0,[sp,#0]            ;164
000038  b108              CBZ      r0,|L3.62|
00003a  9800              LDR      r0,[sp,#0]            ;165
00003c  e7f1              B        |L3.34|
                  |L3.62|
00003e  e000              B        |L3.66|
                  |L3.64|
000040  e7e3              B        |L3.10|
                  |L3.66|
000042  bf00              NOP                            ;166
000044  2000              MOVS     r0,#0                 ;169
000046  e7ec              B        |L3.34|
;;;171    
                          ENDP

                  |L3.72|
                          DCD      pgmarvel_priv
                  |L3.76|
00004c  6d617276          DCB      "marvel interrupt error!\n",0
000050  656c2069
000054  6e746572
000058  72757074
00005c  20657272
000060  6f72210a
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L4.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L4.32|
                  |L4.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L4.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L4.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L4.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L4.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L4.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L4.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0
