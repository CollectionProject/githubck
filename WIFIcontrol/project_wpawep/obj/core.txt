; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\core.o --depend=.\obj\core.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\core.crf ..\sdio\src\core.c]
                          THUMB

                          AREA ||i.ffs||, CODE, READONLY, ALIGN=1

                  ||ffs|| PROC
;;;14     
;;;15     static int ffs(int x)
000000  4601              MOV      r1,r0
;;;16     {
;;;17         int r = 1;
000002  2201              MOVS     r2,#1
;;;18     
;;;19         if (!x)
000004  b909              CBNZ     r1,|L1.10|
;;;20             return 0;
000006  2000              MOVS     r0,#0
                  |L1.8|
;;;21         if (!(x & 0xffff)) {
;;;22             x >>= 16;
;;;23             r += 16;
;;;24         }
;;;25         if (!(x & 0xff)) {
;;;26             x >>= 8;
;;;27             r += 8;
;;;28         }
;;;29         if (!(x & 0xf)) {
;;;30             x >>= 4;
;;;31             r += 4;
;;;32         }
;;;33         if (!(x & 3)) {
;;;34             x >>= 2;
;;;35             r += 2;
;;;36         }
;;;37         if (!(x & 1)) {
;;;38             x >>= 1;
;;;39             r += 1;
;;;40         }
;;;41         return r;
;;;42     }
000008  4770              BX       lr
                  |L1.10|
00000a  0408              LSLS     r0,r1,#16             ;21
00000c  0c00              LSRS     r0,r0,#16             ;21
00000e  d101              BNE      |L1.20|
000010  1409              ASRS     r1,r1,#16             ;22
000012  3210              ADDS     r2,r2,#0x10           ;23
                  |L1.20|
000014  f0110fff          TST      r1,#0xff              ;25
000018  d101              BNE      |L1.30|
00001a  1209              ASRS     r1,r1,#8              ;26
00001c  3208              ADDS     r2,r2,#8              ;27
                  |L1.30|
00001e  f0110f0f          TST      r1,#0xf               ;29
000022  d101              BNE      |L1.40|
000024  1109              ASRS     r1,r1,#4              ;30
000026  1d12              ADDS     r2,r2,#4              ;31
                  |L1.40|
000028  f0110f03          TST      r1,#3                 ;33
00002c  d101              BNE      |L1.50|
00002e  1089              ASRS     r1,r1,#2              ;34
000030  1c92              ADDS     r2,r2,#2              ;35
                  |L1.50|
000032  f0110f01          TST      r1,#1                 ;37
000036  d101              BNE      |L1.60|
000038  1049              ASRS     r1,r1,#1              ;38
00003a  1c52              ADDS     r2,r2,#1              ;39
                  |L1.60|
00003c  4610              MOV      r0,r2                 ;41
00003e  e7e3              B        |L1.8|
;;;43     
                          ENDP


                          AREA ||i.fls||, CODE, READONLY, ALIGN=1

                  ||fls|| PROC
;;;43     
;;;44     static  int fls(int x)
000000  4601              MOV      r1,r0
;;;45     {
;;;46         int r = 32;
000002  2220              MOVS     r2,#0x20
;;;47     
;;;48         if (!x)
000004  b909              CBNZ     r1,|L2.10|
;;;49             return 0;
000006  2000              MOVS     r0,#0
                  |L2.8|
;;;50         if (!(x & 0xffff0000u)) {
;;;51             x <<= 16;
;;;52             r -= 16;
;;;53         }
;;;54         if (!(x & 0xff000000u)) {
;;;55             x <<= 8;
;;;56             r -= 8;
;;;57         }
;;;58         if (!(x & 0xf0000000u)) {
;;;59             x <<= 4;
;;;60             r -= 4;
;;;61         }
;;;62         if (!(x & 0xc0000000u)) {
;;;63             x <<= 2;
;;;64             r -= 2;
;;;65         }
;;;66         if (!(x & 0x80000000u)) {
;;;67             x <<= 1;
;;;68             r -= 1;
;;;69         }
;;;70         return r;
;;;71     }
000008  4770              BX       lr
                  |L2.10|
00000a  0c08              LSRS     r0,r1,#16             ;50
00000c  0400              LSLS     r0,r0,#16             ;50
00000e  d101              BNE      |L2.20|
000010  0409              LSLS     r1,r1,#16             ;51
000012  3a10              SUBS     r2,r2,#0x10           ;52
                  |L2.20|
000014  f0114f7f          TST      r1,#0xff000000        ;54
000018  d101              BNE      |L2.30|
00001a  0209              LSLS     r1,r1,#8              ;55
00001c  3a08              SUBS     r2,r2,#8              ;56
                  |L2.30|
00001e  f0114f70          TST      r1,#0xf0000000        ;58
000022  d101              BNE      |L2.40|
000024  0109              LSLS     r1,r1,#4              ;59
000026  1f12              SUBS     r2,r2,#4              ;60
                  |L2.40|
000028  f0114f40          TST      r1,#0xc0000000        ;62
00002c  d101              BNE      |L2.50|
00002e  0089              LSLS     r1,r1,#2              ;63
000030  1e92              SUBS     r2,r2,#2              ;64
                  |L2.50|
000032  f0114f00          TST      r1,#0x80000000        ;66
000036  d101              BNE      |L2.60|
000038  0049              LSLS     r1,r1,#1              ;67
00003a  1e52              SUBS     r2,r2,#1              ;68
                  |L2.60|
00003c  4610              MOV      r0,r2                 ;70
00003e  e7e3              B        |L2.8|
;;;72     
                          ENDP


                          AREA ||i.mmc_add_card||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  mmc_add_card PROC
;;;636     */
;;;637    int mmc_add_card(struct mmc_card *card)
000000  b538              PUSH     {r3-r5,lr}
;;;638    {
000002  4604              MOV      r4,r0
;;;639        const char *type;
;;;640    
;;;641        //dev_set_name(&card->dev, "%s:%04x", mmc_hostname(card->host), card->rca);
;;;642    
;;;643        switch (card->type) {
000004  68a0              LDR      r0,[r4,#8]
000006  b120              CBZ      r0,|L3.18|
000008  2801              CMP      r0,#1
00000a  d004              BEQ      |L3.22|
00000c  2802              CMP      r0,#2
00000e  d10b              BNE      |L3.40|
000010  e008              B        |L3.36|
                  |L3.18|
;;;644        case MMC_TYPE_MMC:
;;;645            type = "MMC";
000012  a51b              ADR      r5,|L3.128|
;;;646            break;
000014  e00a              B        |L3.44|
                  |L3.22|
;;;647        case MMC_TYPE_SD:
;;;648            type = "SD";
000016  a51b              ADR      r5,|L3.132|
;;;649            if (mmc_card_blockaddr(card))
000018  68e0              LDR      r0,[r4,#0xc]
00001a  f0100f08          TST      r0,#8
00001e  d000              BEQ      |L3.34|
;;;650                type = "SDHC";
000020  a519              ADR      r5,|L3.136|
                  |L3.34|
;;;651            break;
000022  e003              B        |L3.44|
                  |L3.36|
;;;652        case MMC_TYPE_SDIO:
;;;653            type = "SDIO";
000024  a51a              ADR      r5,|L3.144|
;;;654            break;
000026  e001              B        |L3.44|
                  |L3.40|
;;;655        default:
;;;656            type = "?";
000028  a51b              ADR      r5,|L3.152|
;;;657            break;
00002a  bf00              NOP      
                  |L3.44|
00002c  bf00              NOP                            ;646
;;;658        }
;;;659    
;;;660        if (mmc_host_is_spi(card->host)) {
00002e  6820              LDR      r0,[r4,#0]
000030  6940              LDR      r0,[r0,#0x14]
000032  f0100f10          TST      r0,#0x10
000036  d00d              BEQ      |L3.84|
;;;661            printk(KERN_INFO "%s: new %s%s card on SPI\n",
000038  68e0              LDR      r0,[r4,#0xc]
00003a  f0100f04          TST      r0,#4
00003e  d001              BEQ      |L3.68|
;;;662                   mmc_hostname(card->host),
;;;663                   mmc_card_highspeed(card) ? "high speed " : "",
000040  a016              ADR      r0,|L3.156|
000042  e000              B        |L3.70|
                  |L3.68|
000044  a011              ADR      r0,|L3.140|
                  |L3.70|
000046  4602              MOV      r2,r0
000048  462b              MOV      r3,r5
00004a  a117              ADR      r1,|L3.168|
00004c  a018              ADR      r0,|L3.176|
00004e  f7fffffe          BL       __2printf
000052  e00e              B        |L3.114|
                  |L3.84|
;;;664                   type);
;;;665        } else {
;;;666            printk(KERN_INFO "%s: new %s%s card at address %04x\n",
000054  6863              LDR      r3,[r4,#4]
000056  9300              STR      r3,[sp,#0]
000058  68e0              LDR      r0,[r4,#0xc]
00005a  f0100f04          TST      r0,#4
00005e  d001              BEQ      |L3.100|
;;;667                   mmc_hostname(card->host),
;;;668                   mmc_card_highspeed(card) ? "high speed " : "",
000060  a00e              ADR      r0,|L3.156|
000062  e000              B        |L3.102|
                  |L3.100|
000064  a009              ADR      r0,|L3.140|
                  |L3.102|
000066  4602              MOV      r2,r0
000068  462b              MOV      r3,r5
00006a  a10f              ADR      r1,|L3.168|
00006c  a017              ADR      r0,|L3.204|
00006e  f7fffffe          BL       __2printf
                  |L3.114|
;;;669                   type, card->rca);
;;;670        }
;;;671        /*下面这个device的注册会引发mmc_bus_type的相关动作，
;;;672    	但是这里MMC卡的驱动永远不会注册进来,所以他就是个孤魂
;;;673    	野鬼飘荡在bus上面，后面使用的是sdio_driver*/
;;;674        /*ret = device_add(&card->dev);
;;;675    	if (ret)
;;;676    		return ret;
;;;677    
;;;678    #ifdef CONFIG_DEBUG_FS
;;;679    	mmc_add_card_debugfs(card);
;;;680    #endif*/
;;;681    
;;;682        mmc_card_set_present(card);
000072  68e0              LDR      r0,[r4,#0xc]
000074  f0400001          ORR      r0,r0,#1
000078  60e0              STR      r0,[r4,#0xc]
;;;683    
;;;684        return 0;
00007a  2000              MOVS     r0,#0
;;;685    }
00007c  bd38              POP      {r3-r5,pc}
;;;686    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
000080  4d4d4300          DCB      "MMC",0
                  |L3.132|
000084  534400            DCB      "SD",0
000087  00                DCB      0
                  |L3.136|
000088  53444843          DCB      "SDHC"
                  |L3.140|
00008c  00                DCB      0
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L3.144|
000090  5344494f          DCB      "SDIO",0
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L3.152|
000098  3f00              DCB      "?",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L3.156|
00009c  68696768          DCB      "high speed ",0
0000a0  20737065
0000a4  65642000
                  |L3.168|
0000a8  77696669          DCB      "wifi",0
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L3.176|
0000b0  25733a20          DCB      "%s: new %s%s card on SPI\n",0
0000b4  6e657720
0000b8  25732573
0000bc  20636172
0000c0  64206f6e
0000c4  20535049
0000c8  0a00    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L3.204|
0000cc  25733a20          DCB      "%s: new %s%s card at address %04x\n",0
0000d0  6e657720
0000d4  25732573
0000d8  20636172
0000dc  64206174
0000e0  20616464
0000e4  72657373
0000e8  20253034
0000ec  780a00  
0000ef  00                DCB      0

                          AREA ||i.mmc_align_data_size||, CODE, READONLY, ALIGN=1

                  mmc_align_data_size PROC
;;;90      */
;;;91     unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
000000  4602              MOV      r2,r0
;;;92     {
;;;93         /*
;;;94     	 * FIXME: We don't have a system for the controller to tell
;;;95     	 * the core about its problems yet, so for now we just 32-bit
;;;96     	 * align the size.
;;;97     	 */
;;;98         sz = ((sz + 3) / 4) * 4;
000002  1cc8              ADDS     r0,r1,#3
000004  0880              LSRS     r0,r0,#2
000006  0081              LSLS     r1,r0,#2
;;;99     
;;;100        return sz;
000008  4608              MOV      r0,r1
;;;101    }
00000a  4770              BX       lr
;;;102    
                          ENDP


                          AREA ||i.mmc_alloc_card||, CODE, READONLY, ALIGN=2

                  mmc_alloc_card PROC
;;;612     */
;;;613    struct mmc_card *mmc_alloc_card(struct mmc_host *host)
000000  b570              PUSH     {r4-r6,lr}
;;;614    {
000002  4605              MOV      r5,r0
;;;615        static struct mmc_card marvel_gcard;//静态变量，代替malloc
;;;616        struct mmc_card *card=&marvel_gcard;
000004  4c04              LDR      r4,|L5.24|
;;;617        /*card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);
;;;618    	if (!card)
;;;619    		return ERR_PTR(-ENOMEM);*/
;;;620        memset(card,0,sizeof(struct mmc_card));
000006  21d4              MOVS     r1,#0xd4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;621        card->host = host;
00000e  6025              STR      r5,[r4,#0]
;;;622        host->card=card;//this is a bug
000010  656c              STR      r4,[r5,#0x54]
;;;623    
;;;624        /*	device_initialize(&card->dev);
;;;625    
;;;626    	card->dev.parent = mmc_classdev(host);
;;;627    	card->dev.bus = &mmc_bus_type;
;;;628    	card->dev.release = mmc_release_card;
;;;629    	card->dev.type = type;*/
;;;630    
;;;631        return card;
000012  4620              MOV      r0,r4
;;;632    }
000014  bd70              POP      {r4-r6,pc}
;;;633    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      marvel_gcard

                          AREA ||i.mmc_alloc_host||, CODE, READONLY, ALIGN=2

                  mmc_alloc_host PROC
;;;695    
;;;696    struct mmc_host *mmc_alloc_host(void)
000000  b510              PUSH     {r4,lr}
;;;697    {
;;;698        static struct mmc_host s3c2440_gsdiohost;
;;;699        struct mmc_host *host=&s3c2440_gsdiohost;
000002  4c08              LDR      r4,|L6.36|
;;;700        memset(host,0,sizeof(struct mmc_host));
000004  21dc              MOVS     r1,#0xdc
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       __aeabi_memclr4
;;;701    #define PAGE_CACHE_SIZE   (1<<12)// 4kB
;;;702        host->max_hw_segs = 1;
00000c  2001              MOVS     r0,#1
00000e  83a0              STRH     r0,[r4,#0x1c]
;;;703        host->max_phys_segs = 1;
000010  83e0              STRH     r0,[r4,#0x1e]
;;;704        host->max_seg_size = PAGE_CACHE_SIZE;
000012  0300              LSLS     r0,r0,#12
000014  61a0              STR      r0,[r4,#0x18]
;;;705    
;;;706        host->max_req_size = PAGE_CACHE_SIZE;
000016  6260              STR      r0,[r4,#0x24]
;;;707        host->max_blk_size = 512;
000018  10c0              ASRS     r0,r0,#3
00001a  62a0              STR      r0,[r4,#0x28]
;;;708        host->max_blk_count = PAGE_CACHE_SIZE / 512;
00001c  2008              MOVS     r0,#8
00001e  62e0              STR      r0,[r4,#0x2c]
;;;709    
;;;710        return host;
000020  4620              MOV      r0,r4
;;;711    }
000022  bd10              POP      {r4,pc}
;;;712    
                          ENDP

                  |L6.36|
                          DCD      s3c2440_gsdiohost

                          AREA ||i.mmc_go_idle||, CODE, READONLY, ALIGN=1

                  mmc_go_idle PROC
;;;511    
;;;512    int mmc_go_idle(struct mmc_host *host)
000000  b530              PUSH     {r4,r5,lr}
;;;513    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
;;;514        int err;
;;;515        struct mmc_command cmd;
;;;516    
;;;517        /*
;;;518    	 * Non-SPI hosts need to prevent chipselect going active during
;;;519    	 * GO_IDLE; that would put chips into SPI mode.  Remind them of
;;;520    	 * that in case of hardware that won't pull up DAT3/nCS otherwise.
;;;521    	 *
;;;522    	 * SPI hosts ignore ios.chip_select; it's managed according to
;;;523    	 * rules that must accomodate non-MMC slaves which this layer
;;;524    	 * won't even know about.
;;;525    	 */
;;;526        if (!mmc_host_is_spi(host)) {
000006  6960              LDR      r0,[r4,#0x14]
000008  f0100f10          TST      r0,#0x10
00000c  d106              BNE      |L7.28|
;;;527            mmc_set_chip_select(host, MMC_CS_HIGH);
00000e  2101              MOVS     r1,#1
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       mmc_set_chip_select
;;;528            mmc_delay(1);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       mmc_delay
                  |L7.28|
;;;529        }
;;;530    
;;;531        memset(&cmd, 0, sizeof(struct mmc_command));
00001c  212c              MOVS     r1,#0x2c
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       __aeabi_memclr4
;;;532    
;;;533        cmd.opcode = MMC_GO_IDLE_STATE;
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
;;;534        cmd.arg = 0;
000028  9001              STR      r0,[sp,#4]
;;;535        cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;
00002a  20c0              MOVS     r0,#0xc0
00002c  9006              STR      r0,[sp,#0x18]
;;;536    
;;;537        err = mmc_wait_for_cmd(host, &cmd, 0);
00002e  2200              MOVS     r2,#0
000030  4669              MOV      r1,sp
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       mmc_wait_for_cmd
000038  4605              MOV      r5,r0
;;;538    
;;;539        mmc_delay(10);
00003a  200a              MOVS     r0,#0xa
00003c  f7fffffe          BL       mmc_delay
;;;540    
;;;541        if (!mmc_host_is_spi(host)) {
000040  6960              LDR      r0,[r4,#0x14]
000042  f0100f10          TST      r0,#0x10
000046  d106              BNE      |L7.86|
;;;542            mmc_set_chip_select(host, MMC_CS_DONTCARE);
000048  2100              MOVS     r1,#0
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       mmc_set_chip_select
;;;543            mmc_delay(1);
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       mmc_delay
                  |L7.86|
;;;544        }
;;;545    
;;;546        host->use_spi_crc = 0;
000056  6c20              LDR      r0,[r4,#0x40]
000058  f0200001          BIC      r0,r0,#1
00005c  6420              STR      r0,[r4,#0x40]
;;;547    
;;;548        return err;
00005e  4628              MOV      r0,r5
;;;549    }
000060  b00b              ADD      sp,sp,#0x2c
000062  bd30              POP      {r4,r5,pc}
;;;550    
                          ENDP


                          AREA ||i.mmc_power_up||, CODE, READONLY, ALIGN=2

                  mmc_power_up PROC
;;;462     */
;;;463    static void mmc_power_up(struct mmc_host *host)
000000  b570              PUSH     {r4-r6,lr}
;;;464    {
000002  4604              MOV      r4,r0
;;;465        int bit;
;;;466    
;;;467        /* If ocr is set, we use it */
;;;468        if (host->ocr)
000004  6be0              LDR      r0,[r4,#0x3c]
000006  b120              CBZ      r0,|L8.18|
;;;469            bit = ffs(host->ocr) - 1;
000008  6be0              LDR      r0,[r4,#0x3c]
00000a  f7fffffe          BL       ||ffs||
00000e  1e45              SUBS     r5,r0,#1
000010  e003              B        |L8.26|
                  |L8.18|
;;;470        else
;;;471            bit = fls(host->ocr_avail) - 1;
000012  6920              LDR      r0,[r4,#0x10]
000014  f7fffffe          BL       ||fls||
000018  1e45              SUBS     r5,r0,#1
                  |L8.26|
;;;472    
;;;473        host->ios.vdd = bit;
00001a  86a5              STRH     r5,[r4,#0x34]
;;;474        //if (mmc_host_is_spi(host)) {
;;;475        if(0){
;;;476            host->ios.chip_select = MMC_CS_HIGH;
;;;477            host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
;;;478        } else {
;;;479            host->ios.chip_select = MMC_CS_DONTCARE;
00001c  2100              MOVS     r1,#0
00001e  2037              MOVS     r0,#0x37
000020  5501              STRB     r1,[r0,r4]
;;;480            host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
000022  2101              MOVS     r1,#1
000024  2036              MOVS     r0,#0x36
000026  5501              STRB     r1,[r0,r4]
;;;481        }
;;;482        host->ios.power_mode = MMC_POWER_UP;
000028  2038              MOVS     r0,#0x38
00002a  5501              STRB     r1,[r0,r4]
;;;483        host->ios.bus_width = MMC_BUS_WIDTH_1;
00002c  2100              MOVS     r1,#0
00002e  2039              MOVS     r0,#0x39
000030  5501              STRB     r1,[r0,r4]
;;;484        host->ios.timing = MMC_TIMING_LEGACY;
000032  203a              MOVS     r0,#0x3a
000034  5501              STRB     r1,[r0,r4]
;;;485        //mmc_set_ios(host);
;;;486    
;;;487        /*
;;;488    	 * This delay should be sufficient to allow the power supply
;;;489    	 * to reach the minimum voltage.
;;;490    	 */
;;;491        mmc_delay(1);
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       mmc_delay
;;;492        if (host->f_min > 400000) {
00003c  4909              LDR      r1,|L8.100|
00003e  68a0              LDR      r0,[r4,#8]
000040  4288              CMP      r0,r1
000042  d902              BLS      |L8.74|
;;;493            pr_warning("%s: Minimum clock frequency too high for "
;;;494                       "identification mode\n", mmc_hostname(host));
;;;495            host->ios.clock = host->f_min;
000044  68a0              LDR      r0,[r4,#8]
000046  6320              STR      r0,[r4,#0x30]
000048  e001              B        |L8.78|
                  |L8.74|
;;;496        } else
;;;497            host->ios.clock = 400000;
00004a  4806              LDR      r0,|L8.100|
00004c  6320              STR      r0,[r4,#0x30]
                  |L8.78|
;;;498    
;;;499        host->ios.power_mode = MMC_POWER_ON;
00004e  2102              MOVS     r1,#2
000050  2038              MOVS     r0,#0x38
000052  5501              STRB     r1,[r0,r4]
;;;500        mmc_set_ios(host);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       mmc_set_ios
;;;501    
;;;502        /*
;;;503    	 * This delay must be at least 74 clock sizes, or 1 ms, or the
;;;504    	 * time required to reach a stable voltage.
;;;505    	 */
;;;506        mmc_delay(1);//1ms
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       mmc_delay
;;;507    
;;;508        //	pr_debug("mmc power up ok!current realy clock=%dk(SDICON=%d)\n",50000/(rSDIPRE+1),rSDICON);
;;;509    }
000060  bd70              POP      {r4-r6,pc}
;;;510    
                          ENDP

000062  0000              DCW      0x0000
                  |L8.100|
                          DCD      0x00061a80

                          AREA ||i.mmc_request_done||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_u
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  mmc_request_done PROC
;;;153     */
;;;154    void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;155    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;156        struct mmc_command *cmd = mrq->cmd;
000008  682c              LDR      r4,[r5,#0]
;;;157        int err = cmd->error;
00000a  6a27              LDR      r7,[r4,#0x20]
;;;158    
;;;159        if (err && cmd->retries && mmc_host_is_spi(host)) {
00000c  b15f              CBZ      r7,|L9.38|
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  b148              CBZ      r0,|L9.38|
000012  6970              LDR      r0,[r6,#0x14]
000014  f0100f10          TST      r0,#0x10
000018  d005              BEQ      |L9.38|
;;;160            if (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)
00001a  68a0              LDR      r0,[r4,#8]
00001c  f0100f04          TST      r0,#4
000020  d001              BEQ      |L9.38|
;;;161                cmd->retries = 0;
000022  2000              MOVS     r0,#0
000024  61e0              STR      r0,[r4,#0x1c]
                  |L9.38|
;;;162        }
;;;163    
;;;164        if (err && cmd->retries) {//重试
000026  b197              CBZ      r7,|L9.78|
000028  69e0              LDR      r0,[r4,#0x1c]
00002a  b180              CBZ      r0,|L9.78|
;;;165            printk("%s: req failed (CMD%u): %d, retrying...\n",
00002c  463b              MOV      r3,r7
00002e  a10b              ADR      r1,|L9.92|
000030  a00c              ADR      r0,|L9.100|
000032  6822              LDR      r2,[r4,#0]
000034  f7fffffe          BL       __2printf
;;;166                   mmc_hostname(host), cmd->opcode, err);
;;;167    
;;;168            cmd->retries--;
000038  69e0              LDR      r0,[r4,#0x1c]
00003a  1e40              SUBS     r0,r0,#1
00003c  61e0              STR      r0,[r4,#0x1c]
;;;169            cmd->error = 0;
00003e  2000              MOVS     r0,#0
000040  6220              STR      r0,[r4,#0x20]
;;;170            host->ops->request(host, mrq);
000042  6870              LDR      r0,[r6,#4]
000044  4629              MOV      r1,r5
000046  6882              LDR      r2,[r0,#8]
000048  4630              MOV      r0,r6
00004a  4790              BLX      r2
00004c  e004              B        |L9.88|
                  |L9.78|
;;;171        } else {
;;;172            //led_trigger_event(host->led, LED_OFF);
;;;173    
;;;174            pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",
;;;175                     mmc_hostname(host), cmd->opcode, err,
;;;176                     cmd->resp[0], cmd->resp[1],
;;;177                     cmd->resp[2], cmd->resp[3]);
;;;178    
;;;179            if (mrq->data) {
;;;180                pr_debug("%s:     %d bytes transferred: %d\n",
;;;181                         mmc_hostname(host),
;;;182                         mrq->data->bytes_xfered, mrq->data->error);
;;;183            }
;;;184    
;;;185            if (mrq->stop) {
;;;186                pr_debug("%s:     (CMD%u): %d: %08x %08x %08x %08x\n",
;;;187                         mmc_hostname(host), mrq->stop->opcode,
;;;188                         mrq->stop->error,
;;;189                         mrq->stop->resp[0], mrq->stop->resp[1],
;;;190                         mrq->stop->resp[2], mrq->stop->resp[3]);
;;;191            }
;;;192    
;;;193            if (mrq->done)
00004e  6928              LDR      r0,[r5,#0x10]
000050  b110              CBZ      r0,|L9.88|
;;;194                mrq->done(mrq->done_data);
000052  e9d50103          LDRD     r0,r1,[r5,#0xc]
000056  4788              BLX      r1
                  |L9.88|
;;;195        }
;;;196    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;197    
                          ENDP

                  |L9.92|
00005c  77696669          DCB      "wifi",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L9.100|
000064  25733a20          DCB      "%s: req failed (CMD%u): %d, retrying...\n",0
000068  72657120
00006c  6661696c
000070  65642028
000074  434d4425
000078  75293a20
00007c  25642c20
000080  72657472
000084  79696e67
000088  2e2e2e0a
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.mmc_rescan||, CODE, READONLY, ALIGN=2

                  mmc_rescan PROC
;;;580    
;;;581    void  mmc_rescan(struct mmc_host *host)
000000  b538              PUSH     {r3-r5,lr}
;;;582    {
000002  4604              MOV      r4,r0
;;;583        u32 ocr;
;;;584        int err;
;;;585        mmc_power_up(host);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       mmc_power_up
;;;586        mmc_go_idle(host);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       mmc_go_idle
;;;587        err=mmc_send_if_cond(host, host->ocr_avail);
000010  4620              MOV      r0,r4
000012  6921              LDR      r1,[r4,#0x10]
000014  f7fffffe          BL       mmc_send_if_cond
000018  4605              MOV      r5,r0
;;;588        if(err)
;;;589            pr_debug("mmc card support SD 1.0 cards !\n");
;;;590        else
;;;591            pr_debug("mmc card support SD 2.0 cards !\n");
;;;592        /*
;;;593    	 * First we search for SDIO...
;;;594    	 */
;;;595        err = mmc_send_io_op_cond(host, 0, &ocr);
00001a  466a              MOV      r2,sp
00001c  2100              MOVS     r1,#0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       mmc_send_io_op_cond
000024  4605              MOV      r5,r0
;;;596        if (!err) {
000026  b95d              CBNZ     r5,|L10.64|
;;;597    
;;;598            pr_debug("IO op cond=0x%x\n",ocr);
;;;599            if (mmc_attach_sdio(host, ocr))
000028  4620              MOV      r0,r4
00002a  9900              LDR      r1,[sp,#0]
00002c  f7fffffe          BL       mmc_attach_sdio
000030  b118              CBZ      r0,|L10.58|
;;;600                //mmc_power_off(host);
;;;601                printk("power off sdio.\n");
000032  a004              ADR      r0,|L10.68|
000034  f7fffffe          BL       __2printf
000038  e002              B        |L10.64|
                  |L10.58|
;;;602            else
;;;603                printk("SD card probe [ok]!\n");
00003a  a007              ADR      r0,|L10.88|
00003c  f7fffffe          BL       __2printf
                  |L10.64|
;;;604        }
;;;605    
;;;606    }
000040  bd38              POP      {r3-r5,pc}
;;;607    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
000044  706f7765          DCB      "power off sdio.\n",0
000048  72206f66
00004c  66207364
000050  696f2e0a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L10.88|
000058  53442063          DCB      "SD card probe [ok]!\n",0
00005c  61726420
000060  70726f62
000064  65205b6f
000068  6b5d210a
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.mmc_select_voltage||, CODE, READONLY, ALIGN=1

                  mmc_select_voltage PROC
;;;555     */
;;;556    u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
000000  b570              PUSH     {r4-r6,lr}
;;;557    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;558        int bit;
;;;559    
;;;560        ocr &= host->ocr_avail;
000006  6930              LDR      r0,[r6,#0x10]
000008  4004              ANDS     r4,r4,r0
;;;561    
;;;562        bit = ffs(ocr);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       ||ffs||
000010  4605              MOV      r5,r0
;;;563        if (bit) {
000012  b145              CBZ      r5,|L11.38|
;;;564            bit -= 1;
000014  1e6d              SUBS     r5,r5,#1
;;;565    
;;;566            ocr &= 3 << bit;
000016  2003              MOVS     r0,#3
000018  40a8              LSLS     r0,r0,r5
00001a  4004              ANDS     r4,r4,r0
;;;567    
;;;568            host->ios.vdd = bit;
00001c  86b5              STRH     r5,[r6,#0x34]
;;;569            pr_debug("support vdd=%d",host->ios.vdd);
;;;570            mmc_set_ios(host);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       mmc_set_ios
000024  e000              B        |L11.40|
                  |L11.38|
;;;571        } else {
;;;572            pr_warning("%s: host doesn't support card's voltages\n",
;;;573                       mmc_hostname(host));
;;;574            ocr = 0;
000026  2400              MOVS     r4,#0
                  |L11.40|
;;;575        }
;;;576    
;;;577        return ocr;
000028  4620              MOV      r0,r4
;;;578    }
00002a  bd70              POP      {r4-r6,pc}
;;;579    
                          ENDP


                          AREA ||i.mmc_set_bus_mode||, CODE, READONLY, ALIGN=1

                  mmc_set_bus_mode PROC
;;;225     */
;;;226    void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;228        host->ios.bus_mode = mode;
000006  2036              MOVS     r0,#0x36
000008  5544              STRB     r4,[r0,r5]
;;;229        mmc_set_ios(host);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       mmc_set_ios
;;;230    }
000010  bd70              POP      {r4-r6,pc}
;;;231    
                          ENDP


                          AREA ||i.mmc_set_bus_width||, CODE, READONLY, ALIGN=1

                  mmc_set_bus_width PROC
;;;234     */
;;;235    void mmc_set_bus_width(struct mmc_host *host, unsigned int width)
000000  b570              PUSH     {r4-r6,lr}
;;;236    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;237        host->ios.bus_width = width;
000006  2039              MOVS     r0,#0x39
000008  5544              STRB     r4,[r0,r5]
;;;238        mmc_set_ios(host);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       mmc_set_ios
;;;239    }
000010  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP


                          AREA ||i.mmc_set_chip_select||, CODE, READONLY, ALIGN=1

                  mmc_set_chip_select PROC
;;;201     */
;;;202    void mmc_set_chip_select(struct mmc_host *host, int mode)
000000  b570              PUSH     {r4-r6,lr}
;;;203    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;204        host->ios.chip_select = mode;
000006  2037              MOVS     r0,#0x37
000008  5544              STRB     r4,[r0,r5]
;;;205        mmc_set_ios(host);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       mmc_set_ios
;;;206    }
000010  bd70              POP      {r4-r6,pc}
;;;207    
                          ENDP


                          AREA ||i.mmc_set_clock||, CODE, READONLY, ALIGN=1

                  mmc_set_clock PROC
;;;211     */
;;;212    void mmc_set_clock(struct mmc_host *host, unsigned int hz)
000000  b570              PUSH     {r4-r6,lr}
;;;213    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;214        //	WARN_ON(hz < host->f_min);
;;;215    
;;;216        if (hz > host->f_max)
000006  68e0              LDR      r0,[r4,#0xc]
000008  42a8              CMP      r0,r5
00000a  d200              BCS      |L15.14|
;;;217            hz = host->f_max;
00000c  68e5              LDR      r5,[r4,#0xc]
                  |L15.14|
;;;218    
;;;219        host->ios.clock = hz;
00000e  6325              STR      r5,[r4,#0x30]
;;;220        mmc_set_ios(host);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       mmc_set_ios
;;;221    }
000016  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP


                          AREA ||i.mmc_set_data_timeout||, CODE, READONLY, ALIGN=2

                  mmc_set_data_timeout PROC
;;;250     */
;;;251    void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
000000  b5f0              PUSH     {r4-r7,lr}
;;;252    {
;;;253        unsigned int mult;
;;;254    
;;;255        /*
;;;256    	 * SDIO cards only define an upper 1 s limit on access.
;;;257    	 */
;;;258        if (mmc_card_sdio(card)) {
000002  688a              LDR      r2,[r1,#8]
000004  2a02              CMP      r2,#2
000006  d104              BNE      |L16.18|
;;;259            data->timeout_ns = 1000000000;
000008  4a2b              LDR      r2,|L16.184|
00000a  6002              STR      r2,[r0,#0]
;;;260            data->timeout_clks = 0;
00000c  2200              MOVS     r2,#0
00000e  6042              STR      r2,[r0,#4]
                  |L16.16|
;;;261            return;
;;;262        }
;;;263    
;;;264        /*
;;;265    	 * SD cards use a 100 multiplier rather than 10
;;;266    	 */
;;;267        mult = mmc_card_sd(card) ? 100 : 10;
;;;268    
;;;269        /*
;;;270    	 * Scale up the multiplier (and therefore the timeout) by
;;;271    	 * the r2w factor for writes.
;;;272    	 */
;;;273        if (data->flags & MMC_DATA_WRITE)
;;;274            mult <<= card->csd.r2w_factor;
;;;275    
;;;276        data->timeout_ns = card->csd.tacc_ns * mult;
;;;277        data->timeout_clks = card->csd.tacc_clks * mult;
;;;278    
;;;279        /*
;;;280    	 * SD cards also have an upper limit on the timeout.
;;;281    	 */
;;;282        if (mmc_card_sd(card)) {
;;;283            unsigned int timeout_us, limit_us;
;;;284    
;;;285            timeout_us = data->timeout_ns / 1000;
;;;286            timeout_us += data->timeout_clks * 1000 /
;;;287                          (card->host->ios.clock / 1000);
;;;288    
;;;289            if (data->flags & MMC_DATA_WRITE)
;;;290                /*
;;;291    			 * The limit is really 250 ms, but that is
;;;292    			 * insufficient for some crappy cards.
;;;293    			 */
;;;294                limit_us = 300000;
;;;295            else
;;;296                limit_us = 100000;
;;;297    
;;;298            /*
;;;299    		 * SDHC cards always use these fixed values.
;;;300    		 */
;;;301            if (timeout_us > limit_us || mmc_card_blockaddr(card)) {
;;;302                data->timeout_ns = limit_us * 1000;
;;;303                data->timeout_clks = 0;
;;;304            }
;;;305        }
;;;306        /*
;;;307    	 * Some cards need very high timeouts if driven in SPI mode.
;;;308    	 * The worst observed timeout was 900ms after writing a
;;;309    	 * continuous stream of data until the internal logic
;;;310    	 * overflowed.
;;;311    	 */
;;;312        if (mmc_host_is_spi(card->host)) {
;;;313            if (data->flags & MMC_DATA_WRITE) {
;;;314                if (data->timeout_ns < 1000000000)
;;;315                    data->timeout_ns = 1000000000;	/* 1s */
;;;316            } else {
;;;317                if (data->timeout_ns < 100000000)
;;;318                    data->timeout_ns =  100000000;	/* 100ms */
;;;319            }
;;;320        }
;;;321    }
000010  bdf0              POP      {r4-r7,pc}
                  |L16.18|
000012  688a              LDR      r2,[r1,#8]            ;267
000014  2a01              CMP      r2,#1                 ;267
000016  d101              BNE      |L16.28|
000018  2264              MOVS     r2,#0x64              ;267
00001a  e000              B        |L16.30|
                  |L16.28|
00001c  220a              MOVS     r2,#0xa               ;267
                  |L16.30|
00001e  4613              MOV      r3,r2                 ;267
000020  6942              LDR      r2,[r0,#0x14]         ;273
000022  f4127f80          TST      r2,#0x100             ;273
000026  d001              BEQ      |L16.44|
000028  6e0a              LDR      r2,[r1,#0x60]         ;274
00002a  4093              LSLS     r3,r3,r2              ;274
                  |L16.44|
00002c  6dca              LDR      r2,[r1,#0x5c]         ;276
00002e  435a              MULS     r2,r3,r2              ;276
000030  6002              STR      r2,[r0,#0]            ;276
000032  2258              MOVS     r2,#0x58              ;277
000034  5a52              LDRH     r2,[r2,r1]            ;277
000036  435a              MULS     r2,r3,r2              ;277
000038  6042              STR      r2,[r0,#4]            ;277
00003a  688a              LDR      r2,[r1,#8]            ;282
00003c  2a01              CMP      r2,#1                 ;282
00003e  d123              BNE      |L16.136|
000040  f44f767a          MOV      r6,#0x3e8             ;285
000044  6805              LDR      r5,[r0,#0]            ;285
000046  fbb5f4f6          UDIV     r4,r5,r6              ;285
00004a  680d              LDR      r5,[r1,#0]            ;286
00004c  6b2d              LDR      r5,[r5,#0x30]         ;286
00004e  fbb5f6f6          UDIV     r6,r5,r6              ;286
000052  f44f777a          MOV      r7,#0x3e8             ;286
000056  6845              LDR      r5,[r0,#4]            ;286
000058  437d              MULS     r5,r7,r5              ;286
00005a  fbb5f5f6          UDIV     r5,r5,r6              ;286
00005e  442c              ADD      r4,r4,r5              ;286
000060  6945              LDR      r5,[r0,#0x14]         ;289
000062  f4157f80          TST      r5,#0x100             ;289
000066  d001              BEQ      |L16.108|
000068  4a14              LDR      r2,|L16.188|
00006a  e000              B        |L16.110|
                  |L16.108|
00006c  4a14              LDR      r2,|L16.192|
                  |L16.110|
00006e  4294              CMP      r4,r2                 ;301
000070  d803              BHI      |L16.122|
000072  68cd              LDR      r5,[r1,#0xc]          ;301
000074  f0150f08          TST      r5,#8                 ;301
000078  d005              BEQ      |L16.134|
                  |L16.122|
00007a  f44f757a          MOV      r5,#0x3e8             ;302
00007e  4355              MULS     r5,r2,r5              ;302
000080  6005              STR      r5,[r0,#0]            ;302
000082  2500              MOVS     r5,#0                 ;303
000084  6045              STR      r5,[r0,#4]            ;303
                  |L16.134|
000086  bf00              NOP                            ;305
                  |L16.136|
000088  680a              LDR      r2,[r1,#0]            ;312
00008a  6952              LDR      r2,[r2,#0x14]         ;312
00008c  f0120f10          TST      r2,#0x10              ;312
000090  d010              BEQ      |L16.180|
000092  6942              LDR      r2,[r0,#0x14]         ;313
000094  f4127f80          TST      r2,#0x100             ;313
000098  d006              BEQ      |L16.168|
00009a  4c07              LDR      r4,|L16.184|
00009c  6802              LDR      r2,[r0,#0]            ;314
00009e  42a2              CMP      r2,r4                 ;314
0000a0  d208              BCS      |L16.180|
0000a2  4622              MOV      r2,r4                 ;315
0000a4  6002              STR      r2,[r0,#0]            ;315
0000a6  e005              B        |L16.180|
                  |L16.168|
0000a8  4c06              LDR      r4,|L16.196|
0000aa  6802              LDR      r2,[r0,#0]            ;317
0000ac  42a2              CMP      r2,r4                 ;317
0000ae  d201              BCS      |L16.180|
0000b0  4622              MOV      r2,r4                 ;318
0000b2  6002              STR      r2,[r0,#0]            ;318
                  |L16.180|
0000b4  bf00              NOP      
0000b6  e7ab              B        |L16.16|
;;;322    
                          ENDP

                  |L16.184|
                          DCD      0x3b9aca00
                  |L16.188|
                          DCD      0x000493e0
                  |L16.192|
                          DCD      0x000186a0
                  |L16.196|
                          DCD      0x05f5e100

                          AREA ||i.mmc_set_ios||, CODE, READONLY, ALIGN=1

                  mmc_set_ios PROC
;;;132     */
;;;133    static void mmc_set_ios(struct mmc_host *host)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135        struct mmc_ios *ios = &host->ios;
000004  f1040530          ADD      r5,r4,#0x30
;;;136    
;;;137        pr_debug("%s: clock %uHz busmode %u powermode %u cs %u Vdd %u "
;;;138                 "width %u timing %u\n",
;;;139                 mmc_hostname(host), ios->clock, ios->bus_mode,
;;;140                 ios->power_mode, ios->chip_select, ios->vdd,
;;;141                 ios->bus_width, ios->timing);
;;;142    
;;;143        host->ops->set_ios(host, ios);
000008  6860              LDR      r0,[r4,#4]
00000a  4629              MOV      r1,r5
00000c  68c2              LDR      r2,[r0,#0xc]
00000e  4620              MOV      r0,r4
000010  4790              BLX      r2
;;;144    }
000012  bd70              POP      {r4-r6,pc}
;;;145    
                          ENDP


                          AREA ||i.mmc_set_timing||, CODE, READONLY, ALIGN=1

                  mmc_set_timing PROC
;;;444     */
;;;445    void mmc_set_timing(struct mmc_host *host, unsigned int timing)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;447        host->ios.timing = timing;
000006  203a              MOVS     r0,#0x3a
000008  5544              STRB     r4,[r0,r5]
;;;448        mmc_set_ios(host);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       mmc_set_ios
;;;449    }
000010  bd70              POP      {r4-r6,pc}
;;;450    
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.mmc_start_request||, CODE, READONLY, ALIGN=1

                  mmc_start_request PROC
;;;326    static void
;;;327            mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;329    #ifdef CONFIG_MMC_DEBUG
;;;330        unsigned int i, sz;
;;;331        struct scatterlist *sg;
;;;332    #endif
;;;333        //sdio_deb_enter;
;;;334        pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
;;;335                 mmc_hostname(host), mrq->cmd->opcode,
;;;336                 mrq->cmd->arg, mrq->cmd->flags);
;;;337    
;;;338        if (mrq->data) {
;;;339            pr_debug("%s:     blksz %d blocks %d flags %08x "
;;;340                     "tsac %d ms nsac %d\n",
;;;341                     mmc_hostname(host), mrq->data->blksz,
;;;342                     mrq->data->blocks, mrq->data->flags,
;;;343                     mrq->data->timeout_ns / 1000000,
;;;344                     mrq->data->timeout_clks);
;;;345        }
;;;346    
;;;347        if (mrq->stop) {
;;;348            pr_debug("%s:     CMD%u arg %08x flags %08x\n",
;;;349                     mmc_hostname(host), mrq->stop->opcode,
;;;350                     mrq->stop->arg, mrq->stop->flags);
;;;351        }
;;;352    
;;;353        //	WARN_ON(!host->claimed);
;;;354        //led_trigger_event(host->led, LED_FULL);
;;;355    
;;;356        mrq->cmd->error = 0;
000006  2000              MOVS     r0,#0
000008  6821              LDR      r1,[r4,#0]
00000a  6208              STR      r0,[r1,#0x20]
;;;357        mrq->cmd->mrq = mrq;
00000c  6820              LDR      r0,[r4,#0]
00000e  6284              STR      r4,[r0,#0x28]
;;;358        if (mrq->data) {
000010  6860              LDR      r0,[r4,#4]
000012  b188              CBZ      r0,|L20.56|
;;;359            /*BUG_ON(mrq->data->blksz > host->max_blk_size);
;;;360    		BUG_ON(mrq->data->blocks > host->max_blk_count);
;;;361    		BUG_ON(mrq->data->blocks * mrq->data->blksz >
;;;362    			host->max_req_size);
;;;363    
;;;364    #ifdef CONFIG_MMC_DEBUG
;;;365    		sz = 0;
;;;366    		for_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i)
;;;367    			sz += sg->length;
;;;368    		BUG_ON(sz != mrq->data->blocks * mrq->data->blksz);
;;;369    #endif*/
;;;370    
;;;371            mrq->cmd->data = mrq->data;
000014  e9d41000          LDRD     r1,r0,[r4,#0]
000018  6248              STR      r0,[r1,#0x24]
;;;372            mrq->data->error = 0;
00001a  2000              MOVS     r0,#0
00001c  6861              LDR      r1,[r4,#4]
00001e  6108              STR      r0,[r1,#0x10]
;;;373            mrq->data->mrq = mrq;
000020  6860              LDR      r0,[r4,#4]
000022  6204              STR      r4,[r0,#0x20]
;;;374            if (mrq->stop) {
000024  68a0              LDR      r0,[r4,#8]
000026  b138              CBZ      r0,|L20.56|
;;;375                mrq->data->stop = mrq->stop;
000028  e9d41001          LDRD     r1,r0,[r4,#4]
00002c  61c8              STR      r0,[r1,#0x1c]
;;;376                mrq->stop->error = 0;
00002e  2000              MOVS     r0,#0
000030  68a1              LDR      r1,[r4,#8]
000032  6208              STR      r0,[r1,#0x20]
;;;377                mrq->stop->mrq = mrq;
000034  68a0              LDR      r0,[r4,#8]
000036  6284              STR      r4,[r0,#0x28]
                  |L20.56|
;;;378            }
;;;379        }
;;;380        host->ops->request(host, mrq);
000038  6868              LDR      r0,[r5,#4]
00003a  4621              MOV      r1,r4
00003c  6882              LDR      r2,[r0,#8]
00003e  4628              MOV      r0,r5
000040  4790              BLX      r2
;;;381        //sdio_deb_leave;
;;;382    }
000042  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP


                          AREA ||i.mmc_wait_done||, CODE, READONLY, ALIGN=1

                  mmc_wait_done PROC
;;;384    
;;;385    static void mmc_wait_done(void *data)
000000  4601              MOV      r1,r0
;;;386    {
;;;387        unsigned char *p=data;
;;;388        *p=1;
000002  2201              MOVS     r2,#1
000004  700a              STRB     r2,[r1,#0]
;;;389    }
000006  4770              BX       lr
;;;390    /**
                          ENDP


                          AREA ||i.mmc_wait_for_cmd||, CODE, READONLY, ALIGN=1

                  mmc_wait_for_cmd PROC
;;;422     */
;;;423    int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
000000  b570              PUSH     {r4-r6,lr}
;;;424    {
000002  b086              SUB      sp,sp,#0x18
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;425        struct mmc_request mrq;
;;;426    
;;;427        //WARN_ON(!host->claimed);
;;;428        //sdio_deb_enter;
;;;429        memset(&mrq, 0, sizeof(struct mmc_request));
00000a  2114              MOVS     r1,#0x14
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       __aeabi_memclr4
;;;430    
;;;431        memset(cmd->resp, 0, sizeof(cmd->resp));
000012  2000              MOVS     r0,#0
000014  60a0              STR      r0,[r4,#8]
000016  60e0              STR      r0,[r4,#0xc]
000018  6120              STR      r0,[r4,#0x10]
00001a  6160              STR      r0,[r4,#0x14]
;;;432        cmd->retries = retries;
00001c  61e5              STR      r5,[r4,#0x1c]
;;;433    
;;;434        mrq.cmd = cmd;
00001e  9401              STR      r4,[sp,#4]
;;;435        cmd->data = NULL;
000020  6260              STR      r0,[r4,#0x24]
;;;436    
;;;437        mmc_wait_for_req(host, &mrq);
000022  a901              ADD      r1,sp,#4
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       mmc_wait_for_req
;;;438        //pr_debug("wait_for_req out!\n");
;;;439        // sdio_deb_leave;
;;;440        return cmd->error;
00002a  6a20              LDR      r0,[r4,#0x20]
;;;441    }
00002c  b006              ADD      sp,sp,#0x18
00002e  bd70              POP      {r4-r6,pc}
;;;442    /*
                          ENDP


                          AREA ||i.mmc_wait_for_req||, CODE, READONLY, ALIGN=2

                  mmc_wait_for_req PROC
;;;398     */
;;;399    void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
000000  b538              PUSH     {r3-r5,lr}
;;;400    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;401        //DECLARE_COMPLETION_ONSTACK(complete);
;;;402        unsigned char complete=0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;403        //sdio_deb_enter;
;;;404        mrq->done_data = (void *)&complete;
00000a  f8c4d00c          STR      sp,[r4,#0xc]
;;;405        mrq->done = mmc_wait_done;
00000e  4806              LDR      r0,|L23.40|
000010  6120              STR      r0,[r4,#0x10]
;;;406    
;;;407        mmc_start_request(host, mrq);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       mmc_start_request
;;;408        while(!complete);//等待命令完成
00001a  bf00              NOP      
                  |L23.28|
00001c  f89d0000          LDRB     r0,[sp,#0]
000020  2800              CMP      r0,#0
000022  d0fb              BEQ      |L23.28|
;;;409        //sdio_deb_leave;
;;;410        //wait_for_completion(&complete);
;;;411    }
000024  bd38              POP      {r3-r5,pc}
;;;412    
                          ENDP

000026  0000              DCW      0x0000
                  |L23.40|
                          DCD      mmc_wait_done

                          AREA ||i.sdio_add_func||, CODE, READONLY, ALIGN=1

                  sdio_add_func PROC
;;;742     */
;;;743    int sdio_add_func(struct sdio_func *func)
000000  4601              MOV      r1,r0
;;;744    {
;;;745        int ret=0;
000002  2000              MOVS     r0,#0
;;;746    
;;;747        //dev_set_name(&func->dev, "%s:%d", mmc_card_id(func->card), func->num);
;;;748    
;;;749        //ret = device_add(&func->dev);//调用sdio_bus进行match和probe
;;;750        //ret = device_add(&func->dev)
;;;751        //	if (ret == 0)
;;;752        sdio_func_set_present(func);
000004  6a4a              LDR      r2,[r1,#0x24]
000006  f0420201          ORR      r2,r2,#1
00000a  624a              STR      r2,[r1,#0x24]
;;;753    
;;;754        return ret;
;;;755    }
00000c  4770              BX       lr
;;;756    
                          ENDP


                          AREA ||i.sdio_alloc_func||, CODE, READONLY, ALIGN=2

                  sdio_alloc_func PROC
;;;715     */
;;;716    struct sdio_func *sdio_alloc_func(struct mmc_card *card)
000000  b570              PUSH     {r4-r6,lr}
;;;717    {
000002  4605              MOV      r5,r0
;;;718        static struct sdio_func marvel_gsdiofunc;
;;;719    
;;;720        struct sdio_func *func=&marvel_gsdiofunc;
000004  4c03              LDR      r4,|L25.20|
;;;721    
;;;722        /*func = kzalloc(sizeof(struct sdio_func), GFP_KERNEL);
;;;723    	if (!func)
;;;724    		return ERR_PTR(-ENOMEM);*/
;;;725        memset(func,0,sizeof(struct sdio_func));
000006  2138              MOVS     r1,#0x38
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;726        func->card = card;
00000e  6025              STR      r5,[r4,#0]
;;;727    
;;;728    
;;;729        //	device_initialize(&func->dev);
;;;730    
;;;731        //	func->dev.parent = &card->dev;
;;;732        //	func->dev.bus = &sdio_bus_type;
;;;733        //	func->dev.release = sdio_release_func;
;;;734    
;;;735        return func;
000010  4620              MOV      r0,r4
;;;736    }
000012  bd70              POP      {r4-r6,pc}
;;;737    
                          ENDP

                  |L25.20|
                          DCD      marvel_gsdiofunc

                          AREA ||i.sdio_bus_probe||, CODE, READONLY, ALIGN=2

                  sdio_bus_probe PROC
;;;970    
;;;971    struct lbs_private *sdio_bus_probe(struct sdio_func *func)
000000  b570              PUSH     {r4-r6,lr}
;;;972    {
000002  4606              MOV      r6,r0
;;;973        struct sdio_device_id *id;
;;;974        int ret;
;;;975    
;;;976        id = sdio_match_device(func);
000004  4630              MOV      r0,r6
000006  f7fffffe          BL       sdio_match_device
00000a  4605              MOV      r5,r0
;;;977        if (!id){
00000c  b925              CBNZ     r5,|L26.24|
;;;978            marvell_error("Cann't find support modules!\n");
00000e  a009              ADR      r0,|L26.52|
000010  f7fffffe          BL       __2printf
;;;979            return (struct lbs_private *)NULL;
000014  2000              MOVS     r0,#0
                  |L26.22|
;;;980        }
;;;981        /* Set the default block size so the driver is sure it's something
;;;982    	 * sensible. */
;;;983        ret = sdio_set_block_size(func, 0);
;;;984        if (ret)
;;;985            return (struct lbs_private *)NULL;
;;;986        return if_sdio_probe(func,id);
;;;987    }
000016  bd70              POP      {r4-r6,pc}
                  |L26.24|
000018  2100              MOVS     r1,#0                 ;983
00001a  4630              MOV      r0,r6                 ;983
00001c  f7fffffe          BL       sdio_set_block_size
000020  4604              MOV      r4,r0                 ;983
000022  b10c              CBZ      r4,|L26.40|
000024  2000              MOVS     r0,#0                 ;985
000026  e7f6              B        |L26.22|
                  |L26.40|
000028  4629              MOV      r1,r5                 ;986
00002a  4630              MOV      r0,r6                 ;986
00002c  f7fffffe          BL       if_sdio_probe
000030  e7f1              B        |L26.22|
;;;988    
                          ENDP

000032  0000              DCW      0x0000
                  |L26.52|
000034  43616e6e          DCB      "Cann't find support modules!\n",0
000038  27742066
00003c  696e6420
000040  73757070
000044  6f727420
000048  6d6f6475
00004c  6c657321
000050  0a00    
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.sdio_card_irq_get||, CODE, READONLY, ALIGN=1

                  sdio_card_irq_get PROC
;;;811    
;;;812    static int sdio_card_irq_get(struct mmc_card *card)
000000  4601              MOV      r1,r0
;;;813    {
;;;814        struct mmc_host *host = card->host;
000002  680a              LDR      r2,[r1,#0]
;;;815        if (!host->sdio_irqs++)
000004  6e50              LDR      r0,[r2,#0x64]
000006  1c40              ADDS     r0,r0,#1
000008  6650              STR      r0,[r2,#0x64]
;;;816            pr_debug("setup sdio irq success!\n");
;;;817    
;;;818        //	WARN_ON(!host->claimed);
;;;819    
;;;820        //if (!host->sdio_irqs++) {
;;;821        //第一次使用时要创建sdio host的irq线程，为了适应部分sd卡控制器不能中断的情况，
;;;822        //内核使用sdio_irq_thread线程定期轮询SDIO控制器的状态来调度中断请求
;;;823        //atomic_set(&host->sdio_irq_thread_abort, 0);
;;;824        /*host->sdio_irq_thread =
;;;825    			kthread_run(sdio_irq_thread, host, "ksdioirqd/%s",
;;;826    				mmc_hostname(host));*/
;;;827        /*	if (IS_ERR(host->sdio_irq_thread)) {
;;;828    			int err = PTR_ERR(host->sdio_irq_thread);
;;;829    			host->sdio_irqs--;
;;;830    			return err;
;;;831    		}
;;;832    	}*/
;;;833    
;;;834        return 0;
00000a  2000              MOVS     r0,#0
;;;835    }
00000c  4770              BX       lr
;;;836    
                          ENDP


                          AREA ||i.sdio_claim_irq||, CODE, READONLY, ALIGN=1

                  sdio_claim_irq PROC
;;;849     */
;;;850    int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
000000  b5fe              PUSH     {r1-r7,lr}
;;;851    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;852        int ret;
;;;853        unsigned char reg;
;;;854    
;;;855        //BUG_ON(!func);
;;;856        //BUG_ON(!func->card);
;;;857    
;;;858        pr_debug("SDIO: Enabling IRQ for %s...\n", sdio_func_id(func));
;;;859    
;;;860        if (func->irq_handler) {
000006  68a0              LDR      r0,[r4,#8]
000008  b110              CBZ      r0,|L28.16|
;;;861            pr_debug("SDIO: IRQ for %s already in use.\n", sdio_func_id(func));
;;;862            return -EBUSY;
00000a  f06f000f          MVN      r0,#0xf
                  |L28.14|
;;;863        }
;;;864    
;;;865        ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
;;;866        if (ret)
;;;867            return ret;
;;;868    
;;;869        reg |= 1 << func->num;
;;;870    
;;;871        reg |= 1; /* Master interrupt enable */
;;;872    
;;;873        ret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
;;;874        if (ret)
;;;875            return ret;
;;;876    
;;;877        func->irq_handler = handler;//安装中断向量，中断时会被调用
;;;878        ret = sdio_card_irq_get(func->card);
;;;879        if (ret)
;;;880            func->irq_handler = NULL;
;;;881    
;;;882        return ret;
;;;883    }
00000e  bdfe              POP      {r1-r7,pc}
                  |L28.16|
000010  ab02              ADD      r3,sp,#8              ;865
000012  2200              MOVS     r2,#0                 ;865
000014  e9cd2300          STRD     r2,r3,[sp,#0]         ;865
000018  2304              MOVS     r3,#4                 ;865
00001a  4611              MOV      r1,r2                 ;865
00001c  6820              LDR      r0,[r4,#0]            ;865
00001e  f7fffffe          BL       mmc_io_rw_direct
000022  4605              MOV      r5,r0                 ;865
000024  b10d              CBZ      r5,|L28.42|
000026  4628              MOV      r0,r5                 ;867
000028  e7f1              B        |L28.14|
                  |L28.42|
00002a  2001              MOVS     r0,#1                 ;869
00002c  68e1              LDR      r1,[r4,#0xc]          ;869
00002e  4088              LSLS     r0,r0,r1              ;869
000030  f89d1008          LDRB     r1,[sp,#8]            ;869
000034  4308              ORRS     r0,r0,r1              ;869
000036  b2c0              UXTB     r0,r0                 ;869
000038  9002              STR      r0,[sp,#8]            ;869
00003a  f89d0008          LDRB     r0,[sp,#8]            ;871
00003e  f0400001          ORR      r0,r0,#1              ;871
000042  9002              STR      r0,[sp,#8]            ;871
000044  2300              MOVS     r3,#0                 ;873
000046  f89d2008          LDRB     r2,[sp,#8]            ;873
00004a  e9cd2300          STRD     r2,r3,[sp,#0]         ;873
00004e  2304              MOVS     r3,#4                 ;873
000050  2200              MOVS     r2,#0                 ;873
000052  2101              MOVS     r1,#1                 ;873
000054  6820              LDR      r0,[r4,#0]            ;873
000056  f7fffffe          BL       mmc_io_rw_direct
00005a  4605              MOV      r5,r0                 ;873
00005c  b10d              CBZ      r5,|L28.98|
00005e  4628              MOV      r0,r5                 ;875
000060  e7d5              B        |L28.14|
                  |L28.98|
000062  60a6              STR      r6,[r4,#8]            ;877
000064  6820              LDR      r0,[r4,#0]            ;878
000066  f7fffffe          BL       sdio_card_irq_get
00006a  4605              MOV      r5,r0                 ;878
00006c  b10d              CBZ      r5,|L28.114|
00006e  2000              MOVS     r0,#0                 ;880
000070  60a0              STR      r0,[r4,#8]            ;880
                  |L28.114|
000072  4628              MOV      r0,r5                 ;882
000074  e7cb              B        |L28.14|
;;;884    
                          ENDP


                          AREA ||i.sdio_enable_func||, CODE, READONLY, ALIGN=1

                  sdio_enable_func PROC
;;;763     */
;;;764    int sdio_enable_func(struct sdio_func *func)
000000  b5fe              PUSH     {r1-r7,lr}
;;;765    {
000002  4604              MOV      r4,r0
;;;766        int ret;
;;;767        unsigned char reg;
;;;768        unsigned long timeout;
;;;769    
;;;770        //BUG_ON(!func);
;;;771        //BUG_ON(!func->card);
;;;772    
;;;773        pr_debug("SDIO: Enabling device %s...\n", sdio_func_id(func));
;;;774    
;;;775        ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IOEx, 0, &reg);
000004  ab02              ADD      r3,sp,#8
000006  2200              MOVS     r2,#0
000008  e9cd2300          STRD     r2,r3,[sp,#0]
00000c  2302              MOVS     r3,#2
00000e  4611              MOV      r1,r2
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       mmc_io_rw_direct
000016  4605              MOV      r5,r0
;;;776        if (ret)
000018  b105              CBZ      r5,|L29.28|
;;;777            goto err;
00001a  e036              B        |L29.138|
                  |L29.28|
;;;778    
;;;779        reg |= 1 << func->num;
00001c  2001              MOVS     r0,#1
00001e  68e1              LDR      r1,[r4,#0xc]
000020  4088              LSLS     r0,r0,r1
000022  f89d1008          LDRB     r1,[sp,#8]
000026  4308              ORRS     r0,r0,r1
000028  b2c0              UXTB     r0,r0
00002a  9002              STR      r0,[sp,#8]
;;;780    
;;;781        ret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IOEx, reg, NULL);
00002c  2300              MOVS     r3,#0
00002e  f89d2008          LDRB     r2,[sp,#8]
000032  e9cd2300          STRD     r2,r3,[sp,#0]
000036  2302              MOVS     r3,#2
000038  2200              MOVS     r2,#0
00003a  2101              MOVS     r1,#1
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       mmc_io_rw_direct
000042  4605              MOV      r5,r0
;;;782        if (ret)
000044  b105              CBZ      r5,|L29.72|
;;;783            goto err;
000046  e020              B        |L29.138|
                  |L29.72|
;;;784    
;;;785        timeout =func->enable_timeout;
000048  6a26              LDR      r6,[r4,#0x20]
;;;786    
;;;787        while (1) {
00004a  e01a              B        |L29.130|
                  |L29.76|
;;;788            ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IORx, 0, &reg);
00004c  ab02              ADD      r3,sp,#8
00004e  2200              MOVS     r2,#0
000050  e9cd2300          STRD     r2,r3,[sp,#0]
000054  2303              MOVS     r3,#3
000056  4611              MOV      r1,r2
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       mmc_io_rw_direct
00005e  4605              MOV      r5,r0
;;;789            if (ret)
000060  b105              CBZ      r5,|L29.100|
;;;790                goto err;
000062  e012              B        |L29.138|
                  |L29.100|
;;;791            if (reg & (1 << func->num))
000064  2001              MOVS     r0,#1
000066  68e1              LDR      r1,[r4,#0xc]
000068  4088              LSLS     r0,r0,r1
00006a  f89d1008          LDRB     r1,[sp,#8]
00006e  4208              TST      r0,r1
000070  d000              BEQ      |L29.116|
;;;792                break;
000072  e007              B        |L29.132|
                  |L29.116|
;;;793    
;;;794            ms_delay();
000074  f7fffffe          BL       ms_delay
;;;795            timeout--;
000078  1e76              SUBS     r6,r6,#1
;;;796            ret = -ETIME;
00007a  f06f0548          MVN      r5,#0x48
;;;797            if (timeout==0)
00007e  b906              CBNZ     r6,|L29.130|
;;;798                goto err;
000080  e003              B        |L29.138|
                  |L29.130|
000082  e7e3              B        |L29.76|
                  |L29.132|
000084  bf00              NOP                            ;792
;;;799        }
;;;800    
;;;801        pr_debug("SDIO: Enabled device %s\n", sdio_func_id(func));
;;;802    
;;;803        return 0;
000086  2000              MOVS     r0,#0
                  |L29.136|
;;;804    
;;;805        err:
;;;806        pr_debug("SDIO: Failed to enable device %s\n", sdio_func_id(func));
;;;807        return ret;
;;;808    }
000088  bdfe              POP      {r1-r7,pc}
                  |L29.138|
00008a  4628              MOV      r0,r5                 ;807
00008c  e7fc              B        |L29.136|
;;;809    
                          ENDP


                          AREA ||i.sdio_match_device||, CODE, READONLY, ALIGN=2

                  sdio_match_device PROC
;;;907    };
;;;908    static struct sdio_device_id *sdio_match_device(struct sdio_func *func)
000000  b570              PUSH     {r4-r6,lr}
;;;909    {
000002  4605              MOV      r5,r0
;;;910        struct sdio_device_id *ids=(struct sdio_device_id *)if_sdio_ids;
000004  4c0a              LDR      r4,|L30.48|
;;;911        pr_debug("function vendor=0x%x	device=0x%x\n",func->vendor,func->device);
;;;912        if (ids) {
000006  b18c              CBZ      r4,|L30.44|
;;;913            while (ids->class || ids->vendor || ids->device) {
000008  e007              B        |L30.26|
                  |L30.10|
;;;914                if (sdio_match_one(func, ids))
00000a  4621              MOV      r1,r4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       sdio_match_one
000012  b108              CBZ      r0,|L30.24|
;;;915                    return ids;
000014  4620              MOV      r0,r4
                  |L30.22|
;;;916                ids++;
;;;917            }
;;;918        }
;;;919        return NULL;
;;;920    }
000016  bd70              POP      {r4-r6,pc}
                  |L30.24|
000018  1da4              ADDS     r4,r4,#6              ;916
                  |L30.26|
00001a  7820              LDRB     r0,[r4,#0]            ;913
00001c  2800              CMP      r0,#0                 ;913
00001e  d1f4              BNE      |L30.10|
000020  8860              LDRH     r0,[r4,#2]            ;913
000022  2800              CMP      r0,#0                 ;913
000024  d1f1              BNE      |L30.10|
000026  88a0              LDRH     r0,[r4,#4]            ;913
000028  2800              CMP      r0,#0                 ;913
00002a  d1ee              BNE      |L30.10|
                  |L30.44|
00002c  2000              MOVS     r0,#0                 ;919
00002e  e7f2              B        |L30.22|
;;;921    
                          ENDP

                  |L30.48|
                          DCD      if_sdio_ids

                          AREA ||i.sdio_match_one||, CODE, READONLY, ALIGN=1

                  sdio_match_one PROC
;;;890    /******************************************sdio bus *******************************/
;;;891    static const struct sdio_device_id *sdio_match_one(struct sdio_func *func,
000000  4602              MOV      r2,r0
;;;892                                                       const struct sdio_device_id *id)
;;;893    {
;;;894        if (id->class != ( u8)SDIO_ANY_ID && id->class != func->class)
000002  7808              LDRB     r0,[r1,#0]
000004  28ff              CMP      r0,#0xff
000006  d005              BEQ      |L31.20|
000008  7808              LDRB     r0,[r1,#0]
00000a  7c13              LDRB     r3,[r2,#0x10]
00000c  4298              CMP      r0,r3
00000e  d001              BEQ      |L31.20|
;;;895            return NULL;
000010  2000              MOVS     r0,#0
                  |L31.18|
;;;896        if (id->vendor != (u16)SDIO_ANY_ID && id->vendor != func->vendor)
;;;897            return NULL;
;;;898        if (id->device != (u16)SDIO_ANY_ID && id->device != func->device)
;;;899            return NULL;
;;;900        return id;
;;;901    }
000012  4770              BX       lr
                  |L31.20|
000014  8848              LDRH     r0,[r1,#2]            ;896
000016  f5a0437f          SUB      r3,r0,#0xff00         ;896
00001a  3bff              SUBS     r3,r3,#0xff           ;896
00001c  d005              BEQ      |L31.42|
00001e  8848              LDRH     r0,[r1,#2]            ;896
000020  8a53              LDRH     r3,[r2,#0x12]         ;896
000022  4298              CMP      r0,r3                 ;896
000024  d001              BEQ      |L31.42|
000026  2000              MOVS     r0,#0                 ;897
000028  e7f3              B        |L31.18|
                  |L31.42|
00002a  8888              LDRH     r0,[r1,#4]            ;898
00002c  f5a0437f          SUB      r3,r0,#0xff00         ;898
000030  3bff              SUBS     r3,r3,#0xff           ;898
000032  d005              BEQ      |L31.64|
000034  8888              LDRH     r0,[r1,#4]            ;898
000036  8a93              LDRH     r3,[r2,#0x14]         ;898
000038  4298              CMP      r0,r3                 ;898
00003a  d001              BEQ      |L31.64|
00003c  2000              MOVS     r0,#0                 ;899
00003e  e7e8              B        |L31.18|
                  |L31.64|
000040  4608              MOV      r0,r1                 ;900
000042  e7e6              B        |L31.18|
;;;902    
                          ENDP


                          AREA ||i.sdio_set_block_size||, CODE, READONLY, ALIGN=1

                  sdio_set_block_size PROC
;;;944     */
;;;945    int sdio_set_block_size(struct sdio_func *func, unsigned blksz)
000000  b57c              PUSH     {r2-r6,lr}
;;;946    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;947        int ret;
;;;948    
;;;949        if (blksz > func->card->host->max_blk_size)
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  6a80              LDR      r0,[r0,#0x28]
00000c  42a8              CMP      r0,r5
00000e  d202              BCS      |L32.22|
;;;950            return -EINVAL;
000010  f06f0015          MVN      r0,#0x15
                  |L32.20|
;;;951    
;;;952        if (blksz == 0) {
;;;953            blksz = min(func->max_blksize, func->card->host->max_blk_size);
;;;954            blksz = min(blksz, 512u);
;;;955        }
;;;956    
;;;957        ret = mmc_io_rw_direct(func->card, 1, 0,
;;;958                               SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,
;;;959                               blksz & 0xff, NULL);
;;;960        if (ret)
;;;961            return ret;
;;;962        ret = mmc_io_rw_direct(func->card, 1, 0,
;;;963                               SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1,
;;;964                               (blksz >> 8) & 0xff, NULL);
;;;965        if (ret)
;;;966            return ret;
;;;967        func->cur_blksize = blksz;
;;;968        return 0;
;;;969    }
000014  bd7c              POP      {r2-r6,pc}
                  |L32.22|
000016  b99d              CBNZ     r5,|L32.64|
000018  6821              LDR      r1,[r4,#0]            ;953
00001a  69a0              LDR      r0,[r4,#0x18]         ;953
00001c  6809              LDR      r1,[r1,#0]            ;953
00001e  6a89              LDR      r1,[r1,#0x28]         ;953
000020  4288              CMP      r0,r1                 ;953
000022  d201              BCS      |L32.40|
000024  69a0              LDR      r0,[r4,#0x18]         ;953
000026  e002              B        |L32.46|
                  |L32.40|
000028  6820              LDR      r0,[r4,#0]            ;953
00002a  6800              LDR      r0,[r0,#0]            ;953
00002c  6a80              LDR      r0,[r0,#0x28]         ;953
                  |L32.46|
00002e  4605              MOV      r5,r0                 ;953
000030  f5b57f00          CMP      r5,#0x200             ;954
000034  d201              BCS      |L32.58|
000036  4628              MOV      r0,r5                 ;954
000038  e001              B        |L32.62|
                  |L32.58|
00003a  f44f7000          MOV      r0,#0x200             ;954
                  |L32.62|
00003e  4605              MOV      r5,r0                 ;954
                  |L32.64|
000040  2300              MOVS     r3,#0                 ;957
000042  b2ea              UXTB     r2,r5                 ;957
000044  e9cd2300          STRD     r2,r3,[sp,#0]         ;957
000048  2210              MOVS     r2,#0x10              ;957
00004a  68e1              LDR      r1,[r4,#0xc]          ;957
00004c  eb022301          ADD      r3,r2,r1,LSL #8       ;957
000050  2200              MOVS     r2,#0                 ;957
000052  2101              MOVS     r1,#1                 ;957
000054  6820              LDR      r0,[r4,#0]            ;957
000056  f7fffffe          BL       mmc_io_rw_direct
00005a  4606              MOV      r6,r0                 ;957
00005c  b10e              CBZ      r6,|L32.98|
00005e  4630              MOV      r0,r6                 ;961
000060  e7d8              B        |L32.20|
                  |L32.98|
000062  2300              MOVS     r3,#0                 ;962
000064  f3c52207          UBFX     r2,r5,#8,#8           ;962
000068  e9cd2300          STRD     r2,r3,[sp,#0]         ;962
00006c  2210              MOVS     r2,#0x10              ;962
00006e  68e1              LDR      r1,[r4,#0xc]          ;962
000070  eb022101          ADD      r1,r2,r1,LSL #8       ;962
000074  1c4b              ADDS     r3,r1,#1              ;962
000076  2200              MOVS     r2,#0                 ;962
000078  2101              MOVS     r1,#1                 ;962
00007a  6820              LDR      r0,[r4,#0]            ;962
00007c  f7fffffe          BL       mmc_io_rw_direct
000080  4606              MOV      r6,r0                 ;962
000082  b10e              CBZ      r6,|L32.136|
000084  4630              MOV      r0,r6                 ;966
000086  e7c5              B        |L32.20|
                  |L32.136|
000088  61e5              STR      r5,[r4,#0x1c]         ;967
00008a  2000              MOVS     r0,#0                 ;968
00008c  e7c2              B        |L32.20|
;;;970    
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L33.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L33.32|
                  |L33.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L33.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L33.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L33.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L33.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L33.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L33.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L33.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  marvel_gcard
                          %        212
                  s3c2440_gsdiohost
                          %        220
                  marvel_gsdiofunc
                          %        56

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  if_sdio_ids
000000  ff00              DCB      0xff,0x00
000002  02df              DCW      0x02df
000004  9103              DCW      0x9103
000006  ff00              DCB      0xff,0x00
000008  02df9104          DCW      0x02df,0x9104
00000c  0000              DCB      0x00,0x00
00000e  0000              DCW      0x0000
000010  0000              DCW      0x0000
