; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\pbuf.o --depend=.\obj\pbuf.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\pbuf.crf ..\lwIP\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=1

                  pbuf_alloc PROC
;;;151    struct pbuf *
;;;152    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;153    {
000004  4683              MOV      r11,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;154      struct pbuf *p, *q, *r;
;;;155      u16_t offset;
;;;156      s32_t rem_len; /* remaining length */
;;;157      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;158    
;;;159      /* determine header offset */
;;;160      offset = 0;
00000e  2600              MOVS     r6,#0
;;;161      switch (layer) {
000010  f1bb0f00          CMP      r11,#0
000014  d009              BEQ      |L1.42|
000016  f1bb0f01          CMP      r11,#1
00001a  d00a              BEQ      |L1.50|
00001c  f1bb0f02          CMP      r11,#2
000020  d00b              BEQ      |L1.58|
000022  f1bb0f03          CMP      r11,#3
000026  d10d              BNE      |L1.68|
000028  e00b              B        |L1.66|
                  |L1.42|
;;;162      case PBUF_TRANSPORT:
;;;163        /* add room for transport (often TCP) layer header */
;;;164        offset += PBUF_TRANSPORT_HLEN;
00002a  f1060014          ADD      r0,r6,#0x14
00002e  b286              UXTH     r6,r0
;;;165        /* FALLTHROUGH */
;;;166      case PBUF_IP:
000030  bf00              NOP      
                  |L1.50|
;;;167        /* add room for IP layer header */
;;;168        offset += PBUF_IP_HLEN;
000032  f1060014          ADD      r0,r6,#0x14
000036  b286              UXTH     r6,r0
;;;169        /* FALLTHROUGH */
;;;170      case PBUF_LINK:
000038  bf00              NOP      
                  |L1.58|
;;;171        /* add room for link layer header */
;;;172        offset += PBUF_LINK_HLEN;
00003a  f106000e          ADD      r0,r6,#0xe
00003e  b286              UXTH     r6,r0
;;;173        break;
000040  e003              B        |L1.74|
                  |L1.66|
;;;174      case PBUF_RAW:
;;;175        break;
000042  e002              B        |L1.74|
                  |L1.68|
;;;176      default:
;;;177        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
;;;178        return NULL;
000044  2000              MOVS     r0,#0
                  |L1.70|
;;;179      }
;;;180    
;;;181      switch (type) {
;;;182      case PBUF_POOL:
;;;183        /* allocate head of pbuf chain into p */
;;;184        ALLOC_POOL_PBUF(p);
;;;185        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;186        if (p == NULL) {
;;;187          return NULL;
;;;188        }
;;;189        p->type = type;
;;;190        p->next = NULL;
;;;191    
;;;192        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;193        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;194        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;195                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;196        /* the total length of the pbuf chain is the requested size */
;;;197        p->tot_len = length;
;;;198        /* set the length of the first pbuf in the chain */
;;;199        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;200        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;201                    ((u8_t*)p->payload + p->len <=
;;;202                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;203        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;204          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;205        /* set reference count (needed here in case we fail) */
;;;206        p->ref = 1;
;;;207    
;;;208        /* now allocate the tail of the pbuf chain */
;;;209    
;;;210        /* remember first pbuf for linkage in next iteration */
;;;211        r = p;
;;;212        /* remaining length to be allocated */
;;;213        rem_len = length - p->len;
;;;214        /* any remaining pbufs to be allocated? */
;;;215        while (rem_len > 0) {
;;;216          ALLOC_POOL_PBUF(q);
;;;217          if (q == NULL) {
;;;218            /* free chain so far allocated */
;;;219            pbuf_free(p);
;;;220            /* bail out unsuccesfully */
;;;221            return NULL;
;;;222          }
;;;223          q->type = type;
;;;224          q->flags = 0;
;;;225          q->next = NULL;
;;;226          /* make previous pbuf point to this pbuf */
;;;227          r->next = q;
;;;228          /* set total length of this pbuf and next in chain */
;;;229          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;230          q->tot_len = (u16_t)rem_len;
;;;231          /* this pbuf length is pool size, unless smaller sized tail */
;;;232          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;233          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;234          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;235                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;236          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;237                      ((u8_t*)p->payload + p->len <=
;;;238                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;239          q->ref = 1;
;;;240          /* calculate remaining length to be allocated */
;;;241          rem_len -= q->len;
;;;242          /* remember this pbuf for linkage in next iteration */
;;;243          r = q;
;;;244        }
;;;245        /* end of chain */
;;;246        /*r->next = NULL;*/
;;;247    
;;;248        break;
;;;249      case PBUF_RAM:
;;;250        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;251        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;252        if (p == NULL) {
;;;253          return NULL;
;;;254        }
;;;255        /* Set up internal structure of the pbuf. */
;;;256        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;257        p->len = p->tot_len = length;
;;;258        p->next = NULL;
;;;259        p->type = type;
;;;260    
;;;261        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;262               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;263        break;
;;;264      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;265      case PBUF_ROM:
;;;266      /* pbuf references existing (externally allocated) RAM payload? */
;;;267      case PBUF_REF:
;;;268        /* only allocate memory for the pbuf structure */
;;;269        p = memp_malloc(MEMP_PBUF);
;;;270        if (p == NULL) {
;;;271          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;272                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;273          return NULL;
;;;274        }
;;;275        /* caller must set this field properly, afterwards */
;;;276        p->payload = NULL;
;;;277        p->len = p->tot_len = length;
;;;278        p->next = NULL;
;;;279        p->type = type;
;;;280        break;
;;;281      default:
;;;282        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
;;;283        return NULL;
;;;284      }
;;;285      /* set reference count */
;;;286      p->ref = 1;
;;;287      /* set flags */
;;;288      p->flags = 0;
;;;289      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;290      return p;
;;;291    }
000046  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.74|
00004a  bf00              NOP                            ;173
00004c  f1b80f00          CMP      r8,#0                 ;181
000050  d062              BEQ      |L1.280|
000052  f1b80f01          CMP      r8,#1                 ;181
000056  d07f              BEQ      |L1.344|
000058  f1b80f02          CMP      r8,#2                 ;181
00005c  d07d              BEQ      |L1.346|
00005e  f1b80f03          CMP      r8,#3                 ;181
000062  d178              BNE      |L1.342|
000064  bf00              NOP                            ;184
000066  2008              MOVS     r0,#8                 ;184
000068  f7fffffe          BL       memp_malloc
00006c  4604              MOV      r4,r0                 ;184
00006e  bf00              NOP                            ;184
000070  bf00              NOP                            ;185
000072  bf00              NOP                            ;185
000074  b90c              CBNZ     r4,|L1.122|
000076  2000              MOVS     r0,#0                 ;187
000078  e7e5              B        |L1.70|
                  |L1.122|
00007a  f884800c          STRB     r8,[r4,#0xc]          ;189
00007e  2000              MOVS     r0,#0                 ;190
000080  6020              STR      r0,[r4,#0]            ;190
000082  f1060010          ADD      r0,r6,#0x10           ;193
000086  4420              ADD      r0,r0,r4              ;193
000088  1cc0              ADDS     r0,r0,#3              ;193
00008a  f0200003          BIC      r0,r0,#3              ;193
00008e  6060              STR      r0,[r4,#4]            ;193
000090  8127              STRH     r7,[r4,#8]            ;197
000092  1cf0              ADDS     r0,r6,#3              ;199
000094  f0200003          BIC      r0,r0,#3              ;199
000098  f5c060c2          RSB      r0,r0,#0x610          ;199
00009c  42b8              CMP      r0,r7                 ;199
00009e  dd01              BLE      |L1.164|
0000a0  4638              MOV      r0,r7                 ;199
0000a2  e004              B        |L1.174|
                  |L1.164|
0000a4  1cf0              ADDS     r0,r6,#3              ;199
0000a6  f0200003          BIC      r0,r0,#3              ;199
0000aa  f5c060c2          RSB      r0,r0,#0x610          ;199
                  |L1.174|
0000ae  8160              STRH     r0,[r4,#0xa]          ;199
0000b0  2001              MOVS     r0,#1                 ;206
0000b2  81e0              STRH     r0,[r4,#0xe]          ;206
0000b4  46a2              MOV      r10,r4                ;211
0000b6  8960              LDRH     r0,[r4,#0xa]          ;213
0000b8  eba70900          SUB      r9,r7,r0              ;213
0000bc  e028              B        |L1.272|
                  |L1.190|
0000be  bf00              NOP                            ;216
0000c0  2008              MOVS     r0,#8                 ;216
0000c2  f7fffffe          BL       memp_malloc
0000c6  4605              MOV      r5,r0                 ;216
0000c8  bf00              NOP                            ;216
0000ca  b925              CBNZ     r5,|L1.214|
0000cc  4620              MOV      r0,r4                 ;219
0000ce  f7fffffe          BL       pbuf_free
0000d2  2000              MOVS     r0,#0                 ;221
0000d4  e7b7              B        |L1.70|
                  |L1.214|
0000d6  f885800c          STRB     r8,[r5,#0xc]          ;223
0000da  2000              MOVS     r0,#0                 ;224
0000dc  7368              STRB     r0,[r5,#0xd]          ;224
0000de  6028              STR      r0,[r5,#0]            ;225
0000e0  f8ca5000          STR      r5,[r10,#0]           ;227
0000e4  f8a59008          STRH     r9,[r5,#8]            ;230
0000e8  fa1ff089          UXTH     r0,r9                 ;232
0000ec  f5b06fc2          CMP      r0,#0x610             ;232
0000f0  da02              BGE      |L1.248|
0000f2  fa1ff089          UXTH     r0,r9                 ;232
0000f6  e001              B        |L1.252|
                  |L1.248|
0000f8  f44f60c2          MOV      r0,#0x610             ;232
                  |L1.252|
0000fc  8168              STRH     r0,[r5,#0xa]          ;232
0000fe  f1050010          ADD      r0,r5,#0x10           ;233
000102  6068              STR      r0,[r5,#4]            ;233
000104  2001              MOVS     r0,#1                 ;239
000106  81e8              STRH     r0,[r5,#0xe]          ;239
000108  8968              LDRH     r0,[r5,#0xa]          ;241
00010a  eba90900          SUB      r9,r9,r0              ;241
00010e  46aa              MOV      r10,r5                ;243
                  |L1.272|
000110  f1b90f00          CMP      r9,#0                 ;215
000114  dcd3              BGT      |L1.190|
000116  e033              B        |L1.384|
                  |L1.280|
000118  f1060113          ADD      r1,r6,#0x13           ;251
00011c  f0210203          BIC      r2,r1,#3              ;251
000120  1cf9              ADDS     r1,r7,#3              ;251
000122  f0210103          BIC      r1,r1,#3              ;251
000126  4411              ADD      r1,r1,r2              ;251
000128  b288              UXTH     r0,r1                 ;251
00012a  f7fffffe          BL       mem_malloc
00012e  4604              MOV      r4,r0                 ;251
000130  b90c              CBNZ     r4,|L1.310|
000132  2000              MOVS     r0,#0                 ;253
000134  e787              B        |L1.70|
                  |L1.310|
000136  f1040010          ADD      r0,r4,#0x10           ;256
00013a  4430              ADD      r0,r0,r6              ;256
00013c  1cc0              ADDS     r0,r0,#3              ;256
00013e  f0200003          BIC      r0,r0,#3              ;256
000142  6060              STR      r0,[r4,#4]            ;256
000144  8127              STRH     r7,[r4,#8]            ;257
000146  8167              STRH     r7,[r4,#0xa]          ;257
000148  2000              MOVS     r0,#0                 ;258
00014a  6020              STR      r0,[r4,#0]            ;258
00014c  f884800c          STRB     r8,[r4,#0xc]          ;259
000150  e016              B        |L1.384|
000152  e001              B        |L1.344|
000154  e001              B        |L1.346|
                  |L1.342|
000156  e011              B        |L1.380|
                  |L1.344|
000158  bf00              NOP                            ;267
                  |L1.346|
00015a  2007              MOVS     r0,#7                 ;269
00015c  f7fffffe          BL       memp_malloc
000160  4604              MOV      r4,r0                 ;269
000162  b91c              CBNZ     r4,|L1.364|
000164  bf00              NOP                            ;271
000166  bf00              NOP                            ;271
000168  2000              MOVS     r0,#0                 ;273
00016a  e76c              B        |L1.70|
                  |L1.364|
00016c  2000              MOVS     r0,#0                 ;276
00016e  6060              STR      r0,[r4,#4]            ;276
000170  8127              STRH     r7,[r4,#8]            ;277
000172  8167              STRH     r7,[r4,#0xa]          ;277
000174  6020              STR      r0,[r4,#0]            ;278
000176  f884800c          STRB     r8,[r4,#0xc]          ;279
00017a  e001              B        |L1.384|
                  |L1.380|
00017c  2000              MOVS     r0,#0                 ;283
00017e  e762              B        |L1.70|
                  |L1.384|
000180  bf00              NOP                            ;248
000182  2001              MOVS     r0,#1                 ;286
000184  81e0              STRH     r0,[r4,#0xe]          ;286
000186  2000              MOVS     r0,#0                 ;288
000188  7360              STRB     r0,[r4,#0xd]          ;288
00018a  bf00              NOP                            ;289
00018c  bf00              NOP                            ;289
00018e  4620              MOV      r0,r4                 ;290
000190  e759              B        |L1.70|
;;;292    
                          ENDP


                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_cat PROC
;;;613    void
;;;614    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;615    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;616      struct pbuf *p;
;;;617    
;;;618      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000006  bf00              NOP      
000008  b106              CBZ      r6,|L2.12|
00000a  b94d              CBNZ     r5,|L2.32|
                  |L2.12|
00000c  bf00              NOP      
00000e  a30d              ADR      r3,|L2.68|
000010  f240226a          MOV      r2,#0x26a
000014  a111              ADR      r1,|L2.92|
000016  a01f              ADR      r0,|L2.148|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L2.30|
;;;619                 ((h != NULL) && (t != NULL)), return;);
;;;620    
;;;621      /* proceed to last pbuf of chain */
;;;622      for (p = h; p->next != NULL; p = p->next) {
;;;623        /* add total length of second chain to all totals of first chain */
;;;624        p->tot_len += t->tot_len;
;;;625      }
;;;626      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;627      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
;;;628      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;629      /* add total length of second chain to last pbuf total of first chain */
;;;630      p->tot_len += t->tot_len;
;;;631      /* chain last pbuf of head (p) with first of tail (t) */
;;;632      p->next = t;
;;;633      /* p->next now references t, but the caller will drop its reference to t,
;;;634       * so netto there is no change to the reference count of t.
;;;635       */
;;;636    }
00001e  bd70              POP      {r4-r6,pc}
                  |L2.32|
000020  bf00              NOP                            ;618
000022  4634              MOV      r4,r6                 ;622
000024  e004              B        |L2.48|
                  |L2.38|
000026  8920              LDRH     r0,[r4,#8]            ;624
000028  8929              LDRH     r1,[r5,#8]            ;624
00002a  4408              ADD      r0,r0,r1              ;624
00002c  8120              STRH     r0,[r4,#8]            ;624
00002e  6824              LDR      r4,[r4,#0]            ;622
                  |L2.48|
000030  6820              LDR      r0,[r4,#0]            ;622
000032  2800              CMP      r0,#0                 ;622
000034  d1f7              BNE      |L2.38|
000036  8920              LDRH     r0,[r4,#8]            ;630
000038  8929              LDRH     r1,[r5,#8]            ;630
00003a  4408              ADD      r0,r0,r1              ;630
00003c  8120              STRH     r0,[r4,#8]            ;630
00003e  6025              STR      r5,[r4,#0]            ;632
000040  bf00              NOP      
000042  e7ec              B        |L2.30|
;;;637    
                          ENDP

                  |L2.68|
000044  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\pbuf.c",0
000048  7749505c
00004c  7372635c
000050  636f7265
000054  5c706275
000058  662e6300
                  |L2.92|
00005c  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000060  3d204e55
000064  4c4c2920
000068  26262028
00006c  7420213d
000070  204e554c
000074  4c292028
000078  70726f67
00007c  72616d6d
000080  65722076
000084  696f6c61
000088  74657320
00008c  41504929
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L2.148|
000094  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000098  7274696f
00009c  6e202225
0000a0  73222066
0000a4  61696c65
0000a8  64206174
0000ac  206c696e
0000b0  65202564
0000b4  20696e20
0000b8  25730a00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;654    void
;;;655    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;656    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;657      pbuf_cat(h, t);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       pbuf_cat
;;;658      /* t is now referenced by h */
;;;659      pbuf_ref(t);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pbuf_ref
;;;660      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
000014  bf00              NOP      
000016  bf00              NOP      
;;;661    }
000018  bd70              POP      {r4-r6,pc}
;;;662    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;572    u8_t
;;;573    pbuf_clen(struct pbuf *p)
000000  4601              MOV      r1,r0
;;;574    {
;;;575      u8_t len;
;;;576    
;;;577      len = 0;
000002  2000              MOVS     r0,#0
;;;578      while (p != NULL) {
000004  e002              B        |L4.12|
                  |L4.6|
;;;579        ++len;
000006  1c42              ADDS     r2,r0,#1
000008  b2d0              UXTB     r0,r2
;;;580        p = p->next;
00000a  6809              LDR      r1,[r1,#0]
                  |L4.12|
00000c  2900              CMP      r1,#0                 ;578
00000e  d1fa              BNE      |L4.6|
;;;581      }
;;;582      return len;
;;;583    }
000010  4770              BX       lr
;;;584    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=1

                  pbuf_coalesce PROC
;;;878    struct pbuf*
;;;879    pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;880    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;881      struct pbuf *q;
;;;882      err_t err;
;;;883      if (p->next == NULL) {
000008  6820              LDR      r0,[r4,#0]
00000a  b910              CBNZ     r0,|L5.18|
;;;884        return p;
00000c  4620              MOV      r0,r4
                  |L5.14|
;;;885      }
;;;886      q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
;;;887      if (q == NULL) {
;;;888        /* @todo: what do we do now? */
;;;889        return p;
;;;890      }
;;;891      err = pbuf_copy(q, p);
;;;892      if(err!= ERR_OK)
;;;893      	LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
;;;894      pbuf_free(p);
;;;895      return q;
;;;896    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.18|
000012  8921              LDRH     r1,[r4,#8]            ;886
000014  2200              MOVS     r2,#0                 ;886
000016  4630              MOV      r0,r6                 ;886
000018  f7fffffe          BL       pbuf_alloc
00001c  4605              MOV      r5,r0                 ;886
00001e  b90d              CBNZ     r5,|L5.36|
000020  4620              MOV      r0,r4                 ;889
000022  e7f4              B        |L5.14|
                  |L5.36|
000024  4621              MOV      r1,r4                 ;891
000026  4628              MOV      r0,r5                 ;891
000028  f7fffffe          BL       pbuf_copy
00002c  4607              MOV      r7,r0                 ;891
00002e  4620              MOV      r0,r4                 ;894
000030  f7fffffe          BL       pbuf_free
000034  4628              MOV      r0,r5                 ;895
000036  e7ea              B        |L5.14|
                          ENDP


                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy PROC
;;;720    err_t
;;;721    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;722    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;723      u16_t offset_to=0, offset_from=0, len;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;724    
;;;725      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;726        (void*)p_to, (void*)p_from));
;;;727    
;;;728      /* is the target big enough to hold the source? */
;;;729      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000010  bf00              NOP      
000012  b125              CBZ      r5,|L6.30|
000014  b11c              CBZ      r4,|L6.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  da0c              BGE      |L6.56|
                  |L6.30|
00001e  bf00              NOP      
000020  a331              ADR      r3,|L6.232|
000022  f24022d9          MOV      r2,#0x2d9
000026  a136              ADR      r1,|L6.256|
000028  a041              ADR      r0,|L6.304|
00002a  f7fffffe          BL       __2printf
00002e  bf00              NOP      
000030  f06f0009          MVN      r0,#9
                  |L6.52|
;;;730                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;731    
;;;732      /* iterate through pbuf chain */
;;;733      do
;;;734      {
;;;735        LWIP_ASSERT("p_to != NULL", p_to != NULL);
;;;736        /* copy one part of the original chain */
;;;737        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;738          /* complete current p_from fits into current p_to */
;;;739          len = p_from->len - offset_from;
;;;740        } else {
;;;741          /* current p_from does not fit into current p_to */
;;;742          len = p_to->len - offset_to;
;;;743        }
;;;744        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;745        offset_to += len;
;;;746        offset_from += len;
;;;747        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;748        if (offset_to == p_to->len) {
;;;749          /* on to next p_to (if any) */
;;;750          offset_to = 0;
;;;751          p_to = p_to->next;
;;;752        }
;;;753        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;754        if (offset_from >= p_from->len) {
;;;755          /* on to next p_from (if any) */
;;;756          offset_from = 0;
;;;757          p_from = p_from->next;
;;;758        }
;;;759    
;;;760        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;761          /* don't copy more than one packet! */
;;;762          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;763                     (p_from->next == NULL), return ERR_VAL;);
;;;764        }
;;;765        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;766          /* don't copy more than one packet! */
;;;767          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;768                      (p_to->next == NULL), return ERR_VAL;);
;;;769        }
;;;770      } while (p_from);
;;;771      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
;;;772      return ERR_OK;
;;;773    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L6.56|
000038  bf00              NOP                            ;729
00003a  bf00              NOP                            ;733
                  |L6.60|
00003c  8968              LDRH     r0,[r5,#0xa]          ;737
00003e  1b80              SUBS     r0,r0,r6              ;737
000040  8961              LDRH     r1,[r4,#0xa]          ;737
000042  1bc9              SUBS     r1,r1,r7              ;737
000044  4288              CMP      r0,r1                 ;737
000046  db04              BLT      |L6.82|
000048  8960              LDRH     r0,[r4,#0xa]          ;739
00004a  1bc0              SUBS     r0,r0,r7              ;739
00004c  fa1ff880          UXTH     r8,r0                 ;739
000050  e003              B        |L6.90|
                  |L6.82|
000052  8968              LDRH     r0,[r5,#0xa]          ;742
000054  1b80              SUBS     r0,r0,r6              ;742
000056  fa1ff880          UXTH     r8,r0                 ;742
                  |L6.90|
00005a  6862              LDR      r2,[r4,#4]            ;744
00005c  19d1              ADDS     r1,r2,r7              ;744
00005e  686a              LDR      r2,[r5,#4]            ;744
000060  1990              ADDS     r0,r2,r6              ;744
000062  4642              MOV      r2,r8                 ;744
000064  f7fffffe          BL       __aeabi_memcpy
000068  eb060008          ADD      r0,r6,r8              ;745
00006c  b286              UXTH     r6,r0                 ;745
00006e  eb070008          ADD      r0,r7,r8              ;746
000072  b287              UXTH     r7,r0                 ;746
000074  8968              LDRH     r0,[r5,#0xa]          ;748
000076  42b0              CMP      r0,r6                 ;748
000078  d101              BNE      |L6.126|
00007a  2600              MOVS     r6,#0                 ;750
00007c  682d              LDR      r5,[r5,#0]            ;751
                  |L6.126|
00007e  8960              LDRH     r0,[r4,#0xa]          ;754
000080  42b8              CMP      r0,r7                 ;754
000082  dc01              BGT      |L6.136|
000084  2700              MOVS     r7,#0                 ;756
000086  6824              LDR      r4,[r4,#0]            ;757
                  |L6.136|
000088  b19c              CBZ      r4,|L6.178|
00008a  8960              LDRH     r0,[r4,#0xa]          ;760
00008c  8921              LDRH     r1,[r4,#8]            ;760
00008e  4288              CMP      r0,r1                 ;760
000090  d10f              BNE      |L6.178|
000092  bf00              NOP                            ;762
000094  6820              LDR      r0,[r4,#0]            ;762
000096  b158              CBZ      r0,|L6.176|
000098  bf00              NOP                            ;762
00009a  a313              ADR      r3,|L6.232|
00009c  f24022fa          MOV      r2,#0x2fa             ;762
0000a0  a12d              ADR      r1,|L6.344|
0000a2  a023              ADR      r0,|L6.304|
0000a4  f7fffffe          BL       __2printf
0000a8  bf00              NOP                            ;762
0000aa  f06f0008          MVN      r0,#8                 ;762
0000ae  e7c1              B        |L6.52|
                  |L6.176|
0000b0  bf00              NOP                            ;762
                  |L6.178|
0000b2  b19d              CBZ      r5,|L6.220|
0000b4  8968              LDRH     r0,[r5,#0xa]          ;765
0000b6  8929              LDRH     r1,[r5,#8]            ;765
0000b8  4288              CMP      r0,r1                 ;765
0000ba  d10f              BNE      |L6.220|
0000bc  bf00              NOP                            ;767
0000be  6828              LDR      r0,[r5,#0]            ;767
0000c0  b158              CBZ      r0,|L6.218|
0000c2  bf00              NOP                            ;767
0000c4  a308              ADR      r3,|L6.232|
0000c6  f24022ff          MOV      r2,#0x2ff             ;767
0000ca  a123              ADR      r1,|L6.344|
0000cc  a018              ADR      r0,|L6.304|
0000ce  f7fffffe          BL       __2printf
0000d2  bf00              NOP                            ;767
0000d4  f06f0008          MVN      r0,#8                 ;767
0000d8  e7ac              B        |L6.52|
                  |L6.218|
0000da  bf00              NOP                            ;767
                  |L6.220|
0000dc  2c00              CMP      r4,#0                 ;770
0000de  d1ad              BNE      |L6.60|
0000e0  bf00              NOP                            ;771
0000e2  bf00              NOP                            ;771
0000e4  2000              MOVS     r0,#0                 ;772
0000e6  e7a5              B        |L6.52|
;;;774    
                          ENDP

                  |L6.232|
0000e8  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\pbuf.c",0
0000ec  7749505c
0000f0  7372635c
0000f4  636f7265
0000f8  5c706275
0000fc  662e6300
                  |L6.256|
000100  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000104  5f636f70
000108  793a2074
00010c  61726765
000110  74206e6f
000114  74206269
000118  6720656e
00011c  6f756768
000120  20746f20
000124  686f6c64
000128  20736f75
00012c  72636500
                  |L6.304|
000130  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000134  7274696f
000138  6e202225
00013c  73222066
000140  61696c65
000144  64206174
000148  206c696e
00014c  65202564
000150  20696e20
000154  25730a00
                  |L6.344|
000158  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
00015c  5f636f70
000160  79282920
000164  646f6573
000168  206e6f74
00016c  20616c6c
000170  6f772070
000174  61636b65
000178  74207175
00017c  65756573
000180  210a00  
000183  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy_partial PROC
;;;786    u16_t
;;;787    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;788    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;789      struct pbuf *p;
;;;790      u16_t left;
;;;791      u16_t buf_copy_len;
;;;792      u16_t copied_total = 0;
00000c  f04f0b00          MOV      r11,#0
;;;793    
;;;794      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
000010  bf00              NOP      
000012  f1b80f00          CMP      r8,#0
000016  d10b              BNE      |L7.48|
000018  bf00              NOP      
00001a  a327              ADR      r3,|L7.184|
00001c  f240321a          MOV      r2,#0x31a
000020  a12b              ADR      r1,|L7.208|
000022  a033              ADR      r0,|L7.240|
000024  f7fffffe          BL       __2printf
000028  bf00              NOP      
00002a  2000              MOVS     r0,#0
                  |L7.44|
;;;795      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
;;;796    
;;;797      left = 0;
;;;798    
;;;799      if((buf == NULL) || (dataptr == NULL)) {
;;;800        return 0;
;;;801      }
;;;802    
;;;803      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;804      for(p = buf; len != 0 && p != NULL; p = p->next) {
;;;805        if ((offset != 0) && (offset >= p->len)) {
;;;806          /* don't copy from this buffer -> on to the next */
;;;807          offset -= p->len;
;;;808        } else {
;;;809          /* copy from this buffer. maybe only partially. */
;;;810          buf_copy_len = p->len - offset;
;;;811          if (buf_copy_len > len)
;;;812              buf_copy_len = len;
;;;813          /* copy the necessary parts of the buffer */
;;;814          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;815          copied_total += buf_copy_len;
;;;816          left += buf_copy_len;
;;;817          len -= buf_copy_len;
;;;818          offset = 0;
;;;819        }
;;;820      }
;;;821      return copied_total;
;;;822    }
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.48|
000030  bf00              NOP                            ;794
000032  bf00              NOP                            ;795
000034  f1b90f00          CMP      r9,#0                 ;795
000038  d10a              BNE      |L7.80|
00003a  bf00              NOP                            ;795
00003c  a31e              ADR      r3,|L7.184|
00003e  f240321b          MOV      r2,#0x31b             ;795
000042  a135              ADR      r1,|L7.280|
000044  a02a              ADR      r0,|L7.240|
000046  f7fffffe          BL       __2printf
00004a  bf00              NOP                            ;795
00004c  2000              MOVS     r0,#0                 ;795
00004e  e7ed              B        |L7.44|
                  |L7.80|
000050  bf00              NOP                            ;795
000052  f04f0a00          MOV      r10,#0                ;797
000056  f1b80f00          CMP      r8,#0                 ;799
00005a  d002              BEQ      |L7.98|
00005c  f1b90f00          CMP      r9,#0                 ;799
000060  d101              BNE      |L7.102|
                  |L7.98|
000062  2000              MOVS     r0,#0                 ;800
000064  e7e2              B        |L7.44|
                  |L7.102|
000066  4644              MOV      r4,r8                 ;804
000068  e020              B        |L7.172|
                  |L7.106|
00006a  b135              CBZ      r5,|L7.122|
00006c  8960              LDRH     r0,[r4,#0xa]          ;805
00006e  42a8              CMP      r0,r5                 ;805
000070  dc03              BGT      |L7.122|
000072  8960              LDRH     r0,[r4,#0xa]          ;807
000074  1a28              SUBS     r0,r5,r0              ;807
000076  b285              UXTH     r5,r0                 ;807
000078  e017              B        |L7.170|
                  |L7.122|
00007a  8960              LDRH     r0,[r4,#0xa]          ;810
00007c  1b40              SUBS     r0,r0,r5              ;810
00007e  b287              UXTH     r7,r0                 ;810
000080  42b7              CMP      r7,r6                 ;811
000082  dd00              BLE      |L7.134|
000084  4637              MOV      r7,r6                 ;812
                  |L7.134|
000086  6862              LDR      r2,[r4,#4]            ;814
000088  1951              ADDS     r1,r2,r5              ;814
00008a  eb09000a          ADD      r0,r9,r10             ;814
00008e  463a              MOV      r2,r7                 ;814
000090  f7fffffe          BL       __aeabi_memcpy
000094  eb0b0007          ADD      r0,r11,r7             ;815
000098  fa1ffb80          UXTH     r11,r0                ;815
00009c  eb0a0007          ADD      r0,r10,r7             ;816
0000a0  fa1ffa80          UXTH     r10,r0                ;816
0000a4  1bf0              SUBS     r0,r6,r7              ;817
0000a6  b286              UXTH     r6,r0                 ;817
0000a8  2500              MOVS     r5,#0                 ;818
                  |L7.170|
0000aa  6824              LDR      r4,[r4,#0]            ;804
                  |L7.172|
0000ac  b10e              CBZ      r6,|L7.178|
0000ae  2c00              CMP      r4,#0                 ;804
0000b0  d1db              BNE      |L7.106|
                  |L7.178|
0000b2  4658              MOV      r0,r11                ;821
0000b4  e7ba              B        |L7.44|
;;;823    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L7.184|
0000b8  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\pbuf.c",0
0000bc  7749505c
0000c0  7372635c
0000c4  636f7265
0000c8  5c706275
0000cc  662e6300
                  |L7.208|
0000d0  70627566          DCB      "pbuf_copy_partial: invalid buf",0
0000d4  5f636f70
0000d8  795f7061
0000dc  72746961
0000e0  6c3a2069
0000e4  6e76616c
0000e8  69642062
0000ec  756600  
0000ef  00                DCB      0
                  |L7.240|
0000f0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f4  7274696f
0000f8  6e202225
0000fc  73222066
000100  61696c65
000104  64206174
000108  206c696e
00010c  65202564
000110  20696e20
000114  25730a00
                  |L7.280|
000118  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
00011c  5f636f70
000120  795f7061
000124  72746961
000128  6c3a2069
00012c  6e76616c
000130  69642064
000134  61746170
000138  747200  
00013b  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=1

                  pbuf_dechain PROC
;;;671    struct pbuf *
;;;672    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;673    {
000002  4604              MOV      r4,r0
;;;674      struct pbuf *q;
;;;675      u8_t tail_gone = 1;
000004  2601              MOVS     r6,#1
;;;676      /* tail */
;;;677      q = p->next;
000006  6825              LDR      r5,[r4,#0]
;;;678      /* pbuf has successor in chain? */
;;;679      if (q != NULL) {
000008  b18d              CBZ      r5,|L8.46|
;;;680        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;681        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
;;;682        /* enforce invariant if assertion is disabled */
;;;683        q->tot_len = p->tot_len - p->len;
00000a  8920              LDRH     r0,[r4,#8]
00000c  8961              LDRH     r1,[r4,#0xa]
00000e  1a40              SUBS     r0,r0,r1
000010  8128              STRH     r0,[r5,#8]
;;;684        /* decouple pbuf from remainder */
;;;685        p->next = NULL;
000012  2000              MOVS     r0,#0
000014  6020              STR      r0,[r4,#0]
;;;686        /* total length of pbuf p is its own length only */
;;;687        p->tot_len = p->len;
000016  8960              LDRH     r0,[r4,#0xa]
000018  8120              STRH     r0,[r4,#8]
;;;688        /* q is no longer referenced by p, free it */
;;;689        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;690        tail_gone = pbuf_free(q);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       pbuf_free
000024  4606              MOV      r6,r0
;;;691        if (tail_gone > 0) {
000026  2e00              CMP      r6,#0
000028  dd01              BLE      |L8.46|
;;;692          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE,
00002a  bf00              NOP      
00002c  bf00              NOP      
                  |L8.46|
;;;693                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;694        }
;;;695        /* return remaining tail or NULL if deallocated */
;;;696      }
;;;697      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;698      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
;;;699      return ((tail_gone > 0) ? NULL : q);
00002e  2e00              CMP      r6,#0
000030  dd01              BLE      |L8.54|
000032  2000              MOVS     r0,#0
                  |L8.52|
;;;700    }
000034  bd70              POP      {r4-r6,pc}
                  |L8.54|
000036  4628              MOV      r0,r5                 ;699
000038  e7fc              B        |L8.52|
;;;701    
                          ENDP


                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=1

                  pbuf_free PROC
;;;497    u8_t
;;;498    pbuf_free(struct pbuf *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;499    {
000004  4604              MOV      r4,r0
;;;500      u16_t type;
;;;501      struct pbuf *q;
;;;502      u8_t count;
;;;503    
;;;504      if (p == NULL) {
000006  b924              CBNZ     r4,|L9.18|
;;;505        LWIP_ASSERT("p != NULL", p != NULL);
;;;506        /* if assertions are disabled, proceed with debug output */
;;;507        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
000008  bf00              NOP      
00000a  bf00              NOP      
;;;508        return 0;
00000c  2000              MOVS     r0,#0
                  |L9.14|
;;;509      }
;;;510      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));
;;;511    
;;;512      PERF_START;
;;;513    
;;;514      LWIP_ASSERT("pbuf_free: sane type",
;;;515        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;516        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;517    
;;;518      count = 0;
;;;519      /* de-allocate all consecutive pbufs from the head of the chain that
;;;520       * obtain a zero reference count after decrementing*/
;;;521      while (p != NULL) {
;;;522        u16_t ref;
;;;523        SYS_ARCH_DECL_PROTECT(old_level);
;;;524        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;525         * we must protect it. We put the new ref into a local variable to prevent
;;;526         * further protection. */
;;;527        SYS_ARCH_PROTECT(old_level);
;;;528        /* all pbufs in a chain are referenced at least once */
;;;529        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;530        /* decrease reference count (number of pointers to pbuf) */
;;;531        ref = --(p->ref);
;;;532        SYS_ARCH_UNPROTECT(old_level);
;;;533        /* this pbuf is no longer referenced to? */
;;;534        if (ref == 0) {
;;;535          /* remember next pbuf in chain for next iteration */
;;;536          q = p->next;
;;;537          LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
;;;538          type = p->type;
;;;539          /* is this a pbuf from the pool? */
;;;540          if (type == PBUF_POOL) {
;;;541            memp_free(MEMP_PBUF_POOL, p);
;;;542          /* is this a ROM or RAM referencing pbuf? */
;;;543          } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;544            memp_free(MEMP_PBUF, p);
;;;545          /* type == PBUF_RAM */
;;;546          } else {
;;;547            mem_free(p);
;;;548          }
;;;549          count++;
;;;550          /* proceed to next pbuf */
;;;551          p = q;
;;;552        /* p->ref > 0, this pbuf is still referenced to */
;;;553        /* (and so the remaining pbufs in chain as well) */
;;;554        } else {
;;;555          LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;556          /* stop walking through the chain */
;;;557          p = NULL;
;;;558        }
;;;559      }
;;;560      PERF_STOP("pbuf_free");
;;;561      /* return number of de-allocated pbufs */
;;;562      return count;
;;;563    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L9.18|
000012  bf00              NOP                            ;510
000014  bf00              NOP                            ;510
000016  2600              MOVS     r6,#0                 ;518
000018  e026              B        |L9.104|
                  |L9.26|
00001a  89e0              LDRH     r0,[r4,#0xe]          ;531
00001c  1e40              SUBS     r0,r0,#1              ;531
00001e  b280              UXTH     r0,r0                 ;531
000020  81e0              STRH     r0,[r4,#0xe]          ;531
000022  4680              MOV      r8,r0                 ;531
000024  f1b80f00          CMP      r8,#0                 ;534
000028  d11a              BNE      |L9.96|
00002a  6827              LDR      r7,[r4,#0]            ;536
00002c  bf00              NOP                            ;537
00002e  bf00              NOP                            ;537
000030  7b25              LDRB     r5,[r4,#0xc]          ;538
000032  2d03              CMP      r5,#3                 ;540
000034  d104              BNE      |L9.64|
000036  4621              MOV      r1,r4                 ;541
000038  2008              MOVS     r0,#8                 ;541
00003a  f7fffffe          BL       memp_free
00003e  e00b              B        |L9.88|
                  |L9.64|
000040  2d01              CMP      r5,#1                 ;543
000042  d001              BEQ      |L9.72|
000044  2d02              CMP      r5,#2                 ;543
000046  d104              BNE      |L9.82|
                  |L9.72|
000048  4621              MOV      r1,r4                 ;544
00004a  2007              MOVS     r0,#7                 ;544
00004c  f7fffffe          BL       memp_free
000050  e002              B        |L9.88|
                  |L9.82|
000052  4620              MOV      r0,r4                 ;547
000054  f7fffffe          BL       mem_free
                  |L9.88|
000058  1c70              ADDS     r0,r6,#1              ;549
00005a  b2c6              UXTB     r6,r0                 ;549
00005c  463c              MOV      r4,r7                 ;551
00005e  e002              B        |L9.102|
                  |L9.96|
000060  bf00              NOP                            ;555
000062  bf00              NOP                            ;555
000064  2400              MOVS     r4,#0                 ;557
                  |L9.102|
000066  bf00              NOP                            ;559
                  |L9.104|
000068  2c00              CMP      r4,#0                 ;521
00006a  d1d6              BNE      |L9.26|
00006c  4630              MOV      r0,r6                 ;562
00006e  e7ce              B        |L9.14|
;;;564    
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_header PROC
;;;390    u8_t
;;;391    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;392    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;393      u16_t type;
;;;394      void *payload;
;;;395      u16_t increment_magnitude;
;;;396    
;;;397      LWIP_ASSERT("p != NULL", p != NULL);
;;;398      if ((header_size_increment == 0) || (p == NULL))
000008  b105              CBZ      r5,|L10.12|
00000a  b914              CBNZ     r4,|L10.18|
                  |L10.12|
;;;399        return 0;
00000c  2000              MOVS     r0,#0
                  |L10.14|
;;;400     
;;;401      if (header_size_increment < 0){
;;;402        increment_magnitude = -header_size_increment;
;;;403        /* Check that we aren't going to move off the end of the pbuf */
;;;404        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;405      } else {
;;;406        increment_magnitude = header_size_increment;
;;;407    #if 0
;;;408        /* Can't assert these as some callers speculatively call
;;;409             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;410        /* Check that we've got the correct type of pbuf to work with */
;;;411        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;412                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;413        /* Check that we aren't going to move off the beginning of the pbuf */
;;;414        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;415                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;416    #endif
;;;417      }
;;;418    
;;;419      type = p->type;
;;;420      /* remember current payload pointer */
;;;421      payload = p->payload;
;;;422    
;;;423      /* pbuf types containing payloads? */
;;;424      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;425        /* set new payload pointer */
;;;426        p->payload = (u8_t *)p->payload - header_size_increment;
;;;427        /* boundary check fails? */
;;;428        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;429          LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;430            (void *)p->payload,
;;;431            (void *)(p + 1)));\
;;;432          /* restore old payload pointer */
;;;433          p->payload = payload;
;;;434          /* bail out unsuccesfully */
;;;435          return 1;
;;;436        }
;;;437      /* pbuf types refering to external payloads? */
;;;438      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;439        /* hide a header in the payload? */
;;;440        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;441          /* increase payload pointer */
;;;442          p->payload = (u8_t *)p->payload - header_size_increment;
;;;443        } else {
;;;444          /* cannot expand payload to front (yet!)
;;;445           * bail out unsuccesfully */
;;;446          return 1;
;;;447        }
;;;448      }
;;;449      else {
;;;450        /* Unknown type */
;;;451        LWIP_ASSERT("bad pbuf type", 0);
;;;452        return 1;
;;;453      }
;;;454      /* modify pbuf length fields */
;;;455      p->len += header_size_increment;
;;;456      p->tot_len += header_size_increment;
;;;457    
;;;458      LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;459        (void *)payload, (void *)p->payload, header_size_increment));
;;;460    
;;;461      return 0;
;;;462    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L10.18|
000012  2d00              CMP      r5,#0                 ;401
000014  da11              BGE      |L10.58|
000016  4268              RSBS     r0,r5,#0              ;402
000018  b287              UXTH     r7,r0                 ;402
00001a  bf00              NOP                            ;404
00001c  8960              LDRH     r0,[r4,#0xa]          ;404
00001e  42b8              CMP      r0,r7                 ;404
000020  da0a              BGE      |L10.56|
000022  bf00              NOP                            ;404
000024  a31d              ADR      r3,|L10.156|
000026  f44f72ca          MOV      r2,#0x194             ;404
00002a  a122              ADR      r1,|L10.180|
00002c  a029              ADR      r0,|L10.212|
00002e  f7fffffe          BL       __2printf
000032  bf00              NOP                            ;404
000034  2001              MOVS     r0,#1                 ;404
000036  e7ea              B        |L10.14|
                  |L10.56|
000038  e000              B        |L10.60|
                  |L10.58|
00003a  b2af              UXTH     r7,r5                 ;406
                  |L10.60|
00003c  7b26              LDRB     r6,[r4,#0xc]          ;419
00003e  f8d48004          LDR      r8,[r4,#4]            ;421
000042  b10e              CBZ      r6,|L10.72|
000044  2e03              CMP      r6,#3                 ;424
000046  d10d              BNE      |L10.100|
                  |L10.72|
000048  6860              LDR      r0,[r4,#4]            ;426
00004a  1b40              SUBS     r0,r0,r5              ;426
00004c  6060              STR      r0,[r4,#4]            ;426
00004e  f1040010          ADD      r0,r4,#0x10           ;428
000052  6861              LDR      r1,[r4,#4]            ;428
000054  4281              CMP      r1,r0                 ;428
000056  d216              BCS      |L10.134|
000058  bf00              NOP                            ;429
00005a  bf00              NOP                            ;429
00005c  f8c48004          STR      r8,[r4,#4]            ;433
000060  2001              MOVS     r0,#1                 ;435
000062  e7d4              B        |L10.14|
                  |L10.100|
000064  2e02              CMP      r6,#2                 ;438
000066  d001              BEQ      |L10.108|
000068  2e01              CMP      r6,#1                 ;438
00006a  d10a              BNE      |L10.130|
                  |L10.108|
00006c  2d00              CMP      r5,#0                 ;440
00006e  da06              BGE      |L10.126|
000070  8960              LDRH     r0,[r4,#0xa]          ;440
000072  42b8              CMP      r0,r7                 ;440
000074  db03              BLT      |L10.126|
000076  6860              LDR      r0,[r4,#4]            ;442
000078  1b40              SUBS     r0,r0,r5              ;442
00007a  6060              STR      r0,[r4,#4]            ;442
00007c  e003              B        |L10.134|
                  |L10.126|
00007e  2001              MOVS     r0,#1                 ;446
000080  e7c5              B        |L10.14|
                  |L10.130|
000082  2001              MOVS     r0,#1                 ;452
000084  e7c3              B        |L10.14|
                  |L10.134|
000086  8960              LDRH     r0,[r4,#0xa]          ;455
000088  4428              ADD      r0,r0,r5              ;455
00008a  8160              STRH     r0,[r4,#0xa]          ;455
00008c  8920              LDRH     r0,[r4,#8]            ;456
00008e  4428              ADD      r0,r0,r5              ;456
000090  8120              STRH     r0,[r4,#8]            ;456
000092  bf00              NOP                            ;458
000094  bf00              NOP                            ;458
000096  2000              MOVS     r0,#0                 ;461
000098  e7b9              B        |L10.14|
;;;463    
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
00009c  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\pbuf.c",0
0000a0  7749505c
0000a4  7372635c
0000a8  636f7265
0000ac  5c706275
0000b0  662e6300
                  |L10.180|
0000b4  696e6372          DCB      "increment_magnitude <= p->len",0
0000b8  656d656e
0000bc  745f6d61
0000c0  676e6974
0000c4  75646520
0000c8  3c3d2070
0000cc  2d3e6c65
0000d0  6e00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L10.212|
0000d4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d8  7274696f
0000dc  6e202225
0000e0  73222066
0000e4  61696c65
0000e8  64206174
0000ec  206c696e
0000f0  65202564
0000f4  20696e20
0000f8  25730a00

                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=1

                  pbuf_realloc PROC
;;;309    void
;;;310    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;311    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;312      struct pbuf *q;
;;;313      u16_t rem_len; /* remaining length */
;;;314      s32_t grow;
;;;315    
;;;316      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
;;;317      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
;;;318                  p->type == PBUF_ROM ||
;;;319                  p->type == PBUF_RAM ||
;;;320                  p->type == PBUF_REF);
;;;321    
;;;322      /* desired length larger than current length? */
;;;323      if (new_len >= p->tot_len) {
000008  8930              LDRH     r0,[r6,#8]
00000a  42b8              CMP      r0,r7
00000c  dc01              BGT      |L11.18|
                  |L11.14|
;;;324        /* enlarging not yet supported */
;;;325        return;
;;;326      }
;;;327    
;;;328      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;329       * (which may be negative in case of shrinking) */
;;;330      grow = new_len - p->tot_len;
;;;331    
;;;332      /* first, step over any pbufs that should remain in the chain */
;;;333      rem_len = new_len;
;;;334      q = p;
;;;335      /* should this pbuf be kept? */
;;;336      while (rem_len > q->len) {
;;;337        /* decrease remaining length by pbuf length */
;;;338        rem_len -= q->len;
;;;339        /* decrease total length indicator */
;;;340        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
;;;341        q->tot_len += (u16_t)grow;
;;;342        /* proceed to next pbuf in chain */
;;;343        q = q->next;
;;;344        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;345      }
;;;346      /* we have now reached the new last pbuf (in q) */
;;;347      /* rem_len == desired length for pbuf q */
;;;348    
;;;349      /* shrink allocated memory for PBUF_RAM */
;;;350      /* (other types merely adjust their length fields */
;;;351      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;352        /* reallocate and adjust the length of the pbuf that will be split */
;;;353        q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
;;;354        LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
;;;355      }
;;;356      /* adjust length fields for new last pbuf */
;;;357      q->len = rem_len;
;;;358      q->tot_len = q->len;
;;;359    
;;;360      /* any remaining pbufs in chain? */
;;;361      if (q->next != NULL) {
;;;362        /* free remaining pbufs in chain */
;;;363        pbuf_free(q->next);
;;;364      }
;;;365      /* q is last packet in chain */
;;;366      q->next = NULL;
;;;367    
;;;368    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L11.18|
000012  8930              LDRH     r0,[r6,#8]            ;330
000014  eba70800          SUB      r8,r7,r0              ;330
000018  463d              MOV      r5,r7                 ;333
00001a  4634              MOV      r4,r6                 ;334
00001c  e006              B        |L11.44|
                  |L11.30|
00001e  8960              LDRH     r0,[r4,#0xa]          ;338
000020  1a28              SUBS     r0,r5,r0              ;338
000022  b285              UXTH     r5,r0                 ;338
000024  8920              LDRH     r0,[r4,#8]            ;341
000026  4440              ADD      r0,r0,r8              ;341
000028  8120              STRH     r0,[r4,#8]            ;341
00002a  6824              LDR      r4,[r4,#0]            ;343
                  |L11.44|
00002c  8960              LDRH     r0,[r4,#0xa]          ;336
00002e  42a8              CMP      r0,r5                 ;336
000030  dbf5              BLT      |L11.30|
000032  7b20              LDRB     r0,[r4,#0xc]          ;351
000034  b950              CBNZ     r0,|L11.76|
000036  8960              LDRH     r0,[r4,#0xa]          ;351
000038  42a8              CMP      r0,r5                 ;351
00003a  d007              BEQ      |L11.76|
00003c  6860              LDR      r0,[r4,#4]            ;353
00003e  1b00              SUBS     r0,r0,r4              ;353
000040  4428              ADD      r0,r0,r5              ;353
000042  b281              UXTH     r1,r0                 ;353
000044  4620              MOV      r0,r4                 ;353
000046  f7fffffe          BL       mem_realloc
00004a  4604              MOV      r4,r0                 ;353
                  |L11.76|
00004c  8165              STRH     r5,[r4,#0xa]          ;357
00004e  8960              LDRH     r0,[r4,#0xa]          ;358
000050  8120              STRH     r0,[r4,#8]            ;358
000052  6820              LDR      r0,[r4,#0]            ;361
000054  b110              CBZ      r0,|L11.92|
000056  6820              LDR      r0,[r4,#0]            ;363
000058  f7fffffe          BL       pbuf_free
                  |L11.92|
00005c  2000              MOVS     r0,#0                 ;366
00005e  6020              STR      r0,[r4,#0]            ;366
000060  bf00              NOP      
000062  e7d4              B        |L11.14|
;;;369    
                          ENDP


                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=1

                  pbuf_ref PROC
;;;591    void
;;;592    pbuf_ref(struct pbuf *p)
000000  b110              CBZ      r0,|L12.8|
;;;593    {
;;;594      SYS_ARCH_DECL_PROTECT(old_level);
;;;595      /* pbuf given? */
;;;596      if (p != NULL) {
;;;597        SYS_ARCH_PROTECT(old_level);
;;;598        ++(p->ref);
000002  89c1              LDRH     r1,[r0,#0xe]
000004  1c49              ADDS     r1,r1,#1
000006  81c1              STRH     r1,[r0,#0xe]
                  |L12.8|
;;;599        SYS_ARCH_UNPROTECT(old_level);
;;;600      }
;;;601    }
000008  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_take PROC
;;;834    err_t
;;;835    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;836    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
;;;837      struct pbuf *p;
;;;838      u16_t buf_copy_len;
;;;839      u16_t total_copy_len = len;
00000a  46c8              MOV      r8,r9
;;;840      u16_t copied_total = 0;
00000c  f04f0a00          MOV      r10,#0
;;;841    
;;;842      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
000010  bf00              NOP      
000012  b95c              CBNZ     r4,|L13.44|
000014  bf00              NOP      
000016  a31e              ADR      r3,|L13.144|
000018  f240324a          MOV      r2,#0x34a
00001c  a122              ADR      r1,|L13.168|
00001e  a028              ADR      r0,|L13.192|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP      
000026  2000              MOVS     r0,#0
                  |L13.40|
;;;843      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
;;;844    
;;;845      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;846        return ERR_ARG;
;;;847      }
;;;848    
;;;849      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;850      for(p = buf; total_copy_len != 0; p = p->next) {
;;;851        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;852        buf_copy_len = total_copy_len;
;;;853        if (buf_copy_len > p->len) {
;;;854          /* this pbuf cannot hold all remaining data */
;;;855          buf_copy_len = p->len;
;;;856        }
;;;857        /* copy the necessary parts of the buffer */
;;;858        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;859        total_copy_len -= buf_copy_len;
;;;860        copied_total += buf_copy_len;
;;;861      }
;;;862      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;863      return ERR_OK;
;;;864    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L13.44|
00002c  bf00              NOP                            ;842
00002e  bf00              NOP                            ;843
000030  b956              CBNZ     r6,|L13.72|
000032  bf00              NOP                            ;843
000034  a316              ADR      r3,|L13.144|
000036  f240324b          MOV      r2,#0x34b             ;843
00003a  a12b              ADR      r1,|L13.232|
00003c  a020              ADR      r0,|L13.192|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP                            ;843
000044  2000              MOVS     r0,#0                 ;843
000046  e7ef              B        |L13.40|
                  |L13.72|
000048  bf00              NOP                            ;843
00004a  b11c              CBZ      r4,|L13.84|
00004c  b116              CBZ      r6,|L13.84|
00004e  8920              LDRH     r0,[r4,#8]            ;845
000050  4548              CMP      r0,r9                 ;845
000052  da02              BGE      |L13.90|
                  |L13.84|
000054  f06f0009          MVN      r0,#9                 ;846
000058  e7e6              B        |L13.40|
                  |L13.90|
00005a  4625              MOV      r5,r4                 ;850
00005c  e013              B        |L13.134|
                  |L13.94|
00005e  4647              MOV      r7,r8                 ;852
000060  8968              LDRH     r0,[r5,#0xa]          ;853
000062  42b8              CMP      r0,r7                 ;853
000064  da00              BGE      |L13.104|
000066  896f              LDRH     r7,[r5,#0xa]          ;855
                  |L13.104|
000068  eb06010a          ADD      r1,r6,r10             ;858
00006c  463a              MOV      r2,r7                 ;858
00006e  6868              LDR      r0,[r5,#4]            ;858
000070  f7fffffe          BL       __aeabi_memcpy
000074  eba80007          SUB      r0,r8,r7              ;859
000078  fa1ff880          UXTH     r8,r0                 ;859
00007c  eb0a0007          ADD      r0,r10,r7             ;860
000080  fa1ffa80          UXTH     r10,r0                ;860
000084  682d              LDR      r5,[r5,#0]            ;850
                  |L13.134|
000086  f1b80f00          CMP      r8,#0                 ;850
00008a  d1e8              BNE      |L13.94|
00008c  2000              MOVS     r0,#0                 ;863
00008e  e7cb              B        |L13.40|
;;;865    
                          ENDP

                  |L13.144|
000090  2e2e5c6c          DCB      "..\\lwIP\\src\\core\\pbuf.c",0
000094  7749505c
000098  7372635c
00009c  636f7265
0000a0  5c706275
0000a4  662e6300
                  |L13.168|
0000a8  70627566          DCB      "pbuf_take: invalid buf",0
0000ac  5f74616b
0000b0  653a2069
0000b4  6e76616c
0000b8  69642062
0000bc  756600  
0000bf  00                DCB      0
                  |L13.192|
0000c0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c4  7274696f
0000c8  6e202225
0000cc  73222066
0000d0  61696c65
0000d4  64206174
0000d8  206c696e
0000dc  65202564
0000e0  20696e20
0000e4  25730a00
                  |L13.232|
0000e8  70627566          DCB      "pbuf_take: invalid dataptr",0
0000ec  5f74616b
0000f0  653a2069
0000f4  6e76616c
0000f8  69642064
0000fc  61746170
000100  747200  
000103  00                DCB      0
