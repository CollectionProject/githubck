; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\netapp.o --depend=.\obj\netapp.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\netapp.crf ..\netapp\netapp.c]
                          THUMB

                          AREA ||i.ClientConError||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ClientConError PROC
;;;160    /* TCP 客户端连接到服务器反馈*/
;;;161    static void ClientConError(void *arg, err_t err)
000000  b570              PUSH     {r4-r6,lr}
;;;162    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;163        TcpClient.connected=0;
000006  2000              MOVS     r0,#0
000008  4903              LDR      r1,|L1.24|
00000a  7308              STRB     r0,[r1,#0xc]
;;;164        printf("TCP connect to server %d \r\n",err);
00000c  4621              MOV      r1,r4
00000e  a003              ADR      r0,|L1.28|
000010  f7fffffe          BL       __2printf
;;;165    }
000014  bd70              POP      {r4-r6,pc}
;;;166    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      TcpClient
                  |L1.28|
00001c  54435020          DCB      "TCP connect to server %d \r\n",0
000020  636f6e6e
000024  65637420
000028  746f2073
00002c  65727665
000030  72202564
000034  200d0a00

                          AREA ||i.ReConTcpServer||, CODE, READONLY, ALIGN=2

                  ReConTcpServer PROC
;;;180    
;;;181    void ReConTcpServer(void)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183        if(!TcpClient.connected){
000002  4803              LDR      r0,|L2.16|
000004  7b00              LDRB     r0,[r0,#0xc]  ; TcpClient
000006  b908              CBNZ     r0,|L2.12|
;;;184            TCP_Client_Init();
000008  f7fffffe          BL       TCP_Client_Init
                  |L2.12|
;;;185        }
;;;186    }
00000c  bd10              POP      {r4,pc}
;;;187    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      TcpClient

                          AREA ||i.TCP_Client_Init||, CODE, READONLY, ALIGN=2

                  TCP_Client_Init PROC
;;;167    /* TCP 客户端初始化 ，TcpClient.ipaddr连接到远程的服务器 ，*/
;;;168    void TCP_Client_Init(void) 
000000  b510              PUSH     {r4,lr}
;;;169    { 
;;;170        TcpClient.connected=1;
000002  2001              MOVS     r0,#1
000004  4910              LDR      r1,|L3.72|
000006  7308              STRB     r0,[r1,#0xc]
;;;171        IP4_ADDR(&TcpClient.ipaddr,192,168,1,3);
000008  4810              LDR      r0,|L3.76|
00000a  f7fffffe          BL       htonl
00000e  490e              LDR      r1,|L3.72|
000010  6048              STR      r0,[r1,#4]  ; TcpClient
;;;172        TcpClient.port=8080;
000012  f6417090          MOV      r0,#0x1f90
000016  6088              STR      r0,[r1,#8]  ; TcpClient
;;;173        TcpClient.pcb=tcp_new();                  /*  建立通信的TCP 控制块(Clipcb)                */
000018  f7fffffe          BL       tcp_new
00001c  490a              LDR      r1,|L3.72|
00001e  6008              STR      r0,[r1,#0]  ; TcpClient
;;;174        tcp_bind(TcpClient.pcb,IP_ADDR_ANY,0);    /*  绑定本地IP 地址和端口号*/
000020  2200              MOVS     r2,#0
000022  6808              LDR      r0,[r1,#0]  ; TcpClient
000024  490a              LDR      r1,|L3.80|
000026  f7fffffe          BL       tcp_bind
;;;175        tcp_err(TcpClient.pcb, ClientConError);
00002a  4907              LDR      r1,|L3.72|
00002c  6808              LDR      r0,[r1,#0]  ; TcpClient
00002e  4909              LDR      r1,|L3.84|
000030  f7fffffe          BL       tcp_err
;;;176        tcp_connect(TcpClient.pcb,&TcpClient.ipaddr,
000034  4904              LDR      r1,|L3.72|
000036  6889              LDR      r1,[r1,#8]  ; TcpClient
000038  b28a              UXTH     r2,r1
00003a  4903              LDR      r1,|L3.72|
00003c  4b06              LDR      r3,|L3.88|
00003e  6808              LDR      r0,[r1,#0]  ; TcpClient
000040  1d09              ADDS     r1,r1,#4
000042  f7fffffe          BL       tcp_connect
;;;177                    TcpClient.port,TcpCli_Connected);
;;;178    } 
000046  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  |L3.72|
                          DCD      TcpClient
                  |L3.76|
                          DCD      0xc0a80103
                  |L3.80|
                          DCD      ip_addr_any
                  |L3.84|
                          DCD      ClientConError
                  |L3.88|
                          DCD      TcpCli_Connected

                          AREA ||i.TcpCli_Connected||, CODE, READONLY, ALIGN=2

                  TcpCli_Connected PROC
;;;145    /* TCP 客户端接收到PC发送过来的数据，tcp_client_recv为数据处理*/
;;;146    err_t TcpCli_Connected(void *arg,struct tcp_pcb *pcb,err_t err) 
000000  b570              PUSH     {r4-r6,lr}
;;;147    { 
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;148        //printf("tcp connect %s",err ?"error":"ok");
;;;149        // tcp_write(pcb,html,1200,0);
;;;150        // tcp_sent(pcb, tcp_sended);
;;;151        tcp_arg(pcb,(void *)TCP_TestData);
000008  4906              LDR      r1,|L4.36|
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       tcp_arg
;;;152        tcp_recv(pcb,tcp_client_recv);
000010  4905              LDR      r1,|L4.40|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_recv
;;;153        TcpClient.connected=1;
000018  2001              MOVS     r0,#1
00001a  4904              LDR      r1,|L4.44|
00001c  7308              STRB     r0,[r1,#0xc]
;;;154        return ERR_OK;
00001e  2000              MOVS     r0,#0
;;;155    
;;;156    } 
000020  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      TCP_TestData
                  |L4.40|
                          DCD      tcp_client_recv
                  |L4.44|
                          DCD      TcpClient

                          AREA ||i.UDP_Receive||, CODE, READONLY, ALIGN=1

                  UDP_Receive PROC
;;;74     
;;;75     void UDP_Receive(void *arg, struct udp_pcb *upcb, struct pbuf *p,struct ip_addr *addr, u16_t port) 
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;76     { 
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
00000c  9f08              LDR      r7,[sp,#0x20]
;;;77         struct ip_addr ipaddr=*addr;
00000e  6830              LDR      r0,[r6,#0]
000010  9000              STR      r0,[sp,#0]
;;;78         char *pt=NULL;
000012  f04f0800          MOV      r8,#0
;;;79         if(p != NULL)
000016  b164              CBZ      r4,|L5.50|
;;;80         {
;;;81     	app_delay();
000018  f7fffffe          BL       app_delay
;;;82             udp_sendto(upcb,p,&ipaddr,port);  /* 将收到的数据再发送出去                   */
00001c  463b              MOV      r3,r7
00001e  466a              MOV      r2,sp
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       udp_sendto
;;;83             pt=p->payload;
000028  f8d48004          LDR      r8,[r4,#4]
;;;84             pbuf_free(p);                                           /*  释放缓冲区数据                      */
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       pbuf_free
                  |L5.50|
;;;85         } 
;;;86     } 
000032  e8bd83f8          POP      {r3-r9,pc}
;;;87     
                          ENDP


                          AREA ||i.UDP_Test||, CODE, READONLY, ALIGN=2

                  UDP_Test PROC
;;;89     const static char UDPData[]={"LwIP UDP客户端测试\r\n"}; 
;;;90     void UDP_Test(void) 
000000  b538              PUSH     {r3-r5,lr}
;;;91     { 
;;;92         struct udp_pcb *UdpPcb; 
;;;93         struct ip_addr ipaddr;
;;;94         struct pbuf *p;
;;;95         p = pbuf_alloc(PBUF_RAW,sizeof(UDPData),PBUF_RAM);
000002  2200              MOVS     r2,#0
000004  2115              MOVS     r1,#0x15
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       pbuf_alloc
00000c  4604              MOV      r4,r0
;;;96         if(p==NULL)
00000e  b904              CBNZ     r4,|L6.18|
                  |L6.16|
;;;97             return;
;;;98         p->payload=(void *)UDPData;
;;;99         UdpPcb=udp_new();                                       /*  建立UDP 通信的控制块(pcb)             */
;;;100        udp_bind(UdpPcb,IP_ADDR_ANY,8080);                      /*  绑定本地IP 地址                      */
;;;101        IP4_ADDR(&ipaddr,192, 168, 10, 100);
;;;102        udp_sendto(UdpPcb,p,&ipaddr,8080);                      /* 将收到的数据再发送出去                   */ 
;;;103        udp_recv(UdpPcb,UDP_Receive,NULL);                      /* 设置数据接收时的回调函数                   */
;;;104    
;;;105        LED1(1);
;;;106        LED2(1);
;;;107        LED3(1);
;;;108    }
000010  bd38              POP      {r3-r5,pc}
                  |L6.18|
000012  480e              LDR      r0,|L6.76|
000014  6060              STR      r0,[r4,#4]            ;98
000016  f7fffffe          BL       udp_new
00001a  4605              MOV      r5,r0                 ;99
00001c  f6417290          MOV      r2,#0x1f90            ;100
000020  490b              LDR      r1,|L6.80|
000022  4628              MOV      r0,r5                 ;100
000024  f7fffffe          BL       udp_bind
000028  480a              LDR      r0,|L6.84|
00002a  f7fffffe          BL       htonl
00002e  9000              STR      r0,[sp,#0]            ;101
000030  f6417390          MOV      r3,#0x1f90            ;102
000034  466a              MOV      r2,sp                 ;102
000036  4621              MOV      r1,r4                 ;102
000038  4628              MOV      r0,r5                 ;102
00003a  f7fffffe          BL       udp_sendto
00003e  2200              MOVS     r2,#0                 ;103
000040  4905              LDR      r1,|L6.88|
000042  4628              MOV      r0,r5                 ;103
000044  f7fffffe          BL       udp_recv
000048  bf00              NOP      
00004a  e7e1              B        |L6.16|
;;;109    
                          ENDP

                  |L6.76|
                          DCD      UDPData
                  |L6.80|
                          DCD      ip_addr_any
                  |L6.84|
                          DCD      0xc0a80a64
                  |L6.88|
                          DCD      UDP_Receive

                          AREA ||i.app_delay||, CODE, READONLY, ALIGN=1

                  app_delay PROC
;;;15     
;;;16     static void app_delay()
000000  2000              MOVS     r0,#0
;;;17     {
;;;18         int i;
;;;19         for(i=0;i<1000;i++);
000002  e000              B        |L7.6|
                  |L7.4|
000004  1c40              ADDS     r0,r0,#1
                  |L7.6|
000006  f5b07f7a          CMP      r0,#0x3e8
00000a  dbfb              BLT      |L7.4|
;;;20     }
00000c  4770              BX       lr
;;;21     void jdq_pro(u8 nData)
                          ENDP


                          AREA ||i.jdq_pro||, CODE, READONLY, ALIGN=2

                  jdq_pro PROC
;;;20     }
;;;21     void jdq_pro(u8 nData)
000000  f0100f01          TST      r0,#1
;;;22     {
;;;23     	if(nData & JDQ_1){
000004  d007              BEQ      |L8.22|
;;;24     		JDQ1(0);
000006  4935              LDR      r1,|L8.220|
000008  6809              LDR      r1,[r1,#0]
00000a  f0210110          BIC      r1,r1,#0x10
00000e  4a34              LDR      r2,|L8.224|
000010  f8c2180c          STR      r1,[r2,#0x80c]
000014  e006              B        |L8.36|
                  |L8.22|
;;;25     	}else{
;;;26     		JDQ1(1);
000016  4931              LDR      r1,|L8.220|
000018  6809              LDR      r1,[r1,#0]
00001a  f0410110          ORR      r1,r1,#0x10
00001e  4a30              LDR      r2,|L8.224|
000020  f8c2180c          STR      r1,[r2,#0x80c]
                  |L8.36|
;;;27     	}
;;;28     	if(nData & JDQ_2){
000024  f0100f02          TST      r0,#2
000028  d007              BEQ      |L8.58|
;;;29     		JDQ2(0);
00002a  492c              LDR      r1,|L8.220|
00002c  6809              LDR      r1,[r1,#0]
00002e  f0210120          BIC      r1,r1,#0x20
000032  4a2b              LDR      r2,|L8.224|
000034  f8c2180c          STR      r1,[r2,#0x80c]
000038  e006              B        |L8.72|
                  |L8.58|
;;;30     	}else{
;;;31     		JDQ2(1);
00003a  4928              LDR      r1,|L8.220|
00003c  6809              LDR      r1,[r1,#0]
00003e  f0410120          ORR      r1,r1,#0x20
000042  4a27              LDR      r2,|L8.224|
000044  f8c2180c          STR      r1,[r2,#0x80c]
                  |L8.72|
;;;32     	}
;;;33     	if(nData & JDQ_3){
000048  f0100f04          TST      r0,#4
00004c  d007              BEQ      |L8.94|
;;;34     		JDQ3(0);
00004e  4925              LDR      r1,|L8.228|
000050  6809              LDR      r1,[r1,#0]
000052  f0210102          BIC      r1,r1,#2
000056  4a22              LDR      r2,|L8.224|
000058  f8c21c0c          STR      r1,[r2,#0xc0c]
00005c  e006              B        |L8.108|
                  |L8.94|
;;;35     	}else{
;;;36     		JDQ3(1);
00005e  4921              LDR      r1,|L8.228|
000060  6809              LDR      r1,[r1,#0]
000062  f0410102          ORR      r1,r1,#2
000066  4a1e              LDR      r2,|L8.224|
000068  f8c21c0c          STR      r1,[r2,#0xc0c]
                  |L8.108|
;;;37     	}
;;;38     	if(nData & JDQ_4){
00006c  f0100f08          TST      r0,#8
000070  d007              BEQ      |L8.130|
;;;39     		JDQ4(0);
000072  491a              LDR      r1,|L8.220|
000074  6809              LDR      r1,[r1,#0]
000076  f0210104          BIC      r1,r1,#4
00007a  4a19              LDR      r2,|L8.224|
00007c  f8c2180c          STR      r1,[r2,#0x80c]
000080  e006              B        |L8.144|
                  |L8.130|
;;;40     	}else{
;;;41     		JDQ4(1);
000082  4916              LDR      r1,|L8.220|
000084  6809              LDR      r1,[r1,#0]
000086  f0410104          ORR      r1,r1,#4
00008a  4a15              LDR      r2,|L8.224|
00008c  f8c2180c          STR      r1,[r2,#0x80c]
                  |L8.144|
;;;42     	}
;;;43     	if(nData & JDQ_5){
000090  f0100f10          TST      r0,#0x10
000094  d007              BEQ      |L8.166|
;;;44     		JDQ5(0);
000096  4911              LDR      r1,|L8.220|
000098  6809              LDR      r1,[r1,#0]
00009a  f0210102          BIC      r1,r1,#2
00009e  4a10              LDR      r2,|L8.224|
0000a0  f8c2180c          STR      r1,[r2,#0x80c]
0000a4  e006              B        |L8.180|
                  |L8.166|
;;;45     	}else{
;;;46     		JDQ5(1);
0000a6  490d              LDR      r1,|L8.220|
0000a8  6809              LDR      r1,[r1,#0]
0000aa  f0410102          ORR      r1,r1,#2
0000ae  4a0c              LDR      r2,|L8.224|
0000b0  f8c2180c          STR      r1,[r2,#0x80c]
                  |L8.180|
;;;47     	}
;;;48     	if(nData & JDQ_6){
0000b4  f0100f20          TST      r0,#0x20
0000b8  d007              BEQ      |L8.202|
;;;49     		JDQ6(0);
0000ba  4908              LDR      r1,|L8.220|
0000bc  6809              LDR      r1,[r1,#0]
0000be  f0210101          BIC      r1,r1,#1
0000c2  4a07              LDR      r2,|L8.224|
0000c4  f8c2180c          STR      r1,[r2,#0x80c]
0000c8  e006              B        |L8.216|
                  |L8.202|
;;;50     	}else{
;;;51     		JDQ6(1);
0000ca  4904              LDR      r1,|L8.220|
0000cc  6809              LDR      r1,[r1,#0]
0000ce  f0410101          ORR      r1,r1,#1
0000d2  4a03              LDR      r2,|L8.224|
0000d4  f8c2180c          STR      r1,[r2,#0x80c]
                  |L8.216|
;;;52     	}
;;;53     }
0000d8  4770              BX       lr
;;;54     
                          ENDP

0000da  0000              DCW      0x0000
                  |L8.220|
                          DCD      0x4001080c
                  |L8.224|
                          DCD      0x40010000
                  |L8.228|
                          DCD      0x40010c0c

                          AREA ||i.server_accept||, CODE, READONLY, ALIGN=2

                  server_accept PROC
;;;225    /* TCP 服务器接收数据server_accept*/
;;;226    static err_t server_accept(void *arg, struct tcp_pcb *pcb, err_t err)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;228        /* Tell TCP that this is the structure we wish to be passed for our callbacks. */
;;;229        tcp_arg(pcb, NULL);
000008  2100              MOVS     r1,#0
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       tcp_arg
;;;230        /* Tell TCP that we wish to be informed of incoming data by a call to the http_recv() function. */
;;;231        tcp_recv(pcb, server_recv);
000010  4902              LDR      r1,|L9.28|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_recv
;;;232        return ERR_OK;
000018  2000              MOVS     r0,#0
;;;233    }
00001a  bd70              POP      {r4-r6,pc}
;;;234    
                          ENDP

                  |L9.28|
                          DCD      server_recv

                          AREA ||i.server_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  server_recv PROC
;;;188    /* TCP 服务器接收数据 server_recv 处理*/
;;;189    static err_t   server_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;190    {
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;191    	u8 len = 15;
00000c  f04f080f          MOV      r8,#0xf
;;;192    	u8 i;
;;;193        printf("TCP server receive:");
000010  a029              ADR      r0,|L10.184|
000012  f7fffffe          BL       __2printf
;;;194    	for(i = 0;i< len;i++){
000016  2600              MOVS     r6,#0
000018  e006              B        |L10.40|
                  |L10.26|
;;;195    		printf("%x_",*((u8*)p->payload + i));
00001a  6860              LDR      r0,[r4,#4]
00001c  5d81              LDRB     r1,[r0,r6]
00001e  a02b              ADR      r0,|L10.204|
000020  f7fffffe          BL       __2printf
000024  1c70              ADDS     r0,r6,#1              ;194
000026  b2c6              UXTB     r6,r0                 ;194
                  |L10.40|
000028  4546              CMP      r6,r8                 ;194
00002a  dbf6              BLT      |L10.26|
;;;196    	}
;;;197    	printf("\n");
00002c  a028              ADR      r0,|L10.208|
00002e  f7fffffe          BL       __2printf
;;;198        if(err == ERR_OK && p != NULL)
000032  bbad              CBNZ     r5,|L10.160|
000034  b3a4              CBZ      r4,|L10.160|
;;;199        {
;;;200            /* Inform TCP that we have taken the data. */
;;;201            tcp_recved(pcb, p->tot_len);
000036  8921              LDRH     r1,[r4,#8]
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       tcp_recved
;;;202    
;;;203    		if((*((u8*)p->payload) == 0xAA) && (*((u8*)p->payload+1) == 0x55) &&
00003e  6860              LDR      r0,[r4,#4]
000040  7800              LDRB     r0,[r0,#0]
000042  28aa              CMP      r0,#0xaa
000044  d129              BNE      |L10.154|
000046  6860              LDR      r0,[r4,#4]
000048  7840              LDRB     r0,[r0,#1]
00004a  2855              CMP      r0,#0x55
00004c  d125              BNE      |L10.154|
;;;204    			(*((u8*)p->payload+13) == 0xcc) && (*((u8*)p->payload+14) == 0xdd)){
00004e  6860              LDR      r0,[r4,#4]
000050  7b40              LDRB     r0,[r0,#0xd]
000052  28cc              CMP      r0,#0xcc
000054  d121              BNE      |L10.154|
000056  6860              LDR      r0,[r4,#4]
000058  7b80              LDRB     r0,[r0,#0xe]
00005a  28dd              CMP      r0,#0xdd
00005c  d11d              BNE      |L10.154|
;;;205    			if(*((u8*)p->payload+6) == 0x01){
00005e  6860              LDR      r0,[r4,#4]
000060  7980              LDRB     r0,[r0,#6]
000062  2801              CMP      r0,#1
000064  d109              BNE      |L10.122|
;;;206    				state_pro((u8*)p->payload);
000066  6860              LDR      r0,[r4,#4]
000068  f7fffffe          BL       state_pro
;;;207    				tcp_write(pcb,p->payload,p->tot_len,0);
00006c  8922              LDRH     r2,[r4,#8]
00006e  2300              MOVS     r3,#0
000070  4638              MOV      r0,r7
000072  6861              LDR      r1,[r4,#4]
000074  f7fffffe          BL       tcp_write
000078  e00f              B        |L10.154|
                  |L10.122|
;;;208    			}else if(*((u8*)p->payload+6) == 0x00){
00007a  6860              LDR      r0,[r4,#4]
00007c  7980              LDRB     r0,[r0,#6]
00007e  b960              CBNZ     r0,|L10.154|
;;;209    				jdq_pro(*((u8*)p->payload+9));
000080  6861              LDR      r1,[r4,#4]
000082  7a48              LDRB     r0,[r1,#9]
000084  f7fffffe          BL       jdq_pro
;;;210    				state_pro((u8*)p->payload);
000088  6860              LDR      r0,[r4,#4]
00008a  f7fffffe          BL       state_pro
;;;211    				tcp_write(pcb,p->payload,p->tot_len,0);
00008e  8922              LDRH     r2,[r4,#8]
000090  2300              MOVS     r3,#0
000092  4638              MOV      r0,r7
000094  6861              LDR      r1,[r4,#4]
000096  f7fffffe          BL       tcp_write
                  |L10.154|
;;;212    			}
;;;213    		}
;;;214    		pbuf_free(p);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       pbuf_free
                  |L10.160|
;;;215        }
;;;216    
;;;217        if(err == ERR_OK && p == NULL) {
0000a0  b93d              CBNZ     r5,|L10.178|
0000a2  b934              CBNZ     r4,|L10.178|
;;;218    		tcp_abort(pcb);
0000a4  2101              MOVS     r1,#1
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       tcp_abandon
;;;219            tcp_close(pcb);
0000ac  4638              MOV      r0,r7
0000ae  f7fffffe          BL       tcp_close
                  |L10.178|
;;;220        }
;;;221        return ERR_OK;
0000b2  2000              MOVS     r0,#0
;;;222    }
0000b4  e8bd87f0          POP      {r4-r10,pc}
;;;223    
                          ENDP

                  |L10.184|
0000b8  54435020          DCB      "TCP server receive:",0
0000bc  73657276
0000c0  65722072
0000c4  65636569
0000c8  76653a00
                  |L10.204|
0000cc  25785f00          DCB      "%x_",0
                  |L10.208|
0000d0  0a00              DCB      "\n",0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.state_pro||, CODE, READONLY, ALIGN=2

                  state_pro PROC
;;;54     
;;;55     void state_pro(U8 * p)
000000  2100              MOVS     r1,#0
;;;56     {
;;;57     	*(p+6) = 0x00;
000002  7181              STRB     r1,[r0,#6]
;;;58     	*(p+9) = (GPIOA->ODR & 1<<4)?(*(p+9) & (~(1<<0))):(*(p+9) | 1<<0);
000004  495b              LDR      r1,|L11.372|
000006  6809              LDR      r1,[r1,#0]
000008  f0110f10          TST      r1,#0x10
00000c  d003              BEQ      |L11.22|
00000e  7a41              LDRB     r1,[r0,#9]
000010  f0210101          BIC      r1,r1,#1
000014  e002              B        |L11.28|
                  |L11.22|
000016  7a41              LDRB     r1,[r0,#9]
000018  f0410101          ORR      r1,r1,#1
                  |L11.28|
00001c  7241              STRB     r1,[r0,#9]
;;;59     	*(p+9) = (GPIOA->ODR & 1<<5)?(*(p+9) & (~(1<<1))):(*(p+9) | 1<<1);
00001e  4955              LDR      r1,|L11.372|
000020  6809              LDR      r1,[r1,#0]
000022  f0110f20          TST      r1,#0x20
000026  d003              BEQ      |L11.48|
000028  7a41              LDRB     r1,[r0,#9]
00002a  f0210102          BIC      r1,r1,#2
00002e  e002              B        |L11.54|
                  |L11.48|
000030  7a41              LDRB     r1,[r0,#9]
000032  f0410102          ORR      r1,r1,#2
                  |L11.54|
000036  7241              STRB     r1,[r0,#9]
;;;60     	*(p+9) = (GPIOB->ODR & 1<<1)?(*(p+9) & (~(1<<2))):(*(p+9) | 1<<2);
000038  494f              LDR      r1,|L11.376|
00003a  6809              LDR      r1,[r1,#0]
00003c  f0110f02          TST      r1,#2
000040  d003              BEQ      |L11.74|
000042  7a41              LDRB     r1,[r0,#9]
000044  f0210104          BIC      r1,r1,#4
000048  e002              B        |L11.80|
                  |L11.74|
00004a  7a41              LDRB     r1,[r0,#9]
00004c  f0410104          ORR      r1,r1,#4
                  |L11.80|
000050  7241              STRB     r1,[r0,#9]
;;;61     	*(p+9) = (GPIOA->ODR & 1<<2)?(*(p+9) & (~(1<<3))):(*(p+9) | 1<<3);
000052  4948              LDR      r1,|L11.372|
000054  6809              LDR      r1,[r1,#0]
000056  f0110f04          TST      r1,#4
00005a  d003              BEQ      |L11.100|
00005c  7a41              LDRB     r1,[r0,#9]
00005e  f0210108          BIC      r1,r1,#8
000062  e002              B        |L11.106|
                  |L11.100|
000064  7a41              LDRB     r1,[r0,#9]
000066  f0410108          ORR      r1,r1,#8
                  |L11.106|
00006a  7241              STRB     r1,[r0,#9]
;;;62     	*(p+9) = (GPIOA->ODR & 1<<1)?(*(p+9) & (~(1<<4))):(*(p+9) | 1<<4);
00006c  4941              LDR      r1,|L11.372|
00006e  6809              LDR      r1,[r1,#0]
000070  f0110f02          TST      r1,#2
000074  d003              BEQ      |L11.126|
000076  7a41              LDRB     r1,[r0,#9]
000078  f0210110          BIC      r1,r1,#0x10
00007c  e002              B        |L11.132|
                  |L11.126|
00007e  7a41              LDRB     r1,[r0,#9]
000080  f0410110          ORR      r1,r1,#0x10
                  |L11.132|
000084  7241              STRB     r1,[r0,#9]
;;;63     	*(p+9) = (GPIOA->ODR & 1<<0)?(*(p+9) & (~(1<<5))):(*(p+9) | 1<<5);
000086  493b              LDR      r1,|L11.372|
000088  6809              LDR      r1,[r1,#0]
00008a  f0110f01          TST      r1,#1
00008e  d003              BEQ      |L11.152|
000090  7a41              LDRB     r1,[r0,#9]
000092  f0210120          BIC      r1,r1,#0x20
000096  e002              B        |L11.158|
                  |L11.152|
000098  7a41              LDRB     r1,[r0,#9]
00009a  f0410120          ORR      r1,r1,#0x20
                  |L11.158|
00009e  7241              STRB     r1,[r0,#9]
;;;64     
;;;65     	*(p+10) = INPUT_0_PIN ? (*(p+10) | 1<<0) : (*(p+10) & (~(1<<0)));
0000a0  4936              LDR      r1,|L11.380|
0000a2  6809              LDR      r1,[r1,#0]
0000a4  f0110f20          TST      r1,#0x20
0000a8  d003              BEQ      |L11.178|
0000aa  7a81              LDRB     r1,[r0,#0xa]
0000ac  f0410101          ORR      r1,r1,#1
0000b0  e002              B        |L11.184|
                  |L11.178|
0000b2  7a81              LDRB     r1,[r0,#0xa]
0000b4  f0210101          BIC      r1,r1,#1
                  |L11.184|
0000b8  7281              STRB     r1,[r0,#0xa]
;;;66     	*(p+10) = INPUT_1_PIN ? (*(p+10) | 1<<1) : (*(p+10) & (~(1<<1)));
0000ba  4931              LDR      r1,|L11.384|
0000bc  6809              LDR      r1,[r1,#0]
0000be  f4115f80          TST      r1,#0x1000
0000c2  d003              BEQ      |L11.204|
0000c4  7a81              LDRB     r1,[r0,#0xa]
0000c6  f0410102          ORR      r1,r1,#2
0000ca  e002              B        |L11.210|
                  |L11.204|
0000cc  7a81              LDRB     r1,[r0,#0xa]
0000ce  f0210102          BIC      r1,r1,#2
                  |L11.210|
0000d2  7281              STRB     r1,[r0,#0xa]
;;;67     	*(p+10) = INPUT_2_PIN ? (*(p+10) | 1<<2) : (*(p+10) & (~(1<<2)));
0000d4  492b              LDR      r1,|L11.388|
0000d6  6889              LDR      r1,[r1,#8]
0000d8  f0110f80          TST      r1,#0x80
0000dc  d003              BEQ      |L11.230|
0000de  7a81              LDRB     r1,[r0,#0xa]
0000e0  f0410104          ORR      r1,r1,#4
0000e4  e002              B        |L11.236|
                  |L11.230|
0000e6  7a81              LDRB     r1,[r0,#0xa]
0000e8  f0210104          BIC      r1,r1,#4
                  |L11.236|
0000ec  7281              STRB     r1,[r0,#0xa]
;;;68     	*(p+10) = INPUT_3_PIN ? (*(p+10) | 1<<3) : (*(p+10) & (~(1<<3)));
0000ee  4924              LDR      r1,|L11.384|
0000f0  6809              LDR      r1,[r1,#0]
0000f2  f4116f00          TST      r1,#0x800
0000f6  d003              BEQ      |L11.256|
0000f8  7a81              LDRB     r1,[r0,#0xa]
0000fa  f0410108          ORR      r1,r1,#8
0000fe  e002              B        |L11.262|
                  |L11.256|
000100  7a81              LDRB     r1,[r0,#0xa]
000102  f0210108          BIC      r1,r1,#8
                  |L11.262|
000106  7281              STRB     r1,[r0,#0xa]
;;;69     	*(p+10) = INPUT_4_PIN ? (*(p+10) | 1<<4) : (*(p+10) & (~(1<<4)));
000108  491e              LDR      r1,|L11.388|
00010a  6889              LDR      r1,[r1,#8]
00010c  f0110f40          TST      r1,#0x40
000110  d003              BEQ      |L11.282|
000112  7a81              LDRB     r1,[r0,#0xa]
000114  f0410110          ORR      r1,r1,#0x10
000118  e002              B        |L11.288|
                  |L11.282|
00011a  7a81              LDRB     r1,[r0,#0xa]
00011c  f0210110          BIC      r1,r1,#0x10
                  |L11.288|
000120  7281              STRB     r1,[r0,#0xa]
;;;70     	*(p+10) = INPUT_5_PIN ? (*(p+10) | 1<<5) : (*(p+10) & (~(1<<5)));
000122  4917              LDR      r1,|L11.384|
000124  6809              LDR      r1,[r1,#0]
000126  f4117f80          TST      r1,#0x100
00012a  d003              BEQ      |L11.308|
00012c  7a81              LDRB     r1,[r0,#0xa]
00012e  f0410120          ORR      r1,r1,#0x20
000132  e002              B        |L11.314|
                  |L11.308|
000134  7a81              LDRB     r1,[r0,#0xa]
000136  f0210120          BIC      r1,r1,#0x20
                  |L11.314|
00013a  7281              STRB     r1,[r0,#0xa]
;;;71     	*(p+10) = INPUT_6_PIN ? (*(p+10) | 1<<6) : (*(p+10) & (~(1<<6)));
00013c  490f              LDR      r1,|L11.380|
00013e  6809              LDR      r1,[r1,#0]
000140  f4114f00          TST      r1,#0x8000
000144  d003              BEQ      |L11.334|
000146  7a81              LDRB     r1,[r0,#0xa]
000148  f0410140          ORR      r1,r1,#0x40
00014c  e002              B        |L11.340|
                  |L11.334|
00014e  7a81              LDRB     r1,[r0,#0xa]
000150  f0210140          BIC      r1,r1,#0x40
                  |L11.340|
000154  7281              STRB     r1,[r0,#0xa]
;;;72     	*(p+10) = INPUT_7_PIN ? (*(p+10) | 1<<7) : (*(p+10) & (~(1<<7)));
000156  4909              LDR      r1,|L11.380|
000158  6809              LDR      r1,[r1,#0]
00015a  f0110f40          TST      r1,#0x40
00015e  d003              BEQ      |L11.360|
000160  7a81              LDRB     r1,[r0,#0xa]
000162  f0410180          ORR      r1,r1,#0x80
000166  e002              B        |L11.366|
                  |L11.360|
000168  7a81              LDRB     r1,[r0,#0xa]
00016a  f0210180          BIC      r1,r1,#0x80
                  |L11.366|
00016e  7281              STRB     r1,[r0,#0xa]
;;;73     }
000170  4770              BX       lr
;;;74     
                          ENDP

000172  0000              DCW      0x0000
                  |L11.372|
                          DCD      0x4001080c
                  |L11.376|
                          DCD      0x40010c0c
                  |L11.380|
                          DCD      0x40010c08
                  |L11.384|
                          DCD      0x40010808
                  |L11.388|
                          DCD      0x40011000

                          AREA ||i.tcp_client_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  tcp_client_recv PROC
;;;123    /* TCP 客户端接收到PC发送过来的数据，tcp_client_recv为数据处理*/
;;;124    static err_t   tcp_client_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  b5f0              PUSH     {r4-r7,lr}
;;;125    {
000002  b085              SUB      sp,sp,#0x14
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;126    	u8 temp[17];
;;;127        printf("TCP client receive 0: %s\n",p->payload);
00000c  a016              ADR      r0,|L12.104|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;128        if(err == ERR_OK && p != NULL) {
000014  b9cd              CBNZ     r5,|L12.74|
000016  b1c4              CBZ      r4,|L12.74|
;;;129            /* Inform TCP that we have taken the data. */
;;;130            tcp_recved(pcb, p->tot_len);
000018  8921              LDRH     r1,[r4,#8]
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       tcp_recved
;;;131    		tcp_write(pcb,p->payload,p->tot_len,0);   
000020  8922              LDRH     r2,[r4,#8]
000022  2300              MOVS     r3,#0
000024  4630              MOV      r0,r6
000026  6861              LDR      r1,[r4,#4]
000028  f7fffffe          BL       tcp_write
;;;132            printf("TCP client receive : %s\n",p->payload);
00002c  a015              ADR      r0,|L12.132|
00002e  6861              LDR      r1,[r4,#4]
000030  f7fffffe          BL       __2printf
;;;133    		MEMCPY(temp,p->payload,14);
000034  220e              MOVS     r2,#0xe
000036  4668              MOV      r0,sp
000038  6861              LDR      r1,[r4,#4]
00003a  f7fffffe          BL       __aeabi_memcpy
;;;134    		printf("TCP client receive : %d\n",temp[9]);
00003e  f89d1009          LDRB     r1,[sp,#9]
000042  a017              ADR      r0,|L12.160|
000044  f7fffffe          BL       __2printf
000048  e007              B        |L12.90|
                  |L12.74|
;;;135        }
;;;136        else if(err == ERR_OK && p == NULL) {
00004a  b935              CBNZ     r5,|L12.90|
00004c  b92c              CBNZ     r4,|L12.90|
;;;137            tcp_close(pcb);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       tcp_close
;;;138    	TcpClient.connected=0;
000054  2000              MOVS     r0,#0
000056  4919              LDR      r1,|L12.188|
000058  7308              STRB     r0,[r1,#0xc]
                  |L12.90|
;;;139        }
;;;140        pbuf_free(p);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       pbuf_free
;;;141        return ERR_OK;
000060  2000              MOVS     r0,#0
;;;142    }
000062  b005              ADD      sp,sp,#0x14
000064  bdf0              POP      {r4-r7,pc}
;;;143    
                          ENDP

000066  0000              DCW      0x0000
                  |L12.104|
000068  54435020          DCB      "TCP client receive 0: %s\n",0
00006c  636c6965
000070  6e742072
000074  65636569
000078  76652030
00007c  3a202573
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L12.132|
000084  54435020          DCB      "TCP client receive : %s\n",0
000088  636c6965
00008c  6e742072
000090  65636569
000094  7665203a
000098  2025730a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L12.160|
0000a0  54435020          DCB      "TCP client receive : %d\n",0
0000a4  636c6965
0000a8  6e742072
0000ac  65636569
0000b0  7665203a
0000b4  2025640a
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L12.188|
                          DCD      TcpClient

                          AREA ||i.tcp_sended||, CODE, READONLY, ALIGN=1

                  tcp_sended PROC
;;;114    extern const char demo[];
;;;115    err_t tcp_sended(void *arg, struct tcp_pcb *tpcb, u16_t len)
000000  4603              MOV      r3,r0
;;;116    {
;;;117        //printf("send len=%d\n",len);
;;;118        //tcp_write(tpcb,html,1200,0);
;;;119        return 0;
000002  2000              MOVS     r0,#0
;;;120    }
000004  4770              BX       lr
;;;121    
                          ENDP


                          AREA ||i.tcp_server_init||, CODE, READONLY, ALIGN=2

                  tcp_server_init PROC
;;;235    /* TCP 服务器初始化，本地IP IP_ADDR_ANY，接收数据server_accept*/
;;;236    void tcp_server_init(void)
000000  b510              PUSH     {r4,lr}
;;;237    {
;;;238        struct tcp_pcb *pcb;
;;;239        pcb = tcp_new();
000002  f7fffffe          BL       tcp_new
000006  4604              MOV      r4,r0
;;;240        tcp_bind(pcb, IP_ADDR_ANY,8080);
000008  f6417290          MOV      r2,#0x1f90
00000c  4906              LDR      r1,|L14.40|
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       tcp_bind
;;;241        pcb = tcp_listen(pcb);
000014  21ff              MOVS     r1,#0xff
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_listen_with_backlog
00001c  4604              MOV      r4,r0
;;;242        //pcb = tcp_listen_with_backlog(pcb,1);
;;;243        tcp_accept(pcb, server_accept);
00001e  4903              LDR      r1,|L14.44|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       tcp_accept
;;;244    }
000026  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  |L14.40|
                          DCD      ip_addr_any
                  |L14.44|
                          DCD      server_accept

                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L15.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L15.32|
                  |L15.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L15.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L15.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L15.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L15.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L15.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L15.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  TcpClient
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  UDPData
000000  4c774950          DCB      0x4c,0x77,0x49,0x50
000004  20554450          DCB      0x20,0x55,0x44,0x50
000008  bfcdbba7          DCB      0xbf,0xcd,0xbb,0xa7
00000c  b6cbb2e2          DCB      0xb6,0xcb,0xb2,0xe2
000010  cad40d0a          DCB      0xca,0xd4,0x0d,0x0a
000014  00                DCB      0x00
                  TCP_TestData
000015  546869            DCB      0x54,0x68,0x69
000018  73206973          DCB      0x73,0x20,0x69,0x73
00001c  204c7749          DCB      0x20,0x4c,0x77,0x49
000020  50205443          DCB      0x50,0x20,0x54,0x43
000024  5020436c          DCB      0x50,0x20,0x43,0x6c
000028  69656e74          DCB      0x69,0x65,0x6e,0x74
00002c  2020d4da          DCB      0x20,0x20,0xd4,0xda
000030  4c756d69          DCB      0x4c,0x75,0x6d,0x69
000034  6e617279          DCB      0x6e,0x61,0x72,0x79
000038  20436f72          DCB      0x20,0x43,0x6f,0x72
00003c  7465782d          DCB      0x74,0x65,0x78,0x2d
000040  4d3320c9          DCB      0x4d,0x33,0x20,0xc9
000044  cfb5c4b2          DCB      0xcf,0xb5,0xc4,0xb2
000048  e2cad4a3          DCB      0xe2,0xca,0xd4,0xa3
00004c  a10d0a00          DCB      0xa1,0x0d,0x0a,0x00
