; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\scan.o --depend=.\obj\scan.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\scan.crf ..\marvel\driver\src\scan.c]
                          THUMB

                          AREA ||i.INIT_LIST_HEAD||, CODE, READONLY, ALIGN=1

                  INIT_LIST_HEAD PROC
;;;33     
;;;34     static __inline void INIT_LIST_HEAD(struct list_head *list)
000000  6000              STR      r0,[r0,#0]
;;;35     {
;;;36     	list->next = list;
;;;37     	list->prev = list;
000002  6040              STR      r0,[r0,#4]
;;;38     }
000004  4770              BX       lr
;;;39     
                          ENDP


                          AREA ||i.clear_bss_descriptor||, CODE, READONLY, ALIGN=1

                  clear_bss_descriptor PROC
;;;247    
;;;248    static __inline void clear_bss_descriptor(struct bss_descriptor *bss)
000000  b510              PUSH     {r4,lr}
;;;249    {
000002  4604              MOV      r4,r0
;;;250    	/* Don't blow away ->list, just BSS data */
;;;251    	memset(bss, 0, offsetof(struct bss_descriptor, list));
000004  f44f71f4          MOV      r1,#0x1e8
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;252    }
00000e  bd10              POP      {r4,pc}
;;;253    
                          ENDP


                          AREA ||i.find_beacon_bss||, CODE, READONLY, ALIGN=1

                  find_beacon_bss PROC
;;;971    
;;;972    struct bss_descriptor *find_beacon_bss(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;973    					     uint8_t *ssid, uint8_t ssid_len,int mode)
;;;974    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;975    	struct bss_descriptor *iter_bss = NULL;
00000c  2400              MOVS     r4,#0
;;;976    	list_for_each_entry_bssdes(iter_bss, &priv->network_list, list) {
00000e  f44f70f4          MOV      r0,#0x1e8
000012  f8d510ec          LDR      r1,[r5,#0xec]
000016  1a0c              SUBS     r4,r1,r0
000018  e013              B        |L3.66|
                  |L3.26|
;;;977    		if (lbs_ssid_cmp(iter_bss->ssid, iter_bss->ssid_len,
00001a  f8941027          LDRB     r1,[r4,#0x27]
00001e  463b              MOV      r3,r7
000020  4632              MOV      r2,r6
000022  1da0              ADDS     r0,r4,#6
000024  f7fffffe          BL       lbs_ssid_cmp
000028  b100              CBZ      r0,|L3.44|
;;;978    				 ssid, ssid_len) != 0)
;;;979    			continue; /* ssid doesn't match */
00002a  e005              B        |L3.56|
                  |L3.44|
;;;980    		if (iter_bss->mode==mode)
00002c  f8940038          LDRB     r0,[r4,#0x38]
000030  4540              CMP      r0,r8
000032  d100              BNE      |L3.54|
;;;981    			break;
000034  e00b              B        |L3.78|
                  |L3.54|
000036  bf00              NOP                            ;979
                  |L3.56|
000038  f44f70f4          MOV      r0,#0x1e8             ;976
00003c  f8d411e8          LDR      r1,[r4,#0x1e8]        ;976
000040  1a0c              SUBS     r4,r1,r0              ;976
                  |L3.66|
000042  f50470f4          ADD      r0,r4,#0x1e8          ;976
000046  f10501ec          ADD      r1,r5,#0xec           ;976
00004a  4288              CMP      r0,r1                 ;976
00004c  d1e5              BNE      |L3.26|
                  |L3.78|
00004e  bf00              NOP      
;;;982    	}
;;;983    	return iter_bss;
000050  4620              MOV      r0,r4
;;;984    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;985    
                          ENDP


                          AREA ||i.is_same_network||, CODE, READONLY, ALIGN=1

                  is_same_network PROC
;;;261    
;;;262    static __inline int is_same_network(struct bss_descriptor *src,
000000  b570              PUSH     {r4-r6,lr}
;;;263    				  struct bss_descriptor *dst)
;;;264    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;265    	/* A network is only a duplicate if the channel, BSSID, and ESSID
;;;266    	 * all match.  We treat all <hidden> with the same BSSID and channel
;;;267    	 * as one network */
;;;268    	return ((src->ssid_len == dst->ssid_len) &&
000006  f8940027          LDRB     r0,[r4,#0x27]
00000a  f8951027          LDRB     r1,[r5,#0x27]
00000e  4288              CMP      r0,r1
000010  d11f              BNE      |L4.82|
;;;269    		(src->channel == dst->channel) &&
000012  6b20              LDR      r0,[r4,#0x30]
000014  6b29              LDR      r1,[r5,#0x30]
000016  4288              CMP      r0,r1
000018  d11b              BNE      |L4.82|
;;;270    		!compare_ether_addr(src->bssid, dst->bssid) &&
00001a  bf00              NOP      
00001c  4620              MOV      r0,r4
00001e  4629              MOV      r1,r5
000020  8802              LDRH     r2,[r0,#0]
000022  880b              LDRH     r3,[r1,#0]
000024  405a              EORS     r2,r2,r3
000026  8843              LDRH     r3,[r0,#2]
000028  884e              LDRH     r6,[r1,#2]
00002a  4073              EORS     r3,r3,r6
00002c  431a              ORRS     r2,r2,r3
00002e  8883              LDRH     r3,[r0,#4]
000030  888e              LDRH     r6,[r1,#4]
000032  4073              EORS     r3,r3,r6
000034  431a              ORRS     r2,r2,r3
000036  d001              BEQ      |L4.60|
000038  2201              MOVS     r2,#1
00003a  e000              B        |L4.62|
                  |L4.60|
00003c  2200              MOVS     r2,#0
                  |L4.62|
00003e  b942              CBNZ     r2,|L4.82|
;;;271    		!memcmp(src->ssid, dst->ssid, src->ssid_len));
000040  f8942027          LDRB     r2,[r4,#0x27]
000044  1da9              ADDS     r1,r5,#6
000046  1da0              ADDS     r0,r4,#6
000048  f7fffffe          BL       memcmp
00004c  b908              CBNZ     r0,|L4.82|
00004e  2001              MOVS     r0,#1                 ;268
                  |L4.80|
;;;272    }
000050  bd70              POP      {r4-r6,pc}
                  |L4.82|
000052  2000              MOVS     r0,#0                 ;268
000054  e7fc              B        |L4.80|
;;;273    
                          ENDP


                          AREA ||i.lbs_do_scan||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  lbs_do_scan PROC
;;;707     */
;;;708    static int lbs_do_scan(struct lbs_private *priv, uint8_t bsstype,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;709    		       struct chanscanparamset *chan_list, int chan_count)
;;;710    {
000004  b0a2              SUB      sp,sp,#0x88
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;711    	int ret = -ENOMEM;
00000e  f06f0a0b          MVN      r10,#0xb
;;;712    	u8 gscan_cmdbuf[MAX_SCAN_CFG_ALLOC];
;;;713    	struct cmd_ds_802_11_scan *scan_cmd;
;;;714    	uint8_t *tlv;	/* pointer into our current, growing TLV storage area */
;;;715    
;;;716    	//u8 cmdbuf[] = {0x00,0x00,0x00,0x00,0x01,0x01,0x1c,0x00,0x00,0x01,0x00,0x00,0x00,0x28,0x00,0x00,0x02,0x00,0x00,0x00,0x28,0x00,0x00,0x03,0x00,0x00,0x00,0x28,0x00,0x00,0x04,0x00,0x00,0x00,0x28,0x00,0x01,0x00,0x0c,0x00,0x82,0x84,0x8b,0x96,0x0c,0x12,0x18,0x24,0x30,0x48,0x60,0x6c};
;;;717    
;;;718    	lbs_deb_enter("\n");
;;;719    	//debug_data_stream("chan param",(char *)chan_list,
;;;720    	//	sizeof(struct chanscanparamset)*chan_count);
;;;721    	lbs_deb_scan( "bsstype %d, chanlist[].chan %d, chan_count %d\n",
000012  b10e              CBZ      r6,|L5.24|
;;;722    		bsstype, chan_list ? chan_list[0].channumber : -1,
000014  7870              LDRB     r0,[r6,#1]
000016  e001              B        |L5.28|
                  |L5.24|
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L5.28|
00001c  4602              MOV      r2,r0
00001e  463b              MOV      r3,r7
000020  4649              MOV      r1,r9
000022  a01d              ADR      r0,|L5.152|
000024  f7fffffe          BL       __2printf
;;;723    		chan_count);
;;;724    	
;;;725    	/* create the fixed part for scan command */
;;;726    	/*scan_cmd = kzalloc(MAX_SCAN_CFG_ALLOC, GFP_KERNEL);
;;;727    	if (scan_cmd == NULL)
;;;728    		goto out;*/
;;;729    	scan_cmd=(struct cmd_ds_802_11_scan *)gscan_cmdbuf;
000028  ac03              ADD      r4,sp,#0xc
;;;730    	memset(scan_cmd,0,MAX_SCAN_CFG_ALLOC);
00002a  217b              MOVS     r1,#0x7b
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       __aeabi_memclr
;;;731    
;;;732    	tlv = scan_cmd->tlvbuffer;
000032  f104050f          ADD      r5,r4,#0xf
;;;733    	/* TODO: do we need to scan for a specific BSSID?
;;;734    	memcpy(scan_cmd->bssid, priv->scan_bssid, ETH_ALEN); */
;;;735    	scan_cmd->bsstype = bsstype;
000036  f8849008          STRB     r9,[r4,#8]
;;;736    
;;;737    	/* add TLVs */
;;;738    	if (priv->scan_ssid_len)//指定扫描
00003a  f8980051          LDRB     r0,[r8,#0x51]
00003e  b120              CBZ      r0,|L5.74|
;;;739    		tlv += lbs_scan_add_ssid_tlv(priv, tlv);
000040  4629              MOV      r1,r5
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       lbs_scan_add_ssid_tlv
000048  4405              ADD      r5,r5,r0
                  |L5.74|
;;;740    	if (chan_list && chan_count)
00004a  b136              CBZ      r6,|L5.90|
00004c  b12f              CBZ      r7,|L5.90|
;;;741    		tlv += lbs_scan_add_chanlist_tlv(tlv, chan_list, chan_count);
00004e  463a              MOV      r2,r7
000050  4631              MOV      r1,r6
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       lbs_scan_add_chanlist_tlv
000058  4405              ADD      r5,r5,r0
                  |L5.90|
;;;742    	tlv += lbs_scan_add_rates_tlv(tlv);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       lbs_scan_add_rates_tlv
000060  4405              ADD      r5,r5,r0
;;;743    
;;;744    	/* This is the final data we are about to send */
;;;745    	scan_cmd->hdr.size = cpu_to_le16(tlv - (uint8_t *)scan_cmd);
000062  1b28              SUBS     r0,r5,r4
000064  8060              STRH     r0,[r4,#2]
;;;746    	//lbs_deb_hex(LBS_DEB_SCAN, "SCAN_CMD", (void *)scan_cmd,
;;;747    	//	    sizeof(*scan_cmd));
;;;748    	//lbs_deb_hex(LBS_DEB_SCAN, "SCAN_TLV", scan_cmd->tlvbuffer,
;;;749    	//	    tlv - scan_cmd->tlvbuffer);
;;;750    
;;;751    	//memcpy(scan_cmd->tlvbuffer,cmdbuf,sizeof(cmdbuf));
;;;752    	xdbug_buf("dbug tlv buf",scan_cmd->tlvbuffer,tlv - scan_cmd->tlvbuffer);
000066  f104000f          ADD      r0,r4,#0xf
00006a  1a2a              SUBS     r2,r5,r0
00006c  4601              MOV      r1,r0
00006e  a016              ADR      r0,|L5.200|
000070  f7fffffe          BL       xdbug_buf
;;;753    
;;;754    	
;;;755    
;;;756    	//debug_data_stream("scan command",(char *)&scan_cmd->hdr,
;;;757    //	le16_to_cpu(scan_cmd->hdr.size));
;;;758    	ret=0;
000074  f04f0a00          MOV      r10,#0
;;;759    #if 1
;;;760    	ret = __lbs_cmd(priv, CMD_802_11_SCAN, &scan_cmd->hdr,
000078  2300              MOVS     r3,#0
00007a  4a17              LDR      r2,|L5.216|
00007c  e9cd2300          STRD     r2,r3,[sp,#0]
000080  8863              LDRH     r3,[r4,#2]
000082  4622              MOV      r2,r4
000084  2106              MOVS     r1,#6
000086  4640              MOV      r0,r8
000088  f7fffffe          BL       __lbs_cmd
00008c  4682              MOV      r10,r0
;;;761    			le16_to_cpu(scan_cmd->hdr.size),
;;;762    			lbs_ret_80211_scan, 0);//这里直接提交扫描命令即可*/
;;;763    #endif
;;;764    
;;;765    	
;;;766    //out:
;;;767    	//kfree(scan_cmd);
;;;768    	lbs_deb_leave_args(LBS_DEB_SCAN, ret);
;;;769    	return ret;
00008e  4650              MOV      r0,r10
;;;770    }
000090  b022              ADD      sp,sp,#0x88
000092  e8bd87f0          POP      {r4-r10,pc}
;;;771    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
000098  62737374          DCB      "bsstype %d, chanlist[].chan %d, chan_count %d\n",0
00009c  79706520
0000a0  25642c20
0000a4  6368616e
0000a8  6c697374
0000ac  5b5d2e63
0000b0  68616e20
0000b4  25642c20
0000b8  6368616e
0000bc  5f636f75
0000c0  6e742025
0000c4  640a00  
0000c7  00                DCB      0
                  |L5.200|
0000c8  64627567          DCB      "dbug tlv buf",0
0000cc  20746c76
0000d0  20627566
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L5.216|
                          DCD      lbs_ret_80211_scan

                          AREA ||i.lbs_process_bss||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_flags
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_u
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lbs_process_bss PROC
;;;317    
;;;318    static int lbs_process_bss(struct bss_descriptor *bss,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;319    			   uint8_t **pbeaconinfo, int *bytesleft)
;;;320    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;321    	struct ieee_ie_fh_param_set *fh;
;;;322    	struct ieee_ie_ds_param_set *ds;
;;;323    	struct ieee_ie_cf_param_set *cf;
;;;324    	struct ieee_ie_ibss_param_set *ibss;
;;;325    	
;;;326    //	DECLARE_SSID_BUF(ssid);
;;;327    	struct ieee_ie_country_info_set *pcountryinfo;
;;;328    	
;;;329    	uint8_t *pos, *end, *p;
;;;330    	uint8_t n_ex_rates = 0, got_basic_rates = 0, n_basic_rates = 0;
00000c  2000              MOVS     r0,#0
00000e  9005              STR      r0,[sp,#0x14]
000010  9004              STR      r0,[sp,#0x10]
000012  9003              STR      r0,[sp,#0xc]
;;;331    	uint16_t beaconsize = 0;
000014  4681              MOV      r9,r0
;;;332    	int ret;
;;;333    
;;;334    	lbs_deb_enter(LBS_DEB_SCAN);
;;;335    
;;;336    	if (*bytesleft >= sizeof(beaconsize)) {
000016  6838              LDR      r0,[r7,#0]
000018  2802              CMP      r0,#2
00001a  d30f              BCC      |L6.60|
;;;337    		/* Extract & convert beacon size from the command buffer */
;;;338    		uint16_t *ptmp_data=(uint16_t *)*pbeaconinfo;
00001c  6830              LDR      r0,[r6,#0]
00001e  9002              STR      r0,[sp,#8]
;;;339    		beaconsize = get_unaligned_le16(ptmp_data);
000020  9802              LDR      r0,[sp,#8]
000022  f8b09000          LDRH     r9,[r0,#0]
;;;340    		lbs_deb_scan("beaconsize=%d\n",beaconsize);
000026  4649              MOV      r1,r9
000028  a0d2              ADR      r0,|L6.884|
00002a  f7fffffe          BL       __2printf
;;;341    		*bytesleft -= sizeof(beaconsize);
00002e  6838              LDR      r0,[r7,#0]
000030  1e80              SUBS     r0,r0,#2
000032  6038              STR      r0,[r7,#0]
;;;342    		*pbeaconinfo += sizeof(beaconsize);
000034  6830              LDR      r0,[r6,#0]
000036  1c80              ADDS     r0,r0,#2
000038  6030              STR      r0,[r6,#0]
;;;343    	}
00003a  bf00              NOP      
                  |L6.60|
;;;344    
;;;345    	if (beaconsize == 0 || beaconsize > *bytesleft) {
00003c  f1b90f00          CMP      r9,#0
000040  d002              BEQ      |L6.72|
000042  6838              LDR      r0,[r7,#0]
000044  4548              CMP      r0,r9
000046  da08              BGE      |L6.90|
                  |L6.72|
;;;346    		*pbeaconinfo += *bytesleft;
000048  6830              LDR      r0,[r6,#0]
00004a  6839              LDR      r1,[r7,#0]
00004c  4408              ADD      r0,r0,r1
00004e  6030              STR      r0,[r6,#0]
;;;347    		*bytesleft = 0;
000050  2000              MOVS     r0,#0
000052  6038              STR      r0,[r7,#0]
;;;348    		ret = -1;
000054  f04f3bff          MOV      r11,#0xffffffff
;;;349    		goto done;
000058  e188              B        |L6.876|
                  |L6.90|
;;;350    	}
;;;351    
;;;352    	/* Initialize the current working beacon pointer for this BSS iteration */
;;;353    	pos = *pbeaconinfo;
00005a  6834              LDR      r4,[r6,#0]
;;;354    	end = pos + beaconsize;
00005c  eb040a09          ADD      r10,r4,r9
;;;355    
;;;356    	/* Advance the return beacon pointer past the current beacon */
;;;357    	*pbeaconinfo += beaconsize;
000060  6830              LDR      r0,[r6,#0]
000062  4448              ADD      r0,r0,r9
000064  6030              STR      r0,[r6,#0]
;;;358    	*bytesleft -= beaconsize;
000066  6838              LDR      r0,[r7,#0]
000068  eba00009          SUB      r0,r0,r9
00006c  6038              STR      r0,[r7,#0]
;;;359    
;;;360    	memcpy(bss->bssid, pos, ETH_ALEN);
00006e  6820              LDR      r0,[r4,#0]
000070  6028              STR      r0,[r5,#0]
000072  88a0              LDRH     r0,[r4,#4]
000074  80a8              STRH     r0,[r5,#4]
;;;361    	lbs_deb_scan("process_bss: BSSID %2x:%2x:%2x:%2x:%2x:%2x\n", 
000076  796b              LDRB     r3,[r5,#5]
000078  792a              LDRB     r2,[r5,#4]
00007a  78e9              LDRB     r1,[r5,#3]
00007c  e88d000e          STM      sp,{r1-r3}
000080  78ab              LDRB     r3,[r5,#2]
000082  786a              LDRB     r2,[r5,#1]
000084  7829              LDRB     r1,[r5,#0]
000086  a0bf              ADR      r0,|L6.900|
000088  f7fffffe          BL       __2printf
;;;362    		bss->bssid[0],bss->bssid[1],
;;;363    		bss->bssid[2],bss->bssid[3],
;;;364    		bss->bssid[4],bss->bssid[5]);
;;;365    	pos += ETH_ALEN;
00008c  1da4              ADDS     r4,r4,#6
;;;366    
;;;367    	if ((end - pos) < 12) {
00008e  ebaa0004          SUB      r0,r10,r4
000092  280c              CMP      r0,#0xc
000094  da05              BGE      |L6.162|
;;;368    		lbs_deb_scan("process_bss: Not enough bytes left\n");
000096  a0c6              ADR      r0,|L6.944|
000098  f7fffffe          BL       __2printf
;;;369    		ret = -1;
00009c  f04f3bff          MOV      r11,#0xffffffff
;;;370    		goto done;
0000a0  e164              B        |L6.876|
                  |L6.162|
;;;371    	}
;;;372    
;;;373    	/*
;;;374    	 * next 4 fields are RSSI, time stamp, beacon interval,
;;;375    	 *   and capability information
;;;376    	 */
;;;377    
;;;378    	/* RSSI is 1 byte long */
;;;379    	bss->rssi = *pos;
0000a2  7820              LDRB     r0,[r4,#0]
0000a4  62e8              STR      r0,[r5,#0x2c]
;;;380    	lbs_deb_scan("process_bss: RSSI %d\n", *pos);
0000a6  7821              LDRB     r1,[r4,#0]
0000a8  a0ca              ADR      r0,|L6.980|
0000aa  f7fffffe          BL       __2printf
;;;381    	pos++;
0000ae  1c64              ADDS     r4,r4,#1
;;;382    
;;;383    	/* time stamp is 8 bytes long */
;;;384    	pos += 8;
0000b0  3408              ADDS     r4,r4,#8
;;;385    
;;;386    	/* beacon interval is 2 bytes long */
;;;387    	bss->beaconperiod = get_unaligned_le16(pos);
0000b2  7820              LDRB     r0,[r4,#0]
0000b4  86a8              STRH     r0,[r5,#0x34]
;;;388    	pos += 2;
0000b6  1ca4              ADDS     r4,r4,#2
;;;389    
;;;390    	/* capability information is 2 bytes long */
;;;391    	bss->capability = get_unaligned_le16(pos);
0000b8  7820              LDRB     r0,[r4,#0]
0000ba  8528              STRH     r0,[r5,#0x28]
;;;392    	lbs_deb_scan("process_bss: capabilities 0x%04x\n", bss->capability);
0000bc  8d29              LDRH     r1,[r5,#0x28]
0000be  a0cb              ADR      r0,|L6.1004|
0000c0  f7fffffe          BL       __2printf
;;;393    	pos += 2;
0000c4  1ca4              ADDS     r4,r4,#2
;;;394    
;;;395    	if (bss->capability & WLAN_CAPABILITY_PRIVACY)
0000c6  8d28              LDRH     r0,[r5,#0x28]
0000c8  f0100f10          TST      r0,#0x10
0000cc  d003              BEQ      |L6.214|
;;;396    		lbs_deb_scan("process_bss: WEP enabled\n");
0000ce  a0d0              ADR      r0,|L6.1040|
0000d0  f7fffffe          BL       __2printf
0000d4  e002              B        |L6.220|
                  |L6.214|
;;;397    	else
;;;398    		lbs_deb_scan("process_bss: WEP off\n");
0000d6  a0d5              ADR      r0,|L6.1068|
0000d8  f7fffffe          BL       __2printf
                  |L6.220|
;;;399    	if (bss->capability & WLAN_CAPABILITY_IBSS){
0000dc  8d28              LDRH     r0,[r5,#0x28]
0000de  f0100f02          TST      r0,#2
0000e2  d006              BEQ      |L6.242|
;;;400    		bss->mode = IW_MODE_ADHOC;
0000e4  2001              MOVS     r0,#1
0000e6  f8850038          STRB     r0,[r5,#0x38]
;;;401    		lbs_deb_scan("mode:adhoc");
0000ea  a0d6              ADR      r0,|L6.1092|
0000ec  f7fffffe          BL       __2printf
0000f0  e005              B        |L6.254|
                  |L6.242|
;;;402    	}
;;;403    	
;;;404    	else{
;;;405    		bss->mode = IW_MODE_INFRA;
0000f2  2002              MOVS     r0,#2
0000f4  f8850038          STRB     r0,[r5,#0x38]
;;;406    		lbs_deb_scan("mode:manage");
0000f8  a0d5              ADR      r0,|L6.1104|
0000fa  f7fffffe          BL       __2printf
                  |L6.254|
;;;407    	}
;;;408    
;;;409    	/* rest of the current buffer are IE's */
;;;410    	lbs_deb_scan("process_bss: IE len %zd\n", end - pos);
0000fe  ebaa0104          SUB      r1,r10,r4
000102  a0d6              ADR      r0,|L6.1116|
000104  f7fffffe          BL       __2printf
;;;411    	//lbs_deb_hex(LBS_DEB_SCAN, "process_bss: IE info", pos, end - pos);
;;;412    
;;;413    	/* process variable IE */
;;;414    	while (pos <= end - 2) {
000108  e120              B        |L6.844|
                  |L6.266|
;;;415    		if (pos + pos[1] > end) {
00010a  7860              LDRB     r0,[r4,#1]
00010c  4420              ADD      r0,r0,r4
00010e  4550              CMP      r0,r10
000110  d903              BLS      |L6.282|
;;;416    			lbs_deb_scan("process_bss: error in processing IE, "
000112  a0d9              ADR      r0,|L6.1144|
000114  f7fffffe          BL       __2printf
;;;417    				     "bytes left < IE length\n");
;;;418    			break;
000118  e11d              B        |L6.854|
                  |L6.282|
;;;419    		}
;;;420    
;;;421    		switch (pos[0]) {
00011a  7820              LDRB     r0,[r4,#0]
00011c  2806              CMP      r0,#6
00011e  d063              BEQ      |L6.488|
000120  dc06              BGT      |L6.304|
000122  2805              CMP      r0,#5
000124  d27e              BCS      |L6.548|
000126  e8dff000          TBB      [pc,r0]
00012a  0c21              DCB      0x0c,0x21
00012c  35435300          DCB      0x35,0x43,0x53,0x00
                  |L6.304|
000130  2807              CMP      r0,#7
000132  d065              BEQ      |L6.512|
000134  2830              CMP      r0,#0x30
000136  d076              BEQ      |L6.550|
000138  2832              CMP      r0,#0x32
00013a  d075              BEQ      |L6.552|
00013c  28dd              CMP      r0,#0xdd
00013e  d171              BNE      |L6.548|
000140  e0a2              B        |L6.648|
;;;422    		case WLAN_EID_SSID:
;;;423    			bss->ssid_len = min(IEEE80211_MAX_SSID_LEN, pos[1]);
000142  7860              LDRB     r0,[r4,#1]
000144  2820              CMP      r0,#0x20
000146  dd01              BLE      |L6.332|
000148  2020              MOVS     r0,#0x20
00014a  e000              B        |L6.334|
                  |L6.332|
00014c  7860              LDRB     r0,[r4,#1]
                  |L6.334|
00014e  f8850027          STRB     r0,[r5,#0x27]
;;;424    			memcpy(bss->ssid, pos + 2, bss->ssid_len);
000152  f8952027          LDRB     r2,[r5,#0x27]
000156  1ca1              ADDS     r1,r4,#2
000158  1da8              ADDS     r0,r5,#6
00015a  f7fffffe          BL       __aeabi_memcpy
;;;425    			lbs_deb_scan("got SSID IE: '%s', len %u\n",
00015e  f8952027          LDRB     r2,[r5,#0x27]
000162  1da9              ADDS     r1,r5,#6
000164  a0d4              ADR      r0,|L6.1208|
000166  f7fffffe          BL       __2printf
;;;426    			             //print_ssid(ssid,(const char *)bss->ssid, bss->ssid_len),
;;;427    			             bss->ssid,
;;;428    			             bss->ssid_len);
;;;429    			break;
00016a  e0eb              B        |L6.836|
;;;430    
;;;431    		case WLAN_EID_SUPP_RATES:
;;;432    			n_basic_rates = min(MAX_RATES, pos[1]);
00016c  7860              LDRB     r0,[r4,#1]
00016e  280e              CMP      r0,#0xe
000170  dd01              BLE      |L6.374|
000172  200e              MOVS     r0,#0xe
000174  e000              B        |L6.376|
                  |L6.374|
000176  7860              LDRB     r0,[r4,#1]
                  |L6.376|
000178  b2c0              UXTB     r0,r0
00017a  9003              STR      r0,[sp,#0xc]
;;;433    			memcpy(bss->rates, pos + 2, n_basic_rates);
00017c  1ca1              ADDS     r1,r4,#2
00017e  f1050039          ADD      r0,r5,#0x39
000182  9a03              LDR      r2,[sp,#0xc]
000184  f7fffffe          BL       __aeabi_memcpy
;;;434    			got_basic_rates = 1;
000188  2001              MOVS     r0,#1
00018a  9004              STR      r0,[sp,#0x10]
;;;435    			lbs_deb_scan("got RATES IE\n");
00018c  a0d1              ADR      r0,|L6.1236|
00018e  f7fffffe          BL       __2printf
;;;436    			break;
000192  e0d7              B        |L6.836|
;;;437    
;;;438    		case WLAN_EID_FH_PARAMS:
;;;439    			fh = (struct ieee_ie_fh_param_set *) pos;
000194  940a              STR      r4,[sp,#0x28]
;;;440    			memcpy(&bss->phy.fh, fh, sizeof(*fh));
000196  9c0a              LDR      r4,[sp,#0x28]
000198  6820              LDR      r0,[r4,#0]
00019a  64e8              STR      r0,[r5,#0x4c]
00019c  88a0              LDRH     r0,[r4,#4]
00019e  f8a50050          STRH     r0,[r5,#0x50]
0001a2  79a0              LDRB     r0,[r4,#6]
0001a4  f8850052          STRB     r0,[r5,#0x52]
;;;441    			lbs_deb_scan("got FH IE\n");
0001a8  a0ce              ADR      r0,|L6.1252|
0001aa  f7fffffe          BL       __2printf
;;;442    			break;
0001ae  e0c9              B        |L6.836|
;;;443    
;;;444    		case WLAN_EID_DS_PARAMS:
;;;445    			ds = (struct ieee_ie_ds_param_set *) pos;
0001b0  9409              STR      r4,[sp,#0x24]
;;;446    			bss->channel = ds->channel;
0001b2  9c09              LDR      r4,[sp,#0x24]
0001b4  78a0              LDRB     r0,[r4,#2]
0001b6  6328              STR      r0,[r5,#0x30]
;;;447    			memcpy(&bss->phy.ds, ds, sizeof(*ds));
0001b8  9c09              LDR      r4,[sp,#0x24]
0001ba  8820              LDRH     r0,[r4,#0]
0001bc  f8a5004c          STRH     r0,[r5,#0x4c]
0001c0  78a0              LDRB     r0,[r4,#2]
0001c2  f885004e          STRB     r0,[r5,#0x4e]
;;;448    			lbs_deb_scan("got DS IE, channel %d\n", bss->channel);
0001c6  a0ca              ADR      r0,|L6.1264|
0001c8  6b29              LDR      r1,[r5,#0x30]
0001ca  f7fffffe          BL       __2printf
;;;449    			break;
0001ce  e0b9              B        |L6.836|
;;;450    
;;;451    		case WLAN_EID_CF_PARAMS:
;;;452    			cf = (struct ieee_ie_cf_param_set *) pos;
0001d0  9408              STR      r4,[sp,#0x20]
;;;453    			memcpy(&bss->ss.cf, cf, sizeof(*cf));
0001d2  9c08              LDR      r4,[sp,#0x20]
0001d4  6820              LDR      r0,[r4,#0]
0001d6  f8c50053          STR      r0,[r5,#0x53]
0001da  6860              LDR      r0,[r4,#4]
0001dc  f8c50057          STR      r0,[r5,#0x57]
;;;454    			lbs_deb_scan("got CF IE\n");
0001e0  a0c9              ADR      r0,|L6.1288|
0001e2  f7fffffe          BL       __2printf
;;;455    			break;
0001e6  e0ad              B        |L6.836|
                  |L6.488|
;;;456    
;;;457    		case WLAN_EID_IBSS_PARAMS:
;;;458    			ibss = (struct ieee_ie_ibss_param_set *) pos;
0001e8  9407              STR      r4,[sp,#0x1c]
;;;459    			bss->atimwindow = ibss->atimwindow;
0001ea  9c07              LDR      r4,[sp,#0x1c]
0001ec  8860              LDRH     r0,[r4,#2]
0001ee  86e8              STRH     r0,[r5,#0x36]
;;;460    			memcpy(&bss->ss.ibss, ibss, sizeof(*ibss));
0001f0  9c07              LDR      r4,[sp,#0x1c]
0001f2  6820              LDR      r0,[r4,#0]
0001f4  f8c50053          STR      r0,[r5,#0x53]
;;;461    			lbs_deb_scan("got IBSS IE\n");
0001f8  a0c6              ADR      r0,|L6.1300|
0001fa  f7fffffe          BL       __2printf
;;;462    			break;
0001fe  e0a1              B        |L6.836|
                  |L6.512|
;;;463    
;;;464    		case WLAN_EID_COUNTRY:
;;;465    			pcountryinfo = (struct ieee_ie_country_info_set *) pos;
000200  46a0              MOV      r8,r4
;;;466    			lbs_deb_scan("got COUNTRY IE\n");
000202  a0c8              ADR      r0,|L6.1316|
000204  f7fffffe          BL       __2printf
;;;467    			if (pcountryinfo->header.len < sizeof(pcountryinfo->countrycode)
000208  4644              MOV      r4,r8
00020a  f8980001          LDRB     r0,[r8,#1]
00020e  2803              CMP      r0,#3
000210  d303              BCC      |L6.538|
;;;468    			    || pcountryinfo->header.len > 254) {
000212  f8980001          LDRB     r0,[r8,#1]
000216  28fe              CMP      r0,#0xfe
000218  dd0d              BLE      |L6.566|
                  |L6.538|
;;;469    				lbs_deb_scan("%s: 11D- Err CountryInfo len %d, min %zd, max 254\n",
00021a  f8982001          LDRB     r2,[r8,#1]
00021e  2303              MOVS     r3,#3
000220  49c4              LDR      r1,|L6.1332|
000222  e002              B        |L6.554|
                  |L6.548|
000224  e088              B        |L6.824|
                  |L6.550|
000226  e072              B        |L6.782|
                  |L6.552|
000228  e00e              B        |L6.584|
                  |L6.554|
00022a  a0c3              ADR      r0,|L6.1336|
00022c  f7fffffe          BL       __2printf
;;;470    					     __func__,
;;;471    					     pcountryinfo->header.len,
;;;472    					     sizeof(pcountryinfo->countrycode));
;;;473    				ret = -1;
000230  f04f3bff          MOV      r11,#0xffffffff
;;;474    				goto done;
000234  e09a              B        |L6.876|
                  |L6.566|
;;;475    			}
;;;476    
;;;477    			memcpy(&bss->countryinfo, pcountryinfo,
000236  f8980001          LDRB     r0,[r8,#1]
00023a  1c82              ADDS     r2,r0,#2
00023c  4641              MOV      r1,r8
00023e  f105005b          ADD      r0,r5,#0x5b
000242  f7fffffe          BL       __aeabi_memcpy
;;;478    				pcountryinfo->header.len + 2);
;;;479    			//lbs_deb_hex(LBS_DEB_SCAN, "process_bss: 11d countryinfo",
;;;480    			//	    (uint8_t *) pcountryinfo,
;;;481    			//	    (int) (pcountryinfo->header.len + 2));
;;;482    			break;
000246  e07d              B        |L6.836|
                  |L6.584|
;;;483    
;;;484    		case WLAN_EID_EXT_SUPP_RATES:
;;;485    			/* only process extended supported rate if data rate is
;;;486    			 * already found. Data rate IE should come before
;;;487    			 * extended supported rate IE
;;;488    			 */
;;;489    			lbs_deb_scan("got RATESEX IE\n");
000248  a0c8              ADR      r0,|L6.1388|
00024a  f7fffffe          BL       __2printf
;;;490    			if (!got_basic_rates) {
00024e  9804              LDR      r0,[sp,#0x10]
000250  b918              CBNZ     r0,|L6.602|
;;;491    				lbs_deb_scan("... but ignoring it\n");
000252  a0ca              ADR      r0,|L6.1404|
000254  f7fffffe          BL       __2printf
;;;492    				break;
000258  e074              B        |L6.836|
                  |L6.602|
;;;493    			}
;;;494    
;;;495    			n_ex_rates = pos[1];
00025a  7860              LDRB     r0,[r4,#1]
00025c  9005              STR      r0,[sp,#0x14]
;;;496    			if (n_basic_rates + n_ex_rates > MAX_RATES)
00025e  9905              LDR      r1,[sp,#0x14]
000260  9803              LDR      r0,[sp,#0xc]
000262  4408              ADD      r0,r0,r1
000264  280e              CMP      r0,#0xe
000266  dd04              BLE      |L6.626|
;;;497    				n_ex_rates = MAX_RATES - n_basic_rates;
000268  9803              LDR      r0,[sp,#0xc]
00026a  f1c0000e          RSB      r0,r0,#0xe
00026e  b2c0              UXTB     r0,r0
000270  9005              STR      r0,[sp,#0x14]
                  |L6.626|
;;;498    
;;;499    			p = bss->rates + n_basic_rates;
000272  f1050039          ADD      r0,r5,#0x39
000276  9903              LDR      r1,[sp,#0xc]
000278  4408              ADD      r0,r0,r1
00027a  9006              STR      r0,[sp,#0x18]
;;;500    			memcpy(p, pos + 2, n_ex_rates);
00027c  1ca1              ADDS     r1,r4,#2
00027e  e9dd2005          LDRD     r2,r0,[sp,#0x14]
000282  f7fffffe          BL       __aeabi_memcpy
;;;501    			break;
000286  e05d              B        |L6.836|
                  |L6.648|
;;;502    
;;;503    		case WLAN_EID_GENERIC:
;;;504    			if (pos[1] >= 4 &&
000288  7860              LDRB     r0,[r4,#1]
00028a  2804              CMP      r0,#4
00028c  db1f              BLT      |L6.718|
;;;505    			    pos[2] == 0x00 && pos[3] == 0x50 &&
00028e  78a0              LDRB     r0,[r4,#2]
000290  b9e8              CBNZ     r0,|L6.718|
000292  78e0              LDRB     r0,[r4,#3]
000294  2850              CMP      r0,#0x50
000296  d11a              BNE      |L6.718|
;;;506    			    pos[4] == 0xf2 && pos[5] == 0x01) {
000298  7920              LDRB     r0,[r4,#4]
00029a  28f2              CMP      r0,#0xf2
00029c  d117              BNE      |L6.718|
00029e  7960              LDRB     r0,[r4,#5]
0002a0  2801              CMP      r0,#1
0002a2  d114              BNE      |L6.718|
;;;507    				bss->wpa_ie_len = min(pos[1] + 2, MAX_WPA_IE_LEN);
0002a4  7860              LDRB     r0,[r4,#1]
0002a6  1c80              ADDS     r0,r0,#2
0002a8  2840              CMP      r0,#0x40
0002aa  da02              BGE      |L6.690|
0002ac  7860              LDRB     r0,[r4,#1]
0002ae  1c80              ADDS     r0,r0,#2
0002b0  e000              B        |L6.692|
                  |L6.690|
0002b2  2040              MOVS     r0,#0x40
                  |L6.692|
0002b4  f8c5019c          STR      r0,[r5,#0x19c]
;;;508    				memcpy(bss->wpa_ie, pos, bss->wpa_ie_len);
0002b8  4621              MOV      r1,r4
0002ba  f2051059          ADD      r0,r5,#0x159
0002be  f8d5219c          LDR      r2,[r5,#0x19c]
0002c2  f7fffffe          BL       __aeabi_memcpy
;;;509    				lbs_deb_scan("got WPA IE\n");
0002c6  a0b3              ADR      r0,|L6.1428|
0002c8  f7fffffe          BL       __2printf
0002cc  e01e              B        |L6.780|
                  |L6.718|
;;;510    			/*	lbs_deb_hex(LBS_DEB_SCAN, "WPA IE", bss->wpa_ie,
;;;511    					    bss->wpa_ie_len);*/
;;;512    			} else if (pos[1] >= MARVELL_MESH_IE_LENGTH &&
0002ce  7860              LDRB     r0,[r4,#1]
0002d0  2809              CMP      r0,#9
0002d2  db11              BLT      |L6.760|
;;;513    				   pos[2] == 0x00 && pos[3] == 0x50 &&
0002d4  78a0              LDRB     r0,[r4,#2]
0002d6  b978              CBNZ     r0,|L6.760|
0002d8  78e0              LDRB     r0,[r4,#3]
0002da  2850              CMP      r0,#0x50
0002dc  d10c              BNE      |L6.760|
;;;514    				   pos[4] == 0x43 && pos[5] == 0x04) {
0002de  7920              LDRB     r0,[r4,#4]
0002e0  2843              CMP      r0,#0x43
0002e2  d109              BNE      |L6.760|
0002e4  7960              LDRB     r0,[r4,#5]
0002e6  2804              CMP      r0,#4
0002e8  d106              BNE      |L6.760|
;;;515    				lbs_deb_scan("got mesh IE\n");
0002ea  a0ad              ADR      r0,|L6.1440|
0002ec  f7fffffe          BL       __2printf
;;;516    				bss->mesh = 1;
0002f0  2001              MOVS     r0,#1
0002f2  f88501e4          STRB     r0,[r5,#0x1e4]
0002f6  e009              B        |L6.780|
                  |L6.760|
;;;517    			} else {
;;;518    				lbs_deb_scan("got generic IE: %02x:%02x:%02x:%02x, len %d\n",
0002f8  7863              LDRB     r3,[r4,#1]
0002fa  7962              LDRB     r2,[r4,#5]
0002fc  e9cd2300          STRD     r2,r3,[sp,#0]
000300  7923              LDRB     r3,[r4,#4]
000302  78e2              LDRB     r2,[r4,#3]
000304  78a1              LDRB     r1,[r4,#2]
000306  a0aa              ADR      r0,|L6.1456|
000308  f7fffffe          BL       __2printf
                  |L6.780|
;;;519    					pos[2], pos[3],
;;;520    					pos[4], pos[5],
;;;521    					pos[1]);
;;;522    			}
;;;523    			break;
00030c  e01a              B        |L6.836|
                  |L6.782|
;;;524    
;;;525    		case WLAN_EID_RSN:
;;;526    			lbs_deb_scan("got RSN IE\n");
00030e  a0b4              ADR      r0,|L6.1504|
000310  f7fffffe          BL       __2printf
;;;527    			bss->rsn_ie_len = min(pos[1] + 2, MAX_WPA_IE_LEN);
000314  7860              LDRB     r0,[r4,#1]
000316  1c80              ADDS     r0,r0,#2
000318  2840              CMP      r0,#0x40
00031a  da02              BGE      |L6.802|
00031c  7860              LDRB     r0,[r4,#1]
00031e  1c80              ADDS     r0,r0,#2
000320  e000              B        |L6.804|
                  |L6.802|
000322  2040              MOVS     r0,#0x40
                  |L6.804|
000324  f8c501e0          STR      r0,[r5,#0x1e0]
;;;528    			memcpy(bss->rsn_ie, pos, bss->rsn_ie_len);
000328  4621              MOV      r1,r4
00032a  f50570d0          ADD      r0,r5,#0x1a0
00032e  f8d521e0          LDR      r2,[r5,#0x1e0]
000332  f7fffffe          BL       __aeabi_memcpy
;;;529    			/*lbs_deb_hex(LBS_DEB_SCAN, "process_bss: RSN_IE",
;;;530    				    bss->rsn_ie, bss->rsn_ie_len);*/
;;;531    			break;
000336  e005              B        |L6.836|
                  |L6.824|
;;;532    
;;;533    		default:
;;;534    			lbs_deb_scan("got IE 0x%04x, len %d\n",
000338  7862              LDRB     r2,[r4,#1]
00033a  7821              LDRB     r1,[r4,#0]
00033c  a0ab              ADR      r0,|L6.1516|
00033e  f7fffffe          BL       __2printf
;;;535    				     pos[0], pos[1]);
;;;536    			break;
000342  bf00              NOP      
                  |L6.836|
000344  bf00              NOP                            ;429
;;;537    		}
;;;538    
;;;539    		pos += pos[1] + 2;
000346  7860              LDRB     r0,[r4,#1]
000348  1c80              ADDS     r0,r0,#2
00034a  4404              ADD      r4,r4,r0
                  |L6.844|
00034c  f1aa0002          SUB      r0,r10,#2             ;414
000350  42a0              CMP      r0,r4                 ;414
000352  f4bfaeda          BCS      |L6.266|
                  |L6.854|
000356  bf00              NOP                            ;418
;;;540    	}
;;;541    
;;;542    	/* Timestamp */
;;;543    	bss->last_scanned = jiffies;
000358  2000              MOVS     r0,#0
00035a  64a8              STR      r0,[r5,#0x48]
;;;544    	lbs_unset_basic_rate_flags(bss->rates, sizeof(bss->rates));
00035c  210f              MOVS     r1,#0xf
00035e  f1050039          ADD      r0,r5,#0x39
000362  f7fffffe          BL       lbs_unset_basic_rate_flags
;;;545    
;;;546    	ret = 0;
000366  f04f0b00          MOV      r11,#0
;;;547    
;;;548    done:
00036a  bf00              NOP      
                  |L6.876|
;;;549    	lbs_deb_leave_args(LBS_DEB_SCAN, ret);
;;;550    	return ret;
00036c  4658              MOV      r0,r11
;;;551    }
00036e  b00b              ADD      sp,sp,#0x2c
000370  e8bd8ff0          POP      {r4-r11,pc}
;;;552    
                          ENDP

                  |L6.884|
000374  62656163          DCB      "beaconsize=%d\n",0
000378  6f6e7369
00037c  7a653d25
000380  640a00  
000383  00                DCB      0
                  |L6.900|
000384  70726f63          DCB      "process_bss: BSSID %2x:%2x:%2x:%2x:%2x:%2x\n",0
000388  6573735f
00038c  6273733a
000390  20425353
000394  49442025
000398  32783a25
00039c  32783a25
0003a0  32783a25
0003a4  32783a25
0003a8  32783a25
0003ac  32780a00
                  |L6.944|
0003b0  70726f63          DCB      "process_bss: Not enough bytes left\n",0
0003b4  6573735f
0003b8  6273733a
0003bc  204e6f74
0003c0  20656e6f
0003c4  75676820
0003c8  62797465
0003cc  73206c65
0003d0  66740a00
                  |L6.980|
0003d4  70726f63          DCB      "process_bss: RSSI %d\n",0
0003d8  6573735f
0003dc  6273733a
0003e0  20525353
0003e4  49202564
0003e8  0a00    
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L6.1004|
0003ec  70726f63          DCB      "process_bss: capabilities 0x%04x\n",0
0003f0  6573735f
0003f4  6273733a
0003f8  20636170
0003fc  6162696c
000400  69746965
000404  73203078
000408  25303478
00040c  0a00    
00040e  00                DCB      0
00040f  00                DCB      0
                  |L6.1040|
000410  70726f63          DCB      "process_bss: WEP enabled\n",0
000414  6573735f
000418  6273733a
00041c  20574550
000420  20656e61
000424  626c6564
000428  0a00    
00042a  00                DCB      0
00042b  00                DCB      0
                  |L6.1068|
00042c  70726f63          DCB      "process_bss: WEP off\n",0
000430  6573735f
000434  6273733a
000438  20574550
00043c  206f6666
000440  0a00    
000442  00                DCB      0
000443  00                DCB      0
                  |L6.1092|
000444  6d6f6465          DCB      "mode:adhoc",0
000448  3a616468
00044c  6f6300  
00044f  00                DCB      0
                  |L6.1104|
000450  6d6f6465          DCB      "mode:manage",0
000454  3a6d616e
000458  61676500
                  |L6.1116|
00045c  70726f63          DCB      "process_bss: IE len %zd\n",0
000460  6573735f
000464  6273733a
000468  20494520
00046c  6c656e20
000470  257a640a
000474  00      
000475  00                DCB      0
000476  00                DCB      0
000477  00                DCB      0
                  |L6.1144|
000478  70726f63          DCB      "process_bss: error in processing IE, bytes left < IE le"
00047c  6573735f
000480  6273733a
000484  20657272
000488  6f722069
00048c  6e207072
000490  6f636573
000494  73696e67
000498  2049452c
00049c  20627974
0004a0  6573206c
0004a4  65667420
0004a8  3c204945
0004ac  206c65  
0004af  6e677468          DCB      "ngth\n",0
0004b3  0a00    
0004b5  00                DCB      0
0004b6  00                DCB      0
0004b7  00                DCB      0
                  |L6.1208|
0004b8  676f7420          DCB      "got SSID IE: '%s', len %u\n",0
0004bc  53534944
0004c0  2049453a
0004c4  20272573
0004c8  272c206c
0004cc  656e2025
0004d0  750a00  
0004d3  00                DCB      0
                  |L6.1236|
0004d4  676f7420          DCB      "got RATES IE\n",0
0004d8  52415445
0004dc  53204945
0004e0  0a00    
0004e2  00                DCB      0
0004e3  00                DCB      0
                  |L6.1252|
0004e4  676f7420          DCB      "got FH IE\n",0
0004e8  46482049
0004ec  450a00  
0004ef  00                DCB      0
                  |L6.1264|
0004f0  676f7420          DCB      "got DS IE, channel %d\n",0
0004f4  44532049
0004f8  452c2063
0004fc  68616e6e
000500  656c2025
000504  640a00  
000507  00                DCB      0
                  |L6.1288|
000508  676f7420          DCB      "got CF IE\n",0
00050c  43462049
000510  450a00  
000513  00                DCB      0
                  |L6.1300|
000514  676f7420          DCB      "got IBSS IE\n",0
000518  49425353
00051c  2049450a
000520  00      
000521  00                DCB      0
000522  00                DCB      0
000523  00                DCB      0
                  |L6.1316|
000524  676f7420          DCB      "got COUNTRY IE\n",0
000528  434f554e
00052c  54525920
000530  49450a00
                  |L6.1332|
                          DCD      __func__
                  |L6.1336|
000538  25733a20          DCB      "%s: 11D- Err CountryInfo len %d, min %zd, max 254\n",0
00053c  3131442d
000540  20457272
000544  20436f75
000548  6e747279
00054c  496e666f
000550  206c656e
000554  2025642c
000558  206d696e
00055c  20257a64
000560  2c206d61
000564  78203235
000568  340a00  
00056b  00                DCB      0
                  |L6.1388|
00056c  676f7420          DCB      "got RATESEX IE\n",0
000570  52415445
000574  53455820
000578  49450a00
                  |L6.1404|
00057c  2e2e2e20          DCB      "... but ignoring it\n",0
000580  62757420
000584  69676e6f
000588  72696e67
00058c  2069740a
000590  00      
000591  00                DCB      0
000592  00                DCB      0
000593  00                DCB      0
                  |L6.1428|
000594  676f7420          DCB      "got WPA IE\n",0
000598  57504120
00059c  49450a00
                  |L6.1440|
0005a0  676f7420          DCB      "got mesh IE\n",0
0005a4  6d657368
0005a8  2049450a
0005ac  00      
0005ad  00                DCB      0
0005ae  00                DCB      0
0005af  00                DCB      0
                  |L6.1456|
0005b0  676f7420          DCB      "got generic IE: %02x:%02x:%02x:%02x, len %d\n",0
0005b4  67656e65
0005b8  72696320
0005bc  49453a20
0005c0  25303278
0005c4  3a253032
0005c8  783a2530
0005cc  32783a25
0005d0  3032782c
0005d4  206c656e
0005d8  2025640a
0005dc  00      
0005dd  00                DCB      0
0005de  00                DCB      0
0005df  00                DCB      0
                  |L6.1504|
0005e0  676f7420          DCB      "got RSN IE\n",0
0005e4  52534e20
0005e8  49450a00
                  |L6.1516|
0005ec  676f7420          DCB      "got IE 0x%04x, len %d\n",0
0005f0  49452030
0005f4  78253034
0005f8  782c206c
0005fc  656e2025
000600  640a00  
000603  00                DCB      0

                          AREA ||i.lbs_ret_80211_scan||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  lbs_ret_80211_scan PROC
;;;587    
;;;588    static int lbs_ret_80211_scan(struct lbs_private *priv, unsigned long dummy,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;589    			      struct cmd_header *resp)
;;;590    {
000004  f5ad7d03          SUB      sp,sp,#0x20c
000008  4604              MOV      r4,r0
00000a  4690              MOV      r8,r2
;;;591    	struct cmd_ds_802_11_scan_rsp *scanresp = (void *)resp;
00000c  4645              MOV      r5,r8
;;;592    	struct bss_descriptor *iter_bss;
;;;593    
;;;594    	//struct bss_descriptor *safe;
;;;595    	uint8_t *bssinfo;
;;;596     	uint16_t scanrespsize;
;;;597    	int bytesleft;
;;;598    	int idx;
;;;599     	int tlvbufsize;
;;;600    	int ret;
;;;601    	
;;;602    
;;;603    	lbs_deb_enter(LBS_DEB_SCAN);
;;;604    
;;;605    	/* Prune old entries from scan table */
;;;606    	//这个SSID有一个生存时间
;;;607    	 /*list_for_each_entry_safe (iter_bss, safe, &priv->network_list, list) {
;;;608    		unsigned long stale_time = iter_bss->last_scanned + DEFAULT_MAX_SCAN_AGE;
;;;609    		if (time_before(jiffies, stale_time))
;;;610    			continue;
;;;611    		list_move_tail (&iter_bss->list, &priv->network_free_list);
;;;612    		clear_bss_descriptor(iter_bss);
;;;613    	} */
;;;614    
;;;615    	if (scanresp->nr_sets > MAX_NETWORK_COUNT) {
00000e  7aa8              LDRB     r0,[r5,#0xa]
000010  280c              CMP      r0,#0xc
000012  dd07              BLE      |L7.36|
;;;616    		lbs_deb_scan("SCAN_RESP: too many scan results (%d, max %d)\n",
000014  7aa9              LDRB     r1,[r5,#0xa]
000016  220c              MOVS     r2,#0xc
000018  a050              ADR      r0,|L7.348|
00001a  f7fffffe          BL       __2printf
;;;617    			     scanresp->nr_sets, MAX_NETWORK_COUNT);
;;;618    		ret = -1;
00001e  f04f3bff          MOV      r11,#0xffffffff
;;;619    		goto done;
000022  e096              B        |L7.338|
                  |L7.36|
;;;620    	}
;;;621    
;;;622    	bytesleft = get_unaligned_le16(&scanresp->bssdescriptsize);
000024  8928              LDRH     r0,[r5,#8]
000026  9080              STR      r0,[sp,#0x200]
;;;623    	lbs_deb_scan("SCAN_RESP: bssdescriptsize %d\n", bytesleft);
000028  a058              ADR      r0,|L7.396|
00002a  9980              LDR      r1,[sp,#0x200]
00002c  f7fffffe          BL       __2printf
;;;624    
;;;625    	scanrespsize = le16_to_cpu(resp->size);
000030  f8b80002          LDRH     r0,[r8,#2]
000034  9081              STR      r0,[sp,#0x204]
;;;626    	lbs_deb_scan("SCAN_RESP: scan results %d\n", scanresp->nr_sets);
000036  7aa9              LDRB     r1,[r5,#0xa]
000038  a05c              ADR      r0,|L7.428|
00003a  f7fffffe          BL       __2printf
;;;627    
;;;628    	bssinfo = scanresp->bssdesc_and_tlvbuffer;
00003e  f105000b          ADD      r0,r5,#0xb
000042  9082              STR      r0,[sp,#0x208]
;;;629    
;;;630    	/* The size of the TLV buffer is equal to the entire command response
;;;631    	 *   size (scanrespsize) minus the fixed fields (sizeof()'s), the
;;;632    	 *   BSS Descriptions (bssdescriptsize as bytesLef) and the command
;;;633    	 *   response header (S_DS_GEN)
;;;634    	 */
;;;635     	tlvbufsize = scanrespsize - (bytesleft + sizeof(scanresp->bssdescriptsize)
000044  9980              LDR      r1,[sp,#0x200]
000046  310f              ADDS     r1,r1,#0xf
000048  9881              LDR      r0,[sp,#0x204]
00004a  1a40              SUBS     r0,r0,r1
00004c  907f              STR      r0,[sp,#0x1fc]
;;;636    				     + sizeof(scanresp->nr_sets)
;;;637    				     + S_DS_GEN);	   
;;;638    
;;;639    	/*
;;;640    	 *  Process each scan response returned (scanresp->nr_sets). Save
;;;641    	 *    the information in the newbssentry and then insert into the
;;;642    	 *    driver scan table either as an update to an existing entry
;;;643    	 *    or as an addition at the end of the table
;;;644    	 */
;;;645    	for (idx = 0; idx < scanresp->nr_sets && bytesleft; idx++) {
00004e  f04f0a00          MOV      r10,#0
000052  e075              B        |L7.320|
                  |L7.84|
;;;646    		struct bss_descriptor new;
;;;647    		struct bss_descriptor *found = NULL;
000054  f04f0900          MOV      r9,#0
;;;648    		struct bss_descriptor *oldest = NULL;
000058  2700              MOVS     r7,#0
;;;649    		/* Process the data fields and IEs returned for this BSS */
;;;650    		memset(&new, 0, sizeof (struct bss_descriptor));
00005a  f44f71f8          MOV      r1,#0x1f0
00005e  a803              ADD      r0,sp,#0xc
000060  f7fffffe          BL       __aeabi_memclr4
;;;651    		if (lbs_process_bss(&new, &bssinfo, &bytesleft) != 0) {
000064  aa80              ADD      r2,sp,#0x200
000066  a982              ADD      r1,sp,#0x208
000068  a803              ADD      r0,sp,#0xc
00006a  f7fffffe          BL       lbs_process_bss
00006e  b120              CBZ      r0,|L7.122|
;;;652    			/* error parsing the scan response, skipped */
;;;653    			lbs_deb_scan("SCAN_RESP: process_bss returned ERROR(%d)\n",tlvbufsize);
000070  a055              ADR      r0,|L7.456|
000072  997f              LDR      r1,[sp,#0x1fc]
000074  f7fffffe          BL       __2printf
;;;654    			continue;
000078  e060              B        |L7.316|
                  |L7.122|
;;;655    		}
;;;656    
;;;657    		/* Try to find this bss in the scan table */
;;;658    		list_for_each_entry_bssdes(iter_bss, &priv->network_list, list) {
00007a  f44f70f4          MOV      r0,#0x1e8
00007e  f8d410ec          LDR      r1,[r4,#0xec]
000082  1a0e              SUBS     r6,r1,r0
000084  e011              B        |L7.170|
                  |L7.134|
;;;659    			if (is_same_network(iter_bss, &new)) {
000086  a903              ADD      r1,sp,#0xc
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       is_same_network
00008e  b108              CBZ      r0,|L7.148|
;;;660    				found = iter_bss;//之前扫描的结果
000090  46b1              MOV      r9,r6
;;;661    				break;
000092  e010              B        |L7.182|
                  |L7.148|
;;;662    			}
;;;663    
;;;664    			if ((oldest == NULL) ||
000094  b11f              CBZ      r7,|L7.158|
;;;665    			    (iter_bss->last_scanned < oldest->last_scanned))
000096  6cb0              LDR      r0,[r6,#0x48]
000098  6cb9              LDR      r1,[r7,#0x48]
00009a  4288              CMP      r0,r1
00009c  d200              BCS      |L7.160|
                  |L7.158|
;;;666    				oldest = iter_bss;//更新最老的
00009e  4637              MOV      r7,r6
                  |L7.160|
0000a0  f44f70f4          MOV      r0,#0x1e8             ;658
0000a4  f8d611e8          LDR      r1,[r6,#0x1e8]        ;658
0000a8  1a0e              SUBS     r6,r1,r0              ;658
                  |L7.170|
0000aa  f50670f4          ADD      r0,r6,#0x1e8          ;658
0000ae  f10401ec          ADD      r1,r4,#0xec           ;658
0000b2  4288              CMP      r0,r1                 ;658
0000b4  d1e7              BNE      |L7.134|
                  |L7.182|
0000b6  bf00              NOP                            ;661
;;;667    		}
;;;668    
;;;669    		if (found) {
0000b8  f1b90f00          CMP      r9,#0
0000bc  d003              BEQ      |L7.198|
;;;670    			/* found, clear it */
;;;671    			clear_bss_descriptor(found);
0000be  4648              MOV      r0,r9
0000c0  f7fffffe          BL       clear_bss_descriptor
0000c4  e022              B        |L7.268|
                  |L7.198|
;;;672    		} else if (!list_empty(&priv->network_free_list)) {//空闲链表不空
0000c6  f10400f4          ADD      r0,r4,#0xf4
0000ca  6801              LDR      r1,[r0,#0]
0000cc  4281              CMP      r1,r0
0000ce  d101              BNE      |L7.212|
0000d0  2101              MOVS     r1,#1
0000d2  e000              B        |L7.214|
                  |L7.212|
0000d4  2100              MOVS     r1,#0
                  |L7.214|
0000d6  b961              CBNZ     r1,|L7.242|
;;;673    			/* Pull one from the free list */
;;;674    			found = list_entry(priv->network_free_list.next,
0000d8  f44f70f4          MOV      r0,#0x1e8
0000dc  f8d410f4          LDR      r1,[r4,#0xf4]
0000e0  eba10900          SUB      r9,r1,r0
;;;675    					   struct bss_descriptor, list);
;;;676    			list_move_tail(&found->list, &priv->network_list);
0000e4  f10401ec          ADD      r1,r4,#0xec
0000e8  f50970f4          ADD      r0,r9,#0x1e8
0000ec  f7fffffe          BL       list_move_tail
0000f0  e00c              B        |L7.268|
                  |L7.242|
;;;677    		} else if (oldest) {//处理最老的
0000f2  b157              CBZ      r7,|L7.266|
;;;678    			/* If there are no more slots, expire the oldest */
;;;679    			found = oldest;
0000f4  46b9              MOV      r9,r7
;;;680    			clear_bss_descriptor(found);
0000f6  4648              MOV      r0,r9
0000f8  f7fffffe          BL       clear_bss_descriptor
;;;681    			list_move_tail(&found->list, &priv->network_list);
0000fc  f10401ec          ADD      r1,r4,#0xec
000100  f50970f4          ADD      r0,r9,#0x1e8
000104  f7fffffe          BL       list_move_tail
000108  e000              B        |L7.268|
                  |L7.266|
;;;682    		} else {
;;;683    			continue;
00010a  e017              B        |L7.316|
                  |L7.268|
;;;684    		}
;;;685    
;;;686    		lbs_deb_scan("SCAN_RESP: BSSID %2x:%2x:%2x:%2x:%2x:%2x\n",
00010c  f89d3011          LDRB     r3,[sp,#0x11]
000110  f89d2010          LDRB     r2,[sp,#0x10]
000114  f89d100f          LDRB     r1,[sp,#0xf]
000118  e88d000e          STM      sp,{r1-r3}
00011c  f89d300e          LDRB     r3,[sp,#0xe]
000120  f89d200d          LDRB     r2,[sp,#0xd]
000124  f89d100c          LDRB     r1,[sp,#0xc]
000128  a032              ADR      r0,|L7.500|
00012a  f7fffffe          BL       __2printf
;;;687    				new.bssid[0],new.bssid[1],new.bssid[2],new.bssid[3],
;;;688    				new.bssid[4],new.bssid[5]);
;;;689    
;;;690    		/* Copy the locally created newbssentry to the scan table */
;;;691    		memcpy(found, &new, offsetof(struct bss_descriptor, list));//链入
00012e  f44f72f4          MOV      r2,#0x1e8
000132  a903              ADD      r1,sp,#0xc
000134  4648              MOV      r0,r9
000136  f7fffffe          BL       __aeabi_memcpy4
00013a  bf00              NOP                            ;654
                  |L7.316|
00013c  f10a0a01          ADD      r10,r10,#1            ;645
                  |L7.320|
000140  7aa8              LDRB     r0,[r5,#0xa]          ;645
000142  4550              CMP      r0,r10                ;645
000144  dd02              BLE      |L7.332|
000146  9880              LDR      r0,[sp,#0x200]        ;645
000148  2800              CMP      r0,#0                 ;645
00014a  d183              BNE      |L7.84|
                  |L7.332|
;;;692    	}
;;;693    
;;;694    	ret = 0;
00014c  f04f0b00          MOV      r11,#0
;;;695    
;;;696    done:
000150  bf00              NOP      
                  |L7.338|
;;;697    	lbs_deb_leave_args(LBS_DEB_SCAN, ret);
;;;698    	return ret;
000152  4658              MOV      r0,r11
;;;699    }
000154  f50d7d03          ADD      sp,sp,#0x20c
000158  e8bd8ff0          POP      {r4-r11,pc}
;;;700    
                          ENDP

                  |L7.348|
00015c  5343414e          DCB      "SCAN_RESP: too many scan results (%d, max %d)\n",0
000160  5f524553
000164  503a2074
000168  6f6f206d
00016c  616e7920
000170  7363616e
000174  20726573
000178  756c7473
00017c  20282564
000180  2c206d61
000184  78202564
000188  290a00  
00018b  00                DCB      0
                  |L7.396|
00018c  5343414e          DCB      "SCAN_RESP: bssdescriptsize %d\n",0
000190  5f524553
000194  503a2062
000198  73736465
00019c  73637269
0001a0  70747369
0001a4  7a652025
0001a8  640a00  
0001ab  00                DCB      0
                  |L7.428|
0001ac  5343414e          DCB      "SCAN_RESP: scan results %d\n",0
0001b0  5f524553
0001b4  503a2073
0001b8  63616e20
0001bc  72657375
0001c0  6c747320
0001c4  25640a00
                  |L7.456|
0001c8  5343414e          DCB      "SCAN_RESP: process_bss returned ERROR(%d)\n",0
0001cc  5f524553
0001d0  503a2070
0001d4  726f6365
0001d8  73735f62
0001dc  73732072
0001e0  65747572
0001e4  6e656420
0001e8  4552524f
0001ec  52282564
0001f0  290a00  
0001f3  00                DCB      0
                  |L7.500|
0001f4  5343414e          DCB      "SCAN_RESP: BSSID %2x:%2x:%2x:%2x:%2x:%2x\n",0
0001f8  5f524553
0001fc  503a2042
000200  53534944
000204  20253278
000208  3a253278
00020c  3a253278
000210  3a253278
000214  3a253278
000218  3a253278
00021c  0a00    
00021e  00                DCB      0
00021f  00                DCB      0

                          AREA ||i.lbs_scan_add_chanlist_tlv||, CODE, READONLY, ALIGN=1

                  lbs_scan_add_chanlist_tlv PROC
;;;197     */
;;;198    static int lbs_scan_add_chanlist_tlv(uint8_t *tlv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;199    				     struct chanscanparamset *chan_list,
;;;200    				     int chan_count)
;;;201    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;202    	size_t size = sizeof(struct chanscanparamset) *chan_count;
00000a  ebc705c7          RSB      r5,r7,r7,LSL #3
;;;203    	struct mrvl_ie_chanlist_param_set *chan_tlv = (void *)tlv;
00000e  4626              MOV      r6,r4
;;;204    
;;;205    	chan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);
000010  f2401001          MOV      r0,#0x101
000014  8030              STRH     r0,[r6,#0]
;;;206    	memcpy(chan_tlv->chanscanparam, chan_list, size);
000016  462a              MOV      r2,r5
000018  4641              MOV      r1,r8
00001a  1d30              ADDS     r0,r6,#4
00001c  f7fffffe          BL       __aeabi_memcpy
;;;207    	chan_tlv->header.len = cpu_to_le16(size);
000020  8075              STRH     r5,[r6,#2]
;;;208    	return sizeof(chan_tlv->header) + size;
000022  1d28              ADDS     r0,r5,#4
;;;209    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;210    
                          ENDP


                          AREA ||i.lbs_scan_add_rates_tlv||, CODE, READONLY, ALIGN=2

                  lbs_scan_add_rates_tlv PROC
;;;222     */
;;;223    static int lbs_scan_add_rates_tlv(uint8_t *tlv)
000000  4601              MOV      r1,r0
;;;224    {
;;;225    	int i;
;;;226    	struct mrvl_ie_rates_param_set *rate_tlv = (void *)tlv;
000002  460b              MOV      r3,r1
;;;227    
;;;228    	rate_tlv->header.type = cpu_to_le16(TLV_TYPE_RATES);
000004  2001              MOVS     r0,#1
000006  8018              STRH     r0,[r3,#0]
;;;229    	tlv += sizeof(rate_tlv->header);
000008  1d09              ADDS     r1,r1,#4
;;;230    	for (i = 0; i < MAX_RATES; i++) {
00000a  2200              MOVS     r2,#0
00000c  e017              B        |L9.62|
                  |L9.14|
;;;231    		*tlv = lbs_bg_rates[i];
00000e  480f              LDR      r0,|L9.76|
000010  5c80              LDRB     r0,[r0,r2]
000012  7008              STRB     r0,[r1,#0]
;;;232    		if (*tlv == 0)
000014  7808              LDRB     r0,[r1,#0]
000016  b900              CBNZ     r0,|L9.26|
;;;233    			break;
000018  e013              B        |L9.66|
                  |L9.26|
;;;234    		/* This code makes sure that the 802.11b rates (1 MBit/s, 2
;;;235    		   MBit/s, 5.5 MBit/s and 11 MBit/s get's the high bit set.
;;;236    		   Note that the values are MBit/s * 2, to mark them as
;;;237    		   basic rates so that the firmware likes it better */
;;;238    		if (*tlv == 0x02 || *tlv == 0x04 ||
00001a  7808              LDRB     r0,[r1,#0]
00001c  2802              CMP      r0,#2
00001e  d008              BEQ      |L9.50|
000020  7808              LDRB     r0,[r1,#0]
000022  2804              CMP      r0,#4
000024  d005              BEQ      |L9.50|
;;;239    		    *tlv == 0x0b || *tlv == 0x16)
000026  7808              LDRB     r0,[r1,#0]
000028  280b              CMP      r0,#0xb
00002a  d002              BEQ      |L9.50|
00002c  7808              LDRB     r0,[r1,#0]
00002e  2816              CMP      r0,#0x16
000030  d103              BNE      |L9.58|
                  |L9.50|
;;;240    			*tlv |= 0x80;
000032  7808              LDRB     r0,[r1,#0]
000034  f0400080          ORR      r0,r0,#0x80
000038  7008              STRB     r0,[r1,#0]
                  |L9.58|
;;;241    		tlv++;
00003a  1c49              ADDS     r1,r1,#1
00003c  1c52              ADDS     r2,r2,#1              ;230
                  |L9.62|
00003e  2a0e              CMP      r2,#0xe               ;230
000040  dbe5              BLT      |L9.14|
                  |L9.66|
000042  bf00              NOP                            ;233
;;;242    	}
;;;243    	rate_tlv->header.len = cpu_to_le16(i);
000044  805a              STRH     r2,[r3,#2]
;;;244    	return sizeof(rate_tlv->header) + i;
000046  1d10              ADDS     r0,r2,#4
;;;245    }
000048  4770              BX       lr
;;;246    
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      lbs_bg_rates

                          AREA ||i.lbs_scan_add_ssid_tlv||, CODE, READONLY, ALIGN=1

                  lbs_scan_add_ssid_tlv PROC
;;;162     */
;;;163    static int lbs_scan_add_ssid_tlv(struct lbs_private *priv, u8 *tlv)
000000  b570              PUSH     {r4-r6,lr}
;;;164    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;165    	struct mrvl_ie_ssid_param_set *ssid_tlv = (void *)tlv;
000006  462e              MOV      r6,r5
;;;166    
;;;167    	ssid_tlv->header.type = cpu_to_le16(TLV_TYPE_SSID);
000008  2000              MOVS     r0,#0
00000a  8030              STRH     r0,[r6,#0]
;;;168    	ssid_tlv->header.len = cpu_to_le16(priv->scan_ssid_len);
00000c  f8940051          LDRB     r0,[r4,#0x51]
000010  8070              STRH     r0,[r6,#2]
;;;169    	memcpy(ssid_tlv->ssid, priv->scan_ssid, priv->scan_ssid_len);
000012  f8942051          LDRB     r2,[r4,#0x51]
000016  f1040130          ADD      r1,r4,#0x30
00001a  1d30              ADDS     r0,r6,#4
00001c  f7fffffe          BL       __aeabi_memcpy
;;;170    	return sizeof(ssid_tlv->header) + priv->scan_ssid_len;
000020  f8940051          LDRB     r0,[r4,#0x51]
000024  1d00              ADDS     r0,r0,#4
;;;171    }
000026  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP


                          AREA ||i.lbs_scan_create_channel_list||, CODE, READONLY, ALIGN=1

                  lbs_scan_create_channel_list PROC
;;;89     //struct chanscanparamset;
;;;90     static int lbs_scan_create_channel_list(struct lbs_private *priv,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;91     					struct chanscanparamset *scanchanlist)
;;;92     {
000004  4603              MOV      r3,r0
000006  460e              MOV      r6,r1
;;;93     	struct region_channel *scanregion;
;;;94     	struct chan_freq_power *cfp;
;;;95     	u32 rgnidx;
;;;96     	int chanidx;
;;;97     	int nextchan;
;;;98     	uint8_t scantype;
;;;99     
;;;100    	chanidx = 0;
000008  2500              MOVS     r5,#0
;;;101    
;;;102    	/* Set the default scan type to the user specified type, will later
;;;103    	 *   be changed to passive on a per channel basis if restricted by
;;;104    	 *   regulatory requirements (11d or 11h)
;;;105    	 */
;;;106    	scantype = CMD_SCAN_TYPE_ACTIVE;
00000a  46ac              MOV      r12,r5
;;;107    
;;;108    	 for (rgnidx = 0; rgnidx < ARRAY_SIZE(priv->region_channel); rgnidx++) {//区域的所有信道
00000c  2200              MOVS     r2,#0
00000e  e04a              B        |L11.166|
                  |L11.16|
;;;109    	//	for (rgnidx = 0; rgnidx < MAX_REGION_CHANNEL_NUM; rgnidx++) {
;;;110    
;;;111    		#ifdef ENABLE_80211D_DEBUG
;;;112    		if (priv->enable11d && (priv->connect_status != LBS_CONNECTED)
;;;113    		    && (priv->mesh_connect_status != LBS_CONNECTED)) {
;;;114    			/* Scan all the supported chan for the first scan */
;;;115    			if (!priv->universal_channel[rgnidx].valid)
;;;116    				continue;
;;;117    			scanregion = &priv->universal_channel[rgnidx];
;;;118    
;;;119    			/* clear the parsed_region_chan for the first scan */
;;;120    			memset(&priv->parsed_region_chan, 0x00,
;;;121    			       sizeof(priv->parsed_region_chan));
;;;122    		} 
;;;123    		#else 
;;;124    			if (!priv->region_channel[rgnidx].valid)
000010  f5037046          ADD      r0,r3,#0x318
000014  f8100032          LDRB     r0,[r0,r2,LSL #3]
000018  b900              CBNZ     r0,|L11.28|
;;;125    				continue;
00001a  e043              B        |L11.164|
                  |L11.28|
;;;126    			scanregion = &priv->region_channel[rgnidx];
00001c  f5037046          ADD      r0,r3,#0x318
000020  eb0001c2          ADD      r1,r0,r2,LSL #3
;;;127    	
;;;128    		#endif
;;;129    
;;;130    		for (nextchan = 0; nextchan < scanregion->nrcfp; nextchan++, chanidx++) {
000024  2400              MOVS     r4,#0
000026  e039              B        |L11.156|
                  |L11.40|
;;;131    			struct chanscanparamset *chan = &scanchanlist[chanidx];//返回的扫描通道链表
000028  ebc508c5          RSB      r8,r5,r5,LSL #3
00002c  eb080006          ADD      r0,r8,r6
;;;132    
;;;133    			cfp = scanregion->CFP + nextchan;
000030  eb040944          ADD      r9,r4,r4,LSL #1
000034  f8d18004          LDR      r8,[r1,#4]
000038  eb080789          ADD      r7,r8,r9,LSL #2
;;;134    
;;;135    			/*if (priv->enable11d)//disable 802.11d
;;;136    				scantype = lbs_get_scan_type_11d(cfp->channel,
;;;137    								 &priv->parsed_region_chan);*/
;;;138    
;;;139    			if (scanregion->band == BAND_B || scanregion->band == BAND_G)
00003c  f8918002          LDRB     r8,[r1,#2]
000040  f1b80f01          CMP      r8,#1
000044  d004              BEQ      |L11.80|
000046  f8918002          LDRB     r8,[r1,#2]
00004a  f1b80f02          CMP      r8,#2
00004e  d103              BNE      |L11.88|
                  |L11.80|
;;;140    				chan->radiotype = CMD_SCAN_RADIO_TYPE_BG;
000050  f04f0800          MOV      r8,#0
000054  f8808000          STRB     r8,[r0,#0]
                  |L11.88|
;;;141    
;;;142    			if (scantype == CMD_SCAN_TYPE_PASSIVE) {
000058  f1bc0f01          CMP      r12,#1
00005c  d10c              BNE      |L11.120|
;;;143    				chan->maxscantime = cpu_to_le16(MRVDRV_PASSIVE_SCAN_CHAN_TIME);
00005e  f04f0864          MOV      r8,#0x64
000062  f8a08005          STRH     r8,[r0,#5]
;;;144    				chan->chanscanmode.passivescan = 1;
000066  f04f0901          MOV      r9,#1
00006a  f8908002          LDRB     r8,[r0,#2]
00006e  f3690800          BFI      r8,r9,#0,#1
000072  f8808002          STRB     r8,[r0,#2]
000076  e00b              B        |L11.144|
                  |L11.120|
;;;145    			} else {
;;;146    				chan->maxscantime = cpu_to_le16(MRVDRV_ACTIVE_SCAN_CHAN_TIME);
000078  f04f0864          MOV      r8,#0x64
00007c  f8a08005          STRH     r8,[r0,#5]
;;;147    				chan->chanscanmode.passivescan = 0;
000080  f04f0900          MOV      r9,#0
000084  f8908002          LDRB     r8,[r0,#2]
000088  f3690800          BFI      r8,r9,#0,#1
00008c  f8808002          STRB     r8,[r0,#2]
                  |L11.144|
;;;148    			}
;;;149    
;;;150    			chan->channumber = cfp->channel;
000090  f8b78000          LDRH     r8,[r7,#0]
000094  f8808001          STRB     r8,[r0,#1]
000098  1c64              ADDS     r4,r4,#1              ;130
00009a  1c6d              ADDS     r5,r5,#1              ;130
                  |L11.156|
00009c  78c8              LDRB     r0,[r1,#3]            ;130
00009e  42a0              CMP      r0,r4                 ;130
0000a0  dcc2              BGT      |L11.40|
0000a2  bf00              NOP                            ;125
                  |L11.164|
0000a4  1c52              ADDS     r2,r2,#1              ;108
                  |L11.166|
0000a6  2a02              CMP      r2,#2                 ;108
0000a8  d3b2              BCC      |L11.16|
;;;151    		}
;;;152    	}
;;;153    	return chanidx;
0000aa  4628              MOV      r0,r5
;;;154    }
0000ac  e8bd83f0          POP      {r4-r9,pc}
;;;155    
                          ENDP


                          AREA ||i.lbs_scan_networks||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_p
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  lbs_scan_networks PROC
;;;799    
;;;800    int lbs_scan_networks(struct lbs_private *priv, int full_scan)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;801    {
000004  b0dd              SUB      sp,sp,#0x174
000006  4604              MOV      r4,r0
;;;802    	int ret = -ENOMEM;
000008  f06f0b0b          MVN      r11,#0xb
;;;803    	struct chanscanparamset gmarvel_scan_param[LBS_IOCTL_USER_SCAN_CHAN_MAX];
;;;804    	struct chanscanparamset *chan_list;
;;;805    	struct chanscanparamset *curr_chans;
;;;806    	int chan_count;
;;;807    	uint8_t bsstype = CMD_BSS_TYPE_ANY;//IBSS和BSS都接受
00000c  2003              MOVS     r0,#3
00000e  9004              STR      r0,[sp,#0x10]
;;;808    	int numchannels = MRVDRV_CHANNELS_PER_SCAN_CMD;
000010  2004              MOVS     r0,#4
000012  9003              STR      r0,[sp,#0xc]
;;;809    	union iwreq_data wrqu;
;;;810    //#ifdef CONFIG_LIBERTAS_DEBUG
;;;811    	struct bss_descriptor *iter;
;;;812    	int i = 0;
000014  f04f0800          MOV      r8,#0
;;;813    //	DECLARE_SSID_BUF(ssid);
;;;814    //#endif
;;;815    
;;;816    	lbs_deb_enter_args(LBS_DEB_SCAN, full_scan);
;;;817    
;;;818    	/* Cancel any partial outstanding partial scans if this scan
;;;819    	 * is a full scan.
;;;820    	 */
;;;821    /*	if (full_scan && delayed_work_pending(&priv->scan_work))
;;;822    		cancel_delayed_work(&priv->scan_work);*/
;;;823    
;;;824    	/* User-specified bsstype or channel list
;;;825    	TODO: this can be implemented if some user-space application
;;;826    	need the feature. Formerly, it was accessible from debugfs,
;;;827    	but then nowhere used.
;;;828    	if (user_cfg) {
;;;829    		if (user_cfg->bsstype)
;;;830    		bsstype = user_cfg->bsstype;
;;;831    	} */
;;;832    	/*这里清除一个遗留的bug，每次扫描之前清除网络*/
;;;833    	/*list_for_each_entry_bssdes(iter, &priv->network_list, list){
;;;834    		list_move_tail(&iter->list, &priv->network_free_list);
;;;835    		clear_bss_descriptor(iter);
;;;836    		
;;;837    	}*/
;;;838    	INIT_LIST_HEAD(&priv->network_free_list);//初始化扫描相关的链表
000018  f10400f4          ADD      r0,r4,#0xf4
00001c  f7fffffe          BL       INIT_LIST_HEAD
;;;839    	INIT_LIST_HEAD(&priv->network_list);
000020  f10400ec          ADD      r0,r4,#0xec
000024  f7fffffe          BL       INIT_LIST_HEAD
;;;840    	for (i = 0; i < MAX_NETWORK_COUNT; i++) {//当前未用的所有bss_descriptor链入到空闲链表
000028  bf00              NOP      
00002a  e015              B        |L12.88|
                  |L12.44|
;;;841    		list_add_tail(&priv->networks[i].list,
00002c  ebc81248          RSB      r2,r8,r8,LSL #5
000030  f8d410fc          LDR      r1,[r4,#0xfc]
000034  eb011102          ADD      r1,r1,r2,LSL #4
000038  f50170f4          ADD      r0,r1,#0x1e8
00003c  f10401f4          ADD      r1,r4,#0xf4
000040  f7fffffe          BL       list_add_tail
;;;842    			      &priv->network_free_list);
;;;843    		clear_bss_descriptor(&priv->networks[i]);
000044  ebc81248          RSB      r2,r8,r8,LSL #5
000048  f8d410fc          LDR      r1,[r4,#0xfc]
00004c  eb011002          ADD      r0,r1,r2,LSL #4
000050  f7fffffe          BL       clear_bss_descriptor
000054  f1080801          ADD      r8,r8,#1              ;840
                  |L12.88|
000058  f1b80f0c          CMP      r8,#0xc               ;840
00005c  dbe6              BLT      |L12.44|
;;;844    	}	
;;;845    
;;;846            lbs_deb_scan("number channels %d, bsstype %d\n", numchannels, bsstype);
00005e  a03a              ADR      r0,|L12.328|
000060  e9dd1203          LDRD     r1,r2,[sp,#0xc]
000064  f7fffffe          BL       __2printf
;;;847    
;;;848    	/* Create list of channels to scan */
;;;849    	/*chan_list = kzalloc(sizeof(struct chanscanparamset) *
;;;850    			    LBS_IOCTL_USER_SCAN_CHAN_MAX, GFP_KERNEL);*/
;;;851    
;;;852    	chan_list=gmarvel_scan_param;
000068  f10d0914          ADD      r9,sp,#0x14
;;;853    	memset(chan_list,0,sizeof(struct chanscanparamset) *\
00006c  f44f71af          MOV      r1,#0x15e
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       __aeabi_memclr
;;;854    			LBS_IOCTL_USER_SCAN_CHAN_MAX);
;;;855    	
;;;856    	/*if (!chan_list) {
;;;857    		lbs_pr_alert("SCAN: chan_list empty\n");
;;;858    		goto out;
;;;859    	}*/
;;;860    
;;;861    	/* We want to scan all channels */
;;;862    	// debug_data_stream("chan list",(char *)priv->region_channel,sizeof(struct region_channel ));
;;;863    	// debug_data_stream("cpf information",(char *)priv->region_channel[0].CFP,sizeof(struct chan_freq_power)*14);
;;;864    	chan_count = lbs_scan_create_channel_list(priv, chan_list); //需要扫描的所有通道
000076  4649              MOV      r1,r9
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       lbs_scan_create_channel_list
00007e  4605              MOV      r5,r0
;;;865    	memcpy(gmarvel_scan_param,const_chan_parm,14*7);
000080  2262              MOVS     r2,#0x62
000082  4939              LDR      r1,|L12.360|
000084  a805              ADD      r0,sp,#0x14
000086  f7fffffe          BL       __aeabi_memcpy
;;;866    
;;;867    	//netif_stop_queue(priv->dev);
;;;868    	//netif_carrier_off(priv->dev);
;;;869    	/*if (priv->mesh_dev) {
;;;870    		netif_stop_queue(priv->mesh_dev);
;;;871    		netif_carrier_off(priv->mesh_dev);
;;;872    	}*/
;;;873    
;;;874    	/* Prepare to continue an interrupted scan */
;;;875    	lbs_deb_scan("chan_count %d, scan_channel %d\n",
00008a  4629              MOV      r1,r5
00008c  a037              ADR      r0,|L12.364|
00008e  6ae2              LDR      r2,[r4,#0x2c]
000090  f7fffffe          BL       __2printf
;;;876    		     chan_count, priv->scan_channel);
;;;877    	curr_chans = chan_list;
000094  464f              MOV      r7,r9
;;;878    	/* advance channel list by already-scanned-channels */
;;;879    	if (priv->scan_channel > 0) {
000096  6ae0              LDR      r0,[r4,#0x2c]
000098  2800              CMP      r0,#0
00009a  dd05              BLE      |L12.168|
;;;880    		curr_chans += priv->scan_channel;
00009c  6ae0              LDR      r0,[r4,#0x2c]
00009e  ebc000c0          RSB      r0,r0,r0,LSL #3
0000a2  4407              ADD      r7,r7,r0
;;;881    		chan_count -= priv->scan_channel;
0000a4  6ae0              LDR      r0,[r4,#0x2c]
0000a6  1a2d              SUBS     r5,r5,r0
                  |L12.168|
;;;882    	}
;;;883    
;;;884    	/* Send scan command(s)
;;;885    	 * numchannels contains the number of channels we should maximally scan
;;;886    	 * chan_count is the total number of channels to scan
;;;887    	 */
;;;888    
;;;889    	while (chan_count) {
0000a8  e024              B        |L12.244|
                  |L12.170|
;;;890    		int to_scan = min(numchannels, chan_count);
0000aa  9803              LDR      r0,[sp,#0xc]
0000ac  42a8              CMP      r0,r5
0000ae  da01              BGE      |L12.180|
0000b0  9803              LDR      r0,[sp,#0xc]
0000b2  e000              B        |L12.182|
                  |L12.180|
0000b4  4628              MOV      r0,r5
                  |L12.182|
0000b6  4682              MOV      r10,r0
;;;891    		lbs_deb_scan("scanning %d of %d channels\n",
0000b8  462a              MOV      r2,r5
0000ba  4651              MOV      r1,r10
0000bc  a033              ADR      r0,|L12.396|
0000be  f7fffffe          BL       __2printf
;;;892    			     to_scan, chan_count);
;;;893    		ret = lbs_do_scan(priv, bsstype, curr_chans,
0000c2  4653              MOV      r3,r10
0000c4  463a              MOV      r2,r7
0000c6  4620              MOV      r0,r4
0000c8  9904              LDR      r1,[sp,#0x10]
0000ca  f7fffffe          BL       lbs_do_scan
0000ce  4683              MOV      r11,r0
;;;894    				  to_scan);
;;;895    		if (ret) {
0000d0  f1bb0f00          CMP      r11,#0
0000d4  d003              BEQ      |L12.222|
;;;896    			lbs_pr_err("SCAN_CMD failed\n");
0000d6  a034              ADR      r0,|L12.424|
0000d8  f7fffffe          BL       __2printf
;;;897    			goto out2;
0000dc  e02e              B        |L12.316|
                  |L12.222|
;;;898    		}
;;;899    		curr_chans += to_scan;
0000de  ebca00ca          RSB      r0,r10,r10,LSL #3
0000e2  4407              ADD      r7,r7,r0
;;;900    		chan_count -= to_scan;
0000e4  eba5050a          SUB      r5,r5,r10
;;;901    		 memcpy(gmarvel_scan_param,const_chan_parm,14*7);
0000e8  2262              MOVS     r2,#0x62
0000ea  491f              LDR      r1,|L12.360|
0000ec  a805              ADD      r0,sp,#0x14
0000ee  f7fffffe          BL       __aeabi_memcpy
;;;902    		/* somehow schedule the next part of the scan */
;;;903    #ifdef MASK_DEBUG
;;;904    		if (chan_count && !full_scan &&
;;;905    		    !priv->surpriseremoved) {
;;;906    			/* -1 marks just that we're currently scanning */
;;;907    			if (priv->scan_channel < 0)
;;;908    				priv->scan_channel = to_scan;
;;;909    			else
;;;910    				priv->scan_channel += to_scan;
;;;911    			cancel_delayed_work(&priv->scan_work);
;;;912    			queue_delayed_work(priv->work_thread, &priv->scan_work,
;;;913    					   msecs_to_jiffies(300));
;;;914    			/* skip over GIWSCAN event */
;;;915    			goto out;
;;;916    		}
;;;917    #endif
;;;918    
;;;919    	}
0000f2  bf00              NOP      
                  |L12.244|
0000f4  2d00              CMP      r5,#0                 ;889
0000f6  d1d8              BNE      |L12.170|
;;;920    	memset(&wrqu, 0, sizeof(union iwreq_data));
0000f8  2000              MOVS     r0,#0
0000fa  9001              STR      r0,[sp,#4]
0000fc  9002              STR      r0,[sp,#8]
;;;921    	//wireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);
;;;922    
;;;923    
;;;924    	/* Dump the scan table */
;;;925    	//mutex_lock(&priv->lock);
;;;926            printf("################scanning table####################### \r\n");
0000fe  a02f              ADR      r0,|L12.444|
000100  f7fffffe          BL       __2printf
;;;927    	list_for_each_entry_bssdes(iter, &priv->network_list, list)
000104  f44f70f4          MOV      r0,#0x1e8
000108  f8d410ec          LDR      r1,[r4,#0xec]
00010c  1a0e              SUBS     r6,r1,r0
00010e  e00e              B        |L12.302|
                  |L12.272|
;;;928    		printf_scan("%02d: BSSID %pM, RSSI %d, SSID '%s'\n",
000110  1db3              ADDS     r3,r6,#6
000112  9300              STR      r3,[sp,#0]
000114  4641              MOV      r1,r8
000116  f1080801          ADD      r8,r8,#1
00011a  4632              MOV      r2,r6
00011c  a036              ADR      r0,|L12.504|
00011e  6af3              LDR      r3,[r6,#0x2c]
000120  f7fffffe          BL       __2printf
000124  f44f70f4          MOV      r0,#0x1e8             ;927
000128  f8d611e8          LDR      r1,[r6,#0x1e8]        ;927
00012c  1a0e              SUBS     r6,r1,r0              ;927
                  |L12.302|
00012e  f50670f4          ADD      r0,r6,#0x1e8          ;927
000132  f10401ec          ADD      r1,r4,#0xec           ;927
000136  4288              CMP      r0,r1                 ;927
000138  d1ea              BNE      |L12.272|
;;;929    			     i++, iter->bssid, iter->rssi,
;;;930    			     iter->ssid);
;;;931    	//mutex_unlock(&priv->lock);
;;;932    
;;;933    
;;;934    out2:
00013a  bf00              NOP      
                  |L12.316|
;;;935    	priv->scan_channel = 0;
00013c  2000              MOVS     r0,#0
00013e  62e0              STR      r0,[r4,#0x2c]
;;;936    
;;;937    //out:
;;;938    	/*if (priv->connect_status == LBS_CONNECTED) {
;;;939    		//netif_carrier_on(priv->dev);
;;;940    		if (!priv->tx_pending_len)
;;;941    			netif_wake_queue(priv->dev);
;;;942    	}
;;;943    	if (priv->mesh_dev && (priv->mesh_connect_status == LBS_CONNECTED)) {
;;;944    		netif_carrier_on(priv->mesh_dev);
;;;945    		if (!priv->tx_pending_len)
;;;946    			netif_wake_queue(priv->mesh_dev);
;;;947    	}
;;;948    	kfree(chan_list);*/
;;;949    
;;;950    	lbs_deb_leave_args(LBS_DEB_SCAN, ret);
;;;951    	return ret;
000140  4658              MOV      r0,r11
;;;952    }
000142  b05d              ADD      sp,sp,#0x174
000144  e8bd8ff0          POP      {r4-r11,pc}
;;;953    /**
                          ENDP

                  |L12.328|
000148  6e756d62          DCB      "number channels %d, bsstype %d\n",0
00014c  65722063
000150  68616e6e
000154  656c7320
000158  25642c20
00015c  62737374
000160  79706520
000164  25640a00
                  |L12.360|
                          DCD      const_chan_parm
                  |L12.364|
00016c  6368616e          DCB      "chan_count %d, scan_channel %d\n",0
000170  5f636f75
000174  6e742025
000178  642c2073
00017c  63616e5f
000180  6368616e
000184  6e656c20
000188  25640a00
                  |L12.396|
00018c  7363616e          DCB      "scanning %d of %d channels\n",0
000190  6e696e67
000194  20256420
000198  6f662025
00019c  64206368
0001a0  616e6e65
0001a4  6c730a00
                  |L12.424|
0001a8  5343414e          DCB      "SCAN_CMD failed\n",0
0001ac  5f434d44
0001b0  20666169
0001b4  6c65640a
0001b8  00      
0001b9  00                DCB      0
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L12.444|
0001bc  23232323          DCB      "################scanning table####################### \r"
0001c0  23232323
0001c4  23232323
0001c8  23232323
0001cc  7363616e
0001d0  6e696e67
0001d4  20746162
0001d8  6c652323
0001dc  23232323
0001e0  23232323
0001e4  23232323
0001e8  23232323
0001ec  23232323
0001f0  23200d  
0001f3  0a00              DCB      "\n",0
0001f5  00                DCB      0
0001f6  00                DCB      0
0001f7  00                DCB      0
                  |L12.504|
0001f8  25303264          DCB      "%02d: BSSID %pM, RSSI %d, SSID '%s'\n",0
0001fc  3a204253
000200  53494420
000204  25704d2c
000208  20525353
00020c  49202564
000210  2c205353
000214  49442027
000218  2573270a
00021c  00      
00021d  00                DCB      0
00021e  00                DCB      0
00021f  00                DCB      0

                          AREA ||i.lbs_send_specific_ssid_scan||, CODE, READONLY, ALIGN=1

                  lbs_send_specific_ssid_scan PROC
;;;998     */
;;;999    int lbs_send_specific_ssid_scan(struct lbs_private *priv, uint8_t *ssid,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1000   				uint8_t ssid_len)
;;;1001   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1002   //	DECLARE_SSID_BUF(ssid_buf);
;;;1003   	int ret = 0;
00000a  2700              MOVS     r7,#0
;;;1004   
;;;1005   	lbs_deb_enter_args(LBS_DEB_SCAN,ssid);
;;;1006   
;;;1007   	if (!ssid_len)
00000c  b905              CBNZ     r5,|L13.16|
;;;1008   		goto out;
00000e  e012              B        |L13.54|
                  |L13.16|
;;;1009   
;;;1010   	memcpy(priv->scan_ssid, ssid, ssid_len);
000010  462a              MOV      r2,r5
000012  4631              MOV      r1,r6
000014  f1040030          ADD      r0,r4,#0x30
000018  f7fffffe          BL       __aeabi_memcpy
;;;1011   	priv->scan_ssid_len = ssid_len;
00001c  f8845051          STRB     r5,[r4,#0x51]
;;;1012   
;;;1013   	lbs_scan_networks(priv, 1);
000020  2101              MOVS     r1,#1
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       lbs_scan_networks
;;;1014   	if (priv->surpriseremoved) {
000028  f89401ec          LDRB     r0,[r4,#0x1ec]
00002c  b110              CBZ      r0,|L13.52|
;;;1015   		ret = -1;
00002e  f04f37ff          MOV      r7,#0xffffffff
;;;1016   		goto out;
000032  e000              B        |L13.54|
                  |L13.52|
;;;1017   	}
;;;1018   
;;;1019   out:
000034  bf00              NOP      
                  |L13.54|
;;;1020   	lbs_deb_leave_args(LBS_DEB_SCAN, ret);
;;;1021   	return ret;
000036  4638              MOV      r0,r7
;;;1022   }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;1023   
                          ENDP


                          AREA ||i.lbs_ssid_cmp||, CODE, READONLY, ALIGN=1

                  lbs_ssid_cmp PROC
;;;960     */
;;;961    int lbs_ssid_cmp(uint8_t *ssid1, uint8_t ssid1_len, uint8_t *ssid2,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;962    		 uint8_t ssid2_len)
;;;963    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;964    	if (ssid1_len != ssid2_len)
00000c  42b4              CMP      r4,r6
00000e  d003              BEQ      |L14.24|
;;;965    		return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L14.20|
;;;966    
;;;967    	return memcmp(ssid1, ssid2, ssid1_len);
;;;968    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L14.24|
000018  4622              MOV      r2,r4                 ;967
00001a  4629              MOV      r1,r5                 ;967
00001c  4638              MOV      r0,r7                 ;967
00001e  f7fffffe          BL       memcmp
000022  e7f7              B        |L14.20|
;;;969    
                          ENDP


                          AREA ||i.lbs_unset_basic_rate_flags||, CODE, READONLY, ALIGN=1

                  lbs_unset_basic_rate_flags PROC
;;;289     */
;;;290    static void lbs_unset_basic_rate_flags(u8 *rates, size_t len)
000000  4602              MOV      r2,r0
;;;291    {
;;;292    	int i;
;;;293    
;;;294    	for (i = 0; i < len; i++)
000002  2000              MOVS     r0,#0
000004  e004              B        |L15.16|
                  |L15.6|
;;;295    		rates[i] &= 0x7f;
000006  5c13              LDRB     r3,[r2,r0]
000008  f003037f          AND      r3,r3,#0x7f
00000c  5413              STRB     r3,[r2,r0]
00000e  1c40              ADDS     r0,r0,#1              ;294
                  |L15.16|
000010  4288              CMP      r0,r1                 ;294
000012  d3f8              BCC      |L15.6|
;;;296    }
000014  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.list_add_tail||, CODE, READONLY, ALIGN=1

                  list_add_tail PROC
;;;83      */
;;;84     static __inline void list_add_tail(struct list_head *new, struct list_head *head)
000000  684a              LDR      r2,[r1,#4]
000002  6048              STR      r0,[r1,#4]
000004  6001              STR      r1,[r0,#0]
000006  6042              STR      r2,[r0,#4]
000008  6010              STR      r0,[r2,#0]
00000a  bf00              NOP      
;;;85     {
;;;86     	__list_add(new, head->prev, head);
;;;87     }
00000c  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.list_move_tail||, CODE, READONLY, ALIGN=1

                  list_move_tail PROC
;;;167     */
;;;168    static __inline void list_move_tail(struct list_head *list,
000000  b570              PUSH     {r4-r6,lr}
;;;169    				  struct list_head *head)
;;;170    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;171    	__list_del(list->prev, list->next);
000006  e9d41000          LDRD     r1,r0,[r4,#0]
00000a  6048              STR      r0,[r1,#4]
00000c  6001              STR      r1,[r0,#0]
00000e  bf00              NOP      
;;;172    	list_add_tail(list, head);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       list_add_tail
;;;173    }
000018  bd70              POP      {r4-r6,pc}
;;;174    
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L19.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L19.32|
                  |L19.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L19.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L19.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L19.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L19.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L19.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L19.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  const_chan_parm
000000  00010000          DCB      0x00,0x01,0x00,0x00
000004  00640000          DCB      0x00,0x64,0x00,0x00
000008  02000000          DCB      0x02,0x00,0x00,0x00
00000c  64000003          DCB      0x64,0x00,0x00,0x03
000010  00000064          DCB      0x00,0x00,0x00,0x64
000014  00000400          DCB      0x00,0x00,0x04,0x00
000018  00006400          DCB      0x00,0x00,0x64,0x00
00001c  00050000          DCB      0x00,0x05,0x00,0x00
000020  00640000          DCB      0x00,0x64,0x00,0x00
000024  06000000          DCB      0x06,0x00,0x00,0x00
000028  64000007          DCB      0x64,0x00,0x00,0x07
00002c  00000064          DCB      0x00,0x00,0x00,0x64
000030  00000800          DCB      0x00,0x00,0x08,0x00
000034  00006400          DCB      0x00,0x00,0x64,0x00
000038  00090000          DCB      0x00,0x09,0x00,0x00
00003c  00640000          DCB      0x00,0x64,0x00,0x00
000040  0a000000          DCB      0x0a,0x00,0x00,0x00
000044  6400000b          DCB      0x64,0x00,0x00,0x0b
000048  00000064          DCB      0x00,0x00,0x00,0x64
00004c  00000c00          DCB      0x00,0x00,0x0c,0x00
000050  00006400          DCB      0x00,0x00,0x64,0x00
000054  000d0000          DCB      0x00,0x0d,0x00,0x00
000058  00640000          DCB      0x00,0x64,0x00,0x00
00005c  0e000000          DCB      0x0e,0x00,0x00,0x00
000060  6400              DCB      0x64,0x00
                  __func__
000062  6c62              DCB      0x6c,0x62
000064  735f7072          DCB      0x73,0x5f,0x70,0x72
000068  6f636573          DCB      0x6f,0x63,0x65,0x73
00006c  735f6273          DCB      0x73,0x5f,0x62,0x73
000070  7300              DCB      0x73,0x00
