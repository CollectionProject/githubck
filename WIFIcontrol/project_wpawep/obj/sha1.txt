; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\sha1.o --depend=.\obj\sha1.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\sha1.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto\sha1.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.hmac_sha1||, CODE, READONLY, ALIGN=1

                  hmac_sha1 PROC
;;;105     */
;;;106    int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
000000  b57f              PUSH     {r0-r6,lr}
;;;107    	       u8 *mac)
;;;108    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  9e0a              LDR      r6,[sp,#0x28]
;;;109    	return hmac_sha1_vector(key, key_len, 1, &data, &data_len, mac);
00000a  aa05              ADD      r2,sp,#0x14
00000c  ab04              ADD      r3,sp,#0x10
00000e  e9cd2600          STRD     r2,r6,[sp,#0]
000012  2201              MOVS     r2,#1
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       hmac_sha1_vector
;;;110    }
00001c  b006              ADD      sp,sp,#0x18
00001e  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP


                          AREA ||i.hmac_sha1_vector||, CODE, READONLY, ALIGN=1

                  hmac_sha1_vector PROC
;;;31      */
;;;32     int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;33     		     const u8 *addr[], const size_t *len, u8 *mac)
;;;34     {
000004  b0a2              SUB      sp,sp,#0x88
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
00000a  e9dd872c          LDRD     r8,r7,[sp,#0xb0]
;;;35     	unsigned char k_pad[64]; /* padding - key XORd with ipad/opad */
;;;36     	unsigned char tk[20];
;;;37     	const u8 *_addr[6];
;;;38     	size_t _len[6], i;
;;;39     
;;;40     	if (num_elem > 5) {
00000e  2d05              CMP      r5,#5
000010  d904              BLS      |L3.28|
;;;41     		/*
;;;42     		 * Fixed limit on the number of fragments to avoid having to
;;;43     		 * allocate memory (which could fail).
;;;44     		 */
;;;45     		return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L3.22|
;;;46     	}
;;;47     
;;;48             /* if key is longer than 64 bytes reset it to key = SHA1(key) */
;;;49             if (key_len > 64) {
;;;50     		if (sha1_vector(1, &key, &key_len, tk))
;;;51     			return -1;
;;;52     		key = tk;
;;;53     		key_len = 20;
;;;54             }
;;;55     
;;;56     	/* the HMAC_SHA1 transform looks like:
;;;57     	 *
;;;58     	 * SHA1(K XOR opad, SHA1(K XOR ipad, text))
;;;59     	 *
;;;60     	 * where K is an n byte key
;;;61     	 * ipad is the byte 0x36 repeated 64 times
;;;62     	 * opad is the byte 0x5c repeated 64 times
;;;63     	 * and text is the data being protected */
;;;64     
;;;65     	/* start out by storing key in ipad */
;;;66     	os_memset(k_pad, 0, sizeof(k_pad));
;;;67     	os_memcpy(k_pad, key, key_len);
;;;68     	/* XOR key with ipad values */
;;;69     	for (i = 0; i < 64; i++)
;;;70     		k_pad[i] ^= 0x36;
;;;71     
;;;72     	/* perform inner SHA1 */
;;;73     	_addr[0] = k_pad;
;;;74     	_len[0] = 64;
;;;75     	for (i = 0; i < num_elem; i++) {
;;;76     		_addr[i + 1] = addr[i];
;;;77     		_len[i + 1] = len[i];
;;;78     	}
;;;79     	if (sha1_vector(1 + num_elem, _addr, _len, mac))
;;;80     		return -1;
;;;81     
;;;82     	os_memset(k_pad, 0, sizeof(k_pad));
;;;83     	os_memcpy(k_pad, key, key_len);
;;;84     	/* XOR key with opad values */
;;;85     	for (i = 0; i < 64; i++)
;;;86     		k_pad[i] ^= 0x5c;
;;;87     
;;;88     	/* perform outer SHA1 */
;;;89     	_addr[0] = k_pad;
;;;90     	_len[0] = 64;
;;;91     	_addr[1] = mac;
;;;92     	_len[1] = SHA1_MAC_LEN;
;;;93     	return sha1_vector(2, _addr, _len, mac);
;;;94     }
000016  b026              ADD      sp,sp,#0x98
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L3.28|
00001c  9823              LDR      r0,[sp,#0x8c]         ;49
00001e  2840              CMP      r0,#0x40              ;49
000020  d90d              BLS      |L3.62|
000022  ab0d              ADD      r3,sp,#0x34           ;50
000024  aa23              ADD      r2,sp,#0x8c           ;50
000026  a922              ADD      r1,sp,#0x88           ;50
000028  2001              MOVS     r0,#1                 ;50
00002a  f7fffffe          BL       sha1_vector
00002e  b110              CBZ      r0,|L3.54|
000030  f04f30ff          MOV      r0,#0xffffffff        ;51
000034  e7ef              B        |L3.22|
                  |L3.54|
000036  a80d              ADD      r0,sp,#0x34           ;52
000038  9022              STR      r0,[sp,#0x88]         ;52
00003a  2014              MOVS     r0,#0x14              ;53
00003c  9023              STR      r0,[sp,#0x8c]         ;53
                  |L3.62|
00003e  2240              MOVS     r2,#0x40              ;66
000040  2100              MOVS     r1,#0                 ;66
000042  a812              ADD      r0,sp,#0x48           ;66
000044  f7fffffe          BL       os_memset
000048  a812              ADD      r0,sp,#0x48           ;67
00004a  e9dd1222          LDRD     r1,r2,[sp,#0x88]      ;67
00004e  f7fffffe          BL       os_memcpy
000052  2400              MOVS     r4,#0                 ;69
000054  e006              B        |L3.100|
                  |L3.86|
000056  a812              ADD      r0,sp,#0x48           ;70
000058  5d00              LDRB     r0,[r0,r4]            ;70
00005a  f0800036          EOR      r0,r0,#0x36           ;70
00005e  a912              ADD      r1,sp,#0x48           ;70
000060  5508              STRB     r0,[r1,r4]            ;70
000062  1c64              ADDS     r4,r4,#1              ;69
                  |L3.100|
000064  2c40              CMP      r4,#0x40              ;69
000066  d3f6              BCC      |L3.86|
000068  a812              ADD      r0,sp,#0x48           ;73
00006a  9007              STR      r0,[sp,#0x1c]         ;73
00006c  2040              MOVS     r0,#0x40              ;74
00006e  9001              STR      r0,[sp,#4]            ;74
000070  2400              MOVS     r4,#0                 ;75
000072  e00b              B        |L3.140|
                  |L3.116|
000074  f8561024          LDR      r1,[r6,r4,LSL #2]     ;76
000078  aa07              ADD      r2,sp,#0x1c           ;76
00007a  1c60              ADDS     r0,r4,#1              ;76
00007c  f8421020          STR      r1,[r2,r0,LSL #2]     ;76
000080  f8581024          LDR      r1,[r8,r4,LSL #2]     ;77
000084  aa01              ADD      r2,sp,#4              ;77
000086  f8421020          STR      r1,[r2,r0,LSL #2]     ;77
00008a  1c64              ADDS     r4,r4,#1              ;75
                  |L3.140|
00008c  42ac              CMP      r4,r5                 ;75
00008e  d3f1              BCC      |L3.116|
000090  1c68              ADDS     r0,r5,#1              ;79
000092  463b              MOV      r3,r7                 ;79
000094  aa01              ADD      r2,sp,#4              ;79
000096  a907              ADD      r1,sp,#0x1c           ;79
000098  f7fffffe          BL       sha1_vector
00009c  b110              CBZ      r0,|L3.164|
00009e  f04f30ff          MOV      r0,#0xffffffff        ;80
0000a2  e7b8              B        |L3.22|
                  |L3.164|
0000a4  2240              MOVS     r2,#0x40              ;82
0000a6  2100              MOVS     r1,#0                 ;82
0000a8  a812              ADD      r0,sp,#0x48           ;82
0000aa  f7fffffe          BL       os_memset
0000ae  a812              ADD      r0,sp,#0x48           ;83
0000b0  e9dd1222          LDRD     r1,r2,[sp,#0x88]      ;83
0000b4  f7fffffe          BL       os_memcpy
0000b8  2400              MOVS     r4,#0                 ;85
0000ba  e006              B        |L3.202|
                  |L3.188|
0000bc  a812              ADD      r0,sp,#0x48           ;86
0000be  5d00              LDRB     r0,[r0,r4]            ;86
0000c0  f080005c          EOR      r0,r0,#0x5c           ;86
0000c4  a912              ADD      r1,sp,#0x48           ;86
0000c6  5508              STRB     r0,[r1,r4]            ;86
0000c8  1c64              ADDS     r4,r4,#1              ;85
                  |L3.202|
0000ca  2c40              CMP      r4,#0x40              ;85
0000cc  d3f6              BCC      |L3.188|
0000ce  a812              ADD      r0,sp,#0x48           ;89
0000d0  9007              STR      r0,[sp,#0x1c]         ;89
0000d2  2040              MOVS     r0,#0x40              ;90
0000d4  9001              STR      r0,[sp,#4]            ;90
0000d6  9708              STR      r7,[sp,#0x20]         ;91
0000d8  2014              MOVS     r0,#0x14              ;92
0000da  9002              STR      r0,[sp,#8]            ;92
0000dc  463b              MOV      r3,r7                 ;93
0000de  aa01              ADD      r2,sp,#4              ;93
0000e0  a907              ADD      r1,sp,#0x1c           ;93
0000e2  2002              MOVS     r0,#2                 ;93
0000e4  f7fffffe          BL       sha1_vector
0000e8  e795              B        |L3.22|
;;;95     
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L4.30|
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;495    }
00001c  4770              BX       lr
                  |L4.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L4.28|
;;;496    
                          ENDP


                          AREA ||i.sha1_prf||, CODE, READONLY, ALIGN=1

                  sha1_prf PROC
;;;126     */
;;;127    int sha1_prf(const u8 *key, size_t key_len, const char *label,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;128    	     const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
;;;129    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4682              MOV      r10,r0
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
00000c  e9dd891d          LDRD     r8,r9,[sp,#0x74]
;;;130    	u8 counter = 0;
000010  2000              MOVS     r0,#0
000012  900e              STR      r0,[sp,#0x38]
;;;131    	size_t pos, plen;
;;;132    	u8 hash[SHA1_MAC_LEN];
;;;133    	size_t label_len = os_strlen(label) + 1;
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       os_strlen
00001a  f1000b01          ADD      r11,r0,#1
;;;134    	const unsigned char *addr[3];
;;;135    	size_t len[3];
;;;136    
;;;137    	addr[0] = (u8 *) label;
00001e  9506              STR      r5,[sp,#0x18]
;;;138    	len[0] = label_len;
000020  f8cdb00c          STR      r11,[sp,#0xc]
;;;139    	addr[1] = data;
000024  9707              STR      r7,[sp,#0x1c]
;;;140    	len[1] = data_len;
000026  981c              LDR      r0,[sp,#0x70]
000028  9004              STR      r0,[sp,#0x10]
;;;141    	addr[2] = &counter;
00002a  a80e              ADD      r0,sp,#0x38
00002c  9008              STR      r0,[sp,#0x20]
;;;142    	len[2] = 1;
00002e  2001              MOVS     r0,#1
000030  9005              STR      r0,[sp,#0x14]
;;;143    
;;;144    	pos = 0;
000032  2400              MOVS     r4,#0
;;;145    	while (pos < buf_len) {
000034  e030              B        |L5.152|
                  |L5.54|
;;;146    		plen = buf_len - pos;
000036  eba90604          SUB      r6,r9,r4
;;;147    		if (plen >= SHA1_MAC_LEN) {
00003a  2e14              CMP      r6,#0x14
00003c  d312              BCC      |L5.100|
;;;148    			if (hmac_sha1_vector(key, key_len, 3, addr, len,
00003e  eb080304          ADD      r3,r8,r4
000042  aa03              ADD      r2,sp,#0xc
000044  e9cd2300          STRD     r2,r3,[sp,#0]
000048  ab06              ADD      r3,sp,#0x18
00004a  2203              MOVS     r2,#3
00004c  4650              MOV      r0,r10
00004e  9910              LDR      r1,[sp,#0x40]
000050  f7fffffe          BL       hmac_sha1_vector
000054  b120              CBZ      r0,|L5.96|
;;;149    					     &buf[pos]))
;;;150    				return -1;
000056  f04f30ff          MOV      r0,#0xffffffff
                  |L5.90|
;;;151    			pos += SHA1_MAC_LEN;
;;;152    		} else {
;;;153    			if (hmac_sha1_vector(key, key_len, 3, addr, len,
;;;154    					     hash))
;;;155    				return -1;
;;;156    			os_memcpy(&buf[pos], hash, plen);
;;;157    			break;
;;;158    		}
;;;159    		counter++;
;;;160    	}
;;;161    
;;;162    	return 0;
;;;163    }
00005a  b013              ADD      sp,sp,#0x4c
00005c  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.96|
000060  3414              ADDS     r4,r4,#0x14           ;151
000062  e014              B        |L5.142|
                  |L5.100|
000064  ab09              ADD      r3,sp,#0x24           ;153
000066  aa03              ADD      r2,sp,#0xc            ;153
000068  e9cd2300          STRD     r2,r3,[sp,#0]         ;153
00006c  ab06              ADD      r3,sp,#0x18           ;153
00006e  2203              MOVS     r2,#3                 ;153
000070  4650              MOV      r0,r10                ;153
000072  9910              LDR      r1,[sp,#0x40]         ;153
000074  f7fffffe          BL       hmac_sha1_vector
000078  b110              CBZ      r0,|L5.128|
00007a  f04f30ff          MOV      r0,#0xffffffff        ;155
00007e  e7ec              B        |L5.90|
                  |L5.128|
000080  eb080004          ADD      r0,r8,r4              ;156
000084  4632              MOV      r2,r6                 ;156
000086  a909              ADD      r1,sp,#0x24           ;156
000088  f7fffffe          BL       os_memcpy
00008c  e006              B        |L5.156|
                  |L5.142|
00008e  f89d0038          LDRB     r0,[sp,#0x38]         ;159
000092  1c40              ADDS     r0,r0,#1              ;159
000094  b2c0              UXTB     r0,r0                 ;159
000096  900e              STR      r0,[sp,#0x38]         ;159
                  |L5.152|
000098  454c              CMP      r4,r9                 ;145
00009a  d3cc              BCC      |L5.54|
                  |L5.156|
00009c  bf00              NOP                            ;157
00009e  2000              MOVS     r0,#0                 ;162
0000a0  e7db              B        |L5.90|
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L10.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L10.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L10.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L10.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L13.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L13.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L13.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L13.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L19.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L19.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP

