; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eap_ikev2_common.o --depend=.\obj\eap_ikev2_common.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eap_ikev2_common.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_common\eap_ikev2_common.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_ikev2_build_frag_ack||, CODE, READONLY, ALIGN=2

                  eap_ikev2_build_frag_ack PROC
;;;56     
;;;57     struct wpabuf * eap_ikev2_build_frag_ack(u8 id, u8 code)
000000  b5f8              PUSH     {r3-r7,lr}
;;;58     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;59     	struct wpabuf *msg;
;;;60     
;;;61     #ifdef CCNS_PL
;;;62     	msg = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IKEV2, 1, code, id);
;;;63     	if (msg == NULL) {
;;;64     		wpa_printf(MSG_ERROR, "EAP-IKEV2: Failed to allocate memory "
;;;65     			   "for fragment ack");
;;;66     		return NULL;
;;;67     	}
;;;68     	wpabuf_put_u8(msg, 0); /* Flags */
;;;69     #else /* CCNS_PL */
;;;70     	msg = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IKEV2, 0, code, id);
000006  462b              MOV      r3,r5
000008  2200              MOVS     r2,#0
00000a  2131              MOVS     r1,#0x31
00000c  4610              MOV      r0,r2
00000e  9400              STR      r4,[sp,#0]
000010  f7fffffe          BL       eap_msg_alloc
000014  4606              MOV      r6,r0
;;;71     	if (msg == NULL) {
000016  b92e              CBNZ     r6,|L2.36|
;;;72     		wpa_printf(MSG_ERROR, "EAP-IKEV2: Failed to allocate memory "
000018  a105              ADR      r1,|L2.48|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       wpa_printf
;;;73     			   "for fragment ack");
;;;74     		return NULL;
000020  2000              MOVS     r0,#0
                  |L2.34|
;;;75     	}
;;;76     #endif /* CCNS_PL */
;;;77     
;;;78     	wpa_printf(MSG_DEBUG, "EAP-IKEV2: Send fragment ack");
;;;79     
;;;80     	return msg;
;;;81     }
000022  bdf8              POP      {r3-r7,pc}
                  |L2.36|
000024  a110              ADR      r1,|L2.104|
000026  2000              MOVS     r0,#0                 ;78
000028  f7fffffe          BL       wpa_printf
00002c  4630              MOV      r0,r6                 ;80
00002e  e7f8              B        |L2.34|
;;;82     
                          ENDP

                  |L2.48|
000030  4541502d          DCB      "EAP-IKEV2: Failed to allocate memory for fragment ack",0
000034  494b4556
000038  323a2046
00003c  61696c65
000040  6420746f
000044  20616c6c
000048  6f636174
00004c  65206d65
000050  6d6f7279
000054  20666f72
000058  20667261
00005c  676d656e
000060  74206163
000064  6b00    
000066  00                DCB      0
000067  00                DCB      0
                  |L2.104|
000068  4541502d          DCB      "EAP-IKEV2: Send fragment ack",0
00006c  494b4556
000070  323a2053
000074  656e6420
000078  66726167
00007c  6d656e74
000080  2061636b
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.eap_ikev2_derive_keymat||, CODE, READONLY, ALIGN=2

                  eap_ikev2_derive_keymat PROC
;;;23     
;;;24     int eap_ikev2_derive_keymat(int prf, struct ikev2_keys *keys,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;25     			    const u8 *i_nonce, size_t i_nonce_len,
;;;26     			    const u8 *r_nonce, size_t r_nonce_len,
;;;27     			    u8 *keymat)
;;;28     {
000004  b083              SUB      sp,sp,#0xc
000006  4683              MOV      r11,r0
000008  460d              MOV      r5,r1
00000a  4617              MOV      r7,r2
00000c  461e              MOV      r6,r3
00000e  e9dd9a10          LDRD     r9,r10,[sp,#0x40]
;;;29     	u8 *nonces;
;;;30     	size_t nlen;
;;;31     
;;;32     	/* KEYMAT = prf+(SK_d, Ni | Nr) */
;;;33     	if (keys->SK_d == NULL || i_nonce == NULL || r_nonce == NULL)
000012  6828              LDR      r0,[r5,#0]
000014  b118              CBZ      r0,|L3.30|
000016  b117              CBZ      r7,|L3.30|
000018  f1b90f00          CMP      r9,#0
00001c  d104              BNE      |L3.40|
                  |L3.30|
;;;34     		return -1;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L3.34|
;;;35     
;;;36     	nlen = i_nonce_len + r_nonce_len;
;;;37     	nonces = os_malloc(nlen);
;;;38     	if (nonces == NULL)
;;;39     		return -1;
;;;40     	os_memcpy(nonces, i_nonce, i_nonce_len);
;;;41     	os_memcpy(nonces + i_nonce_len, r_nonce, r_nonce_len);
;;;42     
;;;43     	if (ikev2_prf_plus(prf, keys->SK_d, keys->SK_d_len, nonces, nlen,
;;;44     			   keymat, EAP_MSK_LEN + EAP_EMSK_LEN)) {
;;;45     		os_free(nonces);
;;;46     		return -1;
;;;47     	}
;;;48     	os_free(nonces);
;;;49     
;;;50     	wpa_hexdump_key(MSG_DEBUG, "EAP-IKEV2: KEYMAT",
;;;51     			keymat, EAP_MSK_LEN + EAP_EMSK_LEN);
;;;52     
;;;53     	return 0;
;;;54     }
000022  b007              ADD      sp,sp,#0x1c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.40|
000028  eb06080a          ADD      r8,r6,r10             ;36
00002c  4640              MOV      r0,r8                 ;37
00002e  f7fffffe          BL       os_malloc
000032  4604              MOV      r4,r0                 ;37
000034  b914              CBNZ     r4,|L3.60|
000036  f04f30ff          MOV      r0,#0xffffffff        ;39
00003a  e7f2              B        |L3.34|
                  |L3.60|
00003c  4632              MOV      r2,r6                 ;40
00003e  4639              MOV      r1,r7                 ;40
000040  4620              MOV      r0,r4                 ;40
000042  f7fffffe          BL       os_memcpy
000046  19a0              ADDS     r0,r4,r6              ;41
000048  4652              MOV      r2,r10                ;41
00004a  4649              MOV      r1,r9                 ;41
00004c  f7fffffe          BL       os_memcpy
000050  2380              MOVS     r3,#0x80              ;43
000052  9a12              LDR      r2,[sp,#0x48]         ;43
000054  e9cd8200          STRD     r8,r2,[sp,#0]         ;43
000058  9302              STR      r3,[sp,#8]            ;43
00005a  4623              MOV      r3,r4                 ;43
00005c  4658              MOV      r0,r11                ;43
00005e  69ea              LDR      r2,[r5,#0x1c]         ;43
000060  6829              LDR      r1,[r5,#0]            ;43
000062  f7fffffe          BL       ikev2_prf_plus
000066  b128              CBZ      r0,|L3.116|
000068  4620              MOV      r0,r4                 ;45
00006a  f7fffffe          BL       os_free
00006e  f04f30ff          MOV      r0,#0xffffffff        ;46
000072  e7d6              B        |L3.34|
                  |L3.116|
000074  4620              MOV      r0,r4                 ;48
000076  f7fffffe          BL       os_free
00007a  2380              MOVS     r3,#0x80              ;50
00007c  a103              ADR      r1,|L3.140|
00007e  2000              MOVS     r0,#0                 ;50
000080  9a12              LDR      r2,[sp,#0x48]         ;50
000082  f7fffffe          BL       wpa_hexdump_key
000086  2000              MOVS     r0,#0                 ;53
000088  e7cb              B        |L3.34|
;;;55     
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
00008c  4541502d          DCB      "EAP-IKEV2: KEYMAT",0
000090  494b4556
000094  323a204b
000098  45594d41
00009c  5400    
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.eap_ikev2_validate_icv||, CODE, READONLY, ALIGN=2

                  eap_ikev2_validate_icv PROC
;;;83     
;;;84     int eap_ikev2_validate_icv(int integ_alg, struct ikev2_keys *keys,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;85     			   int initiator, const struct wpabuf *msg,
;;;86     			   const u8 *pos, const u8 *end)
;;;87     {
000004  b089              SUB      sp,sp,#0x24
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  9f17              LDR      r7,[sp,#0x5c]
;;;88     	const struct ikev2_integ_alg *integ;
;;;89     	size_t icv_len;
;;;90     	u8 icv[IKEV2_MAX_HASH_LEN];
;;;91     	const u8 *SK_a = initiator ? keys->SK_ai : keys->SK_ar;
00000e  f1b80f00          CMP      r8,#0
000012  d001              BEQ      |L4.24|
000014  6868              LDR      r0,[r5,#4]
000016  e000              B        |L4.26|
                  |L4.24|
000018  68a8              LDR      r0,[r5,#8]
                  |L4.26|
00001a  4682              MOV      r10,r0
;;;92     
;;;93     	integ = ikev2_get_integ(integ_alg);
00001c  9809              LDR      r0,[sp,#0x24]
00001e  f7fffffe          BL       ikev2_get_integ
000022  4606              MOV      r6,r0
;;;94     	if (integ == NULL) {
000024  b946              CBNZ     r6,|L4.56|
;;;95     		wpa_printf(MSG_DEBUG, "EAP-IKEV2: Unknown INTEG "
000026  a12d              ADR      r1,|L4.220|
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       wpa_printf
;;;96     			   "transform / cannot validate ICV");
;;;97     		return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L4.50|
;;;98     	}
;;;99     	icv_len = integ->hash_len;
;;;100    
;;;101    	if (end - pos < (int) icv_len) {
;;;102    		wpa_printf(MSG_DEBUG, "EAP-IKEV2: Not enough room in the "
;;;103    			   "message for Integrity Checksum Data");
;;;104    		return -1;
;;;105    	}
;;;106    
;;;107    	if (SK_a == NULL) {
;;;108    		wpa_printf(MSG_DEBUG, "EAP-IKEV2: No SK_a for ICV validation");
;;;109    		return -1;
;;;110    	}
;;;111    
;;;112    	if (ikev2_integ_hash(integ_alg, SK_a, keys->SK_integ_len,
;;;113    			     wpabuf_head(msg),
;;;114    			     wpabuf_len(msg) - icv_len, icv) < 0) {
;;;115    		wpa_printf(MSG_INFO, "EAP-IKEV2: Could not calculate ICV");
;;;116    		return -1;
;;;117    	}
;;;118    
;;;119    	if (os_memcmp(icv, end - icv_len, icv_len) != 0) {
;;;120    		wpa_printf(MSG_INFO, "EAP-IKEV2: Invalid ICV");
;;;121    		wpa_hexdump(MSG_DEBUG, "EAP-IKEV2: Calculated ICV",
;;;122    			    icv, icv_len);
;;;123    		wpa_hexdump(MSG_DEBUG, "EAP-IKEV2: Received ICV",
;;;124    			    end - icv_len, icv_len);
;;;125    		return -1;
;;;126    	}
;;;127    
;;;128    	wpa_printf(MSG_DEBUG, "EAP-IKEV2: Valid Integrity Checksum Data in "
;;;129    		   "the received message");
;;;130    
;;;131    	return icv_len;
;;;132    }
000032  b00d              ADD      sp,sp,#0x34
000034  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.56|
000038  68b4              LDR      r4,[r6,#8]            ;99
00003a  9816              LDR      r0,[sp,#0x58]         ;101
00003c  1a38              SUBS     r0,r7,r0              ;101
00003e  42a0              CMP      r0,r4                 ;101
000040  da06              BGE      |L4.80|
000042  4935              LDR      r1,|L4.280|
000044  2000              MOVS     r0,#0                 ;102
000046  f7fffffe          BL       wpa_printf
00004a  f04f30ff          MOV      r0,#0xffffffff        ;104
00004e  e7f0              B        |L4.50|
                  |L4.80|
000050  f1ba0f00          CMP      r10,#0                ;107
000054  d106              BNE      |L4.100|
000056  a131              ADR      r1,|L4.284|
000058  2000              MOVS     r0,#0                 ;108
00005a  f7fffffe          BL       wpa_printf
00005e  f04f30ff          MOV      r0,#0xffffffff        ;109
000062  e7e6              B        |L4.50|
                  |L4.100|
000064  4648              MOV      r0,r9                 ;112
000066  f7fffffe          BL       wpabuf_len
00006a  eba00b04          SUB      r11,r0,r4             ;112
00006e  4648              MOV      r0,r9                 ;112
000070  f7fffffe          BL       wpabuf_head
000074  ab04              ADD      r3,sp,#0x10           ;112
000076  e9cdb300          STRD     r11,r3,[sp,#0]        ;112
00007a  9003              STR      r0,[sp,#0xc]          ;112
00007c  4603              MOV      r3,r0                 ;112
00007e  4651              MOV      r1,r10                ;112
000080  6a2a              LDR      r2,[r5,#0x20]         ;112
000082  9809              LDR      r0,[sp,#0x24]         ;112
000084  f7fffffe          BL       ikev2_integ_hash
000088  2800              CMP      r0,#0                 ;112
00008a  da06              BGE      |L4.154|
00008c  a12d              ADR      r1,|L4.324|
00008e  2000              MOVS     r0,#0                 ;115
000090  f7fffffe          BL       wpa_printf
000094  f04f30ff          MOV      r0,#0xffffffff        ;116
000098  e7cb              B        |L4.50|
                  |L4.154|
00009a  1b39              SUBS     r1,r7,r4              ;119
00009c  4622              MOV      r2,r4                 ;119
00009e  a804              ADD      r0,sp,#0x10           ;119
0000a0  f7fffffe          BL       os_memcmp
0000a4  b190              CBZ      r0,|L4.204|
0000a6  a130              ADR      r1,|L4.360|
0000a8  2000              MOVS     r0,#0                 ;120
0000aa  f7fffffe          BL       wpa_printf
0000ae  4623              MOV      r3,r4                 ;121
0000b0  aa04              ADD      r2,sp,#0x10           ;121
0000b2  a133              ADR      r1,|L4.384|
0000b4  2000              MOVS     r0,#0                 ;121
0000b6  f7fffffe          BL       wpa_hexdump
0000ba  1b3a              SUBS     r2,r7,r4              ;123
0000bc  4623              MOV      r3,r4                 ;123
0000be  a137              ADR      r1,|L4.412|
0000c0  2000              MOVS     r0,#0                 ;123
0000c2  f7fffffe          BL       wpa_hexdump
0000c6  f04f30ff          MOV      r0,#0xffffffff        ;125
0000ca  e7b2              B        |L4.50|
                  |L4.204|
0000cc  4912              LDR      r1,|L4.280|
0000ce  3148              ADDS     r1,r1,#0x48           ;128
0000d0  2000              MOVS     r0,#0                 ;128
0000d2  f7fffffe          BL       wpa_printf
0000d6  4620              MOV      r0,r4                 ;131
0000d8  e7ab              B        |L4.50|
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
0000dc  4541502d          DCB      "EAP-IKEV2: Unknown INTEG transform / cannot validate IC"
0000e0  494b4556
0000e4  323a2055
0000e8  6e6b6e6f
0000ec  776e2049
0000f0  4e544547
0000f4  20747261
0000f8  6e73666f
0000fc  726d202f
000100  2063616e
000104  6e6f7420
000108  76616c69
00010c  64617465
000110  204943  
000113  5600              DCB      "V",0
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L4.280|
                          DCD      ||.constdata||
                  |L4.284|
00011c  4541502d          DCB      "EAP-IKEV2: No SK_a for ICV validation",0
000120  494b4556
000124  323a204e
000128  6f20534b
00012c  5f612066
000130  6f722049
000134  43562076
000138  616c6964
00013c  6174696f
000140  6e00    
000142  00                DCB      0
000143  00                DCB      0
                  |L4.324|
000144  4541502d          DCB      "EAP-IKEV2: Could not calculate ICV",0
000148  494b4556
00014c  323a2043
000150  6f756c64
000154  206e6f74
000158  2063616c
00015c  63756c61
000160  74652049
000164  435600  
000167  00                DCB      0
                  |L4.360|
000168  4541502d          DCB      "EAP-IKEV2: Invalid ICV",0
00016c  494b4556
000170  323a2049
000174  6e76616c
000178  69642049
00017c  435600  
00017f  00                DCB      0
                  |L4.384|
000180  4541502d          DCB      "EAP-IKEV2: Calculated ICV",0
000184  494b4556
000188  323a2043
00018c  616c6375
000190  6c617465
000194  64204943
000198  5600    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L4.412|
00019c  4541502d          DCB      "EAP-IKEV2: Received ICV",0
0001a0  494b4556
0001a4  323a2052
0001a8  65636569
0001ac  76656420
0001b0  49435600

                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L5.30|
00001a  2001              MOVS     r0,#1
                  |L5.28|
;;;495    }
00001c  4770              BX       lr
                  |L5.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L5.28|
;;;496    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L10.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L10.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L10.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L10.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L13.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L13.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L13.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L13.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L19.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L19.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  4541502d          DCB      0x45,0x41,0x50,0x2d
000004  494b4556          DCB      0x49,0x4b,0x45,0x56
000008  323a204e          DCB      0x32,0x3a,0x20,0x4e
00000c  6f742065          DCB      0x6f,0x74,0x20,0x65
000010  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000014  6820726f          DCB      0x68,0x20,0x72,0x6f
000018  6f6d2069          DCB      0x6f,0x6d,0x20,0x69
00001c  6e207468          DCB      0x6e,0x20,0x74,0x68
000020  65206d65          DCB      0x65,0x20,0x6d,0x65
000024  73736167          DCB      0x73,0x73,0x61,0x67
000028  6520666f          DCB      0x65,0x20,0x66,0x6f
00002c  7220496e          DCB      0x72,0x20,0x49,0x6e
000030  74656772          DCB      0x74,0x65,0x67,0x72
000034  69747920          DCB      0x69,0x74,0x79,0x20
000038  43686563          DCB      0x43,0x68,0x65,0x63
00003c  6b73756d          DCB      0x6b,0x73,0x75,0x6d
000040  20446174          DCB      0x20,0x44,0x61,0x74
000044  61000000          DCB      0x61,0x00,0x00,0x00
000048  4541502d          DCB      0x45,0x41,0x50,0x2d
00004c  494b4556          DCB      0x49,0x4b,0x45,0x56
000050  323a2056          DCB      0x32,0x3a,0x20,0x56
000054  616c6964          DCB      0x61,0x6c,0x69,0x64
000058  20496e74          DCB      0x20,0x49,0x6e,0x74
00005c  65677269          DCB      0x65,0x67,0x72,0x69
000060  74792043          DCB      0x74,0x79,0x20,0x43
000064  6865636b          DCB      0x68,0x65,0x63,0x6b
000068  73756d20          DCB      0x73,0x75,0x6d,0x20
00006c  44617461          DCB      0x44,0x61,0x74,0x61
000070  20696e20          DCB      0x20,0x69,0x6e,0x20
000074  74686520          DCB      0x74,0x68,0x65,0x20
000078  72656365          DCB      0x72,0x65,0x63,0x65
00007c  69766564          DCB      0x69,0x76,0x65,0x64
000080  206d6573          DCB      0x20,0x6d,0x65,0x73
000084  73616765          DCB      0x73,0x61,0x67,0x65
000088  00                DCB      0x00
