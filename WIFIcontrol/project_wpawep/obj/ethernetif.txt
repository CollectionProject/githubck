; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\ethernetif.o --depend=.\obj\ethernetif.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\ethernetif.crf ..\lwIP\port\netif\ethernetif.c]
                          THUMB

                          AREA ||i.ethernetif_init||, CODE, READONLY, ALIGN=2

                  ethernetif_init PROC
;;;277    err_t
;;;278    ethernetif_init(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;279    {
000002  4604              MOV      r4,r0
;;;280      struct ethernetif *ethernetif;
;;;281      LWIP_ASSERT("netif != NULL", (netif != NULL));
;;;282      ethernetif = mem_malloc(sizeof(struct ethernetif));
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       mem_malloc
00000a  4605              MOV      r5,r0
;;;283      if (ethernetif == NULL)
00000c  b925              CBNZ     r5,|L1.24|
;;;284      {
;;;285        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;286        return ERR_MEM;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L1.22|
;;;287      }
;;;288      /*
;;;289       * Initialize the snmp variables and counters inside the struct netif.
;;;290       * The last argument should be replaced with your link speed, in units
;;;291       * of bits per second.
;;;292       */
;;;293      NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, 10000000);
;;;294      netif->state = ethernetif;
;;;295      netif->name[0] = IFNAME0;
;;;296      netif->name[1] = IFNAME1;
;;;297      /* We directly use etharp_output() here to save a function call.
;;;298       * You can instead declare your own function an call etharp_output()
;;;299       * from it if you have to do some checks before sending (e.g. if link
;;;300       * is available...) */
;;;301      netif->output = etharp_output;
;;;302      netif->linkoutput = low_level_output;
;;;303      ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
;;;304      low_level_init(netif);
;;;305      return ERR_OK;
;;;306    }
000016  bd70              POP      {r4-r6,pc}
                  |L1.24|
000018  61e5              STR      r5,[r4,#0x1c]         ;294
00001a  2073              MOVS     r0,#0x73              ;295
00001c  f8840033          STRB     r0,[r4,#0x33]         ;295
000020  2174              MOVS     r1,#0x74              ;296
000022  2034              MOVS     r0,#0x34              ;296
000024  5501              STRB     r1,[r0,r4]            ;296
000026  4806              LDR      r0,|L1.64|
000028  6160              STR      r0,[r4,#0x14]         ;301
00002a  4806              LDR      r0,|L1.68|
00002c  61a0              STR      r0,[r4,#0x18]         ;302
00002e  f1040029          ADD      r0,r4,#0x29           ;303
000032  6028              STR      r0,[r5,#0]            ;303
000034  4620              MOV      r0,r4                 ;304
000036  f7fffffe          BL       low_level_init
00003a  2000              MOVS     r0,#0                 ;305
00003c  e7eb              B        |L1.22|
;;;307    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      etharp_output
                  |L1.68|
                          DCD      low_level_output

                          AREA ||i.ethernetif_input||, CODE, READONLY, ALIGN=1

                  ethernetif_input PROC
;;;243    err_t
;;;244    ethernetif_input(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246      err_t err;
;;;247      //INT8U ret;
;;;248      struct pbuf *p=NULL;
000004  2600              MOVS     r6,#0
;;;249      /* move received packet into a new pbuf */
;;;250      p = low_level_input(netif);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       low_level_input
00000c  4606              MOV      r6,r0
;;;251      /* no packet could be read, silently ignore this */
;;;252      if (p == NULL){
00000e  b90e              CBNZ     r6,|L2.20|
;;;253      	 return ERR_OK;
000010  2000              MOVS     r0,#0
                  |L2.18|
;;;254      }
;;;255      err = netif->input(p, netif); // 将pbuf传递给上层协议栈
;;;256      if (err != ERR_OK){
;;;257        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;258        pbuf_free(p);
;;;259        p = NULL;
;;;260    	return err;
;;;261      }
;;;262      return err;
;;;263    }
000012  bd70              POP      {r4-r6,pc}
                  |L2.20|
000014  4621              MOV      r1,r4                 ;255
000016  4630              MOV      r0,r6                 ;255
000018  6922              LDR      r2,[r4,#0x10]         ;255
00001a  4790              BLX      r2                    ;255
00001c  4605              MOV      r5,r0                 ;255
00001e  b13d              CBZ      r5,|L2.48|
000020  bf00              NOP                            ;257
000022  bf00              NOP                            ;257
000024  4630              MOV      r0,r6                 ;258
000026  f7fffffe          BL       pbuf_free
00002a  2600              MOVS     r6,#0                 ;259
00002c  4628              MOV      r0,r5                 ;260
00002e  e7f0              B        |L2.18|
                  |L2.48|
000030  4628              MOV      r0,r5                 ;262
000032  e7ee              B        |L2.18|
;;;264    
                          ENDP


                          AREA ||i.lbs_sendpbuf||, CODE, READONLY, ALIGN=2

                  lbs_sendpbuf PROC
;;;114    ***********************************************************************************************/
;;;115    char  lbs_sendpbuf(struct lbs_private *priv, struct pbuf *p)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;116    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;117    	struct txpd *txpd;//这是用于控制硬件发送的头信息，必须放在数据包前面写入网卡
;;;118    	struct pbuf *q;
;;;119    	char *p802x_hdr;
;;;120    	char *buffer;
;;;121    	uint16_t pkt_len;
;;;122    	int ret = 0;
000008  f04f0900          MOV      r9,#0
;;;123    	int l = 0;
00000c  46ca              MOV      r10,r9
;;;124    	sdio_sys_wait=0;
00000e  2000              MOVS     r0,#0
000010  4924              LDR      r1,|L3.164|
000012  7008              STRB     r0,[r1,#0]
;;;125    	txpd=(void *)&priv->resp_buf[0][4];
000014  f5046594          ADD      r5,r4,#0x4a0
;;;126    	memset(txpd, 0, sizeof(struct txpd));
000018  2118              MOVS     r1,#0x18
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       __aeabi_memclr
;;;127    	p802x_hdr = (char *)p->payload;//802.3 mac头
000020  f8d7b004          LDR      r11,[r7,#4]
;;;128    	pkt_len = (uint16_t)p->tot_len;
000024  f8b78008          LDRH     r8,[r7,#8]
;;;129    	//接收地址
;;;130    	memcpy(txpd->tx_dest_addr_high, p802x_hdr, ETH_ALEN);
000028  f8db0000          LDR      r0,[r11,#0]
00002c  f8c5000e          STR      r0,[r5,#0xe]
000030  f8bb0004          LDRH     r0,[r11,#4]
000034  8268              STRH     r0,[r5,#0x12]
;;;131    	txpd->tx_packet_length = cpu_to_le16(pkt_len);//802.3的有效数据长度，固件会自动封装802.11数据帧
000036  f8a5800c          STRH     r8,[r5,#0xc]
;;;132    	txpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));//数据的偏移
00003a  2018              MOVS     r0,#0x18
00003c  60a8              STR      r0,[r5,#8]
;;;133    	buffer=(char *)&txpd[1];
00003e  f1050018          ADD      r0,r5,#0x18
000042  9000              STR      r0,[sp,#0]
;;;134    	for(q = p; q != NULL; q = q->next) {
000044  463e              MOV      r6,r7
000046  e009              B        |L3.92|
                  |L3.72|
;;;135    	    memcpy(buffer+l, q->payload, q->len);
000048  8972              LDRH     r2,[r6,#0xa]
00004a  6871              LDR      r1,[r6,#4]
00004c  9b00              LDR      r3,[sp,#0]
00004e  eb03000a          ADD      r0,r3,r10
000052  f7fffffe          BL       __aeabi_memcpy
;;;136    		l+= (int)q->len;
000056  8970              LDRH     r0,[r6,#0xa]
000058  4482              ADD      r10,r10,r0
00005a  6836              LDR      r6,[r6,#0]            ;134
                  |L3.92|
00005c  2e00              CMP      r6,#0                 ;134
00005e  d1f3              BNE      |L3.72|
;;;137    	  }
;;;138    	//memcpy(, p802x_hdr, le16_to_cpu(txpd->tx_packet_length));//真正数据存放的地方
;;;139    	priv->resp_len[0] = pkt_len + sizeof(struct txpd);//是否有数据需要发送靠的就是判断邋pkt_len是否值
000060  f1080018          ADD      r0,r8,#0x18
000064  f8c40498          STR      r0,[r4,#0x498]
;;;140    	if (priv->resp_len[0] > 0) {//发送数据处理
000068  f8d40498          LDR      r0,[r4,#0x498]
00006c  b190              CBZ      r0,|L3.148|
;;;141    	//这里就是调用if_sdio_host_to_card这个函数来处理向设备发送数据
;;;142    	//	debug_data_stream("send data",buffer,priv->resp_len[0]);
;;;143    		ret=if_sdio_send_data(priv,priv->resp_buf[0],
00006e  f8d40498          LDR      r0,[r4,#0x498]
000072  b282              UXTH     r2,r0
000074  f204419c          ADD      r1,r4,#0x49c
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       if_sdio_send_data
00007e  4681              MOV      r9,r0
;;;144    								priv->resp_len[0]);
;;;145    		if (ret) {
000080  f1b90f00          CMP      r9,#0
000084  d003              BEQ      |L3.142|
;;;146    			lbs_deb_tx("host_to_card failed %d\n", ret);
;;;147    			priv->dnld_sent = DNLD_RES_RECEIVED;
000086  2100              MOVS     r1,#0
000088  f24100b8          MOV      r0,#0x10b8
00008c  5501              STRB     r1,[r0,r4]
                  |L3.142|
;;;148    		}
;;;149    		priv->resp_len[0] = 0;
00008e  2000              MOVS     r0,#0
000090  f8c40498          STR      r0,[r4,#0x498]
                  |L3.148|
;;;150    	}
;;;151    	sdio_sys_wait=1;
000094  2001              MOVS     r0,#1
000096  4903              LDR      r1,|L3.164|
000098  7008              STRB     r0,[r1,#0]
;;;152    	return ret;
00009a  f00900ff          AND      r0,r9,#0xff
;;;153    }
00009e  e8bd8ff8          POP      {r3-r11,pc}
;;;154    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L3.164|
                          DCD      sdio_sys_wait

                          AREA ||i.low_level_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  low_level_init PROC
;;;85      */
;;;86     static void low_level_init(struct netif *netif)
000000  b53e              PUSH     {r1-r5,lr}
;;;87     {
000002  4604              MOV      r4,r0
;;;88       /* set MAC hardware address length */
;;;89       printf("enter low level!\n");
000004  a01b              ADR      r0,|L4.116|
000006  f7fffffe          BL       __2printf
;;;90       printf("mac %2x:%2x:%2x:%2x:%2x:%2x\n",pgmarvel_priv->current_addr[0],
00000a  481f              LDR      r0,|L4.136|
00000c  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
00000e  f890310f          LDRB     r3,[r0,#0x10f]
000012  481d              LDR      r0,|L4.136|
000014  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
000016  f890210e          LDRB     r2,[r0,#0x10e]
00001a  481b              LDR      r0,|L4.136|
00001c  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
00001e  f890110d          LDRB     r1,[r0,#0x10d]
000022  4819              LDR      r0,|L4.136|
000024  e88d000e          STM      sp,{r1-r3}
000028  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
00002a  f890310c          LDRB     r3,[r0,#0x10c]
00002e  4816              LDR      r0,|L4.136|
000030  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
000032  f890210b          LDRB     r2,[r0,#0x10b]
000036  4814              LDR      r0,|L4.136|
000038  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
00003a  f890110a          LDRB     r1,[r0,#0x10a]
00003e  a013              ADR      r0,|L4.140|
000040  f7fffffe          BL       __2printf
;;;91     									  	pgmarvel_priv->current_addr[1],
;;;92     									  	pgmarvel_priv->current_addr[2],
;;;93     									  	pgmarvel_priv->current_addr[3],
;;;94     									  	pgmarvel_priv->current_addr[4],
;;;95     									  	pgmarvel_priv->current_addr[5]);
;;;96       netif->hwaddr_len = ETHARP_HWADDR_LEN;
000044  2006              MOVS     r0,#6
000046  f8840028          STRB     r0,[r4,#0x28]
;;;97       memcpy(netif->hwaddr,pgmarvel_priv->current_addr,ETHARP_HWADDR_LEN);
00004a  480f              LDR      r0,|L4.136|
00004c  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
00004e  f5007080          ADD      r0,r0,#0x100
000052  f8d0100a          LDR      r1,[r0,#0xa]
000056  f8c41029          STR      r1,[r4,#0x29]
00005a  89c0              LDRH     r0,[r0,#0xe]
00005c  f8a4002d          STRH     r0,[r4,#0x2d]
;;;98       /* maximum transfer unit */
;;;99       netif->mtu = 1500;
000060  f24050dc          MOV      r0,#0x5dc
000064  8620              STRH     r0,[r4,#0x30]
;;;100      /* device capabilities */
;;;101      /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
;;;102      netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
000066  2032              MOVS     r0,#0x32
000068  f8840032          STRB     r0,[r4,#0x32]
;;;103      printf("leave low level!\n");
00006c  a00f              ADR      r0,|L4.172|
00006e  f7fffffe          BL       __2printf
;;;104    
;;;105    }
000072  bd3e              POP      {r1-r5,pc}
;;;106    
                          ENDP

                  |L4.116|
000074  656e7465          DCB      "enter low level!\n",0
000078  72206c6f
00007c  77206c65
000080  76656c21
000084  0a00    
000086  00                DCB      0
000087  00                DCB      0
                  |L4.136|
                          DCD      pgmarvel_priv
                  |L4.140|
00008c  6d616320          DCB      "mac %2x:%2x:%2x:%2x:%2x:%2x\n",0
000090  2532783a
000094  2532783a
000098  2532783a
00009c  2532783a
0000a0  2532783a
0000a4  2532780a
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L4.172|
0000ac  6c656176          DCB      "leave low level!\n",0
0000b0  65206c6f
0000b4  77206c65
0000b8  76656c21
0000bc  0a00    
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.low_level_input||, CODE, READONLY, ALIGN=2

                  low_level_input PROC
;;;199    //static u8 xxxbuf[] = {0x00,0x1a,0x6b,0x6e,0x90,0x67,0x00,0x26,0xf2,0xa8,0x17,0x5b,0x88,0x8e,0x01,0x03,0x00,0x5f,0x02,0x00,0x8a,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xa7,0x38,0x03,0x5e,0xf0,0x21,0x81,0xf4,0x12,0xb2,0x61,0x49,0x4d,0x19,0xa9,0xca,0xe0,0xfc,0xca,0x47,0x20,0x46,0x36,0x26,0xce,0x14,0xfc,0x01,0xee,0x7d,0x3b,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;;;200    struct pbuf *low_level_input(struct netif *netif)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;201    {
000004  4682              MOV      r10,r0
;;;202      struct eth_packet *rx_pkt=&pgmarvel_priv->rx_pkt;
000006  4813              LDR      r0,|L5.84|
000008  f8d09000          LDR      r9,[r0,#0]  ; pgmarvel_priv
;;;203      struct eth_hdr* ethhdr;
;;;204      struct pbuf *p, *q;
;;;205      u16 len=0;
00000c  2600              MOVS     r6,#0
;;;206      int l =0;
00000e  2700              MOVS     r7,#0
;;;207      char *buffer;
;;;208      p = NULL;
000010  2500              MOVS     r5,#0
;;;209      /* Obtain the size of the packet and put it into the "len"
;;;210         variable. */ 
;;;211     // BSP_IntDis(BSP_INT_ID_TIM2);
;;;212      len=lbs_rev_pkt();
000012  f7fffffe          BL       lbs_rev_pkt
000016  4606              MOV      r6,r0
;;;213    //  BSP_IntEn(BSP_INT_ID_TIM2);
;;;214      if(len>0){
000018  2e00              CMP      r6,#0
00001a  dd18              BLE      |L5.78|
;;;215    	buffer=rx_pkt->data;
00001c  f8d98004          LDR      r8,[r9,#4]
;;;216    	//debug_data_stream("Wireless data",buffer,rx_pkt->len);
;;;217    	  /* We allocate a pbuf chain of pbufs from the pool. */
;;;218    	
;;;219    	 p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
000020  2203              MOVS     r2,#3
000022  4631              MOV      r1,r6
000024  4610              MOV      r0,r2
000026  f7fffffe          BL       pbuf_alloc
00002a  4605              MOV      r5,r0
;;;220    	 if (p != NULL){
00002c  b16d              CBZ      r5,|L5.74|
;;;221    	   for (q = p; q != NULL; q = q->next){
00002e  462c              MOV      r4,r5
000030  e008              B        |L5.68|
                  |L5.50|
;;;222    		  memcpy((u8_t*)q->payload, (u8_t*)&buffer[l], q->len);
000032  8962              LDRH     r2,[r4,#0xa]
000034  eb080107          ADD      r1,r8,r7
000038  6860              LDR      r0,[r4,#4]
00003a  f7fffffe          BL       __aeabi_memcpy
;;;223    	      l = l + q->len;
00003e  8960              LDRH     r0,[r4,#0xa]
000040  4407              ADD      r7,r7,r0
000042  6824              LDR      r4,[r4,#0]            ;221
                  |L5.68|
000044  2c00              CMP      r4,#0                 ;221
000046  d1f4              BNE      |L5.50|
000048  e001              B        |L5.78|
                  |L5.74|
;;;224    	    }    
;;;225    	  }
;;;226    	  else{
;;;227    	  	rest_sys_mem();
00004a  f7fffffe          BL       rest_sys_mem
                  |L5.78|
;;;228    	  }
;;;229    	  	
;;;230      }
;;;231      return p;
00004e  4628              MOV      r0,r5
;;;232    }
000050  e8bd87f0          POP      {r4-r10,pc}
;;;233    
                          ENDP

                  |L5.84|
                          DCD      pgmarvel_priv

                          AREA ||i.low_level_output||, CODE, READONLY, ALIGN=2

                  low_level_output PROC
;;;173    static err_t
;;;174    low_level_output(struct netif *netif, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;176      /* Interrupts are disabled through this whole thing to support multi-threading
;;;177    	   transmit calls. Also this function might be called from an ISR. */
;;;178      //BSP_IntDis(BSP_INT_ID_TIM2);
;;;179      lbs_sendpbuf(pgmarvel_priv,p);
000006  4621              MOV      r1,r4
000008  4803              LDR      r0,|L6.24|
00000a  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
00000c  f7fffffe          BL       lbs_sendpbuf
;;;180      wait_for_data_end();
000010  f7fffffe          BL       wait_for_data_end
;;;181     // BSP_IntEn(BSP_INT_ID_TIM2);
;;;182     // pbuf_free(p);//
;;;183      return ERR_OK;
000014  2000              MOVS     r0,#0
;;;184    }
000016  bd70              POP      {r4-r6,pc}
;;;185    /**
                          ENDP

                  |L6.24|
                          DCD      pgmarvel_priv

                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L8.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L8.32|
                  |L8.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L8.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L8.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L8.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L8.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L8.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L8.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_end_time
                          DCD      0x00000000
                  arp_end_time
                          DCD      0x00000000
