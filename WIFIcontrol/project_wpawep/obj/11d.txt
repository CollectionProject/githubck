; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\11d.o --depend=.\obj\11d.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\11d.crf ..\marvel\driver\src\11d.c]
                          THUMB

                          AREA ||i.generate_domain_info_11d||, CODE, READONLY, ALIGN=2

                  generate_domain_info_11d PROC
;;;149    
;;;150    static int generate_domain_info_11d(struct parsed_region_chan_11d
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;151    				  *parsed_region_chan,
;;;152    				  struct lbs_802_11d_domain_reg *domaininfo)
;;;153    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;154    	u8 nr_subband = 0;
000008  2600              MOVS     r6,#0
;;;155    
;;;156    	u8 nr_chan = parsed_region_chan->nr_chan;
00000a  f8940055          LDRB     r0,[r4,#0x55]
00000e  9001              STR      r0,[sp,#4]
;;;157    	u8 nr_parsedchan = 0;
000010  46b0              MOV      r8,r6
;;;158    
;;;159    	u8 firstchan = 0, nextchan = 0, maxpwr = 0;
000012  46b2              MOV      r10,r6
000014  46b3              MOV      r11,r6
000016  46b1              MOV      r9,r6
;;;160    
;;;161    	u8 i, flag = 0;
000018  2000              MOVS     r0,#0
00001a  9000              STR      r0,[sp,#0]
;;;162    
;;;163    	memcpy(domaininfo->countrycode, parsed_region_chan->countrycode,
00001c  8860              LDRH     r0,[r4,#2]
00001e  8028              STRH     r0,[r5,#0]
000020  7920              LDRB     r0,[r4,#4]
000022  70a8              STRB     r0,[r5,#2]
;;;164    	       COUNTRY_CODE_LEN);
;;;165    
;;;166    	lbs_deb_11d("nrchan %d\n", nr_chan);
;;;167    	lbs_deb_hex(LBS_DEB_11D, "parsed_region_chan", (u8 *)parsed_region_chan,
000024  2356              MOVS     r3,#0x56
000026  4622              MOV      r2,r4
000028  a138              ADR      r1,|L1.268|
00002a  f44f6080          MOV      r0,#0x400
00002e  f7fffffe          BL       lbs_hex
;;;168    		sizeof(struct parsed_region_chan_11d));
;;;169    
;;;170    	for (i = 0; i < nr_chan; i++) {
000032  2700              MOVS     r7,#0
000034  e045              B        |L1.194|
                  |L1.54|
;;;171    		if (!flag) {
000036  9800              LDR      r0,[sp,#0]
000038  b970              CBNZ     r0,|L1.88|
;;;172    			flag = 1;
00003a  2001              MOVS     r0,#1
00003c  9000              STR      r0,[sp,#0]
;;;173    			nextchan = firstchan =
00003e  1d60              ADDS     r0,r4,#5
000040  f8100017          LDRB     r0,[r0,r7,LSL #1]
000044  4682              MOV      r10,r0
000046  4683              MOV      r11,r0
;;;174    			    parsed_region_chan->chanpwr[i].chan;
;;;175    			maxpwr = parsed_region_chan->chanpwr[i].pwr;
000048  1d60              ADDS     r0,r4,#5
00004a  eb000047          ADD      r0,r0,r7,LSL #1
00004e  f8909001          LDRB     r9,[r0,#1]
;;;176    			nr_parsedchan = 1;
000052  f04f0801          MOV      r8,#1
;;;177    			continue;
000056  e032              B        |L1.190|
                  |L1.88|
;;;178    		}
;;;179    
;;;180    		if (parsed_region_chan->chanpwr[i].chan == nextchan + 1 &&
000058  1d60              ADDS     r0,r4,#5
00005a  f8101017          LDRB     r1,[r0,r7,LSL #1]
00005e  f10b0001          ADD      r0,r11,#1
000062  4281              CMP      r1,r0
000064  d10e              BNE      |L1.132|
;;;181    		    parsed_region_chan->chanpwr[i].pwr == maxpwr) {
000066  1d60              ADDS     r0,r4,#5
000068  eb000047          ADD      r0,r0,r7,LSL #1
00006c  7840              LDRB     r0,[r0,#1]
00006e  4548              CMP      r0,r9
000070  d108              BNE      |L1.132|
;;;182    			nextchan++;
000072  f10b0001          ADD      r0,r11,#1
000076  f0000bff          AND      r11,r0,#0xff
;;;183    			nr_parsedchan++;
00007a  f1080001          ADD      r0,r8,#1
00007e  f00008ff          AND      r8,r0,#0xff
000082  e01b              B        |L1.188|
                  |L1.132|
;;;184    		} else {
;;;185    			domaininfo->subband[nr_subband].firstchan = firstchan;
000084  eb060146          ADD      r1,r6,r6,LSL #1
000088  1d28              ADDS     r0,r5,#4
00008a  f800a001          STRB     r10,[r0,r1]
;;;186    			domaininfo->subband[nr_subband].nrchan =
00008e  eb060146          ADD      r1,r6,r6,LSL #1
000092  4408              ADD      r0,r0,r1
000094  f8808001          STRB     r8,[r0,#1]
;;;187    			    nr_parsedchan;
;;;188    			domaininfo->subband[nr_subband].maxtxpwr = maxpwr;
000098  eb060146          ADD      r1,r6,r6,LSL #1
00009c  1d28              ADDS     r0,r5,#4
00009e  4408              ADD      r0,r0,r1
0000a0  f8809002          STRB     r9,[r0,#2]
;;;189    			nr_subband++;
0000a4  1c70              ADDS     r0,r6,#1
0000a6  b2c6              UXTB     r6,r0
;;;190    			nextchan = firstchan =
0000a8  1d60              ADDS     r0,r4,#5
0000aa  f8100017          LDRB     r0,[r0,r7,LSL #1]
0000ae  4682              MOV      r10,r0
0000b0  4683              MOV      r11,r0
;;;191    			    parsed_region_chan->chanpwr[i].chan;
;;;192    			maxpwr = parsed_region_chan->chanpwr[i].pwr;
0000b2  1d60              ADDS     r0,r4,#5
0000b4  eb000047          ADD      r0,r0,r7,LSL #1
0000b8  f8909001          LDRB     r9,[r0,#1]
                  |L1.188|
0000bc  bf00              NOP                            ;177
                  |L1.190|
0000be  1c78              ADDS     r0,r7,#1              ;170
0000c0  b2c7              UXTB     r7,r0                 ;170
                  |L1.194|
0000c2  9801              LDR      r0,[sp,#4]            ;170
0000c4  4287              CMP      r7,r0                 ;170
0000c6  dbb6              BLT      |L1.54|
;;;193    		}
;;;194    	}
;;;195    
;;;196    	if (flag) {
0000c8  9800              LDR      r0,[sp,#0]
0000ca  b188              CBZ      r0,|L1.240|
;;;197    		domaininfo->subband[nr_subband].firstchan = firstchan;
0000cc  eb060146          ADD      r1,r6,r6,LSL #1
0000d0  1d28              ADDS     r0,r5,#4
0000d2  f800a001          STRB     r10,[r0,r1]
;;;198    		domaininfo->subband[nr_subband].nrchan = nr_parsedchan;
0000d6  eb060146          ADD      r1,r6,r6,LSL #1
0000da  4408              ADD      r0,r0,r1
0000dc  f8808001          STRB     r8,[r0,#1]
;;;199    		domaininfo->subband[nr_subband].maxtxpwr = maxpwr;
0000e0  eb060146          ADD      r1,r6,r6,LSL #1
0000e4  1d28              ADDS     r0,r5,#4
0000e6  4408              ADD      r0,r0,r1
0000e8  f8809002          STRB     r9,[r0,#2]
;;;200    		nr_subband++;
0000ec  1c70              ADDS     r0,r6,#1
0000ee  b2c6              UXTB     r6,r0
                  |L1.240|
;;;201    	}
;;;202    	domaininfo->nr_subband = nr_subband;
0000f0  70ee              STRB     r6,[r5,#3]
;;;203    
;;;204    	lbs_deb_11d("nr_subband=%x\n", domaininfo->nr_subband);
;;;205    	lbs_deb_hex(LBS_DEB_11D, "domaininfo", (u8 *)domaininfo,
0000f2  eb060046          ADD      r0,r6,r6,LSL #1
0000f6  1d03              ADDS     r3,r0,#4
0000f8  462a              MOV      r2,r5
0000fa  a109              ADR      r1,|L1.288|
0000fc  f44f6080          MOV      r0,#0x400
000100  f7fffffe          BL       lbs_hex
;;;206    		COUNTRY_CODE_LEN + 1 +
;;;207    		sizeof(struct ieee_subbandset) * nr_subband);
;;;208    	return 0;
000104  2000              MOVS     r0,#0
;;;209    }
000106  e8bd9ffc          POP      {r2-r12,pc}
;;;210    
                          ENDP

00010a  0000              DCW      0x0000
                  |L1.268|
00010c  70617273          DCB      "parsed_region_chan",0
000110  65645f72
000114  6567696f
000118  6e5f6368
00011c  616e00  
00011f  00                DCB      0
                  |L1.288|
000120  646f6d61          DCB      "domaininfo",0
000124  696e696e
000128  666f00  
00012b  00                DCB      0

                          AREA ||i.lbs_chan_2_freq||, CODE, READONLY, ALIGN=2

                  lbs_chan_2_freq PROC
;;;133    
;;;134    u32 lbs_chan_2_freq(u8 chan)
000000  b510              PUSH     {r4,lr}
;;;135    {
000002  4602              MOV      r2,r0
;;;136    	struct chan_freq_power *cf;
;;;137    	u16 i;
;;;138    	u32 freq = 0;
000004  2000              MOVS     r0,#0
;;;139    
;;;140    	cf = channel_freq_power_UN_BG;
000006  4b09              LDR      r3,|L2.44|
;;;141    
;;;142    	for (i = 0; i < ARRAY_SIZE(channel_freq_power_UN_BG); i++) {
000008  2100              MOVS     r1,#0
00000a  e00c              B        |L2.38|
                  |L2.12|
;;;143    		if (chan == cf[i].channel)
00000c  eb010441          ADD      r4,r1,r1,LSL #1
000010  f8334024          LDRH     r4,[r3,r4,LSL #2]
000014  4294              CMP      r4,r2
000016  d104              BNE      |L2.34|
;;;144    			freq = cf[i].freq;
000018  eb010441          ADD      r4,r1,r1,LSL #1
00001c  eb030484          ADD      r4,r3,r4,LSL #2
000020  6860              LDR      r0,[r4,#4]
                  |L2.34|
000022  1c4c              ADDS     r4,r1,#1              ;142
000024  b2a1              UXTH     r1,r4                 ;142
                  |L2.38|
000026  290e              CMP      r1,#0xe               ;142
000028  d3f0              BCC      |L2.12|
;;;145    	}
;;;146    
;;;147    	return freq;
;;;148    }
00002a  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L2.44|
                          DCD      channel_freq_power_UN_BG

                          AREA ||i.lbs_channel_known_11d||, CODE, READONLY, ALIGN=2

                  lbs_channel_known_11d PROC
;;;112    */
;;;113    static u8 lbs_channel_known_11d(u8 chan,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;114    			  struct parsed_region_chan_11d * parsed_region_chan)
;;;115    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;116    	struct chan_power_11d *chanpwr = parsed_region_chan->chanpwr;
000008  1d67              ADDS     r7,r4,#5
;;;117    	u8 nr_chan = parsed_region_chan->nr_chan;
00000a  f8948055          LDRB     r8,[r4,#0x55]
;;;118    	u8 i = 0;
00000e  2500              MOVS     r5,#0
;;;119    
;;;120    	lbs_deb_hex(LBS_DEB_11D, "parsed_region_chan", (u8 *)chanpwr,
000010  ea4f0348          LSL      r3,r8,#1
000014  463a              MOV      r2,r7
000016  a10a              ADR      r1,|L3.64|
000018  f44f6080          MOV      r0,#0x400
00001c  f7fffffe          BL       lbs_hex
;;;121    		sizeof(struct chan_power_11d) * nr_chan);
;;;122    
;;;123    	for (i = 0; i < nr_chan; i++) {
000020  bf00              NOP      
000022  e008              B        |L3.54|
                  |L3.36|
;;;124    		if (chan == chanpwr[i].chan) {
000024  f8170015          LDRB     r0,[r7,r5,LSL #1]
000028  42b0              CMP      r0,r6
00002a  d102              BNE      |L3.50|
;;;125    			lbs_deb_11d("found chan %d\n", chan);
;;;126    			return 1;
00002c  2001              MOVS     r0,#1
                  |L3.46|
;;;127    		}
;;;128    	}
;;;129    
;;;130    	lbs_deb_11d("chan %d not found\n", chan);
;;;131    	return 0;
;;;132    }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L3.50|
000032  1c68              ADDS     r0,r5,#1              ;123
000034  b2c5              UXTB     r5,r0                 ;123
                  |L3.54|
000036  4545              CMP      r5,r8                 ;123
000038  dbf4              BLT      |L3.36|
00003a  2000              MOVS     r0,#0                 ;131
00003c  e7f7              B        |L3.46|
;;;133    
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
000040  70617273          DCB      "parsed_region_chan",0
000044  65645f72
000048  6567696f
00004c  6e5f6368
000050  616e00  
000053  00                DCB      0

                          AREA ||i.lbs_cmd_802_11d_domain_info||, CODE, READONLY, ALIGN=2

                  lbs_cmd_802_11d_domain_info PROC
;;;495    */
;;;496    int lbs_cmd_802_11d_domain_info(struct lbs_private *priv,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;497    				 struct cmd_ds_command *cmd, u16 cmdno,
;;;498    				 u16 cmdoption)
;;;499    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
00000a  461f              MOV      r7,r3
;;;500    	struct cmd_ds_802_11d_domain_info *pdomaininfo =
00000c  f1040a08          ADD      r10,r4,#8
;;;501    	    &cmd->params.domaininfo;
;;;502    	struct mrvl_ie_domain_param_set *domain = &pdomaininfo->domain;
000010  f10a0502          ADD      r5,r10,#2
;;;503    	u8 nr_subband = priv->domainreg.nr_subband;
000014  f240303b          MOV      r0,#0x33b
000018  f8108006          LDRB     r8,[r0,r6]
;;;504    
;;;505    	lbs_deb_enter(LBS_DEB_11D);
;;;506    
;;;507    	lbs_deb_11d("nr_subband=%x\n", nr_subband);
;;;508    
;;;509    	cmd->command = cpu_to_le16(cmdno);
00001c  f8a49000          STRH     r9,[r4,#0]
;;;510    	pdomaininfo->action = cpu_to_le16(cmdoption);
000020  f8aa7000          STRH     r7,[r10,#0]
;;;511    	if (cmdoption == CMD_ACT_GET) {
000024  b94f              CBNZ     r7,|L4.58|
;;;512    		cmd->size =
000026  200e              MOVS     r0,#0xe
000028  8060              STRH     r0,[r4,#2]
;;;513    		    cpu_to_le16(sizeof(pdomaininfo->action) + S_DS_GEN);
;;;514    		lbs_deb_hex(LBS_DEB_11D, "802_11D_DOMAIN_INFO", (u8 *) cmd,
00002a  8863              LDRH     r3,[r4,#2]
00002c  4622              MOV      r2,r4
00002e  a116              ADR      r1,|L4.136|
000030  f44f6080          MOV      r0,#0x400
000034  f7fffffe          BL       lbs_hex
;;;515    			le16_to_cpu(cmd->size));
;;;516    		goto done;
000038  e023              B        |L4.130|
                  |L4.58|
;;;517    	}
;;;518    
;;;519    	domain->header.type = cpu_to_le16(TLV_TYPE_DOMAIN);
00003a  2007              MOVS     r0,#7
00003c  8028              STRH     r0,[r5,#0]
;;;520    	memcpy(domain->countrycode, priv->domainreg.countrycode,
00003e  f8b61338          LDRH     r1,[r6,#0x338]
000042  80a9              STRH     r1,[r5,#4]
000044  f896033a          LDRB     r0,[r6,#0x33a]
000048  71a8              STRB     r0,[r5,#6]
;;;521    	       sizeof(domain->countrycode));
;;;522    
;;;523    	domain->header.len =
00004a  eb080048          ADD      r0,r8,r8,LSL #1
00004e  1cc0              ADDS     r0,r0,#3
000050  8068              STRH     r0,[r5,#2]
;;;524    	    cpu_to_le16(nr_subband * sizeof(struct ieee_subbandset) +
;;;525    			     sizeof(domain->countrycode));
;;;526    
;;;527    	if (nr_subband) {
000052  f1b80f00          CMP      r8,#0
000056  d00a              BEQ      |L4.110|
;;;528    		memcpy(domain->subband, priv->domainreg.subband,
000058  eb080248          ADD      r2,r8,r8,LSL #1
00005c  f506714f          ADD      r1,r6,#0x33c
000060  1de8              ADDS     r0,r5,#7
000062  f7fffffe          BL       __aeabi_memcpy
;;;529    		       nr_subband * sizeof(struct ieee_subbandset));
;;;530    
;;;531    		cmd->size = cpu_to_le16(sizeof(pdomaininfo->action) +
000066  8868              LDRH     r0,[r5,#2]
000068  3012              ADDS     r0,r0,#0x12
00006a  8060              STRH     r0,[r4,#2]
00006c  e001              B        |L4.114|
                  |L4.110|
;;;532    					     le16_to_cpu(domain->header.len) +
;;;533    					     sizeof(struct mrvl_ie_header) +
;;;534    					     S_DS_GEN);
;;;535    	} else {
;;;536    		cmd->size =
00006e  200e              MOVS     r0,#0xe
000070  8060              STRH     r0,[r4,#2]
                  |L4.114|
;;;537    		    cpu_to_le16(sizeof(pdomaininfo->action) + S_DS_GEN);
;;;538    	}
;;;539    
;;;540    	lbs_deb_hex(LBS_DEB_11D, "802_11D_DOMAIN_INFO", (u8 *) cmd, le16_to_cpu(cmd->size));
000072  8863              LDRH     r3,[r4,#2]
000074  4622              MOV      r2,r4
000076  a104              ADR      r1,|L4.136|
000078  f44f6080          MOV      r0,#0x400
00007c  f7fffffe          BL       lbs_hex
;;;541    
;;;542    done:
000080  bf00              NOP      
                  |L4.130|
;;;543    	lbs_deb_enter(LBS_DEB_11D);
;;;544    	return 0;
000082  2000              MOVS     r0,#0
;;;545    }
000084  e8bd87f0          POP      {r4-r10,pc}
;;;546    
                          ENDP

                  |L4.136|
000088  3830325f          DCB      "802_11D_DOMAIN_INFO",0
00008c  3131445f
000090  444f4d41
000094  494e5f49
000098  4e464f00

                          AREA ||i.lbs_code_2_region||, CODE, READONLY, ALIGN=2

                  lbs_code_2_region PROC
;;;59     
;;;60     static u8 *lbs_code_2_region(u8 code)
000000  4602              MOV      r2,r0
;;;61     {
;;;62     	u8 i;
;;;63     
;;;64     	for (i = 0; i < ARRAY_SIZE(region_code_mapping); i++) {
000002  2100              MOVS     r1,#0
000004  e00b              B        |L5.30|
                  |L5.6|
;;;65     		if (region_code_mapping[i].code == code)
000006  4808              LDR      r0,|L5.40|
000008  eb000081          ADD      r0,r0,r1,LSL #2
00000c  78c0              LDRB     r0,[r0,#3]
00000e  4290              CMP      r0,r2
000010  d103              BNE      |L5.26|
;;;66     			return (region_code_mapping[i].region);
000012  4805              LDR      r0,|L5.40|
000014  eb000081          ADD      r0,r0,r1,LSL #2
                  |L5.24|
;;;67     	}
;;;68     	/* default is US */
;;;69     	return (region_code_mapping[0].region);
;;;70     }
000018  4770              BX       lr
                  |L5.26|
00001a  1c48              ADDS     r0,r1,#1              ;64
00001c  b2c1              UXTB     r1,r0                 ;64
                  |L5.30|
00001e  2909              CMP      r1,#9                 ;64
000020  d3f1              BCC      |L5.6|
000022  4801              LDR      r0,|L5.40|
000024  e7f8              B        |L5.24|
;;;71     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      region_code_mapping

                          AREA ||i.lbs_create_dnld_countryinfo_11d||, CODE, READONLY, ALIGN=1

                  lbs_create_dnld_countryinfo_11d PROC
;;;636     */
;;;637    int lbs_create_dnld_countryinfo_11d(struct lbs_private *priv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;638    {
000004  4604              MOV      r4,r0
;;;639    	int ret;
;;;640    	struct region_channel *region_chan;
;;;641    	u8 j;
;;;642    
;;;643    	lbs_deb_enter(LBS_DEB_11D);
;;;644    	lbs_deb_11d("curbssparams.band %d\n", priv->curbssparams.band);
;;;645    
;;;646    	if (priv->enable11d) {
000006  f8d4048c          LDR      r0,[r4,#0x48c]
00000a  b3b8              CBZ      r0,|L6.124|
;;;647    		/* update parsed_region_chan_11; dnld domaininf to FW */
;;;648    
;;;649    		for (j = 0; j < ARRAY_SIZE(priv->region_channel); j++) {
00000c  2600              MOVS     r6,#0
00000e  e012              B        |L6.54|
                  |L6.16|
;;;650    			region_chan = &priv->region_channel[j];
000010  f5047046          ADD      r0,r4,#0x318
000014  eb0005c6          ADD      r5,r0,r6,LSL #3
;;;651    
;;;652    			lbs_deb_11d("%d region_chan->band %d\n", j,
;;;653    			       region_chan->band);
;;;654    
;;;655    			if (!region_chan || !region_chan->valid
000018  b11d              CBZ      r5,|L6.34|
00001a  7828              LDRB     r0,[r5,#0]
00001c  b108              CBZ      r0,|L6.34|
;;;656    			    || !region_chan->CFP)
00001e  6868              LDR      r0,[r5,#4]
000020  b900              CBNZ     r0,|L6.36|
                  |L6.34|
;;;657    				continue;
000022  e006              B        |L6.50|
                  |L6.36|
;;;658    			if (region_chan->band != priv->curbssparams.band)
000024  78a9              LDRB     r1,[r5,#2]
000026  f89400d8          LDRB     r0,[r4,#0xd8]
00002a  4281              CMP      r1,r0
00002c  d000              BEQ      |L6.48|
;;;659    				continue;
00002e  e000              B        |L6.50|
                  |L6.48|
;;;660    			break;
000030  e003              B        |L6.58|
                  |L6.50|
000032  1c70              ADDS     r0,r6,#1              ;649
000034  b2c6              UXTB     r6,r0                 ;649
                  |L6.54|
000036  2e02              CMP      r6,#2                 ;649
000038  d3ea              BCC      |L6.16|
                  |L6.58|
00003a  bf00              NOP      
;;;661    		}
;;;662    
;;;663    		if (j >= ARRAY_SIZE(priv->region_channel)) {
00003c  2e02              CMP      r6,#2
00003e  d302              BCC      |L6.70|
;;;664    			lbs_deb_11d("region_chan not found, band %d\n",
;;;665    			       priv->curbssparams.band);
;;;666    			ret = -1;
000040  f04f37ff          MOV      r7,#0xffffffff
;;;667    			goto done;
000044  e01d              B        |L6.130|
                  |L6.70|
;;;668    		}
;;;669    
;;;670    		memset(&priv->parsed_region_chan, 0,
000046  2156              MOVS     r1,#0x56
000048  f2044035          ADD      r0,r4,#0x435
00004c  f7fffffe          BL       __aeabi_memclr
;;;671    		       sizeof(struct parsed_region_chan_11d));
;;;672    		lbs_generate_parsed_region_chan_11d(region_chan,
000050  f2044135          ADD      r1,r4,#0x435
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       lbs_generate_parsed_region_chan_11d
;;;673    						     &priv->
;;;674    						     parsed_region_chan);
;;;675    
;;;676    		memset(&priv->domainreg, 0,
00005a  21fd              MOVS     r1,#0xfd
00005c  f504704e          ADD      r0,r4,#0x338
000060  f7fffffe          BL       __aeabi_memclr4
;;;677    		       sizeof(struct lbs_802_11d_domain_reg));
;;;678    		generate_domain_info_11d(&priv->parsed_region_chan,
000064  f504714e          ADD      r1,r4,#0x338
000068  f2044035          ADD      r0,r4,#0x435
00006c  f7fffffe          BL       generate_domain_info_11d
;;;679    					 &priv->domainreg);
;;;680    
;;;681    		ret = set_domain_info_11d(priv);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       set_domain_info_11d
000076  4607              MOV      r7,r0
;;;682    
;;;683    		if (ret) {
000078  b107              CBZ      r7,|L6.124|
;;;684    			lbs_deb_11d("error setting domain info\n");
;;;685    			goto done;
00007a  e002              B        |L6.130|
                  |L6.124|
00007c  e7ff              B        |L6.126|
                  |L6.126|
;;;686    		}
;;;687    
;;;688    	}
;;;689    	ret = 0;
00007e  2700              MOVS     r7,#0
;;;690    
;;;691    done:
000080  bf00              NOP      
                  |L6.130|
;;;692    	//lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
;;;693    	return ret;
000082  4638              MOV      r0,r7
;;;694    }
000084  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.lbs_generate_parsed_region_chan_11d||, CODE, READONLY, ALIGN=1

                  lbs_generate_parsed_region_chan_11d PROC
;;;216    */
;;;217    static void lbs_generate_parsed_region_chan_11d(struct region_channel *region_chan,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;218    					  struct parsed_region_chan_11d *
;;;219    					  parsed_region_chan)
;;;220    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;221    	u8 i;
;;;222    	struct chan_freq_power *cfp;
;;;223    
;;;224    	if (region_chan == NULL) {
000008  b90c              CBNZ     r4,|L7.14|
                  |L7.10|
;;;225    		lbs_deb_11d("region_chan is NULL\n");
;;;226    		return;
;;;227    	}
;;;228    
;;;229    	cfp = region_chan->CFP;
;;;230    	if (cfp == NULL) {
;;;231    		lbs_deb_11d("cfp is NULL \n");
;;;232    		return;
;;;233    	}
;;;234    
;;;235    	parsed_region_chan->band = region_chan->band;
;;;236    	parsed_region_chan->region = region_chan->region;
;;;237    	memcpy(parsed_region_chan->countrycode,
;;;238    	       lbs_code_2_region(region_chan->region), COUNTRY_CODE_LEN);
;;;239    
;;;240    	lbs_deb_11d("region 0x%x, band %d\n", parsed_region_chan->region,
;;;241    	       parsed_region_chan->band);
;;;242    
;;;243    	for (i = 0; i < region_chan->nrcfp; i++, cfp++) {
;;;244    		parsed_region_chan->chanpwr[i].chan = cfp->channel;
;;;245    		parsed_region_chan->chanpwr[i].pwr = cfp->maxtxpower;
;;;246    		lbs_deb_11d("chan %d, pwr %d\n",
;;;247    		       parsed_region_chan->chanpwr[i].chan,
;;;248    		       parsed_region_chan->chanpwr[i].pwr);
;;;249    	}
;;;250    	parsed_region_chan->nr_chan = region_chan->nrcfp;
;;;251    
;;;252    	lbs_deb_11d("nrchan %d\n", parsed_region_chan->nr_chan);
;;;253    
;;;254    	return;
;;;255    }
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L7.14|
00000e  6867              LDR      r7,[r4,#4]            ;229
000010  b907              CBNZ     r7,|L7.20|
000012  e7fa              B        |L7.10|
                  |L7.20|
000014  78a0              LDRB     r0,[r4,#2]            ;235
000016  7028              STRB     r0,[r5,#0]            ;235
000018  7860              LDRB     r0,[r4,#1]            ;236
00001a  7068              STRB     r0,[r5,#1]            ;236
00001c  7860              LDRB     r0,[r4,#1]            ;237
00001e  f7fffffe          BL       lbs_code_2_region
000022  8801              LDRH     r1,[r0,#0]            ;237
000024  8069              STRH     r1,[r5,#2]            ;237
000026  7880              LDRB     r0,[r0,#2]            ;237
000028  7128              STRB     r0,[r5,#4]            ;237
00002a  2600              MOVS     r6,#0                 ;243
00002c  e00d              B        |L7.74|
                  |L7.46|
00002e  8838              LDRH     r0,[r7,#0]            ;244
000030  b2c1              UXTB     r1,r0                 ;244
000032  1d68              ADDS     r0,r5,#5              ;244
000034  f8001016          STRB     r1,[r0,r6,LSL #1]     ;244
000038  8938              LDRH     r0,[r7,#8]            ;245
00003a  b2c1              UXTB     r1,r0                 ;245
00003c  1d68              ADDS     r0,r5,#5              ;245
00003e  eb000046          ADD      r0,r0,r6,LSL #1       ;245
000042  7041              STRB     r1,[r0,#1]            ;245
000044  1c70              ADDS     r0,r6,#1              ;243
000046  b2c6              UXTB     r6,r0                 ;243
000048  370c              ADDS     r7,r7,#0xc            ;243
                  |L7.74|
00004a  78e0              LDRB     r0,[r4,#3]            ;243
00004c  42b0              CMP      r0,r6                 ;243
00004e  dcee              BGT      |L7.46|
000050  78e0              LDRB     r0,[r4,#3]            ;250
000052  f8850055          STRB     r0,[r5,#0x55]         ;250
000056  bf00              NOP                            ;254
000058  e7d7              B        |L7.10|
;;;256    
                          ENDP


                          AREA ||i.lbs_get_chan_11d||, CODE, READONLY, ALIGN=2

                  lbs_get_chan_11d PROC
;;;78     */
;;;79     static u8 lbs_get_chan_11d(u8 firstchan, u8 nrchan, u8 *chan)
000000  b5f0              PUSH     {r4-r7,lr}
;;;80     /*find the nrchan-th chan after the firstchan*/
;;;81     {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4615              MOV      r5,r2
;;;82     	u8 i;
;;;83     	struct chan_freq_power *cfp;
;;;84     	u8 cfp_no;
;;;85     
;;;86     	cfp = channel_freq_power_UN_BG;
000008  4e10              LDR      r6,|L8.76|
;;;87     	cfp_no = ARRAY_SIZE(channel_freq_power_UN_BG);
00000a  220e              MOVS     r2,#0xe
;;;88     
;;;89     	for (i = 0; i < cfp_no; i++) {
00000c  2100              MOVS     r1,#0
00000e  e008              B        |L8.34|
                  |L8.16|
;;;90     		if ((cfp + i)->channel == firstchan) {
000010  eb010041          ADD      r0,r1,r1,LSL #1
000014  f8360020          LDRH     r0,[r6,r0,LSL #2]
000018  42a0              CMP      r0,r4
00001a  d100              BNE      |L8.30|
;;;91     			lbs_deb_11d("firstchan found\n");
;;;92     			break;
00001c  e003              B        |L8.38|
                  |L8.30|
00001e  1c48              ADDS     r0,r1,#1              ;89
000020  b2c1              UXTB     r1,r0                 ;89
                  |L8.34|
000022  4291              CMP      r1,r2                 ;89
000024  dbf4              BLT      |L8.16|
                  |L8.38|
000026  bf00              NOP      
;;;93     		}
;;;94     	}
;;;95     
;;;96     	if (i < cfp_no) {
000028  4291              CMP      r1,r2
00002a  da0d              BGE      |L8.72|
;;;97     		/*if beyond the boundary */
;;;98     		if (i + nrchan < cfp_no) {
00002c  18c8              ADDS     r0,r1,r3
00002e  4290              CMP      r0,r2
000030  da0a              BGE      |L8.72|
;;;99     			*chan = (cfp + i + nrchan)->channel;
000032  eb010041          ADD      r0,r1,r1,LSL #1
000036  eb060080          ADD      r0,r6,r0,LSL #2
00003a  eb030743          ADD      r7,r3,r3,LSL #1
00003e  f8300027          LDRH     r0,[r0,r7,LSL #2]
000042  7028              STRB     r0,[r5,#0]
;;;100    			return 1;
000044  2001              MOVS     r0,#1
                  |L8.70|
;;;101    		}
;;;102    	}
;;;103    
;;;104    	return 0;
;;;105    }
000046  bdf0              POP      {r4-r7,pc}
                  |L8.72|
000048  2000              MOVS     r0,#0                 ;104
00004a  e7fc              B        |L8.70|
;;;106    
                          ENDP

                  |L8.76|
                          DCD      channel_freq_power_UN_BG

                          AREA ||i.lbs_get_scan_type_11d||, CODE, READONLY, ALIGN=1

                  lbs_get_scan_type_11d PROC
;;;408    */
;;;409    u8 lbs_get_scan_type_11d(u8 chan,
000000  b570              PUSH     {r4-r6,lr}
;;;410    			  struct parsed_region_chan_11d * parsed_region_chan)
;;;411    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;412    	u8 scan_type = CMD_SCAN_TYPE_PASSIVE;
000006  2601              MOVS     r6,#1
;;;413    
;;;414    	lbs_deb_enter(LBS_DEB_11D);
;;;415    
;;;416    	if (lbs_channel_known_11d(chan, parsed_region_chan)) {
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       lbs_channel_known_11d
000010  b100              CBZ      r0,|L9.20|
;;;417    		lbs_deb_11d("found, do active scan\n");
;;;418    		scan_type = CMD_SCAN_TYPE_ACTIVE;
000012  2600              MOVS     r6,#0
                  |L9.20|
;;;419    	} else {
;;;420    		lbs_deb_11d("not found, do passive scan\n");
;;;421    	}
;;;422    
;;;423    	//lbs_deb_leave_args(LBS_DEB_11D, "ret scan_type %d", scan_type);
;;;424    	return scan_type;
000014  4630              MOV      r0,r6
;;;425    
;;;426    }
000016  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP


                          AREA ||i.lbs_init_11d||, CODE, READONLY, ALIGN=1

                  lbs_init_11d PROC
;;;427    
;;;428    void lbs_init_11d(struct lbs_private *priv)
000000  b510              PUSH     {r4,lr}
;;;429    {
000002  4604              MOV      r4,r0
;;;430    	priv->enable11d = 0;
000004  2000              MOVS     r0,#0
000006  f8c4048c          STR      r0,[r4,#0x48c]
;;;431    	memset(&(priv->parsed_region_chan), 0,
00000a  2156              MOVS     r1,#0x56
00000c  f2044035          ADD      r0,r4,#0x435
000010  f7fffffe          BL       __aeabi_memclr
;;;432    	       sizeof(struct parsed_region_chan_11d));
;;;433    	return;
;;;434    }
000014  bd10              POP      {r4,pc}
;;;435    
                          ENDP


                          AREA ||i.lbs_parse_dnld_countryinfo_11d||, CODE, READONLY, ALIGN=1

                  lbs_parse_dnld_countryinfo_11d PROC
;;;596     */
;;;597    int lbs_parse_dnld_countryinfo_11d(struct lbs_private *priv,struct bss_descriptor * bss)
000000  b570              PUSH     {r4-r6,lr}
;;;598    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;599    	int ret;
;;;600    
;;;601    	lbs_deb_enter(LBS_DEB_11D);
;;;602    	if (priv->enable11d) {
000006  f8d4048c          LDR      r0,[r4,#0x48c]
00000a  b300              CBZ      r0,|L11.78|
;;;603    		memset(&priv->parsed_region_chan, 0,
00000c  2156              MOVS     r1,#0x56
00000e  f2044035          ADD      r0,r4,#0x435
000012  f7fffffe          BL       __aeabi_memclr
;;;604    		       sizeof(struct parsed_region_chan_11d));
;;;605    		ret = parse_domain_info_11d(&bss->countryinfo, 0,
000016  f2044235          ADD      r2,r4,#0x435
00001a  2100              MOVS     r1,#0
00001c  f106005b          ADD      r0,r6,#0x5b
000020  f7fffffe          BL       parse_domain_info_11d
000024  4605              MOV      r5,r0
;;;606    					       &priv->parsed_region_chan);
;;;607    
;;;608    		if (ret == -1) {
000026  1c68              ADDS     r0,r5,#1
000028  d100              BNE      |L11.44|
;;;609    			lbs_deb_11d("error parsing domain_info from AP\n");
;;;610    			goto done;
00002a  e012              B        |L11.82|
                  |L11.44|
;;;611    		}
;;;612    
;;;613    		memset(&priv->domainreg, 0,
00002c  21fd              MOVS     r1,#0xfd
00002e  f504704e          ADD      r0,r4,#0x338
000032  f7fffffe          BL       __aeabi_memclr4
;;;614    		       sizeof(struct lbs_802_11d_domain_reg));
;;;615    		generate_domain_info_11d(&priv->parsed_region_chan,
000036  f504714e          ADD      r1,r4,#0x338
00003a  f2044035          ADD      r0,r4,#0x435
00003e  f7fffffe          BL       generate_domain_info_11d
;;;616    				      &priv->domainreg);
;;;617    
;;;618    		ret = set_domain_info_11d(priv);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       set_domain_info_11d
000048  4605              MOV      r5,r0
;;;619    
;;;620    		if (ret) {
00004a  b105              CBZ      r5,|L11.78|
;;;621    			lbs_deb_11d("error setting domain info\n");
;;;622    			goto done;
00004c  e001              B        |L11.82|
                  |L11.78|
;;;623    		}
;;;624    	}
;;;625    	ret = 0;
00004e  2500              MOVS     r5,#0
;;;626    
;;;627    done:
000050  bf00              NOP      
                  |L11.82|
;;;628    	//lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
;;;629    	return ret;
000052  4628              MOV      r0,r5
;;;630    }
000054  bd70              POP      {r4-r6,pc}
;;;631    
                          ENDP


                          AREA ||i.lbs_region_2_code||, CODE, READONLY, ALIGN=2

                  lbs_region_2_code PROC
;;;42     
;;;43     static u8 lbs_region_2_code(u8 *region)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
000002  4605              MOV      r5,r0
;;;45     	u8 i;
;;;46     
;;;47     	for (i = 0; i < COUNTRY_CODE_LEN && region[i]; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L12.20|
                  |L12.8|
;;;48     		region[i] = toupper(region[i]);
000008  5d28              LDRB     r0,[r5,r4]
00000a  f7fffffe          BL       toupper
00000e  5528              STRB     r0,[r5,r4]
000010  1c60              ADDS     r0,r4,#1              ;47
000012  b2c4              UXTB     r4,r0                 ;47
                  |L12.20|
000014  2c03              CMP      r4,#3                 ;47
000016  da02              BGE      |L12.30|
000018  5d28              LDRB     r0,[r5,r4]            ;47
00001a  2800              CMP      r0,#0                 ;47
00001c  d1f4              BNE      |L12.8|
                  |L12.30|
;;;49     
;;;50     	for (i = 0; i < ARRAY_SIZE(region_code_mapping); i++) {
00001e  2400              MOVS     r4,#0
000020  e00e              B        |L12.64|
                  |L12.34|
;;;51     		if (!memcmp(region, region_code_mapping[i].region,
000022  480a              LDR      r0,|L12.76|
000024  eb000184          ADD      r1,r0,r4,LSL #2
000028  2203              MOVS     r2,#3
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       memcmp
000030  b920              CBNZ     r0,|L12.60|
;;;52     			    COUNTRY_CODE_LEN))
;;;53     			return (region_code_mapping[i].code);
000032  4806              LDR      r0,|L12.76|
000034  eb000084          ADD      r0,r0,r4,LSL #2
000038  78c0              LDRB     r0,[r0,#3]
                  |L12.58|
;;;54     	}
;;;55     
;;;56     	/* default is US */
;;;57     	return (region_code_mapping[0].code);
;;;58     }
00003a  bd70              POP      {r4-r6,pc}
                  |L12.60|
00003c  1c60              ADDS     r0,r4,#1              ;50
00003e  b2c4              UXTB     r4,r0                 ;50
                  |L12.64|
000040  2c09              CMP      r4,#9                 ;50
000042  d3ee              BCC      |L12.34|
000044  4801              LDR      r0,|L12.76|
000046  78c0              LDRB     r0,[r0,#3]            ;57  ; region_code_mapping
000048  e7f7              B        |L12.58|
;;;59     
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      region_code_mapping

                          AREA ||i.lbs_region_chan_supported_11d||, CODE, READONLY, ALIGN=1

                  lbs_region_chan_supported_11d PROC
;;;265    
;;;266    static u8 lbs_region_chan_supported_11d(u8 region, u8 chan)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;267    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;268    	struct chan_freq_power *cfp;
;;;269    	int cfp_no;
;;;270    	u8 idx;
;;;271    	int ret = 0;
000008  f04f0800          MOV      r8,#0
;;;272    
;;;273    	lbs_deb_enter(LBS_DEB_11D);
;;;274    	cfp = lbs_get_region_cfp_table(region, &cfp_no);
00000c  4669              MOV      r1,sp
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       lbs_get_region_cfp_table
000014  4605              MOV      r5,r0
;;;275    	if (cfp == NULL)
000016  b915              CBNZ     r5,|L13.30|
;;;276    		return 0;
000018  2000              MOVS     r0,#0
                  |L13.26|
;;;277    
;;;278    	for (idx = 0; idx < cfp_no; idx++) {
;;;279    		if (chan == (cfp + idx)->channel) {
;;;280    			/* If Mrvl Chip Supported? */
;;;281    			if ((cfp + idx)->unsupported) {
;;;282    				ret = 0;
;;;283    			} else {
;;;284    				ret = 1;
;;;285    			}
;;;286    			goto done;
;;;287    		}
;;;288    	}
;;;289    
;;;290    	/*chan is not in the region table */
;;;291    
;;;292    done:
;;;293    	//lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
;;;294    	return ret;
;;;295    }
00001a  e8bd83f8          POP      {r3-r9,pc}
                  |L13.30|
00001e  2400              MOVS     r4,#0                 ;278
000020  e013              B        |L13.74|
                  |L13.34|
000022  eb040044          ADD      r0,r4,r4,LSL #1       ;279
000026  f8350020          LDRH     r0,[r5,r0,LSL #2]     ;279
00002a  42b0              CMP      r0,r6                 ;279
00002c  d10b              BNE      |L13.70|
00002e  eb040044          ADD      r0,r4,r4,LSL #1       ;281
000032  eb050080          ADD      r0,r5,r0,LSL #2       ;281
000036  7a80              LDRB     r0,[r0,#0xa]          ;281
000038  b110              CBZ      r0,|L13.64|
00003a  f04f0800          MOV      r8,#0                 ;282
00003e  e001              B        |L13.68|
                  |L13.64|
000040  f04f0801          MOV      r8,#1                 ;284
                  |L13.68|
000044  e005              B        |L13.82|
                  |L13.70|
000046  1c60              ADDS     r0,r4,#1              ;278
000048  b2c4              UXTB     r4,r0                 ;278
                  |L13.74|
00004a  9800              LDR      r0,[sp,#0]            ;278
00004c  4284              CMP      r4,r0                 ;278
00004e  dbe8              BLT      |L13.34|
000050  bf00              NOP                            ;292
                  |L13.82|
000052  f00800ff          AND      r0,r8,#0xff           ;294
000056  e7e0              B        |L13.26|
;;;296    
                          ENDP


                          AREA ||i.lbs_ret_802_11d_domain_info||, CODE, READONLY, ALIGN=2

                  lbs_ret_802_11d_domain_info PROC
;;;552     */
;;;553    int lbs_ret_802_11d_domain_info(struct cmd_ds_command *resp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;554    {
000004  4604              MOV      r4,r0
;;;555    	struct cmd_ds_802_11d_domain_info *domaininfo = &resp->params.domaininforesp;
000006  f1040508          ADD      r5,r4,#8
;;;556    	struct mrvl_ie_domain_param_set *domain = &domaininfo->domain;
00000a  1cae              ADDS     r6,r5,#2
;;;557    	u16 action = le16_to_cpu(domaininfo->action);
00000c  882f              LDRH     r7,[r5,#0]
;;;558    	s16 ret = 0;
00000e  f04f0800          MOV      r8,#0
;;;559    	u8 nr_subband = 0;
000012  46c1              MOV      r9,r8
;;;560    
;;;561    	lbs_deb_enter(LBS_DEB_11D);
;;;562    
;;;563    	lbs_deb_hex(LBS_DEB_11D, "domain info resp", (u8 *) resp,
000014  8863              LDRH     r3,[r4,#2]
000016  4622              MOV      r2,r4
000018  a10e              ADR      r1,|L14.84|
00001a  f44f6080          MOV      r0,#0x400
00001e  f7fffffe          BL       lbs_hex
;;;564    		(int)le16_to_cpu(resp->size));
;;;565    
;;;566    	nr_subband = (le16_to_cpu(domain->header.len) - COUNTRY_CODE_LEN) /
000022  8870              LDRH     r0,[r6,#2]
000024  1ec0              SUBS     r0,r0,#3
000026  2103              MOVS     r1,#3
000028  fbb0f0f1          UDIV     r0,r0,r1
00002c  f00009ff          AND      r9,r0,#0xff
;;;567    		      sizeof(struct ieee_subbandset);
;;;568    
;;;569    	lbs_deb_11d("domain info resp: nr_subband %d\n", nr_subband);
;;;570    
;;;571    	if (nr_subband > MRVDRV_MAX_SUBBAND_802_11D) {
000030  f1b90f53          CMP      r9,#0x53
000034  dd02              BLE      |L14.60|
;;;572    		lbs_deb_11d("Invalid Numrer of Subband returned!!\n");
;;;573    		return -1;
000036  1f08              SUBS     r0,r1,#4
                  |L14.56|
;;;574    	}
;;;575    
;;;576    	switch (action) {
;;;577    	case CMD_ACT_SET:	/*Proc Set action */
;;;578    		break;
;;;579    
;;;580    	case CMD_ACT_GET:
;;;581    		break;
;;;582    	default:
;;;583    		lbs_deb_11d("Invalid action:%d\n", domaininfo->action);
;;;584    		ret = -1;
;;;585    		break;
;;;586    	}
;;;587    
;;;588    	//lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
;;;589    	return ret;
;;;590    }
000038  e8bd87f0          POP      {r4-r10,pc}
                  |L14.60|
00003c  b117              CBZ      r7,|L14.68|
00003e  2f01              CMP      r7,#1                 ;576
000040  d101              BNE      |L14.70|
000042  e003              B        |L14.76|
                  |L14.68|
000044  e002              B        |L14.76|
                  |L14.70|
000046  f04f38ff          MOV      r8,#0xffffffff        ;584
00004a  bf00              NOP                            ;585
                  |L14.76|
00004c  bf00              NOP                            ;578
00004e  4640              MOV      r0,r8                 ;589
000050  e7f2              B        |L14.56|
;;;591    
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
000054  646f6d61          DCB      "domain info resp",0
000058  696e2069
00005c  6e666f20
000060  72657370
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.lbs_set_universaltable||, CODE, READONLY, ALIGN=2

                  lbs_set_universaltable PROC
;;;465    //设置要扫描的通道，就是一般的802.11b/g所支持的2.4GHZ所有信道，一共14个
;;;466    int lbs_set_universaltable(struct lbs_private *priv, u8 band)
000000  b530              PUSH     {r4,r5,lr}
;;;467    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;468    	u16 size = sizeof(struct chan_freq_power);
000006  240c              MOVS     r4,#0xc
;;;469    	u16 i = 0;
000008  2100              MOVS     r1,#0
;;;470    
;;;471    	memset(priv->universal_channel, 0,
00000a  f5027040          ADD      r0,r2,#0x300
00000e  2500              MOVS     r5,#0
000010  6285              STR      r5,[r0,#0x28]
000012  62c5              STR      r5,[r0,#0x2c]
000014  6305              STR      r5,[r0,#0x30]
000016  6345              STR      r5,[r0,#0x34]
;;;472    	       sizeof(priv->universal_channel));
;;;473    
;;;474    	priv->universal_channel[i].nrcfp =
000018  20a8              MOVS     r0,#0xa8
00001a  fbb0f0f4          UDIV     r0,r0,r4
00001e  b2c5              UXTB     r5,r0
000020  f502704a          ADD      r0,r2,#0x328
000024  eb0000c1          ADD      r0,r0,r1,LSL #3
000028  70c5              STRB     r5,[r0,#3]
;;;475    	    sizeof(channel_freq_power_UN_BG) / size;
;;;476    	lbs_deb_11d("BG-band nrcfp %d\n",
;;;477    	       priv->universal_channel[i].nrcfp);
;;;478    
;;;479    	priv->universal_channel[i].CFP = channel_freq_power_UN_BG;
00002a  4d0b              LDR      r5,|L15.88|
00002c  f502704a          ADD      r0,r2,#0x328
000030  eb0000c1          ADD      r0,r0,r1,LSL #3
000034  6045              STR      r5,[r0,#4]
;;;480    	priv->universal_channel[i].valid = 1;
000036  2501              MOVS     r5,#1
000038  f502704a          ADD      r0,r2,#0x328
00003c  f8005031          STRB     r5,[r0,r1,LSL #3]
;;;481    	priv->universal_channel[i].region = UNIVERSAL_REGION_CODE;
000040  25ff              MOVS     r5,#0xff
000042  eb0000c1          ADD      r0,r0,r1,LSL #3
000046  7045              STRB     r5,[r0,#1]
;;;482    	priv->universal_channel[i].band = band;
000048  f502704a          ADD      r0,r2,#0x328
00004c  eb0000c1          ADD      r0,r0,r1,LSL #3
000050  7083              STRB     r3,[r0,#2]
;;;483    	i++;
000052  1c49              ADDS     r1,r1,#1
;;;484    
;;;485    	return 0;
000054  2000              MOVS     r0,#0
;;;486    }
000056  bd30              POP      {r4,r5,pc}
;;;487    
                          ENDP

                  |L15.88|
                          DCD      channel_freq_power_UN_BG

                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.parse_domain_info_11d||, CODE, READONLY, ALIGN=2

                  parse_domain_info_11d PROC
;;;302    */
;;;303    static int parse_domain_info_11d(struct ieee_ie_country_info_full_set *countryinfo,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;304    				 u8 band,
;;;305    				 struct parsed_region_chan_11d *parsed_region_chan)
;;;306    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;307    	u8 nr_subband, nrchan;
;;;308    	u8 lastchan, firstchan;
;;;309    	u8 region;
;;;310    	u8 curchan = 0;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;311    
;;;312    	u8 idx = 0;		/*chan index in parsed_region_chan */
00000e  2700              MOVS     r7,#0
;;;313    
;;;314    	u8 j, i;
;;;315    
;;;316    	lbs_deb_enter(LBS_DEB_11D);
;;;317    
;;;318    	/*validation Rules:
;;;319    	   1. valid region Code
;;;320    	   2. First Chan increment
;;;321    	   3. channel range no overlap
;;;322    	   4. channel is valid?
;;;323    	   5. channel is supported by region?
;;;324    	   6. Others
;;;325    	 */
;;;326    
;;;327    	lbs_deb_hex(LBS_DEB_11D, "countryinfo", (u8 *) countryinfo, 30);
000010  231e              MOVS     r3,#0x1e
000012  4622              MOV      r2,r4
000014  a13e              ADR      r1,|L17.272|
000016  f44f6080          MOV      r0,#0x400
00001a  f7fffffe          BL       lbs_hex
;;;328    
;;;329    	if ((*(countryinfo->countrycode)) == 0
00001e  78a0              LDRB     r0,[r4,#2]
000020  b110              CBZ      r0,|L17.40|
;;;330    	    || (countryinfo->header.len <= COUNTRY_CODE_LEN)) {
000022  7860              LDRB     r0,[r4,#1]
000024  2803              CMP      r0,#3
000026  dc00              BGT      |L17.42|
                  |L17.40|
;;;331    		/* No region Info or Wrong region info: treat as No 11D info */
;;;332    		goto done;
000028  e06d              B        |L17.262|
                  |L17.42|
;;;333    	}
;;;334    
;;;335    	/*Step1: check region_code */
;;;336    	parsed_region_chan->region = region =
00002a  1ca0              ADDS     r0,r4,#2
00002c  f7fffffe          BL       lbs_region_2_code
000030  9001              STR      r0,[sp,#4]
000032  7068              STRB     r0,[r5,#1]
;;;337    	    lbs_region_2_code(countryinfo->countrycode);
;;;338    
;;;339    	lbs_deb_11d("regioncode=%x\n", (u8) parsed_region_chan->region);
;;;340    	lbs_deb_hex(LBS_DEB_11D, "countrycode", (u8 *)countryinfo->countrycode,
000034  2303              MOVS     r3,#3
000036  1ca2              ADDS     r2,r4,#2
000038  a138              ADR      r1,|L17.284|
00003a  f44f6080          MOV      r0,#0x400
00003e  f7fffffe          BL       lbs_hex
;;;341    		COUNTRY_CODE_LEN);
;;;342    
;;;343    	parsed_region_chan->band = band;
000042  f8859000          STRB     r9,[r5,#0]
;;;344    
;;;345    	memcpy(parsed_region_chan->countrycode, countryinfo->countrycode,
000046  8860              LDRH     r0,[r4,#2]
000048  8068              STRH     r0,[r5,#2]
00004a  7920              LDRB     r0,[r4,#4]
00004c  7128              STRB     r0,[r5,#4]
;;;346    	       COUNTRY_CODE_LEN);
;;;347    
;;;348    	nr_subband = (countryinfo->header.len - COUNTRY_CODE_LEN) /
00004e  7860              LDRB     r0,[r4,#1]
000050  1ec0              SUBS     r0,r0,#3
000052  2103              MOVS     r1,#3
000054  fbb0f0f1          UDIV     r0,r0,r1
000058  f0000aff          AND      r10,r0,#0xff
;;;349    	    sizeof(struct ieee_subbandset);
;;;350    
;;;351    	for (j = 0, lastchan = 0; j < nr_subband; j++) {
00005c  2600              MOVS     r6,#0
00005e  2000              MOVS     r0,#0
000060  9003              STR      r0,[sp,#0xc]
000062  e041              B        |L17.232|
                  |L17.100|
;;;352    
;;;353    		if (countryinfo->subband[j].firstchan <= lastchan) {
000064  eb060146          ADD      r1,r6,r6,LSL #1
000068  1d60              ADDS     r0,r4,#5
00006a  5c41              LDRB     r1,[r0,r1]
00006c  9803              LDR      r0,[sp,#0xc]
00006e  4281              CMP      r1,r0
000070  dc00              BGT      |L17.116|
;;;354    			/*Step2&3. Check First Chan Num increment and no overlap */
;;;355    			lbs_deb_11d("chan %d>%d, overlap\n",
;;;356    			       countryinfo->subband[j].firstchan, lastchan);
;;;357    			continue;
000072  e037              B        |L17.228|
                  |L17.116|
;;;358    		}
;;;359    
;;;360    		firstchan = countryinfo->subband[j].firstchan;
000074  eb060146          ADD      r1,r6,r6,LSL #1
000078  1d60              ADDS     r0,r4,#5
00007a  5c40              LDRB     r0,[r0,r1]
00007c  9002              STR      r0,[sp,#8]
;;;361    		nrchan = countryinfo->subband[j].nrchan;
00007e  eb060146          ADD      r1,r6,r6,LSL #1
000082  1d60              ADDS     r0,r4,#5
000084  4408              ADD      r0,r0,r1
000086  f890b001          LDRB     r11,[r0,#1]
;;;362    
;;;363    		for (i = 0; idx < MAX_NO_OF_CHAN && i < nrchan; i++) {
00008a  f04f0800          MOV      r8,#0
00008e  e023              B        |L17.216|
                  |L17.144|
;;;364    			/*step4: channel is supported? */
;;;365    
;;;366    			if (!lbs_get_chan_11d(firstchan, i, &curchan)) {
000090  466a              MOV      r2,sp
000092  4641              MOV      r1,r8
000094  9802              LDR      r0,[sp,#8]
000096  f7fffffe          BL       lbs_get_chan_11d
00009a  b900              CBNZ     r0,|L17.158|
;;;367    				/* Chan is not found in UN table */
;;;368    				lbs_deb_11d("chan is not supported: %d \n", i);
;;;369    				break;
00009c  e020              B        |L17.224|
                  |L17.158|
;;;370    			}
;;;371    
;;;372    			lastchan = curchan;
00009e  f89d0000          LDRB     r0,[sp,#0]
0000a2  9003              STR      r0,[sp,#0xc]
;;;373    
;;;374    			if (lbs_region_chan_supported_11d(region, curchan)) {
0000a4  f89d1000          LDRB     r1,[sp,#0]
0000a8  9801              LDR      r0,[sp,#4]
0000aa  f7fffffe          BL       lbs_region_chan_supported_11d
0000ae  b178              CBZ      r0,|L17.208|
;;;375    				/*step5: Check if curchan is supported by mrvl in region */
;;;376    				parsed_region_chan->chanpwr[idx].chan = curchan;
0000b0  f89d1000          LDRB     r1,[sp,#0]
0000b4  1d68              ADDS     r0,r5,#5
0000b6  f8001017          STRB     r1,[r0,r7,LSL #1]
;;;377    				parsed_region_chan->chanpwr[idx].pwr =
0000ba  eb060146          ADD      r1,r6,r6,LSL #1
0000be  1d60              ADDS     r0,r4,#5
0000c0  4408              ADD      r0,r0,r1
0000c2  7881              LDRB     r1,[r0,#2]
0000c4  1d68              ADDS     r0,r5,#5
0000c6  eb000047          ADD      r0,r0,r7,LSL #1
0000ca  7041              STRB     r1,[r0,#1]
;;;378    				    countryinfo->subband[j].maxtxpwr;
;;;379    				idx++;
0000cc  1c78              ADDS     r0,r7,#1
0000ce  b2c7              UXTB     r7,r0
                  |L17.208|
0000d0  f1080001          ADD      r0,r8,#1              ;363
0000d4  f00008ff          AND      r8,r0,#0xff           ;363
                  |L17.216|
0000d8  2f28              CMP      r7,#0x28              ;363
0000da  da01              BGE      |L17.224|
0000dc  45d8              CMP      r8,r11                ;363
0000de  dbd7              BLT      |L17.144|
                  |L17.224|
0000e0  bf00              NOP                            ;369
0000e2  bf00              NOP                            ;357
                  |L17.228|
0000e4  1c70              ADDS     r0,r6,#1              ;351
0000e6  b2c6              UXTB     r6,r0                 ;351
                  |L17.232|
0000e8  4556              CMP      r6,r10                ;351
0000ea  dbbb              BLT      |L17.100|
;;;380    			} else {
;;;381    				/*not supported and ignore the chan */
;;;382    				lbs_deb_11d(
;;;383    				       "i %d, chan %d unsupported in region %x, band %d\n",
;;;384    				       i, curchan, region, band);
;;;385    			}
;;;386    		}
;;;387    
;;;388    		/*Step6: Add other checking if any */
;;;389    
;;;390    	}
;;;391    
;;;392    	parsed_region_chan->nr_chan = idx;
0000ec  f8857055          STRB     r7,[r5,#0x55]
;;;393    
;;;394    	lbs_deb_11d("nrchan=%x\n", parsed_region_chan->nr_chan);
;;;395    	lbs_deb_hex(LBS_DEB_11D, "parsed_region_chan", (u8 *) parsed_region_chan,
0000f0  2156              MOVS     r1,#0x56
0000f2  fb07f001          MUL      r0,r7,r1
0000f6  1d43              ADDS     r3,r0,#5
0000f8  462a              MOV      r2,r5
0000fa  a10b              ADR      r1,|L17.296|
0000fc  f44f6080          MOV      r0,#0x400
000100  f7fffffe          BL       lbs_hex
;;;396    		2 + COUNTRY_CODE_LEN + sizeof(struct parsed_region_chan_11d) * idx);
;;;397    
;;;398    done:
000104  bf00              NOP      
                  |L17.262|
;;;399    	lbs_deb_enter(LBS_DEB_11D);
;;;400    	return 0;
000106  2000              MOVS     r0,#0
;;;401    }
000108  b004              ADD      sp,sp,#0x10
00010a  e8bd9ff0          POP      {r4-r12,pc}
;;;402    
                          ENDP

00010e  0000              DCW      0x0000
                  |L17.272|
000110  636f756e          DCB      "countryinfo",0
000114  74727969
000118  6e666f00
                  |L17.284|
00011c  636f756e          DCB      "countrycode",0
000120  74727963
000124  6f646500
                  |L17.296|
000128  70617273          DCB      "parsed_region_chan",0
00012c  65645f72
000130  6567696f
000134  6e5f6368
000138  616e00  
00013b  00                DCB      0

                          AREA ||i.set_domain_info_11d||, CODE, READONLY, ALIGN=1

                  set_domain_info_11d PROC
;;;440    */
;;;441    static int set_domain_info_11d(struct lbs_private *priv)
000000  b57c              PUSH     {r2-r6,lr}
;;;442    {
000002  4604              MOV      r4,r0
;;;443    	int ret;
;;;444    
;;;445    	if (!priv->enable11d) {
000004  f8d4048c          LDR      r0,[r4,#0x48c]
000008  b908              CBNZ     r0,|L18.14|
;;;446    		lbs_deb_11d("dnld domain Info with 11d disabled\n");
;;;447    		return 0;
00000a  2000              MOVS     r0,#0
                  |L18.12|
;;;448    	}
;;;449    
;;;450    	ret = lbs_prepare_and_send_command(priv, CMD_802_11D_DOMAIN_INFO,
;;;451    				    CMD_ACT_SET,
;;;452    				    CMD_OPTION_WAITFORRSP, 0, NULL);
;;;453    	if (ret)
;;;454    		lbs_deb_11d("fail to dnld domain info\n");
;;;455    
;;;456    	return ret;
;;;457    }
00000c  bd7c              POP      {r2-r6,pc}
                  |L18.14|
00000e  2300              MOVS     r3,#0                 ;450
000010  9300              STR      r3,[sp,#0]            ;450
000012  9301              STR      r3,[sp,#4]            ;450
000014  2302              MOVS     r3,#2                 ;450
000016  2201              MOVS     r2,#1                 ;450
000018  215b              MOVS     r1,#0x5b              ;450
00001a  4620              MOV      r0,r4                 ;450
00001c  f7fffffe          BL       lbs_prepare_and_send_command
000020  4605              MOV      r5,r0                 ;450
000022  4628              MOV      r0,r5                 ;456
000024  e7f2              B        |L18.12|
;;;458    
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L19.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L19.32|
                  |L19.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L19.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L19.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L19.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L19.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L19.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L19.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  region_code_mapping
000000  55532010          DCB      0x55,0x53,0x20,0x10
000004  43412010          DCB      0x43,0x41,0x20,0x10
000008  53472010          DCB      0x53,0x47,0x20,0x10
00000c  45552030          DCB      0x45,0x55,0x20,0x30
000010  41552030          DCB      0x41,0x55,0x20,0x30
000014  4b522030          DCB      0x4b,0x52,0x20,0x30
000018  45532031          DCB      0x45,0x53,0x20,0x31
00001c  46522032          DCB      0x46,0x52,0x20,0x32
000020  4a502040          DCB      0x4a,0x50,0x20,0x40
                  channel_freq_power_UN_BG
000024  0001              DCW      0x0001
000026  0000              DCB      0x00,0x00
                          DCD      0x0000096c
00002c  000a              DCW      0x000a
00002e  0000              DCB      0x00,0x00
000030  0002              DCW      0x0002
000032  0000              DCB      0x00,0x00
                          DCD      0x00000971
000038  000a              DCW      0x000a
00003a  0000              DCB      0x00,0x00
00003c  0003              DCW      0x0003
00003e  0000              DCB      0x00,0x00
                          DCD      0x00000976
000044  000a              DCW      0x000a
000046  0000              DCB      0x00,0x00
000048  0004              DCW      0x0004
00004a  0000              DCB      0x00,0x00
                          DCD      0x0000097b
000050  000a              DCW      0x000a
000052  0000              DCB      0x00,0x00
000054  0005              DCW      0x0005
000056  0000              DCB      0x00,0x00
                          DCD      0x00000980
00005c  000a              DCW      0x000a
00005e  0000              DCB      0x00,0x00
000060  0006              DCW      0x0006
000062  0000              DCB      0x00,0x00
                          DCD      0x00000985
000068  000a              DCW      0x000a
00006a  0000              DCB      0x00,0x00
00006c  0007              DCW      0x0007
00006e  0000              DCB      0x00,0x00
                          DCD      0x0000098a
000074  000a              DCW      0x000a
000076  0000              DCB      0x00,0x00
000078  0008              DCW      0x0008
00007a  0000              DCB      0x00,0x00
                          DCD      0x0000098f
000080  000a              DCW      0x000a
000082  0000              DCB      0x00,0x00
000084  0009              DCW      0x0009
000086  0000              DCB      0x00,0x00
                          DCD      0x00000994
00008c  000a              DCW      0x000a
00008e  0000              DCB      0x00,0x00
000090  000a              DCW      0x000a
000092  0000              DCB      0x00,0x00
                          DCD      0x00000999
000098  000a              DCW      0x000a
00009a  0000              DCB      0x00,0x00
00009c  000b              DCW      0x000b
00009e  0000              DCB      0x00,0x00
                          DCD      0x0000099e
0000a4  000a              DCW      0x000a
0000a6  0000              DCB      0x00,0x00
0000a8  000c              DCW      0x000c
0000aa  0000              DCB      0x00,0x00
                          DCD      0x000009a3
0000b0  000a              DCW      0x000a
0000b2  0000              DCB      0x00,0x00
0000b4  000d              DCW      0x000d
0000b6  0000              DCB      0x00,0x00
                          DCD      0x000009a8
0000bc  000a              DCW      0x000a
0000be  0000              DCB      0x00,0x00
0000c0  000e              DCW      0x000e
0000c2  0000              DCB      0x00,0x00
                          DCD      0x000009b4
0000c8  000a              DCW      0x000a
0000ca  0000              DCB      0x00,0x00
