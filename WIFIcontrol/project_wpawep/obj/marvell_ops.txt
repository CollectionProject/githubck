; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\marvell_ops.o --depend=.\obj\marvell_ops.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\marvell_ops.crf ..\marvel\driver\src\marvell_ops.c]
                          THUMB

                          AREA ||i.__lbs_set_key_material||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  __lbs_set_key_material PROC
;;;249    
;;;250    int __lbs_set_key_material(int key_type,int key_info,u8 *key, u16 key_len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;251    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;252        printf("MARVELL TIME OUT TYPE %d , info %d \n",key_type,key_info);
00000a  462a              MOV      r2,r5
00000c  4621              MOV      r1,r4
00000e  a006              ADR      r0,|L1.40|
000010  f7fffffe          BL       __2printf
;;;253        return lbs_set_key_material(pgmarvel_priv,key_type,key_info,key,key_len);
000014  4633              MOV      r3,r6
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  480d              LDR      r0,|L1.80|
00001c  9700              STR      r7,[sp,#0]
00001e  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
000020  f7fffffe          BL       lbs_set_key_material
;;;254    }
000024  bdf8              POP      {r3-r7,pc}
;;;255    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
000028  4d415256          DCB      "MARVELL TIME OUT TYPE %d , info %d \n",0
00002c  454c4c20
000030  54494d45
000034  204f5554
000038  20545950
00003c  45202564
000040  202c2069
000044  6e666f20
000048  2564200a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L1.80|
                          DCD      pgmarvel_priv

                          AREA ||i.init_marvell_driver||, CODE, READONLY, ALIGN=2

                  init_marvell_driver PROC
;;;17     ***********************************************************************************************/
;;;18     struct lbs_private * init_marvell_driver(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;19     {
;;;20         struct mmc_host *host;
;;;21         struct mmc_card *card;
;;;22         struct sdio_func *func;
;;;23         struct lbs_private *priv;
;;;24         MAR_POW(1);                 //断开模块电源为sdio枚举做准备
000004  4817              LDR      r0,|L2.100|
000006  6800              LDR      r0,[r0,#0]
000008  f4405080          ORR      r0,r0,#0x1000
00000c  4916              LDR      r1,|L2.104|
00000e  f8c10c0c          STR      r0,[r1,#0xc0c]
;;;25         host=stm32_probe();
000012  f7fffffe          BL       stm32_probe
000016  4605              MOV      r5,r0
;;;26         MAR_POW(0);                 //上电模块电源，sdio正常复位
000018  4813              LDR      r0,|L2.104|
00001a  f8d00c0c          LDR      r0,[r0,#0xc0c]
00001e  f4205080          BIC      r0,r0,#0x1000
000022  4911              LDR      r1,|L2.104|
000024  f8c10c0c          STR      r0,[r1,#0xc0c]
;;;27         mmc_rescan(host);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       mmc_rescan
;;;28         printk("Init marvel driver [ok]\r\n");
00002e  a00f              ADR      r0,|L2.108|
000030  f7fffffe          BL       __2printf
;;;29     
;;;30         card=host->card;            //取出card
000034  6d6f              LDR      r7,[r5,#0x54]
;;;31         func=card->sdio_func[0];    //取出第一个func
000036  f8d760ac          LDR      r6,[r7,#0xac]
;;;32         if(func){
00003a  b176              CBZ      r6,|L2.90|
;;;33             priv=(struct lbs_private *)sdio_bus_probe(func);
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       sdio_bus_probe
000042  4604              MOV      r4,r0
;;;34             if(priv){
000044  b12c              CBZ      r4,|L2.82|
;;;35                 printk("Device probe success!\n");
000046  a010              ADR      r0,|L2.136|
000048  f7fffffe          BL       __2printf
;;;36                 return priv;
00004c  4620              MOV      r0,r4
                  |L2.78|
;;;37             }
;;;38             else
;;;39                 printk("Device probe failed!\n");
;;;40         }
;;;41         else
;;;42             printk("cann't find a function device!\n");
;;;43         return 0;
;;;44     }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L2.82|
000052  a013              ADR      r0,|L2.160|
000054  f7fffffe          BL       __2printf
000058  e002              B        |L2.96|
                  |L2.90|
00005a  a017              ADR      r0,|L2.184|
00005c  f7fffffe          BL       __2printf
                  |L2.96|
000060  2000              MOVS     r0,#0                 ;43
000062  e7f4              B        |L2.78|
;;;45     
                          ENDP

                  |L2.100|
                          DCD      0x40010c0c
                  |L2.104|
                          DCD      0x40010000
                  |L2.108|
00006c  496e6974          DCB      "Init marvel driver [ok]\r\n",0
000070  206d6172
000074  76656c20
000078  64726976
00007c  6572205b
000080  6f6b5d0d
000084  0a00    
000086  00                DCB      0
000087  00                DCB      0
                  |L2.136|
000088  44657669          DCB      "Device probe success!\n",0
00008c  63652070
000090  726f6265
000094  20737563
000098  63657373
00009c  210a00  
00009f  00                DCB      0
                  |L2.160|
0000a0  44657669          DCB      "Device probe failed!\n",0
0000a4  63652070
0000a8  726f6265
0000ac  20666169
0000b0  6c656421
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L2.184|
0000b8  63616e6e          DCB      "cann't find a function device!\n",0
0000bc  27742066
0000c0  696e6420
0000c4  61206675
0000c8  6e637469
0000cc  6f6e2064
0000d0  65766963
0000d4  65210a00

                          AREA ||i.init_sleep_mode||, CODE, READONLY, ALIGN=2

                  init_sleep_mode PROC
;;;215    struct cmd_confirm_sleep confirm_sleep;
;;;216    void init_sleep_mode(void)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218        memset(&confirm_sleep, 0, sizeof(confirm_sleep));
000002  2112              MOVS     r1,#0x12
000004  4805              LDR      r0,|L3.28|
000006  f7fffffe          BL       __aeabi_memclr
;;;219        confirm_sleep.hdr.command = cpu_to_le16(CMD_802_11_PS_MODE);
00000a  2021              MOVS     r0,#0x21
00000c  4903              LDR      r1,|L3.28|
00000e  8008              STRH     r0,[r1,#0]
;;;220        confirm_sleep.hdr.size = cpu_to_le16(sizeof(confirm_sleep));
000010  2012              MOVS     r0,#0x12
000012  8048              STRH     r0,[r1,#2]
;;;221        confirm_sleep.action = cpu_to_le16(CMD_SUBCMD_SLEEP_CONFIRMED);
000014  2034              MOVS     r0,#0x34
000016  8108              STRH     r0,[r1,#8]
;;;222    }
000018  bd10              POP      {r4,pc}
;;;223    /***********************************************************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      confirm_sleep

                          AREA ||i.lbs_hard_start_xmit||, CODE, READONLY, ALIGN=1

                  lbs_hard_start_xmit PROC
;;;113    ***********************************************************************************************/
;;;114    char  lbs_hard_start_xmit(struct lbs_private *priv,struct eth_packet * tx_ethpkt)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;115    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;116        struct txpd *txpd;//这是用于控制硬件发送的头信息，必须放在数据包前面写入网卡
;;;117        char *p802x_hdr;
;;;118        unsigned int pkt_len;
;;;119        int ret = 0;
000008  f04f0900          MOV      r9,#0
;;;120        lbs_deb_enter(LBS_DEB_TX);
;;;121        if (priv->surpriseremoved)
00000c  f89401ec          LDRB     r0,[r4,#0x1ec]
000010  b100              CBZ      r0,|L4.20|
;;;122            goto free;
000012  e025              B        |L4.96|
                  |L4.20|
;;;123    
;;;124        if (!tx_ethpkt->len || (tx_ethpkt->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {
000014  8830              LDRH     r0,[r6,#0]
000016  b120              CBZ      r0,|L4.34|
000018  8830              LDRH     r0,[r6,#0]
00001a  f2406126          MOV      r1,#0x626
00001e  4288              CMP      r0,r1
000020  d900              BLS      |L4.36|
                  |L4.34|
;;;125            lbs_deb_tx("tx err: skb length %d 0 or > %zd\n",
;;;126                       tx_ethpkt->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);
;;;127            goto free;
000022  e01d              B        |L4.96|
                  |L4.36|
;;;128        }
;;;129    
;;;130        txpd=(void *)&priv->resp_buf[0][4];
000024  f5046594          ADD      r5,r4,#0x4a0
;;;131        memset(txpd, 0, sizeof(struct txpd));
000028  2118              MOVS     r1,#0x18
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       __aeabi_memclr
;;;132    
;;;133        p802x_hdr = tx_ethpkt->data;//802.3 mac头
000030  f8d68004          LDR      r8,[r6,#4]
;;;134        pkt_len = tx_ethpkt->len;
000034  8837              LDRH     r7,[r6,#0]
;;;135        /* copy destination address from 802.3 header */
;;;136        //接收地址
;;;137        memcpy(txpd->tx_dest_addr_high, p802x_hdr, ETH_ALEN);
000036  f8d80000          LDR      r0,[r8,#0]
00003a  f8c5000e          STR      r0,[r5,#0xe]
00003e  f8b80004          LDRH     r0,[r8,#4]
000042  8268              STRH     r0,[r5,#0x12]
;;;138        txpd->tx_packet_length = cpu_to_le16(pkt_len);//802.3的有效数据长度，固件会自动封装802.11数据帧
000044  81af              STRH     r7,[r5,#0xc]
;;;139        txpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));//数据的偏移
000046  2018              MOVS     r0,#0x18
000048  60a8              STR      r0,[r5,#8]
;;;140        memcpy(&txpd[1], p802x_hdr, le16_to_cpu(txpd->tx_packet_length));//真正数据存放的地方
00004a  89aa              LDRH     r2,[r5,#0xc]
00004c  4641              MOV      r1,r8
00004e  f1050018          ADD      r0,r5,#0x18
000052  f7fffffe          BL       __aeabi_memcpy
;;;141        priv->resp_len[0] = pkt_len + sizeof(struct txpd);//是否有数据需要发送靠的就是判断邋pkt_len是否值
000056  f1070018          ADD      r0,r7,#0x18
00005a  f8c40498          STR      r0,[r4,#0x498]
;;;142        lbs_deb_tx("%s lined up packet\n", __func__);
;;;143        free:
00005e  bf00              NOP      
                  |L4.96|
;;;144        if (priv->resp_len[0] > 0) {//发送数据处理//这里就是调用if_sdio_host_to_card这个函数来处理向设备发送数据
000060  f8d40498          LDR      r0,[r4,#0x498]
000064  b190              CBZ      r0,|L4.140|
;;;145            ret=if_sdio_send_data(priv,priv->resp_buf[0],
000066  f8d40498          LDR      r0,[r4,#0x498]
00006a  b282              UXTH     r2,r0
00006c  f204419c          ADD      r1,r4,#0x49c
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       if_sdio_send_data
000076  4681              MOV      r9,r0
;;;146                                  priv->resp_len[0]);
;;;147            if (ret) {
000078  f1b90f00          CMP      r9,#0
00007c  d003              BEQ      |L4.134|
;;;148                lbs_deb_tx("host_to_card failed %d\n", ret);
;;;149                priv->dnld_sent = DNLD_RES_RECEIVED;
00007e  2100              MOVS     r1,#0
000080  f24100b8          MOV      r0,#0x10b8
000084  5501              STRB     r1,[r0,r4]
                  |L4.134|
;;;150            }
;;;151            priv->resp_len[0] = 0;
000086  2000              MOVS     r0,#0
000088  f8c40498          STR      r0,[r4,#0x498]
                  |L4.140|
;;;152        }
;;;153        wait_for_data_end();
00008c  f7fffffe          BL       wait_for_data_end
;;;154        lbs_deb_leave_args(LBS_DEB_TX, ret);
;;;155        return ret;
000090  f00900ff          AND      r0,r9,#0xff
;;;156    }
000094  e8bd87f0          POP      {r4-r10,pc}
;;;157    
                          ENDP


                          AREA ||i.lbs_ps_sleep||, CODE, READONLY, ALIGN=1

                  lbs_ps_sleep PROC
;;;194    ***********************************************************************************************/
;;;195    void lbs_ps_sleep(struct lbs_private *priv)
000000  b57c              PUSH     {r2-r6,lr}
;;;196    {
000002  4605              MOV      r5,r0
;;;197        int wait_option=CMD_OPTION_WAITFORRSP;
000004  2402              MOVS     r4,#2
;;;198        lbs_deb_enter(LBS_DEB_HOST);
;;;199        /*
;;;200    	 * PS is currently supported only in Infrastructure mode
;;;201    	 * Remove this check if it is to be supported in IBSS mode also
;;;202    	 */
;;;203        lbs_prepare_and_send_command(priv, CMD_802_11_PS_MODE,
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
00000a  9301              STR      r3,[sp,#4]
00000c  4623              MOV      r3,r4
00000e  2230              MOVS     r2,#0x30
000010  2121              MOVS     r1,#0x21
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       lbs_prepare_and_send_command
;;;204                                     CMD_SUBCMD_ENTER_PS, wait_option, 0, NULL);
;;;205    
;;;206        lbs_deb_leave(LBS_DEB_HOST);
;;;207    }
000018  bd7c              POP      {r2-r6,pc}
;;;208    
                          ENDP


                          AREA ||i.lbs_ps_wakeup||, CODE, READONLY, ALIGN=1

                  lbs_ps_wakeup PROC
;;;176    ***********************************************************************************************/
;;;177    void lbs_ps_wakeup(struct lbs_private *priv) 
000000  b53e              PUSH     {r1-r5,lr}
;;;178    {
000002  4605              MOV      r5,r0
;;;179        __le32 Localpsmode;
;;;180        int wait_option=CMD_OPTION_WAITFORRSP;
000004  2402              MOVS     r4,#2
;;;181        lbs_deb_enter(LBS_DEB_HOST);
;;;182        Localpsmode = cpu_to_le32(LBS802_11POWERMODECAM);
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;183        lbs_prepare_and_send_command(priv, CMD_802_11_PS_MODE,//发送命令退出低功耗模式
00000a  ab02              ADD      r3,sp,#8
00000c  2200              MOVS     r2,#0
00000e  e9cd2300          STRD     r2,r3,[sp,#0]
000012  4623              MOV      r3,r4
000014  2231              MOVS     r2,#0x31
000016  2121              MOVS     r1,#0x21
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       lbs_prepare_and_send_command
;;;184                                     CMD_SUBCMD_EXIT_PS,
;;;185                                     wait_option, 0, &Localpsmode);
;;;186    
;;;187        lbs_deb_leave(LBS_DEB_HOST);
;;;188    }
00001e  bd3e              POP      {r1-r5,pc}
;;;189    /***********************************************************************************************
                          ENDP


                          AREA ||i.lbs_rev_pkt||, CODE, READONLY, ALIGN=2

                  lbs_rev_pkt PROC
;;;78     ***********************************************************************************************/
;;;79     u16 lbs_rev_pkt(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;80     {
;;;81         struct lbs_private *priv=pgmarvel_priv;
000004  4815              LDR      r0,|L7.92|
000006  6804              LDR      r4,[r0,#0]  ; pgmarvel_priv
;;;82         struct if_sdio_card *card=priv->card;
000008  6aa6              LDR      r6,[r4,#0x28]
;;;83         struct eth_packet *rx_pkt=&priv->rx_pkt;
00000a  4625              MOV      r5,r4
;;;84         int ret;
;;;85         sdio_sys_wait=0;
00000c  2000              MOVS     r0,#0
00000e  4914              LDR      r1,|L7.96|
000010  7008              STRB     r0,[r1,#0]
;;;86         memset(rx_pkt,0,sizeof(struct eth_packet ));//清零以判断数据接收正常
000012  6028              STR      r0,[r5,#0]
000014  6068              STR      r0,[r5,#4]
;;;87         ret=pool_sdio_interrupt(card->func);
000016  6830              LDR      r0,[r6,#0]
000018  f7fffffe          BL       pool_sdio_interrupt
00001c  4607              MOV      r7,r0
;;;88         if(ret<0){
00001e  2f00              CMP      r7,#0
000020  da04              BGE      |L7.44|
;;;89             lbs_pr_err("read interrupt error!\n");
000022  a010              ADR      r0,|L7.100|
000024  f7fffffe          BL       __2printf
;;;90             try_bug(0);
000028  bf00              NOP      
                  |L7.42|
00002a  e7fe              B        |L7.42|
                  |L7.44|
;;;91         }
;;;92         else if(ret&(IF_SDIO_H_INT_UPLD|IF_SDIO_H_INT_DNLD)){//先判断数据
00002c  f0170f03          TST      r7,#3
000030  d00a              BEQ      |L7.72|
;;;93             if_sdio_interrupt(card->func);
000032  6830              LDR      r0,[r6,#0]
000034  f7fffffe          BL       if_sdio_interrupt
;;;94             if(rx_pkt->len){//接收到数据
000038  8828              LDRH     r0,[r5,#0]
00003a  b150              CBZ      r0,|L7.82|
;;;95                 sdio_sys_wait=1;
00003c  2001              MOVS     r0,#1
00003e  4908              LDR      r1,|L7.96|
000040  7008              STRB     r0,[r1,#0]
;;;96                 return rx_pkt->len;
000042  8828              LDRH     r0,[r5,#0]
                  |L7.68|
;;;97             }
;;;98     
;;;99         }
;;;100        else{
;;;101            sdio_sys_wait=1;
;;;102            return 0;
;;;103        }
;;;104        sdio_sys_wait=1;
;;;105        return 0;
;;;106    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L7.72|
000048  2001              MOVS     r0,#1                 ;101
00004a  4905              LDR      r1,|L7.96|
00004c  7008              STRB     r0,[r1,#0]            ;101
00004e  2000              MOVS     r0,#0                 ;102
000050  e7f8              B        |L7.68|
                  |L7.82|
000052  2001              MOVS     r0,#1                 ;104
000054  4902              LDR      r1,|L7.96|
000056  7008              STRB     r0,[r1,#0]            ;104
000058  2000              MOVS     r0,#0                 ;105
00005a  e7f3              B        |L7.68|
;;;107    /***********************************************************************************************
                          ENDP

                  |L7.92|
                          DCD      pgmarvel_priv
                  |L7.96|
                          DCD      sdio_sys_wait
                  |L7.100|
000064  72656164          DCB      "read interrupt error!\n",0
000068  20696e74
00006c  65727275
000070  70742065
000074  72726f72
000078  210a00  
00007b  00                DCB      0

                          AREA ||i.lbs_scan_worker||, CODE, READONLY, ALIGN=1

                  lbs_scan_worker PROC
;;;65     ***********************************************************************************************/
;;;66     void lbs_scan_worker(struct lbs_private *priv)
000000  b510              PUSH     {r4,lr}
;;;67     {
000002  4604              MOV      r4,r0
;;;68         lbs_deb_enter(LBS_DEB_SCAN);
;;;69         lbs_scan_networks(priv, 0);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       lbs_scan_networks
;;;70         lbs_deb_leave(LBS_DEB_SCAN);
;;;71     }
00000c  bd10              POP      {r4,pc}
;;;72     
                          ENDP


                          AREA ||i.lbs_send_confirmsleep||, CODE, READONLY, ALIGN=2

                  lbs_send_confirmsleep PROC
;;;228     ***********************************************************************************************/
;;;229    void lbs_send_confirmsleep(struct lbs_private *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231        int ret;
;;;232    
;;;233        lbs_deb_enter(LBS_DEB_HOST);
;;;234        lbs_deb_hex(LBS_DEB_HOST, "sleep confirm", (u8 *) &confirm_sleep,
000004  2312              MOVS     r3,#0x12
000006  4a0a              LDR      r2,|L9.48|
000008  a10a              ADR      r1,|L9.52|
00000a  f44f5000          MOV      r0,#0x2000
00000e  f7fffffe          BL       lbs_hex
;;;235    		sizeof(confirm_sleep));
;;;236    
;;;237        ret = priv->hw_host_to_card(priv, MVMS_CMD, (u8 *) &confirm_sleep,
000012  2312              MOVS     r3,#0x12
000014  4a06              LDR      r2,|L9.48|
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  6d66              LDR      r6,[r4,#0x54]
00001c  47b0              BLX      r6
00001e  4605              MOV      r5,r0
;;;238                                    sizeof(confirm_sleep));
;;;239        if (ret) {
000020  b105              CBZ      r5,|L9.36|
;;;240            lbs_pr_alert("confirm_sleep failed\n");
;;;241            goto out;
000022  e004              B        |L9.46|
                  |L9.36|
;;;242        }
;;;243        /* We don't get a response on the sleep-confirmation */
;;;244        priv->dnld_sent = DNLD_RES_RECEIVED;
000024  2100              MOVS     r1,#0
000026  f24100b8          MOV      r0,#0x10b8
00002a  5501              STRB     r1,[r0,r4]
;;;245        out:
00002c  bf00              NOP      
                  |L9.46|
;;;246        lbs_deb_leave(LBS_DEB_HOST);
;;;247    }
00002e  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP

                  |L9.48|
                          DCD      confirm_sleep
                  |L9.52|
000034  736c6565          DCB      "sleep confirm",0
000038  7020636f
00003c  6e666972
000040  6d00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.marvel_assoc_network||, CODE, READONLY, ALIGN=1

                  marvel_assoc_network PROC
;;;54     ***********************************************************************************************/
;;;55     void marvel_assoc_network(struct lbs_private *priv,char *ssid,char *key,char mode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;56     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;57         marvel_assoc_open_network(priv,ssid,key,mode);
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       marvel_assoc_open_network
;;;58     }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;59     
                          ENDP


                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.wpa_L2_send_pkt||, CODE, READONLY, ALIGN=2

                  wpa_L2_send_pkt PROC
;;;162    ***********************************************************************************************/
;;;163    int wpa_L2_send_pkt(u8 *buf,u16 len)
000000  b57c              PUSH     {r2-r6,lr}
;;;164    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;165        struct eth_packet tx_ethpkt;
;;;166        tx_ethpkt.data=(char *)buf;
000006  9401              STR      r4,[sp,#4]
;;;167        tx_ethpkt.len=len;
000008  f8ad5000          STRH     r5,[sp,#0]
;;;168        //debug_data_stream("L2 send",buf,len);
;;;169        return lbs_hard_start_xmit(pgmarvel_priv,&tx_ethpkt);
00000c  4669              MOV      r1,sp
00000e  4802              LDR      r0,|L12.24|
000010  6800              LDR      r0,[r0,#0]  ; pgmarvel_priv
000012  f7fffffe          BL       lbs_hard_start_xmit
;;;170    }
000016  bd7c              POP      {r2-r6,pc}
;;;171    /***********************************************************************************************
                          ENDP

                  |L12.24|
                          DCD      pgmarvel_priv

                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L13.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L13.32|
                  |L13.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L13.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L13.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L13.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L13.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L13.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L13.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  confirm_sleep
                          %        18

                          AREA ||.data||, DATA, ALIGN=2

                  sdio_sys_wait
000000  01000000          DCB      0x01,0x00,0x00,0x00
                  pgmarvel_priv
                          DCD      0x00000000
