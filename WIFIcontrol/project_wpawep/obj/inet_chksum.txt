; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\inet_chksum.o --depend=.\obj\inet_chksum.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\inet_chksum.crf ..\lwIP\src\core\ipv4\inet_chksum.c]
                          THUMB

                          AREA ||i.inet_chksum||, CODE, READONLY, ALIGN=1

                  inet_chksum PROC
;;;403    u16_t
;;;404    inet_chksum(void *dataptr, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;405    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;406      return ~LWIP_CHKSUM(dataptr, len);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       lwip_standard_chksum
00000e  43c0              MVNS     r0,r0
000010  b280              UXTH     r0,r0
;;;407    }
000012  bd70              POP      {r4-r6,pc}
;;;408    
                          ENDP


                          AREA ||i.inet_chksum_pbuf||, CODE, READONLY, ALIGN=1

                  inet_chksum_pbuf PROC
;;;416    u16_t
;;;417    inet_chksum_pbuf(struct pbuf *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;418    {
000004  4606              MOV      r6,r0
;;;419      u32_t acc;
;;;420      struct pbuf *q;
;;;421      u8_t swapped;
;;;422    
;;;423      acc = 0;
000006  2400              MOVS     r4,#0
;;;424      swapped = 0;
000008  2700              MOVS     r7,#0
;;;425      for(q = p; q != NULL; q = q->next) {
00000a  4635              MOV      r5,r6
00000c  e017              B        |L2.62|
                  |L2.14|
;;;426        acc += LWIP_CHKSUM(q->payload, q->len);
00000e  8969              LDRH     r1,[r5,#0xa]
000010  6868              LDR      r0,[r5,#4]
000012  f7fffffe          BL       lwip_standard_chksum
000016  4404              ADD      r4,r4,r0
;;;427        acc = FOLD_U32T(acc);
000018  b2a0              UXTH     r0,r4
00001a  eb004414          ADD      r4,r0,r4,LSR #16
;;;428        if (q->len % 2 != 0) {
00001e  8968              LDRH     r0,[r5,#0xa]
000020  eb0071d0          ADD      r1,r0,r0,LSR #31
000024  1049              ASRS     r1,r1,#1
000026  ebb00141          SUBS     r1,r0,r1,LSL #1
00002a  d007              BEQ      |L2.60|
;;;429          swapped = 1 - swapped;
00002c  f1c70001          RSB      r0,r7,#1
000030  b2c7              UXTB     r7,r0
;;;430          acc = SWAP_BYTES_IN_WORD(acc);
000032  b2e0              UXTB     r0,r4
000034  f3c42107          UBFX     r1,r4,#8,#8
000038  ea412400          ORR      r4,r1,r0,LSL #8
                  |L2.60|
00003c  682d              LDR      r5,[r5,#0]            ;425
                  |L2.62|
00003e  2d00              CMP      r5,#0                 ;425
000040  d1e5              BNE      |L2.14|
;;;431        }
;;;432      }
;;;433    
;;;434      if (swapped) {
000042  b127              CBZ      r7,|L2.78|
;;;435        acc = SWAP_BYTES_IN_WORD(acc);
000044  b2e0              UXTB     r0,r4
000046  f3c42107          UBFX     r1,r4,#8,#8
00004a  ea412400          ORR      r4,r1,r0,LSL #8
                  |L2.78|
;;;436      }
;;;437      return (u16_t)~(acc & 0xffffUL);
00004e  43e0              MVNS     r0,r4
000050  b280              UXTH     r0,r0
;;;438    }
000052  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.inet_chksum_pseudo||, CODE, READONLY, ALIGN=1

                  inet_chksum_pseudo PROC
;;;282    u16_t
;;;283    inet_chksum_pseudo(struct pbuf *p,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;284           struct ip_addr *src, struct ip_addr *dest,
;;;285           u8_t proto, u16_t proto_len)
;;;286    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;287      u32_t acc;
;;;288      struct pbuf *q;
;;;289      u8_t swapped;
;;;290    
;;;291      acc = 0;
000010  2400              MOVS     r4,#0
;;;292      swapped = 0;
000012  46a2              MOV      r10,r4
;;;293      /* iterate through all pbuf in chain */
;;;294      for(q = p; q != NULL; q = q->next) {
000014  4645              MOV      r5,r8
000016  e01a              B        |L3.78|
                  |L3.24|
;;;295        LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
000018  bf00              NOP      
00001a  bf00              NOP      
;;;296          (void *)q, (void *)q->next));
;;;297        acc += LWIP_CHKSUM(q->payload, q->len);
00001c  8969              LDRH     r1,[r5,#0xa]
00001e  6868              LDR      r0,[r5,#4]
000020  f7fffffe          BL       lwip_standard_chksum
000024  4404              ADD      r4,r4,r0
;;;298        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;299        /* just executing this next line is probably faster that the if statement needed
;;;300           to check whether we really need to execute it, and does no harm */
;;;301        acc = FOLD_U32T(acc);
000026  b2a0              UXTH     r0,r4
000028  eb004414          ADD      r4,r0,r4,LSR #16
;;;302        if (q->len % 2 != 0) {
00002c  8968              LDRH     r0,[r5,#0xa]
00002e  eb0071d0          ADD      r1,r0,r0,LSR #31
000032  1049              ASRS     r1,r1,#1
000034  ebb00141          SUBS     r1,r0,r1,LSL #1
000038  d008              BEQ      |L3.76|
;;;303          swapped = 1 - swapped;
00003a  f1ca0001          RSB      r0,r10,#1
00003e  f0000aff          AND      r10,r0,#0xff
;;;304          acc = SWAP_BYTES_IN_WORD(acc);
000042  b2e0              UXTB     r0,r4
000044  f3c42107          UBFX     r1,r4,#8,#8
000048  ea412400          ORR      r4,r1,r0,LSL #8
                  |L3.76|
00004c  682d              LDR      r5,[r5,#0]            ;294
                  |L3.78|
00004e  2d00              CMP      r5,#0                 ;294
000050  d1e2              BNE      |L3.24|
;;;305        }
;;;306        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;307      }
;;;308    
;;;309      if (swapped) {
000052  f1ba0f00          CMP      r10,#0
000056  d004              BEQ      |L3.98|
;;;310        acc = SWAP_BYTES_IN_WORD(acc);
000058  b2e0              UXTB     r0,r4
00005a  f3c42107          UBFX     r1,r4,#8,#8
00005e  ea412400          ORR      r4,r1,r0,LSL #8
                  |L3.98|
;;;311      }
;;;312      acc += (src->addr & 0xffffUL);
000062  6830              LDR      r0,[r6,#0]
000064  b280              UXTH     r0,r0
000066  4404              ADD      r4,r4,r0
;;;313      acc += ((src->addr >> 16) & 0xffffUL);
000068  6830              LDR      r0,[r6,#0]
00006a  f64f71ff          MOV      r1,#0xffff
00006e  ea014010          AND      r0,r1,r0,LSR #16
000072  4404              ADD      r4,r4,r0
;;;314      acc += (dest->addr & 0xffffUL);
000074  6838              LDR      r0,[r7,#0]
000076  b280              UXTH     r0,r0
000078  4404              ADD      r4,r4,r0
;;;315      acc += ((dest->addr >> 16) & 0xffffUL);
00007a  6838              LDR      r0,[r7,#0]
00007c  ea014010          AND      r0,r1,r0,LSR #16
000080  4404              ADD      r4,r4,r0
;;;316      acc += (u32_t)htons((u16_t)proto);
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       htons
000088  4404              ADD      r4,r4,r0
;;;317      acc += (u32_t)htons(proto_len);
00008a  4658              MOV      r0,r11
00008c  f7fffffe          BL       htons
000090  4404              ADD      r4,r4,r0
;;;318    
;;;319      /* Fold 32-bit sum to 16 bits
;;;320         calling this twice is propably faster than if statements... */
;;;321      acc = FOLD_U32T(acc);
000092  b2a0              UXTH     r0,r4
000094  eb004414          ADD      r4,r0,r4,LSR #16
;;;322      acc = FOLD_U32T(acc);
000098  b2a0              UXTH     r0,r4
00009a  eb004414          ADD      r4,r0,r4,LSR #16
;;;323      LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
00009e  bf00              NOP      
0000a0  bf00              NOP      
;;;324      return (u16_t)~(acc & 0xffffUL);
0000a2  43e0              MVNS     r0,r4
0000a4  b280              UXTH     r0,r0
;;;325    }
0000a6  e8bd9ff0          POP      {r4-r12,pc}
;;;326    
                          ENDP


                          AREA ||i.lwip_standard_chksum||, CODE, READONLY, ALIGN=1

                  lwip_standard_chksum PROC
;;;91     static u16_t
;;;92     lwip_standard_chksum(void *dataptr, u16_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;93     {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;94       u32_t acc;
;;;95       u16_t src;
;;;96       u8_t *octetptr;
;;;97     
;;;98       acc = 0;
000008  2400              MOVS     r4,#0
;;;99       /* dataptr may be at odd or even addresses */
;;;100      octetptr = (u8_t*)dataptr;
00000a  4645              MOV      r5,r8
;;;101      while (len > 1) {
00000c  e008              B        |L4.32|
                  |L4.14|
;;;102        /* declare first octet as most significant
;;;103           thus assume network order, ignoring host order */
;;;104        src = (*octetptr) << 8;
00000e  7828              LDRB     r0,[r5,#0]
000010  0207              LSLS     r7,r0,#8
;;;105        octetptr++;
000012  1c6d              ADDS     r5,r5,#1
;;;106        /* declare second octet as least significant */
;;;107        src |= (*octetptr);
000014  7828              LDRB     r0,[r5,#0]
000016  4307              ORRS     r7,r7,r0
;;;108        octetptr++;
000018  1c6d              ADDS     r5,r5,#1
;;;109        acc += src;
00001a  443c              ADD      r4,r4,r7
;;;110        len -= 2;
00001c  1eb0              SUBS     r0,r6,#2
00001e  b286              UXTH     r6,r0
                  |L4.32|
000020  2e01              CMP      r6,#1                 ;101
000022  dcf4              BGT      |L4.14|
;;;111      }
;;;112      if (len > 0) {
000024  2e00              CMP      r6,#0
000026  dd02              BLE      |L4.46|
;;;113        /* accumulate remaining octet */
;;;114        src = (*octetptr) << 8;
000028  7828              LDRB     r0,[r5,#0]
00002a  0207              LSLS     r7,r0,#8
;;;115        acc += src;
00002c  443c              ADD      r4,r4,r7
                  |L4.46|
;;;116      }
;;;117      /* add deferred carry bits */
;;;118      acc = (acc >> 16) + (acc & 0x0000ffffUL);
00002e  b2a0              UXTH     r0,r4
000030  eb004414          ADD      r4,r0,r4,LSR #16
;;;119      if ((acc & 0xffff0000UL) != 0) {
000034  0c20              LSRS     r0,r4,#16
000036  0400              LSLS     r0,r0,#16
000038  d002              BEQ      |L4.64|
;;;120        acc = (acc >> 16) + (acc & 0x0000ffffUL);
00003a  b2a0              UXTH     r0,r4
00003c  eb004414          ADD      r4,r0,r4,LSR #16
                  |L4.64|
;;;121      }
;;;122      /* This maybe a little confusing: reorder sum using htons()
;;;123         instead of ntohs() since it has a little less call overhead.
;;;124         The caller must invert bits for Internet sum ! */
;;;125      return htons((u16_t)acc);
000040  b2a0              UXTH     r0,r4
000042  f7fffffe          BL       htons
;;;126    }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;127    #endif
                          ENDP

