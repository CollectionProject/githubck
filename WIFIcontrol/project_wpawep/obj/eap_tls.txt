; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eap_tls.o --depend=.\obj\eap_tls.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eap_tls.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer\eap_tls.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_peer_method_load||, CODE, READONLY, ALIGN=1

                  eap_peer_method_load PROC
;;;78     
;;;79     static inline int eap_peer_method_load(const char *so)
000000  4601              MOV      r1,r0
;;;80     {
;;;81     	return 0;
000002  2000              MOVS     r0,#0
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.eap_peer_method_unload||, CODE, READONLY, ALIGN=1

                  eap_peer_method_unload PROC
;;;83     
;;;84     static inline int eap_peer_method_unload(struct eap_method *method)
000000  4601              MOV      r1,r0
;;;85     {
;;;86     	return 0;
000002  2000              MOVS     r0,#0
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.eap_peer_tls_register||, CODE, READONLY, ALIGN=2

                  eap_peer_tls_register PROC
;;;263    
;;;264    int eap_peer_tls_register(void)
000000  b570              PUSH     {r4-r6,lr}
;;;265    {
;;;266    	struct eap_method *eap;
;;;267    	int ret;
;;;268    
;;;269    	eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
000002  a314              ADR      r3,|L4.84|
000004  220d              MOVS     r2,#0xd
000006  2100              MOVS     r1,#0
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       eap_peer_method_alloc
00000e  4604              MOV      r4,r0
;;;270    				    EAP_VENDOR_IETF, EAP_TYPE_TLS, "TLS");
;;;271    	if (eap == NULL)
000010  b914              CBNZ     r4,|L4.24|
;;;272    		return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L4.22|
;;;273    
;;;274    	eap->init = eap_tls_init;
;;;275    	eap->deinit = eap_tls_deinit;
;;;276    	eap->process = eap_tls_process;
;;;277    	eap->isKeyAvailable = eap_tls_isKeyAvailable;
;;;278    	eap->getKey = eap_tls_getKey;
;;;279    	eap->get_status = eap_tls_get_status;
;;;280    	eap->has_reauth_data = eap_tls_has_reauth_data;
;;;281    	eap->deinit_for_reauth = eap_tls_deinit_for_reauth;
;;;282    	eap->init_for_reauth = eap_tls_init_for_reauth;
;;;283    	eap->get_emsk = eap_tls_get_emsk;
;;;284    
;;;285    	ret = eap_peer_method_register(eap);
;;;286    	if (ret)
;;;287    		eap_peer_method_free(eap);
;;;288    	return ret;
;;;289    }
000016  bd70              POP      {r4-r6,pc}
                  |L4.24|
000018  480f              LDR      r0,|L4.88|
00001a  60e0              STR      r0,[r4,#0xc]          ;274
00001c  480f              LDR      r0,|L4.92|
00001e  6120              STR      r0,[r4,#0x10]         ;275
000020  480f              LDR      r0,|L4.96|
000022  6160              STR      r0,[r4,#0x14]         ;276
000024  480f              LDR      r0,|L4.100|
000026  61a0              STR      r0,[r4,#0x18]         ;277
000028  480f              LDR      r0,|L4.104|
00002a  61e0              STR      r0,[r4,#0x1c]         ;278
00002c  480f              LDR      r0,|L4.108|
00002e  6220              STR      r0,[r4,#0x20]         ;279
000030  480f              LDR      r0,|L4.112|
000032  6260              STR      r0,[r4,#0x24]         ;280
000034  480f              LDR      r0,|L4.116|
000036  62a0              STR      r0,[r4,#0x28]         ;281
000038  480f              LDR      r0,|L4.120|
00003a  62e0              STR      r0,[r4,#0x2c]         ;282
00003c  480f              LDR      r0,|L4.124|
00003e  6420              STR      r0,[r4,#0x40]         ;283
000040  4620              MOV      r0,r4                 ;285
000042  f7fffffe          BL       eap_peer_method_register
000046  4605              MOV      r5,r0                 ;285
000048  b115              CBZ      r5,|L4.80|
00004a  4620              MOV      r0,r4                 ;287
00004c  f7fffffe          BL       eap_peer_method_free
                  |L4.80|
000050  4628              MOV      r0,r5                 ;288
000052  e7e0              B        |L4.22|
                          ENDP

                  |L4.84|
000054  544c5300          DCB      "TLS",0
                  |L4.88|
                          DCD      eap_tls_init
                  |L4.92|
                          DCD      eap_tls_deinit
                  |L4.96|
                          DCD      eap_tls_process
                  |L4.100|
                          DCD      eap_tls_isKeyAvailable
                  |L4.104|
                          DCD      eap_tls_getKey
                  |L4.108|
                          DCD      eap_tls_get_status
                  |L4.112|
                          DCD      eap_tls_has_reauth_data
                  |L4.116|
                          DCD      eap_tls_deinit_for_reauth
                  |L4.120|
                          DCD      eap_tls_init_for_reauth
                  |L4.124|
                          DCD      eap_tls_get_emsk

                          AREA ||i.eap_tls_deinit||, CODE, READONLY, ALIGN=1

                  eap_tls_deinit PROC
;;;70     
;;;71     static void eap_tls_deinit(struct eap_sm *sm, void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;72     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;73     	struct eap_tls_data *data = priv;
000006  462c              MOV      r4,r5
;;;74     	if (data == NULL)
000008  b904              CBNZ     r4,|L5.12|
                  |L5.10|
;;;75     		return;
;;;76     	eap_peer_tls_ssl_deinit(sm, &data->ssl);
;;;77     	os_free(data->key_data);
;;;78     	os_free(data);
;;;79     }
00000a  bd70              POP      {r4-r6,pc}
                  |L5.12|
00000c  4621              MOV      r1,r4                 ;76
00000e  4630              MOV      r0,r6                 ;76
000010  f7fffffe          BL       eap_peer_tls_ssl_deinit
000014  6ae0              LDR      r0,[r4,#0x2c]         ;77
000016  f7fffffe          BL       os_free
00001a  4620              MOV      r0,r4                 ;78
00001c  f7fffffe          BL       os_free
000020  bf00              NOP      
000022  e7f2              B        |L5.10|
;;;80     
                          ENDP


                          AREA ||i.eap_tls_deinit_for_reauth||, CODE, READONLY, ALIGN=1

                  eap_tls_deinit_for_reauth PROC
;;;192    
;;;193    static void eap_tls_deinit_for_reauth(struct eap_sm *sm, void *priv)
000000  4770              BX       lr
;;;194    {
;;;195    }
;;;196    
                          ENDP


                          AREA ||i.eap_tls_failure||, CODE, READONLY, ALIGN=2

                  eap_tls_failure PROC
;;;81     
;;;82     static struct wpabuf * eap_tls_failure(struct eap_sm *sm,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;83     				       struct eap_tls_data *data,
;;;84     				       struct eap_method_ret *ret, int res,
;;;85     				       struct wpabuf *resp, u8 id)
;;;86     {
000004  4680              MOV      r8,r0
000006  468a              MOV      r10,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
00000c  e9dd7908          LDRD     r7,r9,[sp,#0x20]
;;;87     	wpa_printf(MSG_DEBUG, "EAP-TLS: TLS processing failed");
000010  a10f              ADR      r1,|L7.80|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
;;;88     
;;;89     	ret->methodState = METHOD_DONE;
000018  2004              MOVS     r0,#4
00001a  7120              STRB     r0,[r4,#4]
;;;90     	ret->decision = DECISION_FAIL;
00001c  2000              MOVS     r0,#0
00001e  7160              STRB     r0,[r4,#5]
;;;91     
;;;92     	if (res == -1) {
000020  1c70              ADDS     r0,r6,#1
000022  d10a              BNE      |L7.58|
;;;93     		struct eap_peer_config *config = eap_get_config(sm);
000024  4640              MOV      r0,r8
000026  f7fffffe          BL       eap_get_config
00002a  4605              MOV      r5,r0
;;;94     		if (config) {
00002c  b125              CBZ      r5,|L7.56|
;;;95     			/*
;;;96     			 * The TLS handshake failed. So better forget the old
;;;97     			 * PIN. It may be wrong, we cannot be sure but trying
;;;98     			 * the wrong one again might block it on the card--so
;;;99     			 * better ask the user again.
;;;100    			 */
;;;101    			os_free(config->pin);
00002e  6ea8              LDR      r0,[r5,#0x68]
000030  f7fffffe          BL       os_free
;;;102    			config->pin = NULL;
000034  2000              MOVS     r0,#0
000036  66a8              STR      r0,[r5,#0x68]
                  |L7.56|
;;;103    		}
;;;104    	}
000038  bf00              NOP      
                  |L7.58|
;;;105    
;;;106    	if (resp) {
00003a  b117              CBZ      r7,|L7.66|
;;;107    		/*
;;;108    		 * This is likely an alert message, so send it instead of just
;;;109    		 * ACKing the error.
;;;110    		 */
;;;111    		return resp;
00003c  4638              MOV      r0,r7
                  |L7.62|
;;;112    	}
;;;113    
;;;114    	return eap_peer_tls_build_ack(id, EAP_TYPE_TLS, 0);
;;;115    }
00003e  e8bd87f0          POP      {r4-r10,pc}
                  |L7.66|
000042  2200              MOVS     r2,#0                 ;114
000044  210d              MOVS     r1,#0xd               ;114
000046  4648              MOV      r0,r9                 ;114
000048  f7fffffe          BL       eap_peer_tls_build_ack
00004c  e7f7              B        |L7.62|
;;;116    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
000050  4541502d          DCB      "EAP-TLS: TLS processing failed",0
000054  544c533a
000058  20544c53
00005c  2070726f
000060  63657373
000064  696e6720
000068  6661696c
00006c  656400  
00006f  00                DCB      0

                          AREA ||i.eap_tls_getKey||, CODE, READONLY, ALIGN=1

                  eap_tls_getKey PROC
;;;225    
;;;226    static u8 * eap_tls_getKey(struct eap_sm *sm, void *priv, size_t *len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;227    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;228    	struct eap_tls_data *data = priv;
00000a  4627              MOV      r7,r4
;;;229    	u8 *key;
;;;230    
;;;231    	if (data->key_data == NULL)
00000c  6af8              LDR      r0,[r7,#0x2c]
00000e  b910              CBNZ     r0,|L8.22|
;;;232    		return NULL;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;233    
;;;234    	key = os_malloc(EAP_TLS_KEY_LEN);
;;;235    	if (key == NULL)
;;;236    		return NULL;
;;;237    
;;;238    	*len = EAP_TLS_KEY_LEN;
;;;239    	os_memcpy(key, data->key_data, EAP_TLS_KEY_LEN);
;;;240    
;;;241    	return key;
;;;242    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L8.22|
000016  2040              MOVS     r0,#0x40              ;234
000018  f7fffffe          BL       os_malloc
00001c  4605              MOV      r5,r0                 ;234
00001e  b90d              CBNZ     r5,|L8.36|
000020  2000              MOVS     r0,#0                 ;236
000022  e7f6              B        |L8.18|
                  |L8.36|
000024  2040              MOVS     r0,#0x40              ;238
000026  6030              STR      r0,[r6,#0]            ;238
000028  2240              MOVS     r2,#0x40              ;239
00002a  4628              MOV      r0,r5                 ;239
00002c  6af9              LDR      r1,[r7,#0x2c]         ;239
00002e  f7fffffe          BL       os_memcpy
000032  4628              MOV      r0,r5                 ;241
000034  e7ed              B        |L8.18|
;;;243    
                          ENDP


                          AREA ||i.eap_tls_get_emsk||, CODE, READONLY, ALIGN=1

                  eap_tls_get_emsk PROC
;;;244    
;;;245    static u8 * eap_tls_get_emsk(struct eap_sm *sm, void *priv, size_t *len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;246    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;247    	struct eap_tls_data *data = priv;
00000a  4627              MOV      r7,r4
;;;248    	u8 *key;
;;;249    
;;;250    	if (data->key_data == NULL)
00000c  6af8              LDR      r0,[r7,#0x2c]
00000e  b910              CBNZ     r0,|L9.22|
;;;251    		return NULL;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;252    
;;;253    	key = os_malloc(EAP_EMSK_LEN);
;;;254    	if (key == NULL)
;;;255    		return NULL;
;;;256    
;;;257    	*len = EAP_EMSK_LEN;
;;;258    	os_memcpy(key, data->key_data + EAP_TLS_KEY_LEN, EAP_EMSK_LEN);
;;;259    
;;;260    	return key;
;;;261    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L9.22|
000016  2040              MOVS     r0,#0x40              ;253
000018  f7fffffe          BL       os_malloc
00001c  4605              MOV      r5,r0                 ;253
00001e  b90d              CBNZ     r5,|L9.36|
000020  2000              MOVS     r0,#0                 ;255
000022  e7f6              B        |L9.18|
                  |L9.36|
000024  2040              MOVS     r0,#0x40              ;257
000026  6030              STR      r0,[r6,#0]            ;257
000028  6af8              LDR      r0,[r7,#0x2c]         ;258
00002a  f1000140          ADD      r1,r0,#0x40           ;258
00002e  2240              MOVS     r2,#0x40              ;258
000030  4628              MOV      r0,r5                 ;258
000032  f7fffffe          BL       os_memcpy
000036  4628              MOV      r0,r5                 ;260
000038  e7eb              B        |L9.18|
;;;262    
                          ENDP


                          AREA ||i.eap_tls_get_status||, CODE, READONLY, ALIGN=1

                  eap_tls_get_status PROC
;;;210    
;;;211    static int eap_tls_get_status(struct eap_sm *sm, void *priv, char *buf,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;212    			      size_t buflen, int verbose)
;;;213    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;214    	struct eap_tls_data *data = priv;
000010  46a1              MOV      r9,r4
;;;215    	return eap_peer_tls_status(sm, &data->ssl, buf, buflen, verbose);
000012  463b              MOV      r3,r7
000014  4632              MOV      r2,r6
000016  4649              MOV      r1,r9
000018  4628              MOV      r0,r5
00001a  f8cd8000          STR      r8,[sp,#0]
00001e  f7fffffe          BL       eap_peer_tls_status
;;;216    }
000022  e8bd83f8          POP      {r3-r9,pc}
;;;217    
                          ENDP


                          AREA ||i.eap_tls_has_reauth_data||, CODE, READONLY, ALIGN=1

                  eap_tls_has_reauth_data PROC
;;;185    
;;;186    static Boolean eap_tls_has_reauth_data(struct eap_sm *sm, void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;187    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;188    	struct eap_tls_data *data = priv;
000006  4626              MOV      r6,r4
;;;189    	return tls_connection_established(sm->ssl_ctx, data->ssl.conn);
000008  6831              LDR      r1,[r6,#0]
00000a  f8d50098          LDR      r0,[r5,#0x98]
00000e  f7fffffe          BL       tls_connection_established
;;;190    }
000012  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP


                          AREA ||i.eap_tls_init||, CODE, READONLY, ALIGN=2

                  eap_tls_init PROC
;;;32     
;;;33     static void * eap_tls_init(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;34     {
000002  4605              MOV      r5,r0
;;;35     	struct eap_tls_data *data;
;;;36     	struct eap_peer_config *config = eap_get_config(sm);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       eap_get_config
00000a  4604              MOV      r4,r0
;;;37     	if (config == NULL ||
00000c  b15c              CBZ      r4,|L12.38|
;;;38     	    ((sm->init_phase2 ? config->private_key2 : config->private_key)
00000e  6de8              LDR      r0,[r5,#0x5c]
000010  b108              CBZ      r0,|L12.22|
000012  6c60              LDR      r0,[r4,#0x44]
000014  e000              B        |L12.24|
                  |L12.22|
000016  6a60              LDR      r0,[r4,#0x24]
                  |L12.24|
000018  b958              CBNZ     r0,|L12.50|
;;;39     	     == NULL &&
;;;40     	     (sm->init_phase2 ? config->engine2 : config->engine) == 0)) {
00001a  6de8              LDR      r0,[r5,#0x5c]
00001c  b108              CBZ      r0,|L12.34|
00001e  6f60              LDR      r0,[r4,#0x74]
000020  e000              B        |L12.36|
                  |L12.34|
000022  6ee0              LDR      r0,[r4,#0x6c]
                  |L12.36|
000024  b928              CBNZ     r0,|L12.50|
                  |L12.38|
;;;41     		wpa_printf(MSG_INFO, "EAP-TLS: Private key not configured");
000026  a11c              ADR      r1,|L12.152|
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       wpa_printf
;;;42     		return NULL;
00002e  2000              MOVS     r0,#0
                  |L12.48|
;;;43     	}
;;;44     
;;;45     	data = os_zalloc(sizeof(*data));
;;;46     	if (data == NULL)
;;;47     		return NULL;
;;;48     
;;;49     	if (eap_peer_tls_ssl_init(sm, &data->ssl, config)) {
;;;50     		wpa_printf(MSG_INFO, "EAP-TLS: Failed to initialize SSL.");
;;;51     		eap_tls_deinit(sm, data);
;;;52     		if (config->engine) {
;;;53     			wpa_printf(MSG_DEBUG, "EAP-TLS: Requesting Smartcard "
;;;54     				   "PIN");
;;;55     			eap_sm_request_pin(sm);
;;;56     			sm->ignore = TRUE;
;;;57     		} else if (config->private_key && !config->private_key_passwd)
;;;58     		{
;;;59     			wpa_printf(MSG_DEBUG, "EAP-TLS: Requesting private "
;;;60     				   "key passphrase");
;;;61     			eap_sm_request_passphrase(sm);
;;;62     			sm->ignore = TRUE;
;;;63     		}
;;;64     		return NULL;
;;;65     	}
;;;66     
;;;67     	return data;
;;;68     }
000030  bd70              POP      {r4-r6,pc}
                  |L12.50|
000032  2030              MOVS     r0,#0x30              ;45
000034  f7fffffe          BL       os_zalloc
000038  4606              MOV      r6,r0                 ;45
00003a  b90e              CBNZ     r6,|L12.64|
00003c  2000              MOVS     r0,#0                 ;47
00003e  e7f7              B        |L12.48|
                  |L12.64|
000040  4622              MOV      r2,r4                 ;49
000042  4631              MOV      r1,r6                 ;49
000044  4628              MOV      r0,r5                 ;49
000046  f7fffffe          BL       eap_peer_tls_ssl_init
00004a  b310              CBZ      r0,|L12.146|
00004c  a11b              ADR      r1,|L12.188|
00004e  2000              MOVS     r0,#0                 ;50
000050  f7fffffe          BL       wpa_printf
000054  4631              MOV      r1,r6                 ;51
000056  4628              MOV      r0,r5                 ;51
000058  f7fffffe          BL       eap_tls_deinit
00005c  6ee0              LDR      r0,[r4,#0x6c]         ;52
00005e  b148              CBZ      r0,|L12.116|
000060  a11f              ADR      r1,|L12.224|
000062  2000              MOVS     r0,#0                 ;53
000064  f7fffffe          BL       wpa_printf
000068  4628              MOV      r0,r5                 ;55
00006a  f7fffffe          BL       eap_sm_request_pin
00006e  2001              MOVS     r0,#1                 ;56
000070  62e8              STR      r0,[r5,#0x2c]         ;56
000072  e00c              B        |L12.142|
                  |L12.116|
000074  6a60              LDR      r0,[r4,#0x24]         ;57
000076  b150              CBZ      r0,|L12.142|
000078  6aa0              LDR      r0,[r4,#0x28]         ;57
00007a  b940              CBNZ     r0,|L12.142|
00007c  a121              ADR      r1,|L12.260|
00007e  2000              MOVS     r0,#0                 ;59
000080  f7fffffe          BL       wpa_printf
000084  4628              MOV      r0,r5                 ;61
000086  f7fffffe          BL       eap_sm_request_passphrase
00008a  2001              MOVS     r0,#1                 ;62
00008c  62e8              STR      r0,[r5,#0x2c]         ;62
                  |L12.142|
00008e  2000              MOVS     r0,#0                 ;64
000090  e7ce              B        |L12.48|
                  |L12.146|
000092  4630              MOV      r0,r6                 ;67
000094  e7cc              B        |L12.48|
;;;69     
                          ENDP

000096  0000              DCW      0x0000
                  |L12.152|
000098  4541502d          DCB      "EAP-TLS: Private key not configured",0
00009c  544c533a
0000a0  20507269
0000a4  76617465
0000a8  206b6579
0000ac  206e6f74
0000b0  20636f6e
0000b4  66696775
0000b8  72656400
                  |L12.188|
0000bc  4541502d          DCB      "EAP-TLS: Failed to initialize SSL.",0
0000c0  544c533a
0000c4  20466169
0000c8  6c656420
0000cc  746f2069
0000d0  6e697469
0000d4  616c697a
0000d8  65205353
0000dc  4c2e00  
0000df  00                DCB      0
                  |L12.224|
0000e0  4541502d          DCB      "EAP-TLS: Requesting Smartcard PIN",0
0000e4  544c533a
0000e8  20526571
0000ec  75657374
0000f0  696e6720
0000f4  536d6172
0000f8  74636172
0000fc  64205049
000100  4e00    
000102  00                DCB      0
000103  00                DCB      0
                  |L12.260|
000104  4541502d          DCB      "EAP-TLS: Requesting private key passphrase",0
000108  544c533a
00010c  20526571
000110  75657374
000114  696e6720
000118  70726976
00011c  61746520
000120  6b657920
000124  70617373
000128  70687261
00012c  736500  
00012f  00                DCB      0

                          AREA ||i.eap_tls_init_for_reauth||, CODE, READONLY, ALIGN=1

                  eap_tls_init_for_reauth PROC
;;;197    
;;;198    static void * eap_tls_init_for_reauth(struct eap_sm *sm, void *priv)
000000  b570              PUSH     {r4-r6,lr}
;;;199    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;200    	struct eap_tls_data *data = priv;
000006  4625              MOV      r5,r4
;;;201    	os_free(data->key_data);
000008  6ae8              LDR      r0,[r5,#0x2c]
00000a  f7fffffe          BL       os_free
;;;202    	data->key_data = NULL;
00000e  2000              MOVS     r0,#0
000010  62e8              STR      r0,[r5,#0x2c]
;;;203    	if (eap_peer_tls_reauth_init(sm, &data->ssl)) {
000012  4629              MOV      r1,r5
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       eap_peer_tls_reauth_init
00001a  b120              CBZ      r0,|L13.38|
;;;204    		os_free(data);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       os_free
;;;205    		return NULL;
000022  2000              MOVS     r0,#0
                  |L13.36|
;;;206    	}
;;;207    	return priv;
;;;208    }
000024  bd70              POP      {r4-r6,pc}
                  |L13.38|
000026  4620              MOV      r0,r4                 ;207
000028  e7fc              B        |L13.36|
;;;209    
                          ENDP


                          AREA ||i.eap_tls_isKeyAvailable||, CODE, READONLY, ALIGN=1

                  eap_tls_isKeyAvailable PROC
;;;218    
;;;219    static Boolean eap_tls_isKeyAvailable(struct eap_sm *sm, void *priv)
000000  4603              MOV      r3,r0
;;;220    {
;;;221    	struct eap_tls_data *data = priv;
000002  460a              MOV      r2,r1
;;;222    	return data->key_data != NULL;
000004  6ad0              LDR      r0,[r2,#0x2c]
000006  b108              CBZ      r0,|L14.12|
000008  2001              MOVS     r0,#1
                  |L14.10|
;;;223    }
00000a  4770              BX       lr
                  |L14.12|
00000c  2000              MOVS     r0,#0                 ;222
00000e  e7fc              B        |L14.10|
;;;224    
                          ENDP


                          AREA ||i.eap_tls_process||, CODE, READONLY, ALIGN=2

                  eap_tls_process PROC
;;;142    
;;;143    static struct wpabuf * eap_tls_process(struct eap_sm *sm, void *priv,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;144    				       struct eap_method_ret *ret,
;;;145    				       const struct wpabuf *reqData)
;;;146    {
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
00000c  461d              MOV      r5,r3
;;;147    	size_t left;
;;;148    	int res;
;;;149    	struct wpabuf *resp;
;;;150    	u8 flags, id;
;;;151    	const u8 *pos;
;;;152    	struct eap_tls_data *data = priv;
00000e  46ba              MOV      r10,r7
;;;153    
;;;154    	pos = eap_peer_tls_process_init(sm, &data->ssl, EAP_TYPE_TLS, ret,
000010  ab04              ADD      r3,sp,#0x10
000012  aa06              ADD      r2,sp,#0x18
000014  e9cd5200          STRD     r5,r2,[sp,#0]
000018  9302              STR      r3,[sp,#8]
00001a  4643              MOV      r3,r8
00001c  220d              MOVS     r2,#0xd
00001e  4651              MOV      r1,r10
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       eap_peer_tls_process_init
000026  4681              MOV      r9,r0
;;;155    					reqData, &left, &flags);
;;;156    	if (pos == NULL)
000028  f1b90f00          CMP      r9,#0
00002c  d103              BNE      |L15.54|
;;;157    		return NULL;
00002e  2000              MOVS     r0,#0
                  |L15.48|
;;;158    	id = eap_get_id(reqData);
;;;159    
;;;160    	if (flags & EAP_TLS_FLAGS_START) {
;;;161    		wpa_printf(MSG_DEBUG, "EAP-TLS: Start");
;;;162    		left = 0; /* make sure that this frame is empty, even though it
;;;163    			   * should always be, anyway */
;;;164    	}
;;;165    
;;;166    	resp = NULL;
;;;167    	res = eap_peer_tls_process_helper(sm, &data->ssl, EAP_TYPE_TLS, 0, id,
;;;168    					  pos, left, &resp);
;;;169    
;;;170    	if (res < 0) {
;;;171    		return eap_tls_failure(sm, data, ret, res, resp, id);
;;;172    	}
;;;173    
;;;174    	if (tls_connection_established(sm->ssl_ctx, data->ssl.conn))
;;;175    		eap_tls_success(sm, data, ret);
;;;176    
;;;177    	if (res == 1) {
;;;178    		wpabuf_free(resp);
;;;179    		return eap_peer_tls_build_ack(id, EAP_TYPE_TLS, 0);
;;;180    	}
;;;181    
;;;182    	return resp;
;;;183    }
000030  b007              ADD      sp,sp,#0x1c
000032  e8bd8ff0          POP      {r4-r11,pc}
                  |L15.54|
000036  4628              MOV      r0,r5                 ;158
000038  f7fffffe          BL       eap_get_id
00003c  4683              MOV      r11,r0                ;158
00003e  f89d0010          LDRB     r0,[sp,#0x10]         ;160
000042  f0100f20          TST      r0,#0x20              ;160
000046  d005              BEQ      |L15.84|
000048  a11c              ADR      r1,|L15.188|
00004a  2000              MOVS     r0,#0                 ;161
00004c  f7fffffe          BL       wpa_printf
000050  2000              MOVS     r0,#0                 ;162
000052  9006              STR      r0,[sp,#0x18]         ;162
                  |L15.84|
000054  2000              MOVS     r0,#0                 ;166
000056  9005              STR      r0,[sp,#0x14]         ;166
000058  ab05              ADD      r3,sp,#0x14           ;167
00005a  9a06              LDR      r2,[sp,#0x18]         ;167
00005c  e9cdb900          STRD     r11,r9,[sp,#0]        ;167
000060  e9cd2302          STRD     r2,r3,[sp,#8]         ;167
000064  2300              MOVS     r3,#0                 ;167
000066  220d              MOVS     r2,#0xd               ;167
000068  4651              MOV      r1,r10                ;167
00006a  4630              MOV      r0,r6                 ;167
00006c  f7fffffe          BL       eap_peer_tls_process_helper
000070  4604              MOV      r4,r0                 ;167
000072  2c00              CMP      r4,#0                 ;170
000074  da09              BGE      |L15.138|
000076  9a05              LDR      r2,[sp,#0x14]         ;171
000078  4623              MOV      r3,r4                 ;171
00007a  e9cd2b00          STRD     r2,r11,[sp,#0]        ;171
00007e  4642              MOV      r2,r8                 ;171
000080  4651              MOV      r1,r10                ;171
000082  4630              MOV      r0,r6                 ;171
000084  f7fffffe          BL       eap_tls_failure
000088  e7d2              B        |L15.48|
                  |L15.138|
00008a  f8da1000          LDR      r1,[r10,#0]           ;174
00008e  f8d60098          LDR      r0,[r6,#0x98]         ;174
000092  f7fffffe          BL       tls_connection_established
000096  b120              CBZ      r0,|L15.162|
000098  4642              MOV      r2,r8                 ;175
00009a  4651              MOV      r1,r10                ;175
00009c  4630              MOV      r0,r6                 ;175
00009e  f7fffffe          BL       eap_tls_success
                  |L15.162|
0000a2  2c01              CMP      r4,#1                 ;177
0000a4  d108              BNE      |L15.184|
0000a6  9805              LDR      r0,[sp,#0x14]         ;178
0000a8  f7fffffe          BL       wpabuf_free
0000ac  2200              MOVS     r2,#0                 ;179
0000ae  210d              MOVS     r1,#0xd               ;179
0000b0  4658              MOV      r0,r11                ;179
0000b2  f7fffffe          BL       eap_peer_tls_build_ack
0000b6  e7bb              B        |L15.48|
                  |L15.184|
0000b8  9805              LDR      r0,[sp,#0x14]         ;182
0000ba  e7b9              B        |L15.48|
;;;184    
                          ENDP

                  |L15.188|
0000bc  4541502d          DCB      "EAP-TLS: Start",0
0000c0  544c533a
0000c4  20537461
0000c8  727400  
0000cb  00                DCB      0

                          AREA ||i.eap_tls_success||, CODE, READONLY, ALIGN=2

                  eap_tls_success PROC
;;;117    
;;;118    static void eap_tls_success(struct eap_sm *sm, struct eap_tls_data *data,
000000  b570              PUSH     {r4-r6,lr}
;;;119    			    struct eap_method_ret *ret)
;;;120    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;121    	wpa_printf(MSG_DEBUG, "EAP-TLS: Done");
000008  a113              ADR      r1,|L16.88|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       wpa_printf
;;;122    
;;;123    	ret->methodState = METHOD_DONE;
000010  2004              MOVS     r0,#4
000012  7128              STRB     r0,[r5,#4]
;;;124    	ret->decision = DECISION_UNCOND_SUCC;
000014  2002              MOVS     r0,#2
000016  7168              STRB     r0,[r5,#5]
;;;125    
;;;126    	os_free(data->key_data);
000018  6ae0              LDR      r0,[r4,#0x2c]
00001a  f7fffffe          BL       os_free
;;;127    	data->key_data = eap_peer_tls_derive_key(sm, &data->ssl,
00001e  2380              MOVS     r3,#0x80
000020  a211              ADR      r2,|L16.104|
000022  4621              MOV      r1,r4
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       eap_peer_tls_derive_key
00002a  62e0              STR      r0,[r4,#0x2c]
;;;128    						 "client EAP encryption",
;;;129    						 EAP_TLS_KEY_LEN +
;;;130    						 EAP_EMSK_LEN);
;;;131    	if (data->key_data) {
00002c  6ae0              LDR      r0,[r4,#0x2c]
00002e  b170              CBZ      r0,|L16.78|
;;;132    		wpa_hexdump_key(MSG_DEBUG, "EAP-TLS: Derived key",
000030  2340              MOVS     r3,#0x40
000032  a113              ADR      r1,|L16.128|
000034  2000              MOVS     r0,#0
000036  6ae2              LDR      r2,[r4,#0x2c]
000038  f7fffffe          BL       wpa_hexdump_key
;;;133    				data->key_data, EAP_TLS_KEY_LEN);
;;;134    		wpa_hexdump_key(MSG_DEBUG, "EAP-TLS: Derived EMSK",
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  f1000240          ADD      r2,r0,#0x40
000042  2340              MOVS     r3,#0x40
000044  a114              ADR      r1,|L16.152|
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       wpa_hexdump_key
00004c  e003              B        |L16.86|
                  |L16.78|
;;;135    				data->key_data + EAP_TLS_KEY_LEN,
;;;136    				EAP_EMSK_LEN);
;;;137    	} else {
;;;138    		wpa_printf(MSG_INFO, "EAP-TLS: Failed to derive key");
00004e  a118              ADR      r1,|L16.176|
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       wpa_printf
                  |L16.86|
;;;139    	}
;;;140    }
000056  bd70              POP      {r4-r6,pc}
;;;141    
                          ENDP

                  |L16.88|
000058  4541502d          DCB      "EAP-TLS: Done",0
00005c  544c533a
000060  20446f6e
000064  6500    
000066  00                DCB      0
000067  00                DCB      0
                  |L16.104|
000068  636c6965          DCB      "client EAP encryption",0
00006c  6e742045
000070  41502065
000074  6e637279
000078  7074696f
00007c  6e00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L16.128|
000080  4541502d          DCB      "EAP-TLS: Derived key",0
000084  544c533a
000088  20446572
00008c  69766564
000090  206b6579
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L16.152|
000098  4541502d          DCB      "EAP-TLS: Derived EMSK",0
00009c  544c533a
0000a0  20446572
0000a4  69766564
0000a8  20454d53
0000ac  4b00    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L16.176|
0000b0  4541502d          DCB      "EAP-TLS: Failed to derive key",0
0000b4  544c533a
0000b8  20466169
0000bc  6c656420
0000c0  746f2064
0000c4  65726976
0000c8  65206b65
0000cc  7900    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L17.30|
00001a  2001              MOVS     r0,#1
                  |L17.28|
;;;495    }
00001c  4770              BX       lr
                  |L17.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L17.28|
;;;496    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpa_key_mgmt_ft||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_ft PROC
;;;65     
;;;66     static inline int wpa_key_mgmt_ft(int akm)
000000  4601              MOV      r1,r0
;;;67     {
;;;68     	return akm == WPA_KEY_MGMT_FT_PSK ||
000002  2940              CMP      r1,#0x40
000004  d001              BEQ      |L22.10|
;;;69     		akm == WPA_KEY_MGMT_FT_IEEE8021X;
000006  2920              CMP      r1,#0x20
000008  d101              BNE      |L22.14|
                  |L22.10|
00000a  2001              MOVS     r0,#1                 ;68
                  |L22.12|
;;;70     }
00000c  4770              BX       lr
                  |L22.14|
00000e  2000              MOVS     r0,#0                 ;68
000010  e7fc              B        |L22.12|
;;;71     
                          ENDP


                          AREA ||i.wpa_key_mgmt_sha256||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_sha256 PROC
;;;71     
;;;72     static inline int wpa_key_mgmt_sha256(int akm)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return akm == WPA_KEY_MGMT_PSK_SHA256 ||
000002  f5b17f80          CMP      r1,#0x100
000006  d001              BEQ      |L23.12|
;;;75     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
000008  2980              CMP      r1,#0x80
00000a  d101              BNE      |L23.16|
                  |L23.12|
00000c  2001              MOVS     r0,#1                 ;74
                  |L23.14|
;;;76     }
00000e  4770              BX       lr
                  |L23.16|
000010  2000              MOVS     r0,#0                 ;74
000012  e7fc              B        |L23.14|
;;;77     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_ieee8021x||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_ieee8021x PROC
;;;51     
;;;52     static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return akm == WPA_KEY_MGMT_IEEE8021X ||
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L24.14|
;;;55     		akm == WPA_KEY_MGMT_FT_IEEE8021X ||
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L24.14|
;;;56     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
00000a  2980              CMP      r1,#0x80
00000c  d101              BNE      |L24.18|
                  |L24.14|
00000e  2001              MOVS     r0,#1                 ;54
                  |L24.16|
;;;57     }
000010  4770              BX       lr
                  |L24.18|
000012  2000              MOVS     r0,#0                 ;54
000014  e7fc              B        |L24.16|
;;;58     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_psk||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_psk PROC
;;;58     
;;;59     static inline int wpa_key_mgmt_wpa_psk(int akm)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     	return akm == WPA_KEY_MGMT_PSK ||
000002  2902              CMP      r1,#2
000004  d004              BEQ      |L25.16|
;;;62     		akm == WPA_KEY_MGMT_FT_PSK ||
000006  2940              CMP      r1,#0x40
000008  d002              BEQ      |L25.16|
;;;63     		akm == WPA_KEY_MGMT_PSK_SHA256;
00000a  f5b17f80          CMP      r1,#0x100
00000e  d101              BNE      |L25.20|
                  |L25.16|
000010  2001              MOVS     r0,#1                 ;61
                  |L25.18|
;;;64     }
000012  4770              BX       lr
                  |L25.20|
000014  2000              MOVS     r0,#0                 ;61
000016  e7fc              B        |L25.18|
;;;65     
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L26.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L26.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L26.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L26.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L29.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L29.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L29.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L29.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L35.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L35.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP

