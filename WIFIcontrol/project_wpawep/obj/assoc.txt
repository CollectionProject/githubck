; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\assoc.o --depend=.\obj\assoc.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\assoc.crf ..\marvel\driver\src\assoc.c]
                          THUMB

                          AREA ||i.assoc_helper_associate||, CODE, READONLY, ALIGN=2

                  assoc_helper_associate PROC
;;;714    
;;;715    static int assoc_helper_associate(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;716                                      struct assoc_request * assoc_req)
;;;717    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;718    	int ret = 0, done = 0;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;719    
;;;720    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;721    
;;;722    	/* If we're given and 'any' BSSID, try associating based on SSID */
;;;723    
;;;724    	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {//bssid关联
00000c  4621              MOV      r1,r4
00000e  2005              MOVS     r0,#5
000010  f7fffffe          BL       test_bit
000014  b188              CBZ      r0,|L1.58|
;;;725    		if (compare_ether_addr(bssid_any, assoc_req->bssid)
000016  f104012a          ADD      r1,r4,#0x2a
00001a  480f              LDR      r0,|L1.88|
00001c  f7fffffe          BL       compare_ether_addr
000020  b158              CBZ      r0,|L1.58|
;;;726    		    && compare_ether_addr(bssid_off, assoc_req->bssid)) {//不是任意的bssid，调用关联
000022  f104012a          ADD      r1,r4,#0x2a
000026  480d              LDR      r0,|L1.92|
000028  f7fffffe          BL       compare_ether_addr
00002c  b128              CBZ      r0,|L1.58|
;;;727    			ret = assoc_helper_bssid(priv, assoc_req);
00002e  4621              MOV      r1,r4
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       assoc_helper_bssid
000036  4606              MOV      r6,r0
;;;728    			done = 1;
000038  2701              MOVS     r7,#1
                  |L1.58|
;;;729    		}
;;;730    	}
;;;731    
;;;732    	if (!done && test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {
00003a  b94f              CBNZ     r7,|L1.80|
00003c  4621              MOV      r1,r4
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       test_bit
000044  b120              CBZ      r0,|L1.80|
;;;733    		ret = assoc_helper_essid(priv, assoc_req);//使用essid关联
000046  4621              MOV      r1,r4
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       assoc_helper_essid
00004e  4606              MOV      r6,r0
                  |L1.80|
;;;734    	}
;;;735    
;;;736    	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;737    	return ret;
000050  4630              MOV      r0,r6
;;;738    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;739    
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      bssid_any
                  |L1.92|
                          DCD      bssid_off

                          AREA ||i.assoc_helper_bssid||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_p
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  assoc_helper_bssid PROC
;;;538    	struct assoc_request *assoc_req);
;;;539    static int assoc_helper_bssid(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;540                                  struct assoc_request * assoc_req)
;;;541    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;542    	int ret = 0;
000008  2700              MOVS     r7,#0
;;;543    	struct bss_descriptor * bss;
;;;544    
;;;545    	lbs_deb_enter_args(LBS_DEB_ASSOC,assoc_req->bssid);
;;;546    
;;;547    	/* Search for index position in list for requested MAC */
;;;548    	bss = lbs_find_bssid_in_list(priv, assoc_req->bssid,
00000a  f8942028          LDRB     r2,[r4,#0x28]
00000e  f104012a          ADD      r1,r4,#0x2a
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       lbs_find_bssid_in_list
000018  4605              MOV      r5,r0
;;;549    			    assoc_req->mode);//在扫描到的BSS列表中，寻找合适的bss
;;;550    	if (bss == NULL) {
00001a  b92d              CBNZ     r5,|L2.40|
;;;551    		lbs_deb_assoc("ASSOC: WAP: BSSID %pM not found, "
00001c  f104012a          ADD      r1,r4,#0x2a
000020  a013              ADR      r0,|L2.112|
000022  f7fffffe          BL       __2printf
;;;552    			"cannot associate.\n", assoc_req->bssid);
;;;553    		goto out;
000026  e01f              B        |L2.104|
                  |L2.40|
;;;554    	}
;;;555    	priv->cur_bss=bss;
000028  f8c65100          STR      r5,[r6,#0x100]
;;;556    	memcpy(&assoc_req->bss, bss, sizeof(struct bss_descriptor));
00002c  f44f72f8          MOV      r2,#0x1f0
000030  4629              MOV      r1,r5
000032  f50470b2          ADD      r0,r4,#0x164
000036  f7fffffe          BL       __aeabi_memcpy4
;;;557    	if (assoc_req->mode == IW_MODE_INFRA) {
00003a  f8940028          LDRB     r0,[r4,#0x28]
00003e  2802              CMP      r0,#2
000040  d109              BNE      |L2.86|
;;;558    		ret = lbs_try_associate(priv, assoc_req);//真正处理关联的地方
000042  4621              MOV      r1,r4
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       lbs_try_associate
00004a  4607              MOV      r7,r0
;;;559    		lbs_deb_assoc("ASSOC: lbs_try_associate(bssid) returned %d\n",
00004c  4639              MOV      r1,r7
00004e  a015              ADR      r0,|L2.164|
000050  f7fffffe          BL       __2printf
000054  e007              B        |L2.102|
                  |L2.86|
;;;560    			      ret);
;;;561    	} else if (assoc_req->mode == IW_MODE_ADHOC) {
000056  f8940028          LDRB     r0,[r4,#0x28]
00005a  2801              CMP      r0,#1
00005c  d103              BNE      |L2.102|
;;;562    		lbs_adhoc_join(priv, assoc_req);
00005e  4621              MOV      r1,r4
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       lbs_adhoc_join
                  |L2.102|
;;;563    	}
;;;564    
;;;565    out:
000066  bf00              NOP      
                  |L2.104|
;;;566    	lbs_deb_leave_args(LBS_DEB_ASSOC,ret);
;;;567    	return ret;
000068  4638              MOV      r0,r7
;;;568    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;569    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
000070  4153534f          DCB      "ASSOC: WAP: BSSID %pM not found, cannot associate.\n",0
000074  433a2057
000078  41503a20
00007c  42535349
000080  44202570
000084  4d206e6f
000088  7420666f
00008c  756e642c
000090  2063616e
000094  6e6f7420
000098  6173736f
00009c  63696174
0000a0  652e0a00
                  |L2.164|
0000a4  4153534f          DCB      "ASSOC: lbs_try_associate(bssid) returned %d\n",0
0000a8  433a206c
0000ac  62735f74
0000b0  72795f61
0000b4  73736f63
0000b8  69617465
0000bc  28627373
0000c0  69642920
0000c4  72657475
0000c8  726e6564
0000cc  2025640a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.assoc_helper_channel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  assoc_helper_channel PROC
;;;769    
;;;770    static int assoc_helper_channel(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;771                                    struct assoc_request * assoc_req)
;;;772    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;773    	int ret = 0;
000006  2600              MOVS     r6,#0
;;;774    
;;;775    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;776    
;;;777    	ret = lbs_update_channel(priv);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       lbs_update_channel
00000e  4606              MOV      r6,r0
;;;778    	if (ret) {
000010  b11e              CBZ      r6,|L3.26|
;;;779    		lbs_deb_assoc("ASSOC: channel: error getting channel.\n");
000012  a026              ADR      r0,|L3.172|
000014  f7fffffe          BL       __2printf
;;;780    		goto done;
000018  e046              B        |L3.168|
                  |L3.26|
;;;781    	}
;;;782    
;;;783    	if (assoc_req->channel == priv->curbssparams.channel)
00001a  f8941026          LDRB     r1,[r4,#0x26]
00001e  f89500d9          LDRB     r0,[r5,#0xd9]
000022  4281              CMP      r1,r0
000024  d100              BNE      |L3.40|
;;;784    		goto done;
000026  e03f              B        |L3.168|
                  |L3.40|
;;;785    	
;;;786    #ifdef MASK_DEBUG
;;;787    	 if (priv->mesh_dev) {
;;;788    		/* Change mesh channel first; 21.p21 firmware won't let
;;;789    		   you change channel otherwise (even though it'll return
;;;790    		   an error to this */
;;;791    		lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_STOP,
;;;792    				assoc_req->channel);
;;;793    	}
;;;794    #endif
;;;795    	lbs_deb_assoc("ASSOC: channel: %d -> %d\n",
000028  f8942026          LDRB     r2,[r4,#0x26]
00002c  f89510d9          LDRB     r1,[r5,#0xd9]
000030  a028              ADR      r0,|L3.212|
000032  f7fffffe          BL       __2printf
;;;796    		      priv->curbssparams.channel, assoc_req->channel);
;;;797    
;;;798    	ret = lbs_set_channel(priv, assoc_req->channel);
000036  f8941026          LDRB     r1,[r4,#0x26]
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       lbs_set_channel
000040  4606              MOV      r6,r0
;;;799    	if (ret < 0)
000042  2e00              CMP      r6,#0
000044  da02              BGE      |L3.76|
;;;800    		lbs_deb_assoc("ASSOC: channel: error setting channel.\n");
000046  a02a              ADR      r0,|L3.240|
000048  f7fffffe          BL       __2printf
                  |L3.76|
;;;801    
;;;802    	/* FIXME: shouldn't need to grab the channel _again_ after setting
;;;803    	 * it since the firmware is supposed to return the new channel, but
;;;804    	 * whatever... */
;;;805    	ret = lbs_update_channel(priv);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       lbs_update_channel
000052  4606              MOV      r6,r0
;;;806    	if (ret) {
000054  b11e              CBZ      r6,|L3.94|
;;;807    		lbs_deb_assoc("ASSOC: channel: error getting channel.\n");
000056  a015              ADR      r0,|L3.172|
000058  f7fffffe          BL       __2printf
;;;808    		goto done;
00005c  e024              B        |L3.168|
                  |L3.94|
;;;809    	}
;;;810    
;;;811    	if (assoc_req->channel != priv->curbssparams.channel) {
00005e  f8941026          LDRB     r1,[r4,#0x26]
000062  f89500d9          LDRB     r0,[r5,#0xd9]
000066  4281              CMP      r1,r0
000068  d005              BEQ      |L3.118|
;;;812    		lbs_deb_assoc("ASSOC: channel: failed to update channel to %d\n",
00006a  f8941026          LDRB     r1,[r4,#0x26]
00006e  a02a              ADR      r0,|L3.280|
000070  f7fffffe          BL       __2printf
;;;813    		              assoc_req->channel);
;;;814    		goto restore_mesh;
000074  e017              B        |L3.166|
                  |L3.118|
;;;815    	}
;;;816    
;;;817    	if (   assoc_req->secinfo.wep_enabled
000076  f44f708d          MOV      r0,#0x11a
00007a  5d00              LDRB     r0,[r0,r4]
00007c  b170              CBZ      r0,|L3.156|
;;;818    	    &&   (assoc_req->wep_keys[0].len
00007e  8e20              LDRH     r0,[r4,#0x30]
000080  b940              CBNZ     r0,|L3.148|
;;;819    	       || assoc_req->wep_keys[1].len
000082  2056              MOVS     r0,#0x56
000084  5b00              LDRH     r0,[r0,r4]
000086  b928              CBNZ     r0,|L3.148|
;;;820    	       || assoc_req->wep_keys[2].len
000088  f8b4007c          LDRH     r0,[r4,#0x7c]
00008c  b910              CBNZ     r0,|L3.148|
;;;821    	       || assoc_req->wep_keys[3].len)) {
00008e  f8b400a2          LDRH     r0,[r4,#0xa2]
000092  b118              CBZ      r0,|L3.156|
                  |L3.148|
;;;822    		/* Make sure WEP keys are re-sent to firmware */
;;;823    		set_bit(ASSOC_FLAG_WEP_KEYS, &assoc_req->flags);
000094  4621              MOV      r1,r4
000096  2006              MOVS     r0,#6
000098  f7fffffe          BL       set_bit
                  |L3.156|
;;;824    	}
;;;825    
;;;826    	/* Must restart/rejoin adhoc networks after channel change */
;;;827     	set_bit(ASSOC_FLAG_SSID, &assoc_req->flags);
00009c  4621              MOV      r1,r4
00009e  2001              MOVS     r0,#1
0000a0  f7fffffe          BL       set_bit
;;;828    
;;;829     restore_mesh:
0000a4  bf00              NOP      
                  |L3.166|
;;;830    	/*if (priv->mesh_dev)
;;;831    		lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START,
;;;832    				priv->curbssparams.channel);*/
;;;833    
;;;834     done:
0000a6  bf00              NOP      
                  |L3.168|
;;;835    	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;836    	return ret;
0000a8  4630              MOV      r0,r6
;;;837    }
0000aa  bd70              POP      {r4-r6,pc}
;;;838    
                          ENDP

                  |L3.172|
0000ac  4153534f          DCB      "ASSOC: channel: error getting channel.\n",0
0000b0  433a2063
0000b4  68616e6e
0000b8  656c3a20
0000bc  6572726f
0000c0  72206765
0000c4  7474696e
0000c8  67206368
0000cc  616e6e65
0000d0  6c2e0a00
                  |L3.212|
0000d4  4153534f          DCB      "ASSOC: channel: %d -> %d\n",0
0000d8  433a2063
0000dc  68616e6e
0000e0  656c3a20
0000e4  2564202d
0000e8  3e202564
0000ec  0a00    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L3.240|
0000f0  4153534f          DCB      "ASSOC: channel: error setting channel.\n",0
0000f4  433a2063
0000f8  68616e6e
0000fc  656c3a20
000100  6572726f
000104  72207365
000108  7474696e
00010c  67206368
000110  616e6e65
000114  6c2e0a00
                  |L3.280|
000118  4153534f          DCB      "ASSOC: channel: failed to update channel to %d\n",0
00011c  433a2063
000120  68616e6e
000124  656c3a20
000128  6661696c
00012c  65642074
000130  6f207570
000134  64617465
000138  20636861
00013c  6e6e656c
000140  20746f20
000144  25640a00

                          AREA ||i.assoc_helper_essid||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  assoc_helper_essid PROC
;;;650    
;;;651    static int assoc_helper_essid(struct lbs_private *priv,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;652                                  struct assoc_request * assoc_req)
;;;653    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;654    	int ret = 0;
000008  2700              MOVS     r7,#0
;;;655    	struct bss_descriptor * bss;
;;;656    	int channel = -1;
00000a  f04f38ff          MOV      r8,#0xffffffff
;;;657    //	DECLARE_SSID_BUF(ssid);
;;;658    
;;;659    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;660    
;;;661    	/* FIXME: take channel into account when picking SSIDs if a channel
;;;662    	 * is set.
;;;663    	 */
;;;664    
;;;665    	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags))
00000e  4621              MOV      r1,r4
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       test_bit
000016  b108              CBZ      r0,|L4.28|
;;;666    		channel = assoc_req->channel;
000018  f8948026          LDRB     r8,[r4,#0x26]
                  |L4.28|
;;;667    
;;;668    	lbs_deb_assoc("SSID '%s' requested\n",
00001c  1d21              ADDS     r1,r4,#4
00001e  a02d              ADR      r0,|L4.212|
000020  f7fffffe          BL       __2printf
;;;669    	              assoc_req->ssid);
;;;670    	if (assoc_req->mode == IW_MODE_INFRA) {
000024  f8940028          LDRB     r0,[r4,#0x28]
000028  2802              CMP      r0,#2
00002a  d11e              BNE      |L4.106|
;;;671    		/*lbs_send_specific_ssid_scan(priv, assoc_req->ssid,
;;;672    			assoc_req->ssid_len);*/
;;;673    
;;;674    		bss = lbs_find_ssid_in_list(priv, assoc_req->ssid,
00002c  2202              MOVS     r2,#2
00002e  e9cd2800          STRD     r2,r8,[sp,#0]
000032  f8942025          LDRB     r2,[r4,#0x25]
000036  2300              MOVS     r3,#0
000038  1d21              ADDS     r1,r4,#4
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       lbs_find_ssid_in_list
000040  4605              MOV      r5,r0
;;;675    				assoc_req->ssid_len, NULL, IW_MODE_INFRA, channel);
;;;676    		if (bss != NULL) {			
000042  b175              CBZ      r5,|L4.98|
;;;677    			priv->cur_bss=bss;
000044  f8c65100          STR      r5,[r6,#0x100]
;;;678    			memcpy(&assoc_req->bss, bss, sizeof(struct bss_descriptor));
000048  f44f72f8          MOV      r2,#0x1f0
00004c  4629              MOV      r1,r5
00004e  f50470b2          ADD      r0,r4,#0x164
000052  f7fffffe          BL       __aeabi_memcpy4
;;;679    			ret = lbs_try_associate(priv, assoc_req);
000056  4621              MOV      r1,r4
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       lbs_try_associate
00005e  4607              MOV      r7,r0
000060  e035              B        |L4.206|
                  |L4.98|
;;;680    		} else {
;;;681    			lbs_deb_assoc("SSID not found; cannot associate\n");
000062  a022              ADR      r0,|L4.236|
000064  f7fffffe          BL       __2printf
000068  e031              B        |L4.206|
                  |L4.106|
;;;682    		}
;;;683    	} else if (assoc_req->mode == IW_MODE_ADHOC) {
00006a  f8940028          LDRB     r0,[r4,#0x28]
00006e  2801              CMP      r0,#1
000070  d12d              BNE      |L4.206|
;;;684    		/* Scan for the network, do not save previous results.  Stale
;;;685    		 *   scan data will cause us to join a non-existant adhoc network
;;;686    		 */
;;;687    	/*	lbs_send_specific_ssid_scan(priv, assoc_req->ssid,
;;;688    			assoc_req->ssid_len);*/
;;;689    
;;;690    		/* Search for the requested SSID in the scan table */
;;;691    		bss = lbs_find_ssid_in_list(priv, assoc_req->ssid,
000072  2201              MOVS     r2,#1
000074  e9cd2800          STRD     r2,r8,[sp,#0]
000078  f8942025          LDRB     r2,[r4,#0x25]
00007c  2300              MOVS     r3,#0
00007e  1d21              ADDS     r1,r4,#4
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       lbs_find_ssid_in_list
000086  4605              MOV      r5,r0
;;;692    				assoc_req->ssid_len, NULL, IW_MODE_ADHOC, channel);
;;;693    		if (bss != NULL) {
000088  b185              CBZ      r5,|L4.172|
;;;694    			priv->cur_bss=bss;
00008a  f8c65100          STR      r5,[r6,#0x100]
;;;695    			lbs_deb_assoc("SSID found, will join\n");
00008e  a020              ADR      r0,|L4.272|
000090  f7fffffe          BL       __2printf
;;;696    			memcpy(&assoc_req->bss, bss, sizeof(struct bss_descriptor));
000094  f44f72f8          MOV      r2,#0x1f0
000098  4629              MOV      r1,r5
00009a  f50470b2          ADD      r0,r4,#0x164
00009e  f7fffffe          BL       __aeabi_memcpy4
;;;697    			lbs_adhoc_join(priv, assoc_req);
0000a2  4621              MOV      r1,r4
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       lbs_adhoc_join
0000aa  e010              B        |L4.206|
                  |L4.172|
;;;698    		} else {
;;;699    			/* else send START command */
;;;700    			lbs_deb_assoc("SSID not found, creating adhoc network\n");
0000ac  a01e              ADR      r0,|L4.296|
0000ae  f7fffffe          BL       __2printf
;;;701    			memcpy(&assoc_req->bss.ssid, &assoc_req->ssid,
0000b2  2220              MOVS     r2,#0x20
0000b4  1d21              ADDS     r1,r4,#4
0000b6  f50470b5          ADD      r0,r4,#0x16a
0000ba  f7fffffe          BL       __aeabi_memcpy
;;;702    				IW_ESSID_MAX_SIZE);
;;;703    			assoc_req->bss.ssid_len = assoc_req->ssid_len;
0000be  f8941025          LDRB     r1,[r4,#0x25]
0000c2  f884118b          STRB     r1,[r4,#0x18b]
;;;704    			lbs_adhoc_start(priv, assoc_req);
0000c6  4621              MOV      r1,r4
0000c8  4630              MOV      r0,r6
0000ca  f7fffffe          BL       lbs_adhoc_start
                  |L4.206|
;;;705    		}
;;;706    	}
;;;707    
;;;708    	lbs_deb_leave_args(LBS_DEB_ASSOC,  ret);
;;;709    	return ret;
0000ce  4638              MOV      r0,r7
;;;710    }
0000d0  e8bd81fc          POP      {r2-r8,pc}
;;;711    
                          ENDP

                  |L4.212|
0000d4  53534944          DCB      "SSID '%s' requested\n",0
0000d8  20272573
0000dc  27207265
0000e0  71756573
0000e4  7465640a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L4.236|
0000ec  53534944          DCB      "SSID not found; cannot associate\n",0
0000f0  206e6f74
0000f4  20666f75
0000f8  6e643b20
0000fc  63616e6e
000100  6f742061
000104  73736f63
000108  69617465
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L4.272|
000110  53534944          DCB      "SSID found, will join\n",0
000114  20666f75
000118  6e642c20
00011c  77696c6c
000120  206a6f69
000124  6e0a00  
000127  00                DCB      0
                  |L4.296|
000128  53534944          DCB      "SSID not found, creating adhoc network\n",0
00012c  206e6f74
000130  20666f75
000134  6e642c20
000138  63726561
00013c  74696e67
000140  20616468
000144  6f63206e
000148  6574776f
00014c  726b0a00

                          AREA ||i.assoc_helper_mode||, CODE, READONLY, ALIGN=1

                  assoc_helper_mode PROC
;;;743    
;;;744    static int assoc_helper_mode(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;745                                 struct assoc_request * assoc_req)
;;;746    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;747    	int ret = 0;
000006  2600              MOVS     r6,#0
;;;748    
;;;749    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;750    
;;;751    	if (assoc_req->mode == priv->mode)
000008  f8940028          LDRB     r0,[r4,#0x28]
00000c  f89510e9          LDRB     r1,[r5,#0xe9]
000010  4288              CMP      r0,r1
000012  d100              BNE      |L5.22|
;;;752    		goto done;
000014  e012              B        |L5.60|
                  |L5.22|
;;;753    
;;;754    	if (assoc_req->mode == IW_MODE_INFRA) {
000016  f8940028          LDRB     r0,[r4,#0x28]
00001a  2802              CMP      r0,#2
00001c  d102              BNE      |L5.36|
;;;755    		/*if (priv->psstate != PS_STATE_FULL_POWER)
;;;756    			lbs_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);*/
;;;757    		priv->psmode = LBS802_11POWERMODECAM;
00001e  2000              MOVS     r0,#0
000020  f8a501ee          STRH     r0,[r5,#0x1ee]
                  |L5.36|
;;;758    	}
;;;759    
;;;760    	priv->mode = assoc_req->mode;
000024  f8940028          LDRB     r0,[r4,#0x28]
000028  f88500e9          STRB     r0,[r5,#0xe9]
;;;761    	//802.11网络管理的函数，这里就是改变网络类型，参数为 SNMP_MIB_OID_BSS_TYPE
;;;762    	ret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_BSS_TYPE, assoc_req->mode);
00002c  f8942028          LDRB     r2,[r4,#0x28]
000030  2100              MOVS     r1,#0
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       lbs_set_snmp_mib
000038  4606              MOV      r6,r0
;;;763    
;;;764    done:
00003a  bf00              NOP      
                  |L5.60|
;;;765    	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;766    	return ret;
00003c  4630              MOV      r0,r6
;;;767    }
00003e  bd70              POP      {r4-r6,pc}
;;;768    
                          ENDP


                          AREA ||i.assoc_helper_secinfo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  assoc_helper_secinfo PROC
;;;887    
;;;888    static int assoc_helper_secinfo(struct lbs_private *priv,
000000  b57c              PUSH     {r2-r6,lr}
;;;889                                    struct assoc_request * assoc_req)
;;;890    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;891    	int ret = 0;
000006  2500              MOVS     r5,#0
;;;892    	uint16_t do_wpa;
;;;893    	uint16_t rsn = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;894    
;;;895    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;896    
;;;897    	memcpy(&priv->secinfo, &assoc_req->secinfo,
00000c  f5067000          ADD      r0,r6,#0x200
000010  f5047180          ADD      r1,r4,#0x100
000014  69ca              LDR      r2,[r1,#0x1c]
000016  6989              LDR      r1,[r1,#0x18]
000018  c006              STM      r0!,{r1,r2}
;;;898    		sizeof(struct lbs_802_11_security));
;;;899    
;;;900    	lbs_set_mac_control(priv);
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       lbs_set_mac_control
;;;901    
;;;902    	/* If RSN is already enabled, don't try to enable it again, since
;;;903    	 * ENABLE_RSN resets internal state machines and will clobber the
;;;904    	 * 4-way WPA handshake.
;;;905    	 */
;;;906    
;;;907    	/* Get RSN enabled/disabled */
;;;908    	ret = lbs_cmd_802_11_enable_rsn(priv, CMD_ACT_GET, &rsn);
000020  466a              MOV      r2,sp
000022  2100              MOVS     r1,#0
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       lbs_cmd_802_11_enable_rsn
00002a  4605              MOV      r5,r0
;;;909    	if (ret) {
00002c  b125              CBZ      r5,|L6.56|
;;;910    		lbs_deb_assoc("Failed to get RSN status: %d\n", ret);
00002e  4629              MOV      r1,r5
000030  a014              ADR      r0,|L6.132|
000032  f7fffffe          BL       __2printf
;;;911    		goto out;
000036  e023              B        |L6.128|
                  |L6.56|
;;;912    	}
;;;913    
;;;914    	/* Don't re-enable RSN if it's already enabled */
;;;915    	do_wpa = assoc_req->secinfo.WPAenabled || assoc_req->secinfo.WPA2enabled;
000038  f8940118          LDRB     r0,[r4,#0x118]
00003c  b918              CBNZ     r0,|L6.70|
00003e  f2401019          MOV      r0,#0x119
000042  5d00              LDRB     r0,[r0,r4]
000044  b108              CBZ      r0,|L6.74|
                  |L6.70|
000046  2001              MOVS     r0,#1
000048  e000              B        |L6.76|
                  |L6.74|
00004a  2000              MOVS     r0,#0
                  |L6.76|
00004c  b280              UXTH     r0,r0
00004e  9001              STR      r0,[sp,#4]
;;;916    	if (do_wpa == rsn)
000050  f8bd0004          LDRH     r0,[sp,#4]
000054  f8bd1000          LDRH     r1,[sp,#0]
000058  4288              CMP      r0,r1
00005a  d100              BNE      |L6.94|
;;;917    		goto out;
00005c  e010              B        |L6.128|
                  |L6.94|
;;;918    
;;;919    	/* Set RSN enabled/disabled */
;;;920    	printf("mrl set rsn action: %d\r\n",do_wpa);
00005e  f8bd1004          LDRH     r1,[sp,#4]
000062  a010              ADR      r0,|L6.164|
000064  f7fffffe          BL       __2printf
;;;921    	ret = lbs_cmd_802_11_enable_rsn(priv, CMD_ACT_SET, &do_wpa);
000068  aa01              ADD      r2,sp,#4
00006a  2101              MOVS     r1,#1
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       lbs_cmd_802_11_enable_rsn
000072  4605              MOV      r5,r0
;;;922    	printf("mrl set rsn result: %d\r\n",do_wpa);
000074  f8bd1004          LDRH     r1,[sp,#4]
000078  a011              ADR      r0,|L6.192|
00007a  f7fffffe          BL       __2printf
;;;923    
;;;924    out:
00007e  bf00              NOP      
                  |L6.128|
;;;925    	lbs_deb_leave_args(LBS_DEB_ASSOC,  ret);
;;;926    	return ret;
000080  4628              MOV      r0,r5
;;;927    }
000082  bd7c              POP      {r2-r6,pc}
;;;928    static int assoc_helper_wpa_keys(struct lbs_private *priv,
                          ENDP

                  |L6.132|
000084  4661696c          DCB      "Failed to get RSN status: %d\n",0
000088  65642074
00008c  6f206765
000090  74205253
000094  4e207374
000098  61747573
00009c  3a202564
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L6.164|
0000a4  6d726c20          DCB      "mrl set rsn action: %d\r\n",0
0000a8  73657420
0000ac  72736e20
0000b0  61637469
0000b4  6f6e3a20
0000b8  25640d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L6.192|
0000c0  6d726c20          DCB      "mrl set rsn result: %d\r\n",0
0000c4  73657420
0000c8  72736e20
0000cc  72657375
0000d0  6c743a20
0000d4  25640d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.assoc_helper_wep_keys||, CODE, READONLY, ALIGN=1

                  assoc_helper_wep_keys PROC
;;;843    
;;;844    static int assoc_helper_wep_keys(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;845    				 struct assoc_request *assoc_req)
;;;846    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;847    	int i;
;;;848    	int ret = 0;
000008  2700              MOVS     r7,#0
;;;849    
;;;850    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;851    
;;;852    	/* Set or remove WEP keys */
;;;853    	if (assoc_req->wep_keys[0].len || assoc_req->wep_keys[1].len ||
00000a  8e20              LDRH     r0,[r4,#0x30]
00000c  b940              CBNZ     r0,|L7.32|
00000e  2056              MOVS     r0,#0x56
000010  5b00              LDRH     r0,[r0,r4]
000012  b928              CBNZ     r0,|L7.32|
;;;854    	    assoc_req->wep_keys[2].len || assoc_req->wep_keys[3].len)
000014  f8b4007c          LDRH     r0,[r4,#0x7c]
000018  b910              CBNZ     r0,|L7.32|
00001a  f8b400a2          LDRH     r0,[r4,#0xa2]
00001e  b130              CBZ      r0,|L7.46|
                  |L7.32|
;;;855    		ret = lbs_cmd_802_11_set_wep(priv, CMD_ACT_ADD, assoc_req);
000020  4622              MOV      r2,r4
000022  2102              MOVS     r1,#2
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       lbs_cmd_802_11_set_wep
00002a  4607              MOV      r7,r0
00002c  e005              B        |L7.58|
                  |L7.46|
;;;856    	else
;;;857    		ret = lbs_cmd_802_11_set_wep(priv, CMD_ACT_REMOVE, assoc_req);
00002e  4622              MOV      r2,r4
000030  2104              MOVS     r1,#4
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       lbs_cmd_802_11_set_wep
000038  4607              MOV      r7,r0
                  |L7.58|
;;;858    
;;;859    	if (ret)
00003a  b107              CBZ      r7,|L7.62|
;;;860    		goto out;
00003c  e030              B        |L7.160|
                  |L7.62|
;;;861    
;;;862    	/* enable/disable the MAC's WEP packet filter */
;;;863    	if (assoc_req->secinfo.wep_enabled)//如果使能wep，这里就要重新写入mac
00003e  f44f708d          MOV      r0,#0x11a
000042  5d00              LDRB     r0,[r0,r4]
000044  b130              CBZ      r0,|L7.84|
;;;864    		priv->mac_control |= CMD_ACT_MAC_WEP_ENABLE;
000046  f8b501da          LDRH     r0,[r5,#0x1da]
00004a  f0400008          ORR      r0,r0,#8
00004e  f8a501da          STRH     r0,[r5,#0x1da]
000052  e005              B        |L7.96|
                  |L7.84|
;;;865    	else
;;;866    		priv->mac_control &= ~CMD_ACT_MAC_WEP_ENABLE;
000054  f8b501da          LDRH     r0,[r5,#0x1da]
000058  f0200008          BIC      r0,r0,#8
00005c  f8a501da          STRH     r0,[r5,#0x1da]
                  |L7.96|
;;;867    
;;;868    	lbs_set_mac_control(priv);
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       lbs_set_mac_control
;;;869    
;;;870    	//mutex_lock(&priv->lock);
;;;871    
;;;872    	/* Copy WEP keys into priv wep key fields */
;;;873    	for (i = 0; i < 4; i++) {
000066  2600              MOVS     r6,#0
000068  e013              B        |L7.146|
                  |L7.106|
;;;874    		memcpy(&priv->wep_keys[i], &assoc_req->wep_keys[i],
00006a  eb060246          ADD      r2,r6,r6,LSL #1
00006e  eb021306          ADD      r3,r2,r6,LSL #4
000072  f1040230          ADD      r2,r4,#0x30
000076  eb020143          ADD      r1,r2,r3,LSL #1
00007a  eb060246          ADD      r2,r6,r6,LSL #1
00007e  eb021306          ADD      r3,r2,r6,LSL #4
000082  f5057202          ADD      r2,r5,#0x208
000086  eb020043          ADD      r0,r2,r3,LSL #1
00008a  2226              MOVS     r2,#0x26
00008c  f7fffffe          BL       __aeabi_memcpy
000090  1c76              ADDS     r6,r6,#1              ;873
                  |L7.146|
000092  2e04              CMP      r6,#4                 ;873
000094  dbe9              BLT      |L7.106|
;;;875    		       sizeof(struct enc_key));
;;;876    	}
;;;877    	priv->wep_tx_keyidx = assoc_req->wep_tx_keyidx;
000096  f8b400c8          LDRH     r0,[r4,#0xc8]
00009a  f8a502a0          STRH     r0,[r5,#0x2a0]
;;;878    
;;;879    	//mutex_unlock(&priv->lock);
;;;880    
;;;881    out:
00009e  bf00              NOP      
                  |L7.160|
;;;882    	lbs_deb_leave_args(LBS_DEB_ASSOC,ret);
;;;883    	return ret;
0000a0  4638              MOV      r0,r7
;;;884    }
0000a2  e8bd81f0          POP      {r4-r8,pc}
;;;885    
                          ENDP


                          AREA ||i.assoc_helper_wpa_ie||, CODE, READONLY, ALIGN=1

                  assoc_helper_wpa_ie PROC
;;;968    
;;;969    static int assoc_helper_wpa_ie(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;970                                   struct assoc_request * assoc_req)
;;;971    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;972    	int ret = 0;
000006  2600              MOVS     r6,#0
;;;973    
;;;974    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;975    
;;;976    	if (assoc_req->secinfo.WPAenabled || assoc_req->secinfo.WPA2enabled) {
000008  f8940118          LDRB     r0,[r4,#0x118]
00000c  b918              CBNZ     r0,|L8.22|
00000e  f2401019          MOV      r0,#0x119
000012  5d00              LDRB     r0,[r0,r4]
000014  b170              CBZ      r0,|L8.52|
                  |L8.22|
;;;977    		memcpy(&priv->wpa_ie, &assoc_req->wpa_ie, assoc_req->wpa_ie_len);
000016  f8942160          LDRB     r2,[r4,#0x160]
00001a  f5047190          ADD      r1,r4,#0x120
00001e  f24100de          MOV      r0,#0x10de
000022  4428              ADD      r0,r0,r5
000024  f7fffffe          BL       __aeabi_memcpy
;;;978    		priv->wpa_ie_len = assoc_req->wpa_ie_len;
000028  f8941160          LDRB     r1,[r4,#0x160]
00002c  f241101e          MOV      r0,#0x111e
000030  5541              STRB     r1,[r0,r5]
000032  e009              B        |L8.72|
                  |L8.52|
;;;979    	} else {
;;;980    		memset(&priv->wpa_ie, 0, MAX_WPA_IE_LEN);
000034  2140              MOVS     r1,#0x40
000036  f24100de          MOV      r0,#0x10de
00003a  4428              ADD      r0,r0,r5
00003c  f7fffffe          BL       __aeabi_memclr
;;;981    		priv->wpa_ie_len = 0;
000040  2100              MOVS     r1,#0
000042  f241101e          MOV      r0,#0x111e
000046  5541              STRB     r1,[r0,r5]
                  |L8.72|
;;;982    	}
;;;983    
;;;984    	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;985    	return ret;
000048  4630              MOV      r0,r6
;;;986    }
00004a  bd70              POP      {r4-r6,pc}
;;;987    
                          ENDP


                          AREA ||i.assoc_helper_wpa_keys||, CODE, READONLY, ALIGN=1

                  assoc_helper_wpa_keys PROC
;;;927    }
;;;928    static int assoc_helper_wpa_keys(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;929                                     struct assoc_request * assoc_req)
;;;930    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;931    	int ret = 0;
000008  2600              MOVS     r6,#0
;;;932    	unsigned int flags = assoc_req->flags;
00000a  6827              LDR      r7,[r4,#0]
;;;933    
;;;934    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;935    
;;;936    	/* Work around older firmware bug where WPA unicast and multicast
;;;937    	 * keys must be set independently.  Seen in SDIO parts with firmware
;;;938    	 * version 5.0.11p0.
;;;939    	 */
;;;940    
;;;941    	if (test_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags)) {
00000c  4621              MOV      r1,r4
00000e  2009              MOVS     r0,#9
000010  f7fffffe          BL       test_bit
000014  b150              CBZ      r0,|L9.44|
;;;942    		clear_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags);
000016  4621              MOV      r1,r4
000018  2008              MOVS     r0,#8
00001a  f7fffffe          BL       clear_bit
;;;943    		ret = lbs_cmd_802_11_key_material(priv, CMD_ACT_SET, assoc_req);
00001e  4622              MOV      r2,r4
000020  2101              MOVS     r1,#1
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       lbs_cmd_802_11_key_material
000028  4606              MOV      r6,r0
;;;944    		assoc_req->flags = flags;
00002a  6027              STR      r7,[r4,#0]
                  |L9.44|
;;;945    	}
;;;946    
;;;947    	if (ret)
00002c  b106              CBZ      r6,|L9.48|
;;;948    		goto out;
00002e  e01e              B        |L9.110|
                  |L9.48|
;;;949    
;;;950    	memcpy(&priv->wpa_unicast_key, &assoc_req->wpa_unicast_key,
000030  2226              MOVS     r2,#0x26
000032  f10401f0          ADD      r1,r4,#0xf0
000036  f5057032          ADD      r0,r5,#0x2c8
00003a  f7fffffe          BL       __aeabi_memcpy
;;;951    			sizeof(struct enc_key));
;;;952    
;;;953    	if (test_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags)) {
00003e  4621              MOV      r1,r4
000040  2008              MOVS     r0,#8
000042  f7fffffe          BL       test_bit
000046  b188              CBZ      r0,|L9.108|
;;;954    		clear_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags);
000048  4621              MOV      r1,r4
00004a  2009              MOVS     r0,#9
00004c  f7fffffe          BL       clear_bit
;;;955    
;;;956    		ret = lbs_cmd_802_11_key_material(priv, CMD_ACT_SET, assoc_req);
000050  4622              MOV      r2,r4
000052  2101              MOVS     r1,#1
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       lbs_cmd_802_11_key_material
00005a  4606              MOV      r6,r0
;;;957    		assoc_req->flags = flags;
00005c  6027              STR      r7,[r4,#0]
;;;958    
;;;959    		memcpy(&priv->wpa_mcast_key, &assoc_req->wpa_mcast_key,
00005e  2226              MOVS     r2,#0x26
000060  f10401ca          ADD      r1,r4,#0xca
000064  f20520a2          ADD      r0,r5,#0x2a2
000068  f7fffffe          BL       __aeabi_memcpy
                  |L9.108|
;;;960    				sizeof(struct enc_key));
;;;961    	}
;;;962    
;;;963    out:
00006c  bf00              NOP      
                  |L9.110|
;;;964    	//lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
;;;965    	return ret;
00006e  4630              MOV      r0,r6
;;;966    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;967    
                          ENDP


                          AREA ||i.compare_ether_addr||, CODE, READONLY, ALIGN=1

                  compare_ether_addr PROC
;;;26     	     
;;;27     static __inline unsigned compare_ether_addr(const u8 *addr1, const u8 *addr2)
000000  b570              PUSH     {r4-r6,lr}
;;;28     {
000002  4602              MOV      r2,r0
;;;29     	const u16 *a = (const u16 *) addr1;
000004  4613              MOV      r3,r2
;;;30     	const u16 *b = (const u16 *) addr2;
000006  460c              MOV      r4,r1
;;;31     
;;;32     	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) != 0;
000008  8818              LDRH     r0,[r3,#0]
00000a  8825              LDRH     r5,[r4,#0]
00000c  4068              EORS     r0,r0,r5
00000e  885d              LDRH     r5,[r3,#2]
000010  8866              LDRH     r6,[r4,#2]
000012  4075              EORS     r5,r5,r6
000014  4328              ORRS     r0,r0,r5
000016  889d              LDRH     r5,[r3,#4]
000018  88a6              LDRH     r6,[r4,#4]
00001a  4075              EORS     r5,r5,r6
00001c  4328              ORRS     r0,r0,r5
00001e  d001              BEQ      |L10.36|
000020  2001              MOVS     r0,#1
                  |L10.34|
;;;33     }
000022  bd70              POP      {r4-r6,pc}
                  |L10.36|
000024  2000              MOVS     r0,#0                 ;32
000026  e7fc              B        |L10.34|
;;;34     
                          ENDP


                          AREA ||i.get_common_rates||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  get_common_rates PROC
;;;60      */
;;;61     static int get_common_rates(struct lbs_private *priv,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;62     	u8 *rates,
;;;63     	u16 *rates_size)
;;;64     {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;65     	int i, j;
;;;66     	u8 intersection[MAX_RATES];
;;;67     	u16 intersection_size;
;;;68     	u16 num_rates = 0;
00000a  f04f0900          MOV      r9,#0
;;;69     
;;;70     	intersection_size = min(*rates_size, ARRAY_SIZE(intersection));
00000e  8830              LDRH     r0,[r6,#0]
000010  280e              CMP      r0,#0xe
000012  d201              BCS      |L11.24|
000014  8830              LDRH     r0,[r6,#0]
000016  e000              B        |L11.26|
                  |L11.24|
000018  200e              MOVS     r0,#0xe
                  |L11.26|
00001a  fa1ffa80          UXTH     r10,r0
;;;71     
;;;72     	/* Allow each rate from 'rates' that is supported by the hardware */
;;;73     	for (i = 0; i < ARRAY_SIZE(lbs_bg_rates) && lbs_bg_rates[i]; i++) {
00001e  2400              MOVS     r4,#0
000020  e014              B        |L11.76|
                  |L11.34|
;;;74     		for (j = 0; j < intersection_size && rates[j]; j++) {
000022  2700              MOVS     r7,#0
000024  e00c              B        |L11.64|
                  |L11.38|
;;;75     			if (rates[j] == lbs_bg_rates[i])
000026  5de8              LDRB     r0,[r5,r7]
000028  491f              LDR      r1,|L11.168|
00002a  5d09              LDRB     r1,[r1,r4]
00002c  4288              CMP      r0,r1
00002e  d106              BNE      |L11.62|
;;;76     				intersection[num_rates++] = rates[j];
000030  5dea              LDRB     r2,[r5,r7]
000032  4648              MOV      r0,r9
000034  1c41              ADDS     r1,r0,#1
000036  fa1ff981          UXTH     r9,r1
00003a  f80d2000          STRB     r2,[sp,r0]
                  |L11.62|
00003e  1c7f              ADDS     r7,r7,#1              ;74
                  |L11.64|
000040  4557              CMP      r7,r10                ;74
000042  da02              BGE      |L11.74|
000044  5de8              LDRB     r0,[r5,r7]            ;74
000046  2800              CMP      r0,#0                 ;74
000048  d1ed              BNE      |L11.38|
                  |L11.74|
00004a  1c64              ADDS     r4,r4,#1              ;73
                  |L11.76|
00004c  2c0e              CMP      r4,#0xe               ;73
00004e  d203              BCS      |L11.88|
000050  4815              LDR      r0,|L11.168|
000052  5d00              LDRB     r0,[r0,r4]            ;73
000054  2800              CMP      r0,#0                 ;73
000056  d1e4              BNE      |L11.34|
                  |L11.88|
;;;77     		}
;;;78     	}
;;;79     
;;;80     	lbs_deb_join("TX data rate 0x%02x\n", priv->cur_rate);
000058  f8981317          LDRB     r1,[r8,#0x317]
00005c  a013              ADR      r0,|L11.172|
00005e  f7fffffe          BL       __2printf
;;;81     
;;;82     	if (!priv->enablehwauto) {
000062  f8b801d4          LDRH     r0,[r8,#0x1d4]
000066  b980              CBNZ     r0,|L11.138|
;;;83     		for (i = 0; i < num_rates; i++) {
000068  2400              MOVS     r4,#0
00006a  e007              B        |L11.124|
                  |L11.108|
;;;84     			if (intersection[i] == priv->cur_rate)
00006c  f81d0004          LDRB     r0,[sp,r4]
000070  f8981317          LDRB     r1,[r8,#0x317]
000074  4288              CMP      r0,r1
000076  d100              BNE      |L11.122|
;;;85     				goto done;
000078  e008              B        |L11.140|
                  |L11.122|
00007a  1c64              ADDS     r4,r4,#1              ;83
                  |L11.124|
00007c  454c              CMP      r4,r9                 ;83
00007e  dbf5              BLT      |L11.108|
;;;86     		}
;;;87     		lbs_pr_alert("Previously set fixed data rate %#x isn't "
;;;88     		       "compatible with the network.\n", priv->cur_rate);
;;;89     		return -1;
000080  f04f30ff          MOV      r0,#0xffffffff
                  |L11.132|
;;;90     	}
;;;91     
;;;92     done:
;;;93     	memset(rates, 0, *rates_size);
;;;94     	*rates_size = num_rates;
;;;95     	memcpy(rates, intersection, num_rates);
;;;96     	return 0;
;;;97     }
000084  b004              ADD      sp,sp,#0x10
000086  e8bd87f0          POP      {r4-r10,pc}
                  |L11.138|
00008a  bf00              NOP                            ;92
                  |L11.140|
00008c  8831              LDRH     r1,[r6,#0]            ;93
00008e  4628              MOV      r0,r5                 ;93
000090  f7fffffe          BL       __aeabi_memclr
000094  f8a69000          STRH     r9,[r6,#0]            ;94
000098  464a              MOV      r2,r9                 ;95
00009a  4669              MOV      r1,sp                 ;95
00009c  4628              MOV      r0,r5                 ;95
00009e  f7fffffe          BL       __aeabi_memcpy
0000a2  2000              MOVS     r0,#0                 ;96
0000a4  e7ee              B        |L11.132|
;;;98     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L11.168|
                          DCD      lbs_bg_rates
                  |L11.172|
0000ac  54582064          DCB      "TX data rate 0x%02x\n",0
0000b0  61746120
0000b4  72617465
0000b8  20307825
0000bc  3032780a
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i.init_marvel_adhoc_assoc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  init_marvel_adhoc_assoc PROC
;;;1772   
;;;1773   static void init_marvel_adhoc_assoc(struct assoc_request *assoc,char *ssid,char *key,char mode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1774   {	
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1775   	
;;;1776   	assoc->flags|=(1<<ASSOC_FLAG_SSID);
00000c  6820              LDR      r0,[r4,#0]
00000e  f0400002          ORR      r0,r0,#2
000012  6020              STR      r0,[r4,#0]
;;;1777   
;;;1778   
;;;1779   	printk("please input essid:%s\n",ssid);
000014  4631              MOV      r1,r6
000016  a029              ADR      r0,|L12.188|
000018  f7fffffe          BL       __2printf
;;;1780   	printk("please input wep/wpa key:%s\n",key);
00001c  4629              MOV      r1,r5
00001e  a02d              ADR      r0,|L12.212|
000020  f7fffffe          BL       __2printf
;;;1781           printk("################link####################### ");
000024  a033              ADR      r0,|L12.244|
000026  f7fffffe          BL       __2printf
;;;1782       memcpy(assoc->ssid,ssid,strlen(ssid));
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       strlen
000030  4680              MOV      r8,r0
000032  4602              MOV      r2,r0
000034  4631              MOV      r1,r6
000036  1d20              ADDS     r0,r4,#4
000038  f7fffffe          BL       __aeabi_memcpy
;;;1783       assoc->ssid_len=strlen((const char *)assoc->ssid);
00003c  1d20              ADDS     r0,r4,#4
00003e  f7fffffe          BL       strlen
000042  f8840025          STRB     r0,[r4,#0x25]
;;;1784   
;;;1785   
;;;1786   	if(strlen(key) && assoc->secinfo.WPAenabled!=1 && assoc->secinfo.WPA2enabled!=1){
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       strlen
00004c  b1f0              CBZ      r0,|L12.140|
00004e  f8940118          LDRB     r0,[r4,#0x118]
000052  2801              CMP      r0,#1
000054  d01a              BEQ      |L12.140|
000056  f2401019          MOV      r0,#0x119
00005a  5d00              LDRB     r0,[r0,r4]
00005c  2801              CMP      r0,#1
00005e  d015              BEQ      |L12.140|
;;;1787   		assoc->wep_keys[0].len=strlen(key);
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       strlen
000066  8620              STRH     r0,[r4,#0x30]
;;;1788   		memcpy(assoc->wep_keys[0].key,key,strlen(key));
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       strlen
00006e  4680              MOV      r8,r0
000070  4602              MOV      r2,r0
000072  4629              MOV      r1,r5
000074  f1040036          ADD      r0,r4,#0x36
000078  f7fffffe          BL       __aeabi_memcpy
;;;1789   		assoc->secinfo.wep_enabled=1;
00007c  2101              MOVS     r1,#1
00007e  f44f708d          MOV      r0,#0x11a
000082  5501              STRB     r1,[r0,r4]
;;;1790   		assoc->flags|=((1<<ASSOC_FLAG_WEP_KEYS)|
000084  6820              LDR      r0,[r4,#0]
000086  f440609a          ORR      r0,r0,#0x4d0
00008a  6020              STR      r0,[r4,#0]
                  |L12.140|
;;;1791   		(1<<ASSOC_FLAG_WEP_TX_KEYIDX)|
;;;1792   		(1<<ASSOC_FLAG_SECINFO)|
;;;1793   		(1<<ASSOC_FLAG_MODE));
;;;1794   	}
;;;1795   
;;;1796        assoc->channel=1;
00008c  2001              MOVS     r0,#1
00008e  f8840026          STRB     r0,[r4,#0x26]
;;;1797      	 assoc->band=0;
000092  2000              MOVS     r0,#0
000094  f8840027          STRB     r0,[r4,#0x27]
;;;1798      	 assoc->mode=(mode=='0')?IW_MODE_INFRA:IW_MODE_ADHOC;
000098  2f30              CMP      r7,#0x30
00009a  d101              BNE      |L12.160|
00009c  2002              MOVS     r0,#2
00009e  e000              B        |L12.162|
                  |L12.160|
0000a0  2001              MOVS     r0,#1
                  |L12.162|
0000a2  f8840028          STRB     r0,[r4,#0x28]
;;;1799        memset(assoc->bssid,0,6);
0000a6  2000              MOVS     r0,#0
0000a8  f8c4002a          STR      r0,[r4,#0x2a]
0000ac  85e0              STRH     r0,[r4,#0x2e]
;;;1800        assoc->secinfo.auth_mode=1;
0000ae  2101              MOVS     r1,#1
0000b0  f240101b          MOV      r0,#0x11b
0000b4  5501              STRB     r1,[r0,r4]
;;;1801   }
0000b6  e8bd81f0          POP      {r4-r8,pc}
;;;1802   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L12.188|
0000bc  706c6561          DCB      "please input essid:%s\n",0
0000c0  73652069
0000c4  6e707574
0000c8  20657373
0000cc  69643a25
0000d0  730a00  
0000d3  00                DCB      0
                  |L12.212|
0000d4  706c6561          DCB      "please input wep/wpa key:%s\n",0
0000d8  73652069
0000dc  6e707574
0000e0  20776570
0000e4  2f777061
0000e8  206b6579
0000ec  3a25730a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L12.244|
0000f4  23232323          DCB      "################link####################### ",0
0000f8  23232323
0000fc  23232323
000100  23232323
000104  6c696e6b
000108  23232323
00010c  23232323
000110  23232323
000114  23232323
000118  23232323
00011c  23232320
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0

                          AREA ||i.is_network_compatible||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  is_network_compatible PROC
;;;1462   }
;;;1463   static int is_network_compatible(struct lbs_private *priv,
000000  b5fe              PUSH     {r1-r7,lr}
;;;1464   				 struct bss_descriptor *bss, uint8_t mode)
;;;1465   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
;;;1466   	int matched = 0;
000008  2600              MOVS     r6,#0
;;;1467   
;;;1468   	lbs_deb_enter(LBS_DEB_SCAN);
;;;1469   
;;;1470   	if (bss->mode != mode)//网络模式对不上，是不能匹配的
00000a  f8950038          LDRB     r0,[r5,#0x38]
00000e  42b8              CMP      r0,r7
000010  d000              BEQ      |L13.20|
;;;1471   		goto done;
000012  e0e5              B        |L13.480|
                  |L13.20|
;;;1472   
;;;1473   	matched = match_bss_no_security(&priv->secinfo, bss);
000014  bf00              NOP      
000016  f8940202          LDRB     r0,[r4,#0x202]
00001a  b998              CBNZ     r0,|L13.68|
00001c  f8940200          LDRB     r0,[r4,#0x200]
000020  b980              CBNZ     r0,|L13.68|
000022  f8940201          LDRB     r0,[r4,#0x201]
000026  b968              CBNZ     r0,|L13.68|
000028  f8950159          LDRB     r0,[r5,#0x159]
00002c  28dd              CMP      r0,#0xdd
00002e  d009              BEQ      |L13.68|
000030  f89501a0          LDRB     r0,[r5,#0x1a0]
000034  2830              CMP      r0,#0x30
000036  d005              BEQ      |L13.68|
000038  8d28              LDRH     r0,[r5,#0x28]
00003a  f0100f10          TST      r0,#0x10
00003e  d101              BNE      |L13.68|
000040  2001              MOVS     r0,#1
000042  e000              B        |L13.70|
                  |L13.68|
000044  2000              MOVS     r0,#0
                  |L13.70|
000046  4606              MOV      r6,r0
;;;1474   	if (matched)
000048  b106              CBZ      r6,|L13.76|
;;;1475   		goto done;
00004a  e0c9              B        |L13.480|
                  |L13.76|
;;;1476   	matched = match_bss_static_wep(&priv->secinfo, bss);
00004c  bf00              NOP      
00004e  f8940202          LDRB     r0,[r4,#0x202]
000052  b158              CBZ      r0,|L13.108|
000054  f8940200          LDRB     r0,[r4,#0x200]
000058  b940              CBNZ     r0,|L13.108|
00005a  f8940201          LDRB     r0,[r4,#0x201]
00005e  b928              CBNZ     r0,|L13.108|
000060  8d28              LDRH     r0,[r5,#0x28]
000062  f0100f10          TST      r0,#0x10
000066  d001              BEQ      |L13.108|
000068  2001              MOVS     r0,#1
00006a  e000              B        |L13.110|
                  |L13.108|
00006c  2000              MOVS     r0,#0
                  |L13.110|
00006e  4606              MOV      r6,r0
;;;1477   	if (matched)
000070  b106              CBZ      r6,|L13.116|
;;;1478   		goto done;
000072  e0b5              B        |L13.480|
                  |L13.116|
;;;1479   	matched = match_bss_wpa(&priv->secinfo, bss);
000074  bf00              NOP      
000076  f8940202          LDRB     r0,[r4,#0x202]
00007a  b940              CBNZ     r0,|L13.142|
00007c  f8940200          LDRB     r0,[r4,#0x200]
000080  b128              CBZ      r0,|L13.142|
000082  f8950159          LDRB     r0,[r5,#0x159]
000086  28dd              CMP      r0,#0xdd
000088  d101              BNE      |L13.142|
00008a  2001              MOVS     r0,#1
00008c  e000              B        |L13.144|
                  |L13.142|
00008e  2000              MOVS     r0,#0
                  |L13.144|
000090  4606              MOV      r6,r0
;;;1480   	if (matched) {
000092  b32e              CBZ      r6,|L13.224|
;;;1481   		lbs_deb_scan("is_network_compatible() WPA: wpa_ie 0x%x "
000094  8d28              LDRH     r0,[r5,#0x28]
000096  f0000310          AND      r3,r0,#0x10
00009a  f2402001          MOV      r0,#0x201
00009e  5d00              LDRB     r0,[r0,r4]
0000a0  b108              CBZ      r0,|L13.166|
;;;1482   			     "wpa2_ie 0x%x WEP %s WPA %s WPA2 %s "
;;;1483   			     "privacy 0x%x\n", bss->wpa_ie[0], bss->rsn_ie[0],
;;;1484   			     priv->secinfo.wep_enabled ? "e" : "d",
;;;1485   			     priv->secinfo.WPAenabled ? "e" : "d",
;;;1486   			     priv->secinfo.WPA2enabled ? "e" : "d",
0000a2  a250              ADR      r2,|L13.484|
0000a4  e000              B        |L13.168|
                  |L13.166|
0000a6  a250              ADR      r2,|L13.488|
                  |L13.168|
0000a8  f8940200          LDRB     r0,[r4,#0x200]
0000ac  b108              CBZ      r0,|L13.178|
0000ae  a14d              ADR      r1,|L13.484|
0000b0  e000              B        |L13.180|
                  |L13.178|
0000b2  a14d              ADR      r1,|L13.488|
                  |L13.180|
0000b4  f2402002          MOV      r0,#0x202             ;1485
0000b8  e88d000e          STM      sp,{r1-r3}            ;1485
0000bc  5d00              LDRB     r0,[r0,r4]            ;1485
0000be  b108              CBZ      r0,|L13.196|
0000c0  a048              ADR      r0,|L13.484|
0000c2  e000              B        |L13.198|
                  |L13.196|
0000c4  a048              ADR      r0,|L13.488|
                  |L13.198|
0000c6  4603              MOV      r3,r0                 ;1484
0000c8  f89521a0          LDRB     r2,[r5,#0x1a0]        ;1484
0000cc  f8951159          LDRB     r1,[r5,#0x159]        ;1484
0000d0  4846              LDR      r0,|L13.492|
0000d2  f7fffffe          BL       __2printf
;;;1487   			     (bss->capability & WLAN_CAPABILITY_PRIVACY));
;;;1488   		set_bssinfo_to_priv(priv,bss);
0000d6  4629              MOV      r1,r5
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       set_bssinfo_to_priv
;;;1489   		goto done;
0000de  e07f              B        |L13.480|
                  |L13.224|
;;;1490   	}
;;;1491   	matched = match_bss_wpa2(&priv->secinfo, bss);
0000e0  bf00              NOP      
0000e2  f8940202          LDRB     r0,[r4,#0x202]
0000e6  b940              CBNZ     r0,|L13.250|
0000e8  f8940201          LDRB     r0,[r4,#0x201]
0000ec  b128              CBZ      r0,|L13.250|
0000ee  f89501a0          LDRB     r0,[r5,#0x1a0]
0000f2  2830              CMP      r0,#0x30
0000f4  d101              BNE      |L13.250|
0000f6  2001              MOVS     r0,#1
0000f8  e000              B        |L13.252|
                  |L13.250|
0000fa  2000              MOVS     r0,#0
                  |L13.252|
0000fc  4606              MOV      r6,r0
;;;1492   	if (matched) {
0000fe  b336              CBZ      r6,|L13.334|
;;;1493   		lbs_deb_scan("is_network_compatible() WPA2: wpa_ie 0x%x "
000100  8d28              LDRH     r0,[r5,#0x28]
000102  f0000310          AND      r3,r0,#0x10
000106  f2402001          MOV      r0,#0x201
00010a  5d00              LDRB     r0,[r0,r4]
00010c  b108              CBZ      r0,|L13.274|
;;;1494   			     "wpa2_ie 0x%x WEP %s WPA %s WPA2 %s "
;;;1495   			     "privacy 0x%x\n", bss->wpa_ie[0], bss->rsn_ie[0],
;;;1496   			     priv->secinfo.wep_enabled ? "e" : "d",
;;;1497   			     priv->secinfo.WPAenabled ? "e" : "d",
;;;1498   			     priv->secinfo.WPA2enabled ? "e" : "d",
00010e  a235              ADR      r2,|L13.484|
000110  e000              B        |L13.276|
                  |L13.274|
000112  a235              ADR      r2,|L13.488|
                  |L13.276|
000114  f8940200          LDRB     r0,[r4,#0x200]
000118  b108              CBZ      r0,|L13.286|
00011a  a132              ADR      r1,|L13.484|
00011c  e000              B        |L13.288|
                  |L13.286|
00011e  a132              ADR      r1,|L13.488|
                  |L13.288|
000120  f2402002          MOV      r0,#0x202             ;1497
000124  e88d000e          STM      sp,{r1-r3}            ;1497
000128  5d00              LDRB     r0,[r0,r4]            ;1497
00012a  b108              CBZ      r0,|L13.304|
00012c  a02d              ADR      r0,|L13.484|
00012e  e000              B        |L13.306|
                  |L13.304|
000130  a02d              ADR      r0,|L13.488|
                  |L13.306|
000132  4603              MOV      r3,r0                 ;1496
000134  f89521a0          LDRB     r2,[r5,#0x1a0]        ;1496
000138  f8951159          LDRB     r1,[r5,#0x159]        ;1496
00013c  482b              LDR      r0,|L13.492|
00013e  305c              ADDS     r0,r0,#0x5c           ;1496
000140  f7fffffe          BL       __2printf
;;;1499   			     (bss->capability & WLAN_CAPABILITY_PRIVACY));
;;;1500   		set_bssinfo_to_priv(priv,bss);
000144  4629              MOV      r1,r5
000146  4620              MOV      r0,r4
000148  f7fffffe          BL       set_bssinfo_to_priv
;;;1501   		goto done;
00014c  e048              B        |L13.480|
                  |L13.334|
;;;1502   	}
;;;1503   	matched = match_bss_dynamic_wep(&priv->secinfo, bss);
00014e  bf00              NOP      
000150  f8940202          LDRB     r0,[r4,#0x202]
000154  b998              CBNZ     r0,|L13.382|
000156  f8940200          LDRB     r0,[r4,#0x200]
00015a  b980              CBNZ     r0,|L13.382|
00015c  f8940201          LDRB     r0,[r4,#0x201]
000160  b968              CBNZ     r0,|L13.382|
000162  f8950159          LDRB     r0,[r5,#0x159]
000166  28dd              CMP      r0,#0xdd
000168  d009              BEQ      |L13.382|
00016a  f89501a0          LDRB     r0,[r5,#0x1a0]
00016e  2830              CMP      r0,#0x30
000170  d005              BEQ      |L13.382|
000172  8d28              LDRH     r0,[r5,#0x28]
000174  f0100f10          TST      r0,#0x10
000178  d001              BEQ      |L13.382|
00017a  2001              MOVS     r0,#1
00017c  e000              B        |L13.384|
                  |L13.382|
00017e  2000              MOVS     r0,#0
                  |L13.384|
000180  4606              MOV      r6,r0
;;;1504   	if (matched) {
000182  b15e              CBZ      r6,|L13.412|
;;;1505   		lbs_deb_scan("is_network_compatible() dynamic WEP: "
000184  8d28              LDRH     r0,[r5,#0x28]
000186  f0000310          AND      r3,r0,#0x10
00018a  f89521a0          LDRB     r2,[r5,#0x1a0]
00018e  f8951159          LDRB     r1,[r5,#0x159]
000192  4816              LDR      r0,|L13.492|
000194  30b8              ADDS     r0,r0,#0xb8
000196  f7fffffe          BL       __2printf
;;;1506   			     "wpa_ie 0x%x wpa2_ie 0x%x privacy 0x%x\n",
;;;1507   			     bss->wpa_ie[0], bss->rsn_ie[0],
;;;1508   			     (bss->capability & WLAN_CAPABILITY_PRIVACY));
;;;1509   		goto done;
00019a  e021              B        |L13.480|
                  |L13.412|
;;;1510   	}
;;;1511   
;;;1512   	/* bss security settings don't match those configured on card */
;;;1513   	lbs_deb_scan("is_network_compatible() FAILED: wpa_ie 0x%x "
00019c  8d28              LDRH     r0,[r5,#0x28]
00019e  f0000310          AND      r3,r0,#0x10
0001a2  f2402001          MOV      r0,#0x201
0001a6  5d00              LDRB     r0,[r0,r4]
0001a8  b108              CBZ      r0,|L13.430|
;;;1514   		     "wpa2_ie 0x%x WEP %s WPA %s WPA2 %s privacy 0x%x\n",
;;;1515   		     bss->wpa_ie[0], bss->rsn_ie[0],
;;;1516   		     priv->secinfo.wep_enabled ? "e" : "d",
;;;1517   		     priv->secinfo.WPAenabled ? "e" : "d",
;;;1518   		     priv->secinfo.WPA2enabled ? "e" : "d",
0001aa  a20e              ADR      r2,|L13.484|
0001ac  e000              B        |L13.432|
                  |L13.430|
0001ae  a20e              ADR      r2,|L13.488|
                  |L13.432|
0001b0  f8940200          LDRB     r0,[r4,#0x200]
0001b4  b108              CBZ      r0,|L13.442|
0001b6  a10b              ADR      r1,|L13.484|
0001b8  e000              B        |L13.444|
                  |L13.442|
0001ba  a10b              ADR      r1,|L13.488|
                  |L13.444|
0001bc  f2402002          MOV      r0,#0x202             ;1517
0001c0  e88d000e          STM      sp,{r1-r3}            ;1517
0001c4  5d00              LDRB     r0,[r0,r4]            ;1517
0001c6  b108              CBZ      r0,|L13.460|
0001c8  a006              ADR      r0,|L13.484|
0001ca  e000              B        |L13.462|
                  |L13.460|
0001cc  a006              ADR      r0,|L13.488|
                  |L13.462|
0001ce  4603              MOV      r3,r0                 ;1516
0001d0  f89521a0          LDRB     r2,[r5,#0x1a0]        ;1516
0001d4  f8951159          LDRB     r1,[r5,#0x159]        ;1516
0001d8  4805              LDR      r0,|L13.496|
0001da  f7fffffe          BL       __2printf
;;;1519   		     (bss->capability & WLAN_CAPABILITY_PRIVACY));
;;;1520   
;;;1521   done:
0001de  bf00              NOP      
                  |L13.480|
;;;1522   	lbs_deb_leave_args(LBS_DEB_SCAN, matched);
;;;1523   	return matched;
0001e0  4630              MOV      r0,r6
;;;1524   }
0001e2  bdfe              POP      {r1-r7,pc}
;;;1525   
                          ENDP

                  |L13.484|
0001e4  6500              DCB      "e",0
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L13.488|
0001e8  6400              DCB      "d",0
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L13.492|
                          DCD      ||.constdata||+0x24
                  |L13.496|
                          DCD      ||.constdata||+0x128

                          AREA ||i.iw_auth_to_ieee_auth||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  iw_auth_to_ieee_auth PROC
;;;109    
;;;110    static u8 iw_auth_to_ieee_auth(u8 auth)
000000  b510              PUSH     {r4,lr}
;;;111    {
000002  4604              MOV      r4,r0
;;;112    	if (auth == IW_AUTH_ALG_OPEN_SYSTEM)
000004  2c01              CMP      r4,#1
000006  d101              BNE      |L14.12|
;;;113    		return 0x00;
000008  2000              MOVS     r0,#0
                  |L14.10|
;;;114    	else if (auth == IW_AUTH_ALG_SHARED_KEY)
;;;115    		return 0x01;
;;;116    	else if (auth == IW_AUTH_ALG_LEAP)
;;;117    		return 0x80;
;;;118    
;;;119    	lbs_deb_join("%s: invalid auth alg 0x%X\n", __func__, auth);
;;;120    	return 0;
;;;121    }
00000a  bd10              POP      {r4,pc}
                  |L14.12|
00000c  2c02              CMP      r4,#2                 ;114
00000e  d101              BNE      |L14.20|
000010  2001              MOVS     r0,#1                 ;115
000012  e7fa              B        |L14.10|
                  |L14.20|
000014  2c04              CMP      r4,#4                 ;116
000016  d101              BNE      |L14.28|
000018  2080              MOVS     r0,#0x80              ;117
00001a  e7f6              B        |L14.10|
                  |L14.28|
00001c  4622              MOV      r2,r4                 ;119
00001e  4903              LDR      r1,|L14.44|
000020  a003              ADR      r0,|L14.48|
000022  f7fffffe          BL       __2printf
000026  2000              MOVS     r0,#0                 ;120
000028  e7ef              B        |L14.10|
;;;122    /**
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      __func__
                  |L14.48|
000030  25733a20          DCB      "%s: invalid auth alg 0x%X\n",0
000034  696e7661
000038  6c696420
00003c  61757468
000040  20616c67
000044  20307825
000048  580a00  
00004b  00                DCB      0

                          AREA ||i.lbs_adhoc_join||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_p
                          REQUIRE _printf_str
                  lbs_adhoc_join PROC
;;;997     */
;;;998    static int lbs_adhoc_join(struct lbs_private *priv,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;999    	struct assoc_request *assoc_req)
;;;1000   {
000004  b09e              SUB      sp,sp,#0x78
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;1001   	struct cmd_ds_802_11_ad_hoc_join cmd;
;;;1002   	struct bss_descriptor *bss = &assoc_req->bss;
00000a  f50674b2          ADD      r4,r6,#0x164
;;;1003   	u8 preamble = RADIO_PREAMBLE_LONG;
00000e  f04f0a00          MOV      r10,#0
;;;1004   	//DECLARE_SSID_BUF(ssid);
;;;1005   	u16 ratesize = 0;
000012  2000              MOVS     r0,#0
000014  9003              STR      r0,[sp,#0xc]
;;;1006   	int ret = 0;
000016  2700              MOVS     r7,#0
;;;1007   
;;;1008   	lbs_deb_enter(LBS_DEB_ASSOC);
;;;1009   
;;;1010   	lbs_deb_join("current SSID '%s', ssid length %u\n",
000018  f89520d7          LDRB     r2,[r5,#0xd7]
00001c  f10501b6          ADD      r1,r5,#0xb6
000020  a09c              ADR      r0,|L15.660|
000022  f7fffffe          BL       __2printf
;;;1011   		priv->curbssparams.ssid,
;;;1012   		priv->curbssparams.ssid_len);
;;;1013   	lbs_deb_join("requested ssid '%s', ssid length %u\n",
000026  f8942027          LDRB     r2,[r4,#0x27]
00002a  1da1              ADDS     r1,r4,#6
00002c  a0a2              ADR      r0,|L15.696|
00002e  f7fffffe          BL       __2printf
;;;1014   		bss->ssid, 
;;;1015   		bss->ssid_len);
;;;1016   
;;;1017   	/* check if the requested SSID is already joined */
;;;1018   	if (priv->curbssparams.ssid_len &&
000032  f89500d7          LDRB     r0,[r5,#0xd7]
000036  b1b8              CBZ      r0,|L15.104|
;;;1019   	    !lbs_ssid_cmp(priv->curbssparams.ssid,
000038  f8943027          LDRB     r3,[r4,#0x27]
00003c  f89510d7          LDRB     r1,[r5,#0xd7]
000040  1da2              ADDS     r2,r4,#6
000042  f10500b6          ADD      r0,r5,#0xb6
000046  f7fffffe          BL       lbs_ssid_cmp
00004a  b968              CBNZ     r0,|L15.104|
;;;1020   			priv->curbssparams.ssid_len,
;;;1021   			bss->ssid, bss->ssid_len) &&
;;;1022   	    (priv->mode == IW_MODE_ADHOC) &&
00004c  f89500e9          LDRB     r0,[r5,#0xe9]
000050  2801              CMP      r0,#1
000052  d109              BNE      |L15.104|
;;;1023   	    (priv->connect_status == LBS_CONNECTED)) {
000054  f8d501dc          LDR      r0,[r5,#0x1dc]
000058  b930              CBNZ     r0,|L15.104|
;;;1024   		union iwreq_data wrqu;
;;;1025   
;;;1026   		lbs_deb_join("ADHOC_J_CMD: New ad-hoc SSID is the same as "
00005a  48a1              LDR      r0,|L15.736|
00005c  f7fffffe          BL       __2printf
;;;1027   			"current, not attempting to re-join");
;;;1028   
;;;1029   		/* Send the re-association event though, because the association
;;;1030   		 * request really was successful, even if just a null-op.
;;;1031   		 */
;;;1032   		memset(&wrqu, 0, sizeof(wrqu));
000060  2000              MOVS     r0,#0
000062  9001              STR      r0,[sp,#4]
000064  9002              STR      r0,[sp,#8]
;;;1033   		//memcpy(wrqu.ap_addr.sa_data, priv->curbssparams.bssid,
;;;1034   		 //      ETH_ALEN);
;;;1035   		//wrqu.ap_addr.sa_family = ARPHRD_ETHER;
;;;1036   		//wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
;;;1037   		goto out;
000066  e110              B        |L15.650|
                  |L15.104|
;;;1038   	}
;;;1039   
;;;1040   	/* Use short preamble only when both the BSS and firmware support it */
;;;1041   	if ((priv->capability & WLAN_CAPABILITY_SHORT_PREAMBLE) &&
000068  f8b50108          LDRH     r0,[r5,#0x108]
00006c  f0100f20          TST      r0,#0x20
000070  d008              BEQ      |L15.132|
;;;1042   	    (bss->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)) {
000072  8d20              LDRH     r0,[r4,#0x28]
000074  f0100f20          TST      r0,#0x20
000078  d004              BEQ      |L15.132|
;;;1043   		lbs_deb_join("AdhocJoin: Short preamble\n");
00007a  a09a              ADR      r0,|L15.740|
00007c  f7fffffe          BL       __2printf
;;;1044   		preamble = RADIO_PREAMBLE_SHORT;
000080  f04f0a02          MOV      r10,#2
                  |L15.132|
;;;1045   	}
;;;1046   
;;;1047   	ret = lbs_set_radio(priv, preamble, 1);
000084  2201              MOVS     r2,#1
000086  4651              MOV      r1,r10
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       lbs_set_radio
00008e  4607              MOV      r7,r0
;;;1048   	if (ret)
000090  b107              CBZ      r7,|L15.148|
;;;1049   		goto out;
000092  e0fa              B        |L15.650|
                  |L15.148|
;;;1050   
;;;1051   	lbs_deb_join("AdhocJoin: channel = %d\n", assoc_req->channel);
000094  f8961026          LDRB     r1,[r6,#0x26]
000098  a099              ADR      r0,|L15.768|
00009a  f7fffffe          BL       __2printf
;;;1052   	lbs_deb_join("AdhocJoin: band = %c\n", assoc_req->band);
00009e  f8961027          LDRB     r1,[r6,#0x27]
0000a2  a09e              ADR      r0,|L15.796|
0000a4  f7fffffe          BL       __2printf
;;;1053   
;;;1054   	priv->adhoccreate = 0;
0000a8  2000              MOVS     r0,#0
0000aa  f8850107          STRB     r0,[r5,#0x107]
;;;1055   	priv->curbssparams.channel = bss->channel;
0000ae  6b20              LDR      r0,[r4,#0x30]
0000b0  f88500d9          STRB     r0,[r5,#0xd9]
;;;1056   
;;;1057   	/* Build the join command */
;;;1058   	memset(&cmd, 0, sizeof(cmd));
0000b4  2168              MOVS     r1,#0x68
0000b6  a804              ADD      r0,sp,#0x10
0000b8  f7fffffe          BL       __aeabi_memclr4
;;;1059   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
0000bc  2065              MOVS     r0,#0x65
0000be  f8ad0012          STRH     r0,[sp,#0x12]
;;;1060   
;;;1061   	cmd.bss.type = CMD_BSS_TYPE_IBSS;
0000c2  2102              MOVS     r1,#2
0000c4  f88d103e          STRB     r1,[sp,#0x3e]
;;;1062   	cmd.bss.beaconperiod = cpu_to_le16(bss->beaconperiod);
0000c8  8ea1              LDRH     r1,[r4,#0x34]
0000ca  a806              ADD      r0,sp,#0x18
0000cc  f8ad103f          STRH     r1,[sp,#0x3f]
;;;1063   
;;;1064   	memcpy(&cmd.bss.bssid, &bss->bssid, ETH_ALEN);
0000d0  6820              LDR      r0,[r4,#0]
0000d2  9006              STR      r0,[sp,#0x18]
0000d4  88a0              LDRH     r0,[r4,#4]
0000d6  f8ad001c          STRH     r0,[sp,#0x1c]
;;;1065   	memcpy(&cmd.bss.ssid, &bss->ssid, bss->ssid_len);
0000da  f8942027          LDRB     r2,[r4,#0x27]
0000de  1da1              ADDS     r1,r4,#6
0000e0  f10d001e          ADD      r0,sp,#0x1e
0000e4  f7fffffe          BL       __aeabi_memcpy
;;;1066   
;;;1067   	memcpy(&cmd.bss.ds, &bss->phy.ds, sizeof(struct ieee_ie_ds_param_set));
0000e8  f8b4104c          LDRH     r1,[r4,#0x4c]
0000ec  f8ad1052          STRH     r1,[sp,#0x52]
0000f0  f894104e          LDRB     r1,[r4,#0x4e]
0000f4  f88d1054          STRB     r1,[sp,#0x54]
;;;1068   
;;;1069   	memcpy(&cmd.bss.ibss, &bss->ss.ibss,
0000f8  f8d41053          LDR      r1,[r4,#0x53]
0000fc  f8cd1059          STR      r1,[sp,#0x59]
;;;1070   	       sizeof(struct ieee_ie_ibss_param_set));
;;;1071   
;;;1072   	cmd.bss.capability = cpu_to_le16(bss->capability & CAPINFO_MASK);
000100  8d20              LDRH     r0,[r4,#0x28]
000102  f420405a          BIC      r0,r0,#0xda00
000106  a906              ADD      r1,sp,#0x18
000108  f8ad0061          STRH     r0,[sp,#0x61]
;;;1073   	lbs_deb_join("ADHOC_J_CMD: tmpcap=%4X CAPINFO_MASK=%4X\n",
00010c  8d21              LDRH     r1,[r4,#0x28]
00010e  f46f425a          MVN      r2,#0xda00
000112  a088              ADR      r0,|L15.820|
000114  f7fffffe          BL       __2printf
;;;1074   	       bss->capability, CAPINFO_MASK);
;;;1075   
;;;1076   	/* information on BSSID descriptor passed to FW */
;;;1077   	lbs_deb_join("ADHOC_J_CMD: BSSID = %pM, SSID = '%s'\n",
000118  f10d021e          ADD      r2,sp,#0x1e
00011c  a906              ADD      r1,sp,#0x18
00011e  a090              ADR      r0,|L15.864|
000120  f7fffffe          BL       __2printf
;;;1078   			cmd.bss.bssid, cmd.bss.ssid);
;;;1079   
;;;1080   	/* Only v8 and below support setting these */
;;;1081   	if (priv->fwrelease < 0x09000000) {
000124  6ea8              LDR      r0,[r5,#0x68]
000126  f1b06f10          CMP      r0,#0x9000000
00012a  d205              BCS      |L15.312|
;;;1082   		/* failtimeout */
;;;1083   		cmd.failtimeout = cpu_to_le16(MRVDRV_ASSOCIATION_TIME_OUT);
00012c  20ff              MOVS     r0,#0xff
00012e  f8ad0071          STRH     r0,[sp,#0x71]
;;;1084   		/* probedelay */
;;;1085   		cmd.probedelay = cpu_to_le16(CMD_SCAN_PROBE_DELAY_TIME);
000132  2000              MOVS     r0,#0
000134  f8ad0073          STRH     r0,[sp,#0x73]
                  |L15.312|
;;;1086   	}
;;;1087   
;;;1088   	/* Copy Data rates from the rates recorded in scan response */
;;;1089   	memset(cmd.bss.rates, 0, sizeof(cmd.bss.rates));
000138  210e              MOVS     r1,#0xe
00013a  f10d0063          ADD      r0,sp,#0x63
00013e  f7fffffe          BL       __aeabi_memclr
;;;1090   	ratesize = min(ARRAY_SIZE(cmd.bss.rates), ARRAY_SIZE (bss->rates));
000142  200e              MOVS     r0,#0xe
000144  9003              STR      r0,[sp,#0xc]
;;;1091   	memcpy(cmd.bss.rates, bss->rates, ratesize);
000146  f8bd200c          LDRH     r2,[sp,#0xc]
00014a  f1040139          ADD      r1,r4,#0x39
00014e  f10d0063          ADD      r0,sp,#0x63
000152  f7fffffe          BL       __aeabi_memcpy
;;;1092   	if (get_common_rates(priv, cmd.bss.rates, &ratesize)) {
000156  aa03              ADD      r2,sp,#0xc
000158  f10d0163          ADD      r1,sp,#0x63
00015c  4628              MOV      r0,r5
00015e  f7fffffe          BL       get_common_rates
000162  b128              CBZ      r0,|L15.368|
;;;1093   		lbs_deb_join("ADHOC_JOIN: get_common_rates returned error.\n");
000164  a088              ADR      r0,|L15.904|
000166  f7fffffe          BL       __2printf
;;;1094   		ret = -1;
00016a  f04f37ff          MOV      r7,#0xffffffff
;;;1095   		goto out;
00016e  e08c              B        |L15.650|
                  |L15.368|
;;;1096   	}
;;;1097   
;;;1098   	/* Copy the ad-hoc creation rates into Current BSS state structure */
;;;1099   	memset(&priv->curbssparams.rates, 0, sizeof(priv->curbssparams.rates));
000170  210f              MOVS     r1,#0xf
000172  f10500da          ADD      r0,r5,#0xda
000176  f7fffffe          BL       __aeabi_memclr
;;;1100   	memcpy(&priv->curbssparams.rates, cmd.bss.rates, ratesize);
00017a  f8bd200c          LDRH     r2,[sp,#0xc]
00017e  f10d0163          ADD      r1,sp,#0x63
000182  f10500da          ADD      r0,r5,#0xda
000186  f7fffffe          BL       __aeabi_memcpy
;;;1101   
;;;1102   	/* Set MSB on basic rates as the firmware requires, but _after_
;;;1103   	 * copying to current bss rates.
;;;1104   	 */
;;;1105   	lbs_set_basic_rate_flags(cmd.bss.rates, ratesize);
00018a  f8bd100c          LDRH     r1,[sp,#0xc]
00018e  f10d0063          ADD      r0,sp,#0x63
000192  f7fffffe          BL       lbs_set_basic_rate_flags
;;;1106   
;;;1107   	cmd.bss.ibss.atimwindow = bss->atimwindow;
000196  8ee1              LDRH     r1,[r4,#0x36]
000198  f10d0059          ADD      r0,sp,#0x59
00019c  f8ad105b          STRH     r1,[sp,#0x5b]
;;;1108   
;;;1109   	if (assoc_req->secinfo.wep_enabled) {
0001a0  f44f708d          MOV      r0,#0x11a
0001a4  5d80              LDRB     r0,[r0,r6]
0001a6  b138              CBZ      r0,|L15.440|
;;;1110   		u16 tmp = le16_to_cpu(cmd.bss.capability);
0001a8  f8bd0061          LDRH     r0,[sp,#0x61]
;;;1111   		tmp |= WLAN_CAPABILITY_PRIVACY;
0001ac  f0400010          ORR      r0,r0,#0x10
;;;1112   		cmd.bss.capability = cpu_to_le16(tmp);
0001b0  a906              ADD      r1,sp,#0x18
0001b2  f8ad0061          STRH     r0,[sp,#0x61]
;;;1113   	}
0001b6  bf00              NOP      
                  |L15.440|
;;;1114   
;;;1115   	if (priv->psmode == LBS802_11POWERMODEMAX_PSP) {
0001b8  f8b501ee          LDRH     r0,[r5,#0x1ee]
0001bc  2801              CMP      r0,#1
0001be  d111              BNE      |L15.484|
;;;1116   		__le32 local_ps_mode = cpu_to_le32(LBS802_11POWERMODECAM);
0001c0  2000              MOVS     r0,#0
0001c2  9002              STR      r0,[sp,#8]
;;;1117   
;;;1118   		/* wake up first */
;;;1119   		ret = lbs_prepare_and_send_command(priv, CMD_802_11_PS_MODE,
0001c4  ab02              ADD      r3,sp,#8
0001c6  2200              MOVS     r2,#0
0001c8  e9cd2300          STRD     r2,r3,[sp,#0]
0001cc  4613              MOV      r3,r2
0001ce  2201              MOVS     r2,#1
0001d0  2121              MOVS     r1,#0x21
0001d2  4628              MOV      r0,r5
0001d4  f7fffffe          BL       lbs_prepare_and_send_command
0001d8  4607              MOV      r7,r0
;;;1120   						   CMD_ACT_SET, 0, 0,
;;;1121   						   &local_ps_mode);
;;;1122   		if (ret) {
0001da  b117              CBZ      r7,|L15.482|
;;;1123   			ret = -1;
0001dc  f04f37ff          MOV      r7,#0xffffffff
;;;1124   			goto out;
0001e0  e053              B        |L15.650|
                  |L15.482|
;;;1125   		}
;;;1126   	}
0001e2  bf00              NOP      
                  |L15.484|
;;;1127   	if (lbs_parse_dnld_countryinfo_11d(priv, bss)) {
0001e4  4621              MOV      r1,r4
0001e6  4628              MOV      r0,r5
0001e8  f7fffffe          BL       lbs_parse_dnld_countryinfo_11d
0001ec  b110              CBZ      r0,|L15.500|
;;;1128   		ret = -1;
0001ee  f04f37ff          MOV      r7,#0xffffffff
;;;1129   		goto out;
0001f2  e04a              B        |L15.650|
                  |L15.500|
;;;1130   	}
;;;1131   		if(1){
;;;1132   			int i;
;;;1133   			unsigned char *pchar=(unsigned char *)&cmd;
0001f4  f10d0910          ADD      r9,sp,#0x10
;;;1134   			printf("join adhoc cmd(length=%d):\n",sizeof(struct cmd_ds_802_11_ad_hoc_join));
0001f8  2165              MOVS     r1,#0x65
0001fa  a06f              ADR      r0,|L15.952|
0001fc  f7fffffe          BL       __2printf
;;;1135   			printf("struct cmd_header=%d\n",sizeof(struct cmd_header));
000200  2108              MOVS     r1,#8
000202  a074              ADR      r0,|L15.980|
000204  f7fffffe          BL       __2printf
;;;1136   			printf("struct adhoc_bssdesc=%d\n",sizeof(struct adhoc_bssdesc));
000208  2159              MOVS     r1,#0x59
00020a  a078              ADR      r0,|L15.1004|
00020c  f7fffffe          BL       __2printf
;;;1137   			printf("struct ieee_ie_ds_param_set=%d\n",sizeof(struct ieee_ie_ds_param_set));
000210  2103              MOVS     r1,#3
000212  a07d              ADR      r0,|L15.1032|
000214  f7fffffe          BL       __2printf
;;;1138   	 		printf("struct ieee_ie_ibss_param_set=%d\n",sizeof(struct ieee_ie_ibss_param_set));
000218  2104              MOVS     r1,#4
00021a  a083              ADR      r0,|L15.1064|
00021c  f7fffffe          BL       __2printf
;;;1139   			printf("le16=%d\n",sizeof(__le16));
000220  2102              MOVS     r1,#2
000222  a08a              ADR      r0,|L15.1100|
000224  f7fffffe          BL       __2printf
;;;1140   			printf("le64=%d\n",sizeof(__le64));
000228  2108              MOVS     r1,#8
00022a  a08b              ADR      r0,|L15.1112|
00022c  f7fffffe          BL       __2printf
;;;1141   			printf("struct ieee_ie_header=%d\n",sizeof(struct ieee_ie_header));
000230  2102              MOVS     r1,#2
000232  a08c              ADR      r0,|L15.1124|
000234  f7fffffe          BL       __2printf
;;;1142   			for(i=0;i<sizeof(struct cmd_ds_802_11_ad_hoc_join);i++)
000238  f04f0800          MOV      r8,#0
00023c  e012              B        |L15.612|
                  |L15.574|
;;;1143   			{	
;;;1144   				if((!(i%10))&&(i))
00023e  200a              MOVS     r0,#0xa
000240  fb98f1f0          SDIV     r1,r8,r0
000244  fb008011          MLS      r0,r0,r1,r8
000248  b928              CBNZ     r0,|L15.598|
00024a  f1b80f00          CMP      r8,#0
00024e  d002              BEQ      |L15.598|
;;;1145   					printf("\n");
000250  a037              ADR      r0,|L15.816|
000252  f7fffffe          BL       __2printf
                  |L15.598|
;;;1146   				printf("0x%2x     ",*pchar++);			
000256  f8191b01          LDRB     r1,[r9],#1
00025a  a089              ADR      r0,|L15.1152|
00025c  f7fffffe          BL       __2printf
000260  f1080801          ADD      r8,r8,#1              ;1142
                  |L15.612|
000264  f1b80f65          CMP      r8,#0x65              ;1142
000268  d3e9              BCC      |L15.574|
;;;1147   			}
;;;1148   			printf("\n");
00026a  a031              ADR      r0,|L15.816|
00026c  f7fffffe          BL       __2printf
;;;1149   		}
;;;1150   	
;;;1151   	ret = lbs_cmd_with_response(priv, CMD_802_11_AD_HOC_JOIN, &cmd);
000270  aa04              ADD      r2,sp,#0x10
000272  212c              MOVS     r1,#0x2c
000274  4628              MOV      r0,r5
000276  f7fffffe          BL       lbs_cmd_with_response
00027a  4607              MOV      r7,r0
;;;1152   	if (ret == 0) {
00027c  b927              CBNZ     r7,|L15.648|
;;;1153   		ret = lbs_adhoc_post(priv,
00027e  a904              ADD      r1,sp,#0x10
000280  4628              MOV      r0,r5
000282  f7fffffe          BL       lbs_adhoc_post
000286  4607              MOV      r7,r0
                  |L15.648|
;;;1154   				     (struct cmd_ds_802_11_ad_hoc_result *)&cmd);
;;;1155   	}
;;;1156   
;;;1157   out:
000288  bf00              NOP      
                  |L15.650|
;;;1158   	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;1159   	return ret;
00028a  4638              MOV      r0,r7
;;;1160   }
00028c  b01e              ADD      sp,sp,#0x78
00028e  e8bd87f0          POP      {r4-r10,pc}
;;;1161   
                          ENDP

000292  0000              DCW      0x0000
                  |L15.660|
000294  63757272          DCB      "current SSID '%s', ssid length %u\n",0
000298  656e7420
00029c  53534944
0002a0  20272573
0002a4  272c2073
0002a8  73696420
0002ac  6c656e67
0002b0  74682025
0002b4  750a00  
0002b7  00                DCB      0
                  |L15.696|
0002b8  72657175          DCB      "requested ssid '%s', ssid length %u\n",0
0002bc  65737465
0002c0  64207373
0002c4  69642027
0002c8  2573272c
0002cc  20737369
0002d0  64206c65
0002d4  6e677468
0002d8  2025750a
0002dc  00      
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0
                  |L15.736|
                          DCD      ||.constdata||+0x188
                  |L15.740|
0002e4  4164686f          DCB      "AdhocJoin: Short preamble\n",0
0002e8  634a6f69
0002ec  6e3a2053
0002f0  686f7274
0002f4  20707265
0002f8  616d626c
0002fc  650a00  
0002ff  00                DCB      0
                  |L15.768|
000300  4164686f          DCB      "AdhocJoin: channel = %d\n",0
000304  634a6f69
000308  6e3a2063
00030c  68616e6e
000310  656c203d
000314  2025640a
000318  00      
000319  00                DCB      0
00031a  00                DCB      0
00031b  00                DCB      0
                  |L15.796|
00031c  4164686f          DCB      "AdhocJoin: band = %c"
000320  634a6f69
000324  6e3a2062
000328  616e6420
00032c  3d202563
                  |L15.816|
000330  0a00              DCB      "\n",0
000332  00                DCB      0
000333  00                DCB      0
                  |L15.820|
000334  4144484f          DCB      "ADHOC_J_CMD: tmpcap=%4X CAPINFO_MASK=%4X\n",0
000338  435f4a5f
00033c  434d443a
000340  20746d70
000344  6361703d
000348  25345820
00034c  43415049
000350  4e464f5f
000354  4d41534b
000358  3d253458
00035c  0a00    
00035e  00                DCB      0
00035f  00                DCB      0
                  |L15.864|
000360  4144484f          DCB      "ADHOC_J_CMD: BSSID = %pM, SSID = '%s'\n",0
000364  435f4a5f
000368  434d443a
00036c  20425353
000370  4944203d
000374  2025704d
000378  2c205353
00037c  4944203d
000380  20272573
000384  270a00  
000387  00                DCB      0
                  |L15.904|
000388  4144484f          DCB      "ADHOC_JOIN: get_common_rates returned error.\n",0
00038c  435f4a4f
000390  494e3a20
000394  6765745f
000398  636f6d6d
00039c  6f6e5f72
0003a0  61746573
0003a4  20726574
0003a8  75726e65
0003ac  64206572
0003b0  726f722e
0003b4  0a00    
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L15.952|
0003b8  6a6f696e          DCB      "join adhoc cmd(length=%d):\n",0
0003bc  20616468
0003c0  6f632063
0003c4  6d64286c
0003c8  656e6774
0003cc  683d2564
0003d0  293a0a00
                  |L15.980|
0003d4  73747275          DCB      "struct cmd_header=%d\n",0
0003d8  63742063
0003dc  6d645f68
0003e0  65616465
0003e4  723d2564
0003e8  0a00    
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L15.1004|
0003ec  73747275          DCB      "struct adhoc_bssdesc=%d\n",0
0003f0  63742061
0003f4  64686f63
0003f8  5f627373
0003fc  64657363
000400  3d25640a
000404  00      
000405  00                DCB      0
000406  00                DCB      0
000407  00                DCB      0
                  |L15.1032|
000408  73747275          DCB      "struct ieee_ie_ds_param_set=%d\n",0
00040c  63742069
000410  6565655f
000414  69655f64
000418  735f7061
00041c  72616d5f
000420  7365743d
000424  25640a00
                  |L15.1064|
000428  73747275          DCB      "struct ieee_ie_ibss_param_set=%d\n",0
00042c  63742069
000430  6565655f
000434  69655f69
000438  6273735f
00043c  70617261
000440  6d5f7365
000444  743d2564
000448  0a00    
00044a  00                DCB      0
00044b  00                DCB      0
                  |L15.1100|
00044c  6c653136          DCB      "le16=%d\n",0
000450  3d25640a
000454  00      
000455  00                DCB      0
000456  00                DCB      0
000457  00                DCB      0
                  |L15.1112|
000458  6c653634          DCB      "le64=%d\n",0
00045c  3d25640a
000460  00      
000461  00                DCB      0
000462  00                DCB      0
000463  00                DCB      0
                  |L15.1124|
000464  73747275          DCB      "struct ieee_ie_header=%d\n",0
000468  63742069
00046c  6565655f
000470  69655f68
000474  65616465
000478  723d2564
00047c  0a00    
00047e  00                DCB      0
00047f  00                DCB      0
                  |L15.1152|
000480  30782532          DCB      "0x%2x     ",0
000484  78202020
000488  202000  
00048b  00                DCB      0

                          AREA ||i.lbs_adhoc_post||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_p
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  lbs_adhoc_post PROC
;;;1298   
;;;1299   static int lbs_adhoc_post(struct lbs_private *priv,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1300   			  struct cmd_ds_802_11_ad_hoc_result *resp)
;;;1301   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1302   	int ret = 0;
000008  f04f0800          MOV      r8,#0
;;;1303   	u16 command = le16_to_cpu(resp->hdr.command);
00000c  f8b69000          LDRH     r9,[r6,#0]
;;;1304   	u16 result = le16_to_cpu(resp->hdr.result);
000010  88f7              LDRH     r7,[r6,#6]
;;;1305   	union iwreq_data wrqu;
;;;1306   	struct bss_descriptor *bss;
;;;1307   //	DECLARE_SSID_BUF(ssid);
;;;1308   
;;;1309   	lbs_deb_enter(LBS_DEB_JOIN);
;;;1310   
;;;1311   	if (!priv->in_progress_assoc_req) {
000012  f8d401fc          LDR      r0,[r4,#0x1fc]
000016  b928              CBNZ     r0,|L16.36|
;;;1312   		lbs_deb_join("ADHOC_RESP: no in-progress association "
000018  a021              ADR      r0,|L16.160|
00001a  f7fffffe          BL       __2printf
;;;1313   			"request\n");
;;;1314   		ret = -1;
00001e  f04f38ff          MOV      r8,#0xffffffff
;;;1315   		goto done;
000022  e03a              B        |L16.154|
                  |L16.36|
;;;1316   	}
;;;1317   	bss = &priv->in_progress_assoc_req->bss;
000024  f8d401fc          LDR      r0,[r4,#0x1fc]
000028  f50075b2          ADD      r5,r0,#0x164
;;;1318   
;;;1319   	/*
;;;1320   	 * Join result code 0 --> SUCCESS
;;;1321   	 */
;;;1322   	if (result) {
00002c  b15f              CBZ      r7,|L16.70|
;;;1323   		lbs_deb_join("ADHOC_RESP: failed (result 0x%X)\n", result);
00002e  4639              MOV      r1,r7
000030  a027              ADR      r0,|L16.208|
000032  f7fffffe          BL       __2printf
;;;1324   		if (priv->connect_status == LBS_CONNECTED)
000036  f8d401dc          LDR      r0,[r4,#0x1dc]
00003a  b910              CBNZ     r0,|L16.66|
;;;1325   			//lbs_mac_event_disconnected(priv);
;;;1326   			lbs_deb_join("join failed!\n");
00003c  a02d              ADR      r0,|L16.244|
00003e  f7fffffe          BL       __2printf
                  |L16.66|
;;;1327   		try_bug(0);
000042  bf00              NOP      
                  |L16.68|
000044  e7fe              B        |L16.68|
                  |L16.70|
;;;1328   		ret = -1;
;;;1329   		goto done;
;;;1330   	}
;;;1331   
;;;1332   	/* Send a Media Connected event, according to the Spec */
;;;1333   	priv->connect_status = LBS_CONNECTED;
000046  2000              MOVS     r0,#0
000048  f8c401dc          STR      r0,[r4,#0x1dc]
;;;1334   
;;;1335   	if (command == CMD_RET(CMD_802_11_AD_HOC_START)) {
00004c  f5a94000          SUB      r0,r9,#0x8000
000050  382b              SUBS     r0,r0,#0x2b
000052  d105              BNE      |L16.96|
;;;1336   		/* Update the created network descriptor with the new BSSID */
;;;1337   		memcpy(bss->bssid, resp->bssid, ETH_ALEN);
000054  f8d6000b          LDR      r0,[r6,#0xb]
000058  6028              STR      r0,[r5,#0]
00005a  f8b6000f          LDRH     r0,[r6,#0xf]
00005e  80a8              STRH     r0,[r5,#4]
                  |L16.96|
;;;1338   	}
;;;1339   
;;;1340   	/* Set the BSSID from the joined/started descriptor */
;;;1341   	memcpy(&priv->curbssparams.bssid, bss->bssid, ETH_ALEN);
000060  f1040080          ADD      r0,r4,#0x80
000064  6829              LDR      r1,[r5,#0]
000066  f8c410b0          STR      r1,[r4,#0xb0]
00006a  88a9              LDRH     r1,[r5,#4]
00006c  f8a410b4          STRH     r1,[r4,#0xb4]
;;;1342   
;;;1343   	/* Set the new SSID to current SSID */
;;;1344   	memcpy(&priv->curbssparams.ssid, &bss->ssid, IW_ESSID_MAX_SIZE);
000070  2220              MOVS     r2,#0x20
000072  1da9              ADDS     r1,r5,#6
000074  3036              ADDS     r0,r0,#0x36
000076  f7fffffe          BL       __aeabi_memcpy
;;;1345   	priv->curbssparams.ssid_len = bss->ssid_len;
00007a  f8951027          LDRB     r1,[r5,#0x27]
00007e  f88410d7          STRB     r1,[r4,#0xd7]
;;;1346   
;;;1347   	/*netif_carrier_on(priv->dev);
;;;1348   	if (!priv->tx_pending_len)
;;;1349   		netif_wake_queue(priv->dev);*/
;;;1350   
;;;1351   	memset(&wrqu, 0, sizeof(wrqu));
000082  2000              MOVS     r0,#0
000084  9000              STR      r0,[sp,#0]
000086  9001              STR      r0,[sp,#4]
;;;1352   //	memcpy(wrqu.ap_addr.sa_data, priv->curbssparams.bssid, ETH_ALEN);
;;;1353   	//wrqu.ap_addr.sa_family = ARPHRD_ETHER;
;;;1354   	//wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
;;;1355   
;;;1356   	lbs_deb_join("ADHOC_RESP: Joined/started '%s', BSSID %pM, channel %d\n",
000088  f89430d9          LDRB     r3,[r4,#0xd9]
00008c  f10402b0          ADD      r2,r4,#0xb0
000090  1da9              ADDS     r1,r5,#6
000092  a01c              ADR      r0,|L16.260|
000094  f7fffffe          BL       __2printf
;;;1357   		     bss->ssid,
;;;1358   		     priv->curbssparams.bssid,
;;;1359   		     priv->curbssparams.channel);
;;;1360   
;;;1361   done:
000098  bf00              NOP      
                  |L16.154|
;;;1362   	lbs_deb_leave_args(LBS_DEB_JOIN, ret);
;;;1363   	return ret;
00009a  4640              MOV      r0,r8
;;;1364   }
00009c  e8bd87fc          POP      {r2-r10,pc}
;;;1365   
                          ENDP

                  |L16.160|
0000a0  4144484f          DCB      "ADHOC_RESP: no in-progress association request\n",0
0000a4  435f5245
0000a8  53503a20
0000ac  6e6f2069
0000b0  6e2d7072
0000b4  6f677265
0000b8  73732061
0000bc  73736f63
0000c0  69617469
0000c4  6f6e2072
0000c8  65717565
0000cc  73740a00
                  |L16.208|
0000d0  4144484f          DCB      "ADHOC_RESP: failed (result 0x%X)\n",0
0000d4  435f5245
0000d8  53503a20
0000dc  6661696c
0000e0  65642028
0000e4  72657375
0000e8  6c742030
0000ec  78255829
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L16.244|
0000f4  6a6f696e          DCB      "join failed!\n",0
0000f8  20666169
0000fc  6c656421
000100  0a00    
000102  00                DCB      0
000103  00                DCB      0
                  |L16.260|
000104  4144484f          DCB      "ADHOC_RESP: Joined/started '%s', BSSID %pM, channel %d\n"
000108  435f5245
00010c  53503a20
000110  4a6f696e
000114  65642f73
000118  74617274
00011c  65642027
000120  2573272c
000124  20425353
000128  49442025
00012c  704d2c20
000130  6368616e
000134  6e656c20
000138  25640a  
00013b  00                DCB      0

                          AREA ||i.lbs_adhoc_start||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                  lbs_adhoc_start PROC
;;;1170    */
;;;1171   static int lbs_adhoc_start(struct lbs_private *priv,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1172   	struct assoc_request *assoc_req)
;;;1173   {
000004  b0af              SUB      sp,sp,#0xbc
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;1174   	struct cmd_ds_802_11_ad_hoc_start cmd;
;;;1175   	u8 preamble = RADIO_PREAMBLE_LONG;
00000a  f04f0900          MOV      r9,#0
;;;1176   	size_t ratesize = 0;
00000e  2700              MOVS     r7,#0
;;;1177   	u16 tmpcap = 0;
000010  46b8              MOV      r8,r7
;;;1178   	int ret = 0;
000012  2600              MOVS     r6,#0
;;;1179   	//DECLARE_SSID_BUF(ssid);
;;;1180   
;;;1181   	lbs_deb_enter(LBS_DEB_ASSOC);
;;;1182   
;;;1183   	if (priv->capability & WLAN_CAPABILITY_SHORT_PREAMBLE) {
000014  f8b50108          LDRH     r0,[r5,#0x108]
000018  f0100f20          TST      r0,#0x20
00001c  d004              BEQ      |L17.40|
;;;1184   		lbs_deb_join("ADHOC_START: Will use short preamble\n");
00001e  a050              ADR      r0,|L17.352|
000020  f7fffffe          BL       __2printf
;;;1185   		preamble = RADIO_PREAMBLE_SHORT;
000024  f04f0902          MOV      r9,#2
                  |L17.40|
;;;1186   	}
;;;1187   
;;;1188   	ret = lbs_set_radio(priv, preamble, 1);
000028  2201              MOVS     r2,#1
00002a  4649              MOV      r1,r9
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       lbs_set_radio
000032  4606              MOV      r6,r0
;;;1189   	if (ret)
000034  b106              CBZ      r6,|L17.56|
;;;1190   		goto out;
000036  e08e              B        |L17.342|
                  |L17.56|
;;;1191   
;;;1192   	/* Build the start command */
;;;1193   	memset(&cmd, 0, sizeof(cmd));
000038  21b4              MOVS     r1,#0xb4
00003a  a802              ADD      r0,sp,#8
00003c  f7fffffe          BL       __aeabi_memclr4
;;;1194   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000040  20b1              MOVS     r0,#0xb1
000042  f8ad000a          STRH     r0,[sp,#0xa]
;;;1195   
;;;1196   	memcpy(cmd.ssid, assoc_req->ssid, assoc_req->ssid_len);
000046  f8942025          LDRB     r2,[r4,#0x25]
00004a  1d21              ADDS     r1,r4,#4
00004c  a804              ADD      r0,sp,#0x10
00004e  f7fffffe          BL       __aeabi_memcpy4
;;;1197   
;;;1198   	lbs_deb_join("ADHOC_START: SSID '%s', ssid length %u\n",
000052  f8942025          LDRB     r2,[r4,#0x25]
000056  1d21              ADDS     r1,r4,#4
000058  a04b              ADR      r0,|L17.392|
00005a  f7fffffe          BL       __2printf
;;;1199   		assoc_req->ssid, 
;;;1200   		assoc_req->ssid_len);
;;;1201   
;;;1202   	cmd.bsstype = CMD_BSS_TYPE_IBSS;
00005e  2002              MOVS     r0,#2
000060  f88d0030          STRB     r0,[sp,#0x30]
;;;1203   
;;;1204   	if (priv->beacon_period == 0)
000064  f8b50104          LDRH     r0,[r5,#0x104]
000068  b910              CBNZ     r0,|L17.112|
;;;1205   		priv->beacon_period = MRVDRV_BEACON_INTERVAL;
00006a  2064              MOVS     r0,#0x64
00006c  f8a50104          STRH     r0,[r5,#0x104]
                  |L17.112|
;;;1206   	cmd.beaconperiod = cpu_to_le16(priv->beacon_period);
000070  f8b50104          LDRH     r0,[r5,#0x104]
000074  f8ad0031          STRH     r0,[sp,#0x31]
;;;1207   
;;;1208   	//WARN_ON(!assoc_req->channel);
;;;1209   
;;;1210   	/* set Physical parameter set */
;;;1211   	cmd.ds.header.id = WLAN_EID_DS_PARAMS;
000078  2003              MOVS     r0,#3
00007a  f88d003c          STRB     r0,[sp,#0x3c]
;;;1212   	cmd.ds.header.len = 1;
00007e  2101              MOVS     r1,#1
000080  f88d103d          STRB     r1,[sp,#0x3d]
;;;1213   	cmd.ds.channel = assoc_req->channel;
000084  f8941026          LDRB     r1,[r4,#0x26]
000088  f88d103e          STRB     r1,[sp,#0x3e]
;;;1214   
;;;1215   	/* set IBSS parameter set */
;;;1216   	cmd.ibss.header.id = WLAN_EID_IBSS_PARAMS;
00008c  2006              MOVS     r0,#6
00008e  f88d0034          STRB     r0,[sp,#0x34]
;;;1217   	cmd.ibss.header.len = 2;
000092  2102              MOVS     r1,#2
000094  f88d1035          STRB     r1,[sp,#0x35]
;;;1218   	cmd.ibss.atimwindow = cpu_to_le16(0);
000098  2100              MOVS     r1,#0
00009a  f8ad1036          STRH     r1,[sp,#0x36]
;;;1219   
;;;1220   	/* set capability info */
;;;1221   	tmpcap = WLAN_CAPABILITY_IBSS;
00009e  f04f0802          MOV      r8,#2
;;;1222   	if (assoc_req->secinfo.wep_enabled ||
0000a2  f44f708d          MOV      r0,#0x11a
0000a6  5d00              LDRB     r0,[r0,r4]
0000a8  b930              CBNZ     r0,|L17.184|
;;;1223   	    assoc_req->secinfo.WPAenabled ||
0000aa  f8940118          LDRB     r0,[r4,#0x118]
0000ae  b918              CBNZ     r0,|L17.184|
;;;1224   	    assoc_req->secinfo.WPA2enabled) {
0000b0  f2401019          MOV      r0,#0x119
0000b4  5d00              LDRB     r0,[r0,r4]
0000b6  b128              CBZ      r0,|L17.196|
                  |L17.184|
;;;1225   		lbs_deb_join("ADHOC_START: WEP/WPA enabled, privacy on\n");
0000b8  a03d              ADR      r0,|L17.432|
0000ba  f7fffffe          BL       __2printf
;;;1226   		tmpcap |= WLAN_CAPABILITY_PRIVACY;
0000be  f0480810          ORR      r8,r8,#0x10
0000c2  e002              B        |L17.202|
                  |L17.196|
;;;1227   	} else
;;;1228   		lbs_deb_join("ADHOC_START: WEP disabled, privacy off\n");
0000c4  a045              ADR      r0,|L17.476|
0000c6  f7fffffe          BL       __2printf
                  |L17.202|
;;;1229   
;;;1230   	cmd.capability = cpu_to_le16(tmpcap);
0000ca  f8ad8045          STRH     r8,[sp,#0x45]
;;;1231   
;;;1232   	/* Only v8 and below support setting probe delay */
;;;1233   	if (priv->fwrelease < 0x09000000)
0000ce  6ea8              LDR      r0,[r5,#0x68]
0000d0  f1b06f10          CMP      r0,#0x9000000
0000d4  d202              BCS      |L17.220|
;;;1234   		cmd.probedelay = cpu_to_le16(CMD_SCAN_PROBE_DELAY_TIME);
0000d6  2000              MOVS     r0,#0
0000d8  f8ad0043          STRH     r0,[sp,#0x43]
                  |L17.220|
;;;1235   
;;;1236   	ratesize = min(sizeof(cmd.rates), sizeof(lbs_bg_rates));
0000dc  270e              MOVS     r7,#0xe
;;;1237   	memcpy(cmd.rates, lbs_bg_rates, ratesize);
0000de  463a              MOV      r2,r7
0000e0  4948              LDR      r1,|L17.516|
0000e2  f10d0047          ADD      r0,sp,#0x47
0000e6  f7fffffe          BL       __aeabi_memcpy
;;;1238   
;;;1239   	/* Copy the ad-hoc creating rates into Current BSS state structure */
;;;1240   	memset(&priv->curbssparams.rates, 0, sizeof(priv->curbssparams.rates));
0000ea  210f              MOVS     r1,#0xf
0000ec  f10500da          ADD      r0,r5,#0xda
0000f0  f7fffffe          BL       __aeabi_memclr
;;;1241   	memcpy(&priv->curbssparams.rates, &cmd.rates, ratesize);
0000f4  463a              MOV      r2,r7
0000f6  f10d0147          ADD      r1,sp,#0x47
0000fa  f10500da          ADD      r0,r5,#0xda
0000fe  f7fffffe          BL       __aeabi_memcpy
;;;1242   
;;;1243   	/* Set MSB on basic rates as the firmware requires, but _after_
;;;1244   	 * copying to current bss rates.
;;;1245   	 */
;;;1246   	lbs_set_basic_rate_flags(cmd.rates, ratesize);
000102  4639              MOV      r1,r7
000104  f10d0047          ADD      r0,sp,#0x47
000108  f7fffffe          BL       lbs_set_basic_rate_flags
;;;1247   
;;;1248   	lbs_deb_join("ADHOC_START: rates=%02x %02x %02x %02x\n",
00010c  f89d304a          LDRB     r3,[sp,#0x4a]
000110  9300              STR      r3,[sp,#0]
000112  f89d3049          LDRB     r3,[sp,#0x49]
000116  f89d2048          LDRB     r2,[sp,#0x48]
00011a  f89d1047          LDRB     r1,[sp,#0x47]
00011e  a03a              ADR      r0,|L17.520|
000120  f7fffffe          BL       __2printf
;;;1249   	       cmd.rates[0], cmd.rates[1], cmd.rates[2], cmd.rates[3]);
;;;1250   
;;;1251   	/*if (lbs_create_dnld_countryinfo_11d(priv)) {
;;;1252   		lbs_deb_join("ADHOC_START: dnld_countryinfo_11d failed\n");
;;;1253   		ret = -1;
;;;1254   		goto out;
;;;1255   	}*/
;;;1256   
;;;1257   	lbs_deb_join("ADHOC_START: Starting Ad-Hoc BSS on channel %d, band %d\n",
000124  f8942027          LDRB     r2,[r4,#0x27]
000128  f8941026          LDRB     r1,[r4,#0x26]
00012c  a040              ADR      r0,|L17.560|
00012e  f7fffffe          BL       __2printf
;;;1258   		     assoc_req->channel, assoc_req->band);
;;;1259   
;;;1260   	priv->adhoccreate = 1;
000132  2001              MOVS     r0,#1
000134  f8850107          STRB     r0,[r5,#0x107]
;;;1261   	priv->mode = IW_MODE_ADHOC;
000138  f88500e9          STRB     r0,[r5,#0xe9]
;;;1262   
;;;1263   	ret = lbs_cmd_with_response(priv, CMD_802_11_AD_HOC_START, &cmd);
00013c  aa02              ADD      r2,sp,#8
00013e  212b              MOVS     r1,#0x2b
000140  4628              MOV      r0,r5
000142  f7fffffe          BL       lbs_cmd_with_response
000146  4606              MOV      r6,r0
;;;1264   	if (ret == 0)
000148  b926              CBNZ     r6,|L17.340|
;;;1265   		ret = lbs_adhoc_post(priv,
00014a  a902              ADD      r1,sp,#8
00014c  4628              MOV      r0,r5
00014e  f7fffffe          BL       lbs_adhoc_post
000152  4606              MOV      r6,r0
                  |L17.340|
;;;1266   				     (struct cmd_ds_802_11_ad_hoc_result *)&cmd);
;;;1267   
;;;1268   out:
000154  bf00              NOP      
                  |L17.342|
;;;1269   	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;1270   	return ret;
000156  4630              MOV      r0,r6
;;;1271   }
000158  b02f              ADD      sp,sp,#0xbc
00015a  e8bd83f0          POP      {r4-r9,pc}
;;;1272   
                          ENDP

00015e  0000              DCW      0x0000
                  |L17.352|
000160  4144484f          DCB      "ADHOC_START: Will use short preamble\n",0
000164  435f5354
000168  4152543a
00016c  2057696c
000170  6c207573
000174  65207368
000178  6f727420
00017c  70726561
000180  6d626c65
000184  0a00    
000186  00                DCB      0
000187  00                DCB      0
                  |L17.392|
000188  4144484f          DCB      "ADHOC_START: SSID '%s', ssid length %u\n",0
00018c  435f5354
000190  4152543a
000194  20535349
000198  44202725
00019c  73272c20
0001a0  73736964
0001a4  206c656e
0001a8  67746820
0001ac  25750a00
                  |L17.432|
0001b0  4144484f          DCB      "ADHOC_START: WEP/WPA enabled, privacy on\n",0
0001b4  435f5354
0001b8  4152543a
0001bc  20574550
0001c0  2f575041
0001c4  20656e61
0001c8  626c6564
0001cc  2c207072
0001d0  69766163
0001d4  79206f6e
0001d8  0a00    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L17.476|
0001dc  4144484f          DCB      "ADHOC_START: WEP disabled, privacy off\n",0
0001e0  435f5354
0001e4  4152543a
0001e8  20574550
0001ec  20646973
0001f0  61626c65
0001f4  642c2070
0001f8  72697661
0001fc  6379206f
000200  66660a00
                  |L17.516|
                          DCD      lbs_bg_rates
                  |L17.520|
000208  4144484f          DCB      "ADHOC_START: rates=%02x %02x %02x %02x\n",0
00020c  435f5354
000210  4152543a
000214  20726174
000218  65733d25
00021c  30327820
000220  25303278
000224  20253032
000228  78202530
00022c  32780a00
                  |L17.560|
000230  4144484f          DCB      "ADHOC_START: Starting Ad-Hoc BSS on channel %d, band %d"
000234  435f5354
000238  4152543a
00023c  20537461
000240  7274696e
000244  67204164
000248  2d486f63
00024c  20425353
000250  206f6e20
000254  6368616e
000258  6e656c20
00025c  25642c20
000260  62616e64
000264  202564  
000267  0a00              DCB      "\n",0
000269  00                DCB      0
00026a  00                DCB      0
00026b  00                DCB      0

                          AREA ||i.lbs_adhoc_stop||, CODE, READONLY, ALIGN=1

                  lbs_adhoc_stop PROC
;;;1279    */
;;;1280   int lbs_adhoc_stop(struct lbs_private *priv)
000000  b57c              PUSH     {r2-r6,lr}
;;;1281   {
000002  4604              MOV      r4,r0
;;;1282   	struct cmd_ds_802_11_ad_hoc_stop cmd;
;;;1283   	int ret;
;;;1284   
;;;1285   	lbs_deb_enter(LBS_DEB_JOIN);
;;;1286   
;;;1287   	memset(&cmd, 0, sizeof (cmd));
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
;;;1288   	cmd.hdr.size = cpu_to_le16 (sizeof (cmd));
00000a  2008              MOVS     r0,#8
00000c  f8ad0002          STRH     r0,[sp,#2]
;;;1289   
;;;1290   	ret = lbs_cmd_with_response(priv, CMD_802_11_AD_HOC_STOP, &cmd);
000010  466a              MOV      r2,sp
000012  2140              MOVS     r1,#0x40
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       lbs_cmd_with_response
00001a  4605              MOV      r5,r0
;;;1291   
;;;1292   	/* Clean up everything even if there was an error */
;;;1293   	//lbs_mac_event_disconnected(priv);
;;;1294   
;;;1295   	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;1296   	return ret;
00001c  4628              MOV      r0,r5
;;;1297   }
00001e  bd7c              POP      {r2-r6,pc}
;;;1298   
                          ENDP


                          AREA ||i.lbs_assoc_post||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  lbs_assoc_post PROC
;;;153    
;;;154    static int lbs_assoc_post(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;155    			  struct cmd_ds_802_11_associate_response *resp)
;;;156    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;157    	int ret = 0;
000008  f04f0800          MOV      r8,#0
;;;158    //	union iwreq_data wrqu;
;;;159    	struct bss_descriptor *bss;
;;;160    	u16 status_code;
;;;161    
;;;162    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;163    
;;;164    	if (!priv->in_progress_assoc_req) {
00000c  f8d401fc          LDR      r0,[r4,#0x1fc]
000010  b928              CBNZ     r0,|L19.30|
;;;165    		lbs_deb_assoc("ASSOC_RESP: no in-progress assoc request\n");
000012  a036              ADR      r0,|L19.236|
000014  f7fffffe          BL       __2printf
;;;166    		ret = -1;
000018  f04f38ff          MOV      r8,#0xffffffff
;;;167    		goto done;
00001c  e062              B        |L19.228|
                  |L19.30|
;;;168    	}
;;;169    	bss = &priv->in_progress_assoc_req->bss;
00001e  f8d401fc          LDR      r0,[r4,#0x1fc]
000022  f50077b2          ADD      r7,r0,#0x164
;;;170    
;;;171    	/*
;;;172    	 * Older FW versions map the IEEE 802.11 Status Code in the association
;;;173    	 * response to the following values returned in resp->statuscode:
;;;174    	 *
;;;175    	 *    IEEE Status Code                Marvell Status Code
;;;176    	 *    0                       ->      0x0000 ASSOC_RESULT_SUCCESS
;;;177    	 *    13                      ->      0x0004 ASSOC_RESULT_AUTH_REFUSED
;;;178    	 *    14                      ->      0x0004 ASSOC_RESULT_AUTH_REFUSED
;;;179    	 *    15                      ->      0x0004 ASSOC_RESULT_AUTH_REFUSED
;;;180    	 *    16                      ->      0x0004 ASSOC_RESULT_AUTH_REFUSED
;;;181    	 *    others                  ->      0x0003 ASSOC_RESULT_REFUSED
;;;182    	 *
;;;183    	 * Other response codes:
;;;184    	 *    0x0001 -> ASSOC_RESULT_INVALID_PARAMETERS (unused)
;;;185    	 *    0x0002 -> ASSOC_RESULT_TIMEOUT (internal timer expired waiting for
;;;186    	 *                                    association response from the AP)
;;;187    	 */
;;;188    	printf("resp->statuscode:%x\n",resp->statuscode);
000026  8971              LDRH     r1,[r6,#0xa]
000028  a03b              ADR      r0,|L19.280|
00002a  f7fffffe          BL       __2printf
;;;189    	status_code = le16_to_cpu(resp->statuscode);
00002e  8975              LDRH     r5,[r6,#0xa]
;;;190    	if (/*priv->fwrelease < 0x09000000 这里就不进行固件版本判断了，8686 8385 应该是相同的*/1) {
;;;191    		switch (status_code) {
000030  2d05              CMP      r5,#5
000032  d215              BCS      |L19.96|
000034  e8dff005          TBB      [pc,r5]
000038  0304080c          DCB      0x03,0x04,0x08,0x0c
00003c  1000              DCB      0x10,0x00
;;;192    		case 0x00:
;;;193    			break;
00003e  e014              B        |L19.106|
;;;194    		case 0x01:
;;;195    			lbs_deb_assoc("ASSOC_RESP: invalid parameters\n");
000040  a03b              ADR      r0,|L19.304|
000042  f7fffffe          BL       __2printf
;;;196    			break;
000046  e010              B        |L19.106|
;;;197    		case 0x02:
;;;198    			lbs_deb_assoc("ASSOC_RESP: internal timer "
000048  a041              ADR      r0,|L19.336|
00004a  f7fffffe          BL       __2printf
;;;199    				"expired while waiting for the AP\n");
;;;200    			break;
00004e  e00c              B        |L19.106|
;;;201    		case 0x03:
;;;202    			lbs_deb_assoc("ASSOC_RESP: association "
000050  a04f              ADR      r0,|L19.400|
000052  f7fffffe          BL       __2printf
;;;203    				"refused by AP\n");
;;;204    			break;
000056  e008              B        |L19.106|
;;;205    		case 0x04:
;;;206    			lbs_deb_assoc("ASSOC_RESP: authentication "
000058  a057              ADR      r0,|L19.440|
00005a  f7fffffe          BL       __2printf
;;;207    				"refused by AP\n");
;;;208    			break;
00005e  e004              B        |L19.106|
                  |L19.96|
;;;209    		default:
;;;210    			lbs_deb_assoc("ASSOC_RESP: failure reason 0x%02x "
000060  4629              MOV      r1,r5
000062  a060              ADR      r0,|L19.484|
000064  f7fffffe          BL       __2printf
;;;211    				" unknown\n", status_code);
;;;212    			break;
000068  bf00              NOP      
                  |L19.106|
00006a  bf00              NOP                            ;193
;;;213    		}
;;;214    	} else {
;;;215    		/* v9+ returns the AP's association response */
;;;216    		lbs_deb_assoc("ASSOC_RESP: failure reason 0x%02x\n", status_code);
;;;217    	}
;;;218    
;;;219    	if (status_code) {
00006c  b13d              CBZ      r5,|L19.126|
;;;220    		//lbs_mac_event_disconnected(priv);
;;;221    		lbs_deb_assoc("%s:wrong status code(%d)","assoc",status_code);
00006e  462a              MOV      r2,r5
000070  a167              ADR      r1,|L19.528|
000072  a069              ADR      r0,|L19.536|
000074  f7fffffe          BL       __2printf
;;;222    		//try_bug(0);
;;;223    		ret = -1;
000078  f04f38ff          MOV      r8,#0xffffffff
;;;224    		goto done;
00007c  e032              B        |L19.228|
                  |L19.126|
;;;225    	}
;;;226    
;;;227    	lbs_deb_hex(LBS_DEB_ASSOC, "ASSOC_RESP",
00007e  8870              LDRH     r0,[r6,#2]
000080  f1a00308          SUB      r3,r0,#8
000084  f2410070          MOV      r0,#0x1070
000088  1832              ADDS     r2,r6,r0
00008a  a16a              ADR      r1,|L19.564|
00008c  f44f7080          MOV      r0,#0x100
000090  f7fffffe          BL       lbs_hex
;;;228    		    (void *) (resp + sizeof (resp->hdr)),
;;;229    		    le16_to_cpu(resp->hdr.size) - sizeof (resp->hdr));
;;;230    
;;;231    	/* Send a Media Connected event, according to the Spec */
;;;232    	priv->connect_status = LBS_CONNECTED;
000094  2000              MOVS     r0,#0
000096  f8c401dc          STR      r0,[r4,#0x1dc]
;;;233    
;;;234    	/* Update current SSID and BSSID */
;;;235    	memcpy(&priv->curbssparams.ssid, &bss->ssid, IW_ESSID_MAX_SIZE);
00009a  2220              MOVS     r2,#0x20
00009c  1db9              ADDS     r1,r7,#6
00009e  f10400b6          ADD      r0,r4,#0xb6
0000a2  f7fffffe          BL       __aeabi_memcpy
;;;236    	priv->curbssparams.ssid_len = bss->ssid_len;
0000a6  f8971027          LDRB     r1,[r7,#0x27]
0000aa  f88410d7          STRB     r1,[r4,#0xd7]
;;;237    	memcpy(priv->curbssparams.bssid, bss->bssid, ETH_ALEN);
0000ae  f1040080          ADD      r0,r4,#0x80
0000b2  6839              LDR      r1,[r7,#0]
0000b4  f8c410b0          STR      r1,[r4,#0xb0]
0000b8  88b9              LDRH     r1,[r7,#4]
0000ba  f8a410b4          STRH     r1,[r4,#0xb4]
;;;238    
;;;239    	priv->SNR[TYPE_RXPD][TYPE_AVG] = 0;
0000be  2100              MOVS     r1,#0
0000c0  f8a412f4          STRH     r1,[r4,#0x2f4]
;;;240    	priv->NF[TYPE_RXPD][TYPE_AVG] = 0;
0000c4  f8a412fc          STRH     r1,[r4,#0x2fc]
;;;241    
;;;242    	memset(priv->rawSNR, 0x00, sizeof(priv->rawSNR));
0000c8  f8c41302          STR      r1,[r4,#0x302]
0000cc  f8c41306          STR      r1,[r4,#0x306]
;;;243    	memset(priv->rawNF, 0x00, sizeof(priv->rawNF));
0000d0  f8c4130a          STR      r1,[r4,#0x30a]
0000d4  f8c4130e          STR      r1,[r4,#0x30e]
;;;244    	priv->nextSNRNF = 0;
0000d8  2000              MOVS     r0,#0
0000da  f8a40312          STRH     r0,[r4,#0x312]
;;;245    	priv->numSNRNF = 0;
0000de  f8a40314          STRH     r0,[r4,#0x314]
;;;246    
;;;247    	/*netif_carrier_on(priv->dev);
;;;248    	if (!priv->tx_pending_len)
;;;249    		netif_wake_queue(priv->dev);*/
;;;250    
;;;251    //	memcpy(wrqu.ap_addr.sa_data, priv->curbssparams.bssid, ETH_ALEN);
;;;252    //	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
;;;253    //	wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
;;;254    
;;;255    done:
0000e2  bf00              NOP      
                  |L19.228|
;;;256    	lbs_deb_leave_args(LBS_DEB_ASSOC,ret);
;;;257    	return ret;
0000e4  4640              MOV      r0,r8
;;;258    }
0000e6  e8bd81f0          POP      {r4-r8,pc}
;;;259    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L19.236|
0000ec  4153534f          DCB      "ASSOC_RESP: no in-progress assoc request\n",0
0000f0  435f5245
0000f4  53503a20
0000f8  6e6f2069
0000fc  6e2d7072
000100  6f677265
000104  73732061
000108  73736f63
00010c  20726571
000110  75657374
000114  0a00    
000116  00                DCB      0
000117  00                DCB      0
                  |L19.280|
000118  72657370          DCB      "resp->statuscode:%x\n",0
00011c  2d3e7374
000120  61747573
000124  636f6465
000128  3a25780a
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0
                  |L19.304|
000130  4153534f          DCB      "ASSOC_RESP: invalid parameters\n",0
000134  435f5245
000138  53503a20
00013c  696e7661
000140  6c696420
000144  70617261
000148  6d657465
00014c  72730a00
                  |L19.336|
000150  4153534f          DCB      "ASSOC_RESP: internal timer expired while waiting for th"
000154  435f5245
000158  53503a20
00015c  696e7465
000160  726e616c
000164  2074696d
000168  65722065
00016c  78706972
000170  65642077
000174  68696c65
000178  20776169
00017c  74696e67
000180  20666f72
000184  207468  
000187  65204150          DCB      "e AP\n",0
00018b  0a00    
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L19.400|
000190  4153534f          DCB      "ASSOC_RESP: association refused by AP\n",0
000194  435f5245
000198  53503a20
00019c  6173736f
0001a0  63696174
0001a4  696f6e20
0001a8  72656675
0001ac  73656420
0001b0  62792041
0001b4  500a00  
0001b7  00                DCB      0
                  |L19.440|
0001b8  4153534f          DCB      "ASSOC_RESP: authentication refused by AP\n",0
0001bc  435f5245
0001c0  53503a20
0001c4  61757468
0001c8  656e7469
0001cc  63617469
0001d0  6f6e2072
0001d4  65667573
0001d8  65642062
0001dc  79204150
0001e0  0a00    
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L19.484|
0001e4  4153534f          DCB      "ASSOC_RESP: failure reason 0x%02x  unknown\n",0
0001e8  435f5245
0001ec  53503a20
0001f0  6661696c
0001f4  75726520
0001f8  72656173
0001fc  6f6e2030
000200  78253032
000204  78202075
000208  6e6b6e6f
00020c  776e0a00
                  |L19.528|
000210  6173736f          DCB      "assoc",0
000214  6300    
000216  00                DCB      0
000217  00                DCB      0
                  |L19.536|
000218  25733a77          DCB      "%s:wrong status code(%d)",0
00021c  726f6e67
000220  20737461
000224  74757320
000228  636f6465
00022c  28256429
000230  00      
000231  00                DCB      0
000232  00                DCB      0
000233  00                DCB      0
                  |L19.564|
000234  4153534f          DCB      "ASSOC_RESP",0
000238  435f5245
00023c  535000  
00023f  00                DCB      0

                          AREA ||i.lbs_associate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_p
                  lbs_associate PROC
;;;270     */
;;;271    static int lbs_associate(struct lbs_private *priv,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;272    			 struct assoc_request *assoc_req,
;;;273    			 u16 command)
;;;274    {
000004  f5ad7d0a          SUB      sp,sp,#0x228
000008  4607              MOV      r7,r0
;;;275    	extern char * psk_out;
;;;276    	struct cmd_ds_802_11_associate cmd;
;;;277    	int ret = 0;
00000a  2000              MOVS     r0,#0
00000c  9003              STR      r0,[sp,#0xc]
;;;278    	struct bss_descriptor *bss = &assoc_req->bss;
00000e  988b              LDR      r0,[sp,#0x22c]
000010  f50075b2          ADD      r5,r0,#0x164
;;;279    	u8 *pos = &(cmd.iebuf[0]);
000014  f10d0425          ADD      r4,sp,#0x25
;;;280    	u16 tmpcap, tmplen, tmpauth;
;;;281    	struct mrvl_ie_ssid_param_set *ssid;
;;;282    	struct mrvl_ie_ds_param_set *ds;
;;;283    	struct mrvl_ie_cf_param_set *cf;
;;;284    	struct mrvl_ie_rates_param_set *rates;
;;;285    	struct mrvl_ie_rsn_param_set *rsn;
;;;286    	struct mrvl_ie_auth_type *auth;
;;;287    	extern int newpower_time_out_current_state;
;;;288    	newpower_time_out_current_state = 0;
000018  2000              MOVS     r0,#0
00001a  4966              LDR      r1,|L20.436|
00001c  6008              STR      r0,[r1,#0]  ; newpower_time_out_current_state
;;;289    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;290    
;;;291    	//BUG_ON((command != CMD_802_11_ASSOCIATE) &&
;;;292    	//	(command != CMD_802_11_REASSOCIATE));
;;;293    
;;;294    	memset(&cmd, 0, sizeof(cmd));
00001e  f44f7106          MOV      r1,#0x218
000022  a804              ADD      r0,sp,#0x10
000024  f7fffffe          BL       __aeabi_memclr4
;;;295    	cmd.hdr.command = cpu_to_le16(command);
000028  988c              LDR      r0,[sp,#0x230]
00002a  f8ad0010          STRH     r0,[sp,#0x10]
;;;296    
;;;297    	/* Fill in static fields */
;;;298    	memcpy(cmd.bssid, bss->bssid, ETH_ALEN);
00002e  6828              LDR      r0,[r5,#0]
000030  9006              STR      r0,[sp,#0x18]
000032  88a8              LDRH     r0,[r5,#4]
000034  f8ad001c          STRH     r0,[sp,#0x1c]
;;;299    	cmd.listeninterval = cpu_to_le16(MRVDRV_DEFAULT_LISTEN_INTERVAL);
000038  200a              MOVS     r0,#0xa
00003a  f8ad0020          STRH     r0,[sp,#0x20]
;;;300    
;;;301    	/* Capability info */
;;;302    	tmpcap = (bss->capability & CAPINFO_MASK);
00003e  8d28              LDRH     r0,[r5,#0x28]
000040  f420405a          BIC      r0,r0,#0xda00
000044  9002              STR      r0,[sp,#8]
;;;303    	if (bss->mode == IW_MODE_INFRA)
000046  f8950038          LDRB     r0,[r5,#0x38]
00004a  2802              CMP      r0,#2
00004c  d103              BNE      |L20.86|
;;;304    		tmpcap |= WLAN_CAPABILITY_ESS;
00004e  9802              LDR      r0,[sp,#8]
000050  f0400001          ORR      r0,r0,#1
000054  9002              STR      r0,[sp,#8]
                  |L20.86|
;;;305    	cmd.capability = cpu_to_le16(tmpcap);
000056  9802              LDR      r0,[sp,#8]
000058  f8ad001e          STRH     r0,[sp,#0x1e]
;;;306    	lbs_deb_assoc("ASSOC_CMD: capability 0x%04x\n", tmpcap);
00005c  a056              ADR      r0,|L20.440|
00005e  9902              LDR      r1,[sp,#8]
000060  f7fffffe          BL       __2printf
;;;307    
;;;308    	/* SSID */
;;;309    	ssid = (struct mrvl_ie_ssid_param_set *) pos;
000064  46a1              MOV      r9,r4
;;;310    	ssid->header.type = cpu_to_le16(TLV_TYPE_SSID);
000066  2000              MOVS     r0,#0
000068  464c              MOV      r4,r9
00006a  f8a90000          STRH     r0,[r9,#0]
;;;311    	tmplen = bss->ssid_len;
00006e  f8950027          LDRB     r0,[r5,#0x27]
000072  9001              STR      r0,[sp,#4]
;;;312    	ssid->header.len = cpu_to_le16(tmplen);
000074  f8bd0004          LDRH     r0,[sp,#4]
000078  f8a90002          STRH     r0,[r9,#2]
;;;313    	memcpy(ssid->ssid, bss->ssid, tmplen);
00007c  f8bd2004          LDRH     r2,[sp,#4]
000080  1da9              ADDS     r1,r5,#6
000082  1d20              ADDS     r0,r4,#4
000084  f7fffffe          BL       __aeabi_memcpy
;;;314    	pos += sizeof(ssid->header) + tmplen;
000088  f8bd0004          LDRH     r0,[sp,#4]
00008c  1d00              ADDS     r0,r0,#4
00008e  4404              ADD      r4,r4,r0
;;;315    
;;;316    	ds = (struct mrvl_ie_ds_param_set *) pos;
000090  46a0              MOV      r8,r4
;;;317    	ds->header.type = cpu_to_le16(TLV_TYPE_PHY_DS);
000092  2003              MOVS     r0,#3
000094  4644              MOV      r4,r8
000096  f8a80000          STRH     r0,[r8,#0]
;;;318    	ds->header.len = cpu_to_le16(1);
00009a  2001              MOVS     r0,#1
00009c  f8a80002          STRH     r0,[r8,#2]
;;;319    	ds->channel = bss->phy.ds.channel;
0000a0  204e              MOVS     r0,#0x4e
0000a2  5d40              LDRB     r0,[r0,r5]
0000a4  f8880004          STRB     r0,[r8,#4]
;;;320    	pos += sizeof(ds->header) + 1;
0000a8  1d64              ADDS     r4,r4,#5
;;;321    
;;;322    	cf = (struct mrvl_ie_cf_param_set *) pos;
0000aa  46a2              MOV      r10,r4
;;;323    	cf->header.type = cpu_to_le16(TLV_TYPE_CF);
0000ac  2004              MOVS     r0,#4
0000ae  4654              MOV      r4,r10
0000b0  f8aa0000          STRH     r0,[r10,#0]
;;;324    	tmplen = sizeof(*cf) - sizeof (cf->header);
0000b4  2006              MOVS     r0,#6
0000b6  9001              STR      r0,[sp,#4]
;;;325    	cf->header.len = cpu_to_le16(tmplen);
0000b8  f8bd0004          LDRH     r0,[sp,#4]
0000bc  f8aa0002          STRH     r0,[r10,#2]
;;;326    	/* IE payload should be zeroed, firmware fills it in for us */
;;;327    	pos += sizeof(*cf);
0000c0  340a              ADDS     r4,r4,#0xa
;;;328    
;;;329    	rates = (struct mrvl_ie_rates_param_set *) pos;
0000c2  4626              MOV      r6,r4
;;;330    	rates->header.type = cpu_to_le16(TLV_TYPE_RATES);
0000c4  2001              MOVS     r0,#1
0000c6  4634              MOV      r4,r6
0000c8  8030              STRH     r0,[r6,#0]
;;;331    	tmplen = min(ARRAY_SIZE(bss->rates), MAX_RATES);
0000ca  200e              MOVS     r0,#0xe
0000cc  9001              STR      r0,[sp,#4]
;;;332    	memcpy(&rates->rates, &bss->rates, tmplen);
0000ce  f8bd2004          LDRH     r2,[sp,#4]
0000d2  f1050139          ADD      r1,r5,#0x39
0000d6  1d30              ADDS     r0,r6,#4
0000d8  f7fffffe          BL       __aeabi_memcpy
;;;333    	if (get_common_rates(priv, rates->rates, &tmplen)) {
0000dc  aa01              ADD      r2,sp,#4
0000de  1d31              ADDS     r1,r6,#4
0000e0  4638              MOV      r0,r7
0000e2  f7fffffe          BL       get_common_rates
0000e6  b118              CBZ      r0,|L20.240|
;;;334    		ret = -1;
0000e8  f04f30ff          MOV      r0,#0xffffffff
0000ec  9003              STR      r0,[sp,#0xc]
;;;335    		goto done;
0000ee  e05c              B        |L20.426|
                  |L20.240|
;;;336    	}
;;;337    	pos += sizeof(rates->header) + tmplen;
0000f0  f8bd0004          LDRH     r0,[sp,#4]
0000f4  1d00              ADDS     r0,r0,#4
0000f6  4404              ADD      r4,r4,r0
;;;338    	rates->header.len = cpu_to_le16(tmplen);
0000f8  f8bd0004          LDRH     r0,[sp,#4]
0000fc  8070              STRH     r0,[r6,#2]
;;;339    	lbs_deb_assoc("ASSOC_CMD: num rates %u\n", tmplen);
0000fe  f8bd1004          LDRH     r1,[sp,#4]
000102  a035              ADR      r0,|L20.472|
000104  f7fffffe          BL       __2printf
;;;340    
;;;341    	/* Copy the infra. association rates into Current BSS state structure */
;;;342    	memset(&priv->curbssparams.rates, 0, sizeof(priv->curbssparams.rates));
000108  210f              MOVS     r1,#0xf
00010a  f10700da          ADD      r0,r7,#0xda
00010e  f7fffffe          BL       __aeabi_memclr
;;;343    	memcpy(&priv->curbssparams.rates, &rates->rates, tmplen);
000112  f8bd2004          LDRH     r2,[sp,#4]
000116  1d31              ADDS     r1,r6,#4
000118  f10700da          ADD      r0,r7,#0xda
00011c  f7fffffe          BL       __aeabi_memcpy
;;;344    
;;;345    	/* Set MSB on basic rates as the firmware requires, but _after_
;;;346    	 * copying to current bss rates.
;;;347    	 */
;;;348    	lbs_set_basic_rate_flags(rates->rates, tmplen);
000120  f8bd1004          LDRH     r1,[sp,#4]
000124  1d30              ADDS     r0,r6,#4
000126  f7fffffe          BL       lbs_set_basic_rate_flags
;;;349    
;;;350    	/* Firmware v9+ indicate authentication suites as a TLV */
;;;351    	if (priv->fwrelease >= 0x09000000) {
00012a  6eb8              LDR      r0,[r7,#0x68]
00012c  f1b06f10          CMP      r0,#0x9000000
000130  d319              BCC      |L20.358|
;;;352    		auth = (struct mrvl_ie_auth_type *) pos;
000132  46a3              MOV      r11,r4
;;;353    		auth->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);
000134  f240101f          MOV      r0,#0x11f
000138  465c              MOV      r4,r11
00013a  f8ab0000          STRH     r0,[r11,#0]
;;;354    		auth->header.len = cpu_to_le16(2);
00013e  2002              MOVS     r0,#2
000140  f8ab0002          STRH     r0,[r11,#2]
;;;355    		tmpauth = iw_auth_to_ieee_auth(priv->secinfo.auth_mode);
000144  f2402103          MOV      r1,#0x203
000148  5dc8              LDRB     r0,[r1,r7]
00014a  f7fffffe          BL       iw_auth_to_ieee_auth
00014e  9000              STR      r0,[sp,#0]
;;;356    		auth->auth = cpu_to_le16(tmpauth);
000150  9800              LDR      r0,[sp,#0]
000152  f8ab0004          STRH     r0,[r11,#4]
;;;357    		pos += sizeof(auth->header) + 2;
000156  1da4              ADDS     r4,r4,#6
;;;358    
;;;359    		lbs_deb_join("AUTH_CMD: BSSID %pM, auth 0x%x\n",
000158  f2402003          MOV      r0,#0x203
00015c  5dc2              LDRB     r2,[r0,r7]
00015e  4629              MOV      r1,r5
000160  a024              ADR      r0,|L20.500|
000162  f7fffffe          BL       __2printf
                  |L20.358|
;;;360    			bss->bssid, priv->secinfo.auth_mode);
;;;361    	}
;;;362    	#if WPA_ENABLE
;;;363    	/* WPA/WPA2 IEs */
;;;364    	if (assoc_req->secinfo.WPAenabled || assoc_req->secinfo.WPA2enabled) {
;;;365    
;;;366    
;;;367    		DEBUG_PARAM_SDIO;
;;;368    
;;;369    		#if 1
;;;370    
;;;371    		if (assoc_req->secinfo.WPAenabled)
;;;372    		{
;;;373    			assoc_req->wpa_ie_len = priv->cur_bss->wpa_ie_len;
;;;374    			memcpy(assoc_req->wpa_ie,priv->cur_bss->wpa_ie,priv->cur_bss->wpa_ie_len);
;;;375    			xdbug_buf("set wpa ie",assoc_req->wpa_ie,assoc_req->wpa_ie_len);
;;;376    			
;;;377    		}else
;;;378    		{
;;;379    			//priv->cur_bss->rsn_ie[1] = 0x14;
;;;380    			assoc_req->wpa_ie_len = priv->cur_bss->rsn_ie_len;
;;;381    			memcpy(assoc_req->wpa_ie,priv->cur_bss->rsn_ie,priv->cur_bss->rsn_ie_len);
;;;382    			xdbug_buf("set rsn ie",assoc_req->wpa_ie,assoc_req->wpa_ie_len);
;;;383    		}
;;;384    
;;;385    		priv->__wpa_ie_len = assoc_req->wpa_ie_len;
;;;386    		memcpy(priv->__wpa_ie,assoc_req->wpa_ie,assoc_req->wpa_ie_len);
;;;387    		printf("!!!!!!!!!!!!!!! wpa_ie_len : %d , rsn_ie_len : %d.\r\n",priv->cur_bss->wpa_ie_len,priv->cur_bss->rsn_ie_len);
;;;388    		#endif
;;;389    
;;;390    		DEBUG_PARAM_SDIO
;;;391    		
;;;392    		memcpy(priv->__mac_addr,priv->cur_bss->bssid,ETH_ALEN);
;;;393    
;;;394    		/*初始化WPA相关部分，并设通过WPA程序生成可用的IEs*/
;;;395    		DEBUG_PARMA_SDIO;
;;;396    		assoc_req->wpa_ie_len = priv->__wpa_ie_len;
;;;397    		memcpy(assoc_req->wpa_ie,priv->__wpa_ie,priv->__wpa_ie_len);//下面是经过调用的IELEN
;;;398    
;;;399    
;;;400    		rsn = (struct mrvl_ie_rsn_param_set *) pos;
;;;401    		/* WPA_IE or WPA2_IE */
;;;402    		rsn->header.type = cpu_to_le16((u16) assoc_req->wpa_ie[0]);
;;;403    		tmplen = (u16) assoc_req->wpa_ie[1];
;;;404    		rsn->header.len = cpu_to_le16(tmplen);
;;;405    		memcpy(rsn->rsnie, &assoc_req->wpa_ie[2], tmplen);
;;;406    		
;;;407    		lbs_deb_hex(LBS_DEB_JOIN, "ASSOC_CMD: WPA IE",(u8 *)assoc_req->wpa_ie,assoc_req->wpa_ie_len);
;;;408    		lbs_deb_hex(LBS_DEB_JOIN, "ASSOC_CMD: RSN IE", (u8 *) rsn,
;;;409    			sizeof(rsn->header) + tmplen);
;;;410    		pos += sizeof(rsn->header) + tmplen;
;;;411    	}
;;;412    	#endif
;;;413    	cmd.hdr.size = cpu_to_le16((sizeof(cmd) - sizeof(cmd.iebuf)) +
000166  f10d0025          ADD      r0,sp,#0x25
00016a  1a20              SUBS     r0,r4,r0
00016c  3015              ADDS     r0,r0,#0x15
00016e  b280              UXTH     r0,r0
000170  f8ad0012          STRH     r0,[sp,#0x12]
;;;414    				   (u16)(pos - (u8 *) &cmd.iebuf));
;;;415    
;;;416    	/* update curbssparams */
;;;417    	priv->curbssparams.channel = bss->phy.ds.channel;
000174  204e              MOVS     r0,#0x4e
000176  5d41              LDRB     r1,[r0,r5]
000178  f88710d9          STRB     r1,[r7,#0xd9]
;;;418    	if (lbs_parse_dnld_countryinfo_11d(priv, bss)) {
00017c  4629              MOV      r1,r5
00017e  4638              MOV      r0,r7
000180  f7fffffe          BL       lbs_parse_dnld_countryinfo_11d
000184  b118              CBZ      r0,|L20.398|
;;;419    		ret = -1;
000186  f04f30ff          MOV      r0,#0xffffffff
00018a  9003              STR      r0,[sp,#0xc]
;;;420    		goto done;
00018c  e00d              B        |L20.426|
                  |L20.398|
;;;421    	}
;;;422    
;;;423    	ret = lbs_cmd_with_response(priv, command, &cmd);
00018e  aa04              ADD      r2,sp,#0x10
000190  4638              MOV      r0,r7
000192  998c              LDR      r1,[sp,#0x230]
000194  f7fffffe          BL       lbs_cmd_with_response
000198  9003              STR      r0,[sp,#0xc]
;;;424    	if (ret == 0) {
00019a  9803              LDR      r0,[sp,#0xc]
00019c  b920              CBNZ     r0,|L20.424|
;;;425    		ret = lbs_assoc_post(priv,
00019e  a904              ADD      r1,sp,#0x10
0001a0  4638              MOV      r0,r7
0001a2  f7fffffe          BL       lbs_assoc_post
0001a6  9003              STR      r0,[sp,#0xc]
                  |L20.424|
;;;426    			(struct cmd_ds_802_11_associate_response *) &cmd);
;;;427    	}
;;;428    
;;;429    done:
0001a8  bf00              NOP      
                  |L20.426|
;;;430    	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;431    	return ret;
0001aa  9803              LDR      r0,[sp,#0xc]
;;;432    }
0001ac  f50d7d0d          ADD      sp,sp,#0x234
0001b0  e8bd8ff0          POP      {r4-r11,pc}
;;;433    
                          ENDP

                  |L20.436|
                          DCD      newpower_time_out_current_state
                  |L20.440|
0001b8  4153534f          DCB      "ASSOC_CMD: capability 0x%04x\n",0
0001bc  435f434d
0001c0  443a2063
0001c4  61706162
0001c8  696c6974
0001cc  79203078
0001d0  25303478
0001d4  0a00    
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L20.472|
0001d8  4153534f          DCB      "ASSOC_CMD: num rates %u\n",0
0001dc  435f434d
0001e0  443a206e
0001e4  756d2072
0001e8  61746573
0001ec  2025750a
0001f0  00      
0001f1  00                DCB      0
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L20.500|
0001f4  41555448          DCB      "AUTH_CMD: BSSID %pM, auth 0x%x\n",0
0001f8  5f434d44
0001fc  3a204253
000200  53494420
000204  25704d2c
000208  20617574
00020c  68203078
000210  25780a00

                          AREA ||i.lbs_association_worker||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  lbs_association_worker PROC
;;;1826   
;;;1827   void lbs_association_worker(struct lbs_private *priv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1828   {
000004  b092              SUB      sp,sp,#0x48
000006  4605              MOV      r5,r0
;;;1829   	struct assoc_request * assoc_req = NULL;
000008  2400              MOVS     r4,#0
;;;1830   	char ssid[10];
;;;1831   	int ret = 0;
00000a  2600              MOVS     r6,#0
;;;1832   	int find_any_ssid = 0;
00000c  2700              MOVS     r7,#0
;;;1833   
;;;1834   	lbs_deb_enter(LBS_DEB_ASSOC);
;;;1835   
;;;1836   	assoc_req = priv->pending_assoc_req;//如何关联记录在这里
00000e  f8d541f8          LDR      r4,[r5,#0x1f8]
;;;1837   	priv->pending_assoc_req = NULL;
000012  2000              MOVS     r0,#0
000014  f8c501f8          STR      r0,[r5,#0x1f8]
;;;1838   	priv->in_progress_assoc_req = assoc_req;
000018  f8c541fc          STR      r4,[r5,#0x1fc]
;;;1839   
;;;1840   	if (!assoc_req)
00001c  b904              CBNZ     r4,|L21.32|
;;;1841   		goto done;
00001e  e17f              B        |L21.800|
                  |L21.32|
;;;1842   	wpa_printf(MSG_DEBUG,
000020  f8942025          LDRB     r2,[r4,#0x25]
000024  1d21              ADDS     r1,r4,#4
000026  a80f              ADD      r0,sp,#0x3c
000028  f7fffffe          BL       print_ssid
00002c  4680              MOV      r8,r0
00002e  f240101b          MOV      r0,#0x11b
000032  5d03              LDRB     r3,[r0,r4]
000034  1c40              ADDS     r0,r0,#1
000036  5902              LDR      r2,[r0,r4]
000038  1e80              SUBS     r0,r0,#2
00003a  5d00              LDRB     r0,[r0,r4]
00003c  b108              CBZ      r0,|L21.66|
;;;1843   		"Association Request:\n"
;;;1844   		"    flags:     0x%08lx\n"
;;;1845   		"    SSID:      '%s'\n"
;;;1846   		"    chann:     %d\n"
;;;1847   		"    band:      %d\n"
;;;1848   		"    mode:      %d\n"
;;;1849   		"    BSSID:     "MACSTR"\n"
;;;1850   		"    secinfo:  %s%s%s	key_mgmt:%d\n"
;;;1851   		"    auth_mode: %d\n",
;;;1852   		assoc_req->flags,
;;;1853   		print_ssid(ssid,(const char *)assoc_req->ssid, assoc_req->ssid_len),
;;;1854   		assoc_req->channel, assoc_req->band, assoc_req->mode,
;;;1855   		MAC2STR(assoc_req->bssid),
;;;1856   		assoc_req->secinfo.WPAenabled ? " WPA" : "",
;;;1857   		assoc_req->secinfo.WPA2enabled ? " WPA2" : "",
;;;1858   		assoc_req->secinfo.wep_enabled ? " WEP" : "",
00003e  a1ba              ADR      r1,|L21.808|
000040  e000              B        |L21.68|
                  |L21.66|
000042  a1ba              ADR      r1,|L21.812|
                  |L21.68|
000044  f2401019          MOV      r0,#0x119
000048  5d00              LDRB     r0,[r0,r4]
00004a  b108              CBZ      r0,|L21.80|
00004c  a0b8              ADR      r0,|L21.816|
00004e  e000              B        |L21.82|
                  |L21.80|
000050  a0b6              ADR      r0,|L21.812|
                  |L21.82|
000052  e9cd230c          STRD     r2,r3,[sp,#0x30]      ;1857
000056  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;1857
00005a  f8940118          LDRB     r0,[r4,#0x118]        ;1857
00005e  b108              CBZ      r0,|L21.100|
000060  a3b5              ADR      r3,|L21.824|
000062  e000              B        |L21.102|
                  |L21.100|
000064  a3b1              ADR      r3,|L21.812|
                  |L21.102|
000066  202f              MOVS     r0,#0x2f              ;1856
000068  5d02              LDRB     r2,[r0,r4]            ;1856
00006a  202e              MOVS     r0,#0x2e              ;1856
00006c  5d01              LDRB     r1,[r0,r4]            ;1856
00006e  202d              MOVS     r0,#0x2d              ;1856
000070  5d00              LDRB     r0,[r0,r4]            ;1856
000072  e9cd2308          STRD     r2,r3,[sp,#0x20]      ;1856
000076  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;1856
00007a  202c              MOVS     r0,#0x2c              ;1856
00007c  5d03              LDRB     r3,[r0,r4]            ;1856
00007e  202b              MOVS     r0,#0x2b              ;1856
000080  5d02              LDRB     r2,[r0,r4]            ;1856
000082  f104040c          ADD      r4,r4,#0xc            ;1856
000086  7fa1              LDRB     r1,[r4,#0x1e]         ;1856
000088  7f20              LDRB     r0,[r4,#0x1c]         ;1856
00008a  e9cd2304          STRD     r2,r3,[sp,#0x10]      ;1856
00008e  e9cd0102          STRD     r0,r1,[sp,#8]         ;1856
000092  7ee3              LDRB     r3,[r4,#0x1b]         ;1856
000094  7ea2              LDRB     r2,[r4,#0x1a]         ;1856
000096  e9cd2300          STRD     r2,r3,[sp,#0]         ;1856
00009a  f8542c0c          LDR      r2,[r4,#-0xc]         ;1856
00009e  4643              MOV      r3,r8                 ;1856
0000a0  49a7              LDR      r1,|L21.832|
0000a2  f04f0001          MOV      r0,#1                 ;1856
0000a6  f7fffffe          BL       wpa_printf
;;;1859   		assoc_req->secinfo.key_mgmt,
;;;1860   		assoc_req->secinfo.auth_mode);
;;;1861   	wpa_printf(MSG_DEBUG,"wep_tx_keyidx(%d)\n",assoc_req->wep_tx_keyidx);
0000aa  f8b420bc          LDRH     r2,[r4,#0xbc]
0000ae  f1a4040c          SUB      r4,r4,#0xc
0000b2  a1a4              ADR      r1,|L21.836|
0000b4  f04f0001          MOV      r0,#1
0000b8  f7fffffe          BL       wpa_printf
;;;1862   	print_enckey(assoc_req->wep_keys);
0000bc  f1040030          ADD      r0,r4,#0x30
0000c0  f7fffffe          BL       print_enckey
;;;1863   	print_enckey(assoc_req->wep_keys+1);
0000c4  f1040056          ADD      r0,r4,#0x56
0000c8  f7fffffe          BL       print_enckey
;;;1864   	print_enckey(assoc_req->wep_keys+2);
0000cc  f104007c          ADD      r0,r4,#0x7c
0000d0  f7fffffe          BL       print_enckey
;;;1865   	print_enckey(assoc_req->wep_keys+3);
0000d4  f10400a2          ADD      r0,r4,#0xa2
0000d8  f7fffffe          BL       print_enckey
;;;1866   	wpa_printf(MSG_DEBUG,"wpa mcast key!\n");
0000dc  a19e              ADR      r1,|L21.856|
0000de  2001              MOVS     r0,#1
0000e0  f7fffffe          BL       wpa_printf
;;;1867   	print_enckey(&assoc_req->wpa_mcast_key);
0000e4  f10400ca          ADD      r0,r4,#0xca
0000e8  f7fffffe          BL       print_enckey
;;;1868   	wpa_printf(MSG_DEBUG,"wpa unicase key!\n");
0000ec  a19e              ADR      r1,|L21.872|
0000ee  2001              MOVS     r0,#1
0000f0  f7fffffe          BL       wpa_printf
;;;1869   	print_enckey(&assoc_req->wpa_unicast_key);	
0000f4  f10400f0          ADD      r0,r4,#0xf0
0000f8  f7fffffe          BL       print_enckey
;;;1870   	wpa_printf(MSG_DEBUG,"wpa ie len(%d)!\n",assoc_req->wpa_ie_len);
0000fc  f8942160          LDRB     r2,[r4,#0x160]
000100  a19e              ADR      r1,|L21.892|
000102  2001              MOVS     r0,#1
000104  f7fffffe          BL       wpa_printf
;;;1871   	wpa_hexdump_key(MSG_DEBUG,"wpa ie",assoc_req->wpa_ie,assoc_req->wpa_ie_len);	
000108  f8943160          LDRB     r3,[r4,#0x160]
00010c  f5047290          ADD      r2,r4,#0x120
000110  a19f              ADR      r1,|L21.912|
000112  2001              MOVS     r0,#1
000114  f7fffffe          BL       wpa_hexdump_key
;;;1872   	/* If 'any' SSID was specified, find an SSID to associate with */
;;;1873   	if (test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)
000118  4621              MOV      r1,r4
00011a  2001              MOVS     r0,#1
00011c  f7fffffe          BL       test_bit
000120  b118              CBZ      r0,|L21.298|
;;;1874   	    && !assoc_req->ssid_len)//说明没有指定关联的ESSID
000122  f8940025          LDRB     r0,[r4,#0x25]
000126  b900              CBNZ     r0,|L21.298|
;;;1875   		find_any_ssid = 1;
000128  2701              MOVS     r7,#1
                  |L21.298|
;;;1876   
;;;1877   	/* But don't use 'any' SSID if there's a valid locked BSSID to use */
;;;1878   	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {// 根据BSSID来关联
00012a  4621              MOV      r1,r4
00012c  2005              MOVS     r0,#5
00012e  f7fffffe          BL       test_bit
000132  b160              CBZ      r0,|L21.334|
;;;1879   		if (compare_ether_addr(assoc_req->bssid, bssid_any)//不相同
000134  4998              LDR      r1,|L21.920|
000136  f104002a          ADD      r0,r4,#0x2a
00013a  f7fffffe          BL       compare_ether_addr
00013e  b130              CBZ      r0,|L21.334|
;;;1880   		    && compare_ether_addr(assoc_req->bssid, bssid_off))
000140  4996              LDR      r1,|L21.924|
000142  f104002a          ADD      r0,r4,#0x2a
000146  f7fffffe          BL       compare_ether_addr
00014a  b100              CBZ      r0,|L21.334|
;;;1881   			find_any_ssid = 0;
00014c  2700              MOVS     r7,#0
                  |L21.334|
;;;1882   	}
;;;1883   
;;;1884   	if (find_any_ssid) {//寻找最优网络
00014e  b307              CBZ      r7,|L21.402|
;;;1885   		u8 new_mode = assoc_req->mode;
000150  f8940028          LDRB     r0,[r4,#0x28]
000154  900e              STR      r0,[sp,#0x38]
;;;1886   
;;;1887   		ret = lbs_find_best_network_ssid(priv, assoc_req->ssid,
000156  ab0e              ADD      r3,sp,#0x38
000158  9300              STR      r3,[sp,#0]
00015a  f8943028          LDRB     r3,[r4,#0x28]
00015e  f1040225          ADD      r2,r4,#0x25
000162  1d21              ADDS     r1,r4,#4
000164  4628              MOV      r0,r5
000166  f7fffffe          BL       lbs_find_best_network_ssid
00016a  4606              MOV      r6,r0
;;;1888   				&assoc_req->ssid_len, assoc_req->mode, &new_mode);
;;;1889   		if (ret) {
00016c  b12e              CBZ      r6,|L21.378|
;;;1890   			lbs_deb_assoc("Could not find best network\n");
00016e  a08c              ADR      r0,|L21.928|
000170  f7fffffe          BL       __2printf
;;;1891   			ret = -ENETUNREACH;
000174  f06f0632          MVN      r6,#0x32
;;;1892   			goto out;
000178  e0c9              B        |L21.782|
                  |L21.378|
;;;1893   		}
;;;1894   
;;;1895   		/* Ensure we switch to the mode of the AP */
;;;1896   		if (assoc_req->mode == IW_MODE_AUTO) {
00017a  f8940028          LDRB     r0,[r4,#0x28]
00017e  b938              CBNZ     r0,|L21.400|
;;;1897   			set_bit(ASSOC_FLAG_MODE, &assoc_req->flags);
000180  4621              MOV      r1,r4
000182  2004              MOVS     r0,#4
000184  f7fffffe          BL       set_bit
;;;1898   			assoc_req->mode = new_mode;
000188  f89d0038          LDRB     r0,[sp,#0x38]
00018c  f8840028          STRB     r0,[r4,#0x28]
                  |L21.400|
;;;1899   		}
;;;1900   	}
000190  bf00              NOP      
                  |L21.402|
;;;1901   
;;;1902   	/*
;;;1903   	 * Check if the attributes being changing require deauthentication
;;;1904   	 * from the currently associated infrastructure access point.
;;;1905   	 */
;;;1906   	if (priv->mode == IW_MODE_INFRA) {//在基础网络下，网络连接改变时去关联
000192  f89500e9          LDRB     r0,[r5,#0xe9]
000196  2802              CMP      r0,#2
000198  d111              BNE      |L21.446|
;;;1907   		if (should_deauth_infrastructure(priv, assoc_req)) {
00019a  4621              MOV      r1,r4
00019c  4628              MOV      r0,r5
00019e  f7fffffe          BL       should_deauth_infrastructure
0001a2  b1f8              CBZ      r0,|L21.484|
;;;1908   			ret = lbs_cmd_80211_deauthenticate(priv,
0001a4  2203              MOVS     r2,#3
0001a6  f10501b0          ADD      r1,r5,#0xb0
0001aa  4628              MOV      r0,r5
0001ac  f7fffffe          BL       lbs_cmd_80211_deauthenticate
0001b0  4606              MOV      r6,r0
;;;1909   							   priv->curbssparams.bssid,
;;;1910   							   WLAN_REASON_DEAUTH_LEAVING);
;;;1911   			if (ret) {
0001b2  b1be              CBZ      r6,|L21.484|
;;;1912   				lbs_deb_assoc("Deauthentication due to new "
0001b4  4631              MOV      r1,r6
0001b6  a082              ADR      r0,|L21.960|
0001b8  f7fffffe          BL       __2printf
0001bc  e012              B        |L21.484|
                  |L21.446|
;;;1913   					"configuration request failed: %d\n",
;;;1914   					ret);
;;;1915   			}
;;;1916   		}
;;;1917   	} else if (priv->mode == IW_MODE_ADHOC) {//在adhoc模式下，网络状态改变，停用adhoc模式
0001be  f89500e9          LDRB     r0,[r5,#0xe9]
0001c2  2801              CMP      r0,#1
0001c4  d10e              BNE      |L21.484|
;;;1918   		if (should_stop_adhoc(priv, assoc_req)) {
0001c6  4621              MOV      r1,r4
0001c8  4628              MOV      r0,r5
0001ca  f7fffffe          BL       should_stop_adhoc
0001ce  b148              CBZ      r0,|L21.484|
;;;1919   			ret = lbs_adhoc_stop(priv);
0001d0  4628              MOV      r0,r5
0001d2  f7fffffe          BL       lbs_adhoc_stop
0001d6  4606              MOV      r6,r0
;;;1920   			if (ret) {
0001d8  b126              CBZ      r6,|L21.484|
;;;1921   				lbs_deb_assoc("Teardown of AdHoc network due to "
0001da  4631              MOV      r1,r6
0001dc  4858              LDR      r0,|L21.832|
0001de  30d8              ADDS     r0,r0,#0xd8
0001e0  f7fffffe          BL       __2printf
                  |L21.484|
;;;1922   					"new configuration request failed: %d\n",ret);
;;;1923   			}
;;;1924   
;;;1925   		}
;;;1926   	}
;;;1927   	/* Send the various configuration bits to the firmware */
;;;1928   	if (test_bit(ASSOC_FLAG_MODE, &assoc_req->flags)) {
0001e4  4621              MOV      r1,r4
0001e6  2004              MOVS     r0,#4
0001e8  f7fffffe          BL       test_bit
0001ec  b130              CBZ      r0,|L21.508|
;;;1929   		ret = assoc_helper_mode(priv, assoc_req);//模式改变，发送命令改变网络模式
0001ee  4621              MOV      r1,r4
0001f0  4628              MOV      r0,r5
0001f2  f7fffffe          BL       assoc_helper_mode
0001f6  4606              MOV      r6,r0
;;;1930   		if (ret)
0001f8  b106              CBZ      r6,|L21.508|
;;;1931   			goto out;
0001fa  e088              B        |L21.782|
                  |L21.508|
;;;1932   	}
;;;1933   
;;;1934   	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags)) {
0001fc  4621              MOV      r1,r4
0001fe  2002              MOVS     r0,#2
000200  f7fffffe          BL       test_bit
000204  b130              CBZ      r0,|L21.532|
;;;1935   		ret = assoc_helper_channel(priv, assoc_req);//改变信道
000206  4621              MOV      r1,r4
000208  4628              MOV      r0,r5
00020a  f7fffffe          BL       assoc_helper_channel
00020e  4606              MOV      r6,r0
;;;1936   		if (ret)
000210  b106              CBZ      r6,|L21.532|
;;;1937   			goto out;
000212  e07c              B        |L21.782|
                  |L21.532|
;;;1938   	}
;;;1939   
;;;1940   	if ( test_bit(ASSOC_FLAG_WEP_KEYS, &assoc_req->flags)
000214  4621              MOV      r1,r4
000216  2006              MOVS     r0,#6
000218  f7fffffe          BL       test_bit
00021c  b920              CBNZ     r0,|L21.552|
;;;1941   	    || test_bit(ASSOC_FLAG_WEP_TX_KEYIDX, &assoc_req->flags)) {
00021e  4621              MOV      r1,r4
000220  2007              MOVS     r0,#7
000222  f7fffffe          BL       test_bit
000226  b130              CBZ      r0,|L21.566|
                  |L21.552|
;;;1942   		ret = assoc_helper_wep_keys(priv, assoc_req);//wep密钥管理
000228  4621              MOV      r1,r4
00022a  4628              MOV      r0,r5
00022c  f7fffffe          BL       assoc_helper_wep_keys
000230  4606              MOV      r6,r0
;;;1943   		if (ret)
000232  b106              CBZ      r6,|L21.566|
;;;1944   			goto out;
000234  e06b              B        |L21.782|
                  |L21.566|
;;;1945   	}
;;;1946   
;;;1947   	if (test_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags)) {//加密信息改变
000236  4621              MOV      r1,r4
000238  200a              MOVS     r0,#0xa
00023a  f7fffffe          BL       test_bit
00023e  b130              CBZ      r0,|L21.590|
;;;1948   		ret = assoc_helper_secinfo(priv, assoc_req);
000240  4621              MOV      r1,r4
000242  4628              MOV      r0,r5
000244  f7fffffe          BL       assoc_helper_secinfo
000248  4606              MOV      r6,r0
;;;1949   		if (ret)
00024a  b106              CBZ      r6,|L21.590|
;;;1950   			goto out;
00024c  e05f              B        |L21.782|
                  |L21.590|
;;;1951   	}
;;;1952   
;;;1953   	if (test_bit(ASSOC_FLAG_WPA_IE, &assoc_req->flags)) {
00024e  4621              MOV      r1,r4
000250  200b              MOVS     r0,#0xb
000252  f7fffffe          BL       test_bit
000256  b130              CBZ      r0,|L21.614|
;;;1954   		ret = assoc_helper_wpa_ie(priv, assoc_req);
000258  4621              MOV      r1,r4
00025a  4628              MOV      r0,r5
00025c  f7fffffe          BL       assoc_helper_wpa_ie
000260  4606              MOV      r6,r0
;;;1955   		if (ret)
000262  b106              CBZ      r6,|L21.614|
;;;1956   			goto out;
000264  e053              B        |L21.782|
                  |L21.614|
;;;1957   	}
;;;1958   
;;;1959   	if (test_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags)
000266  4621              MOV      r1,r4
000268  2008              MOVS     r0,#8
00026a  f7fffffe          BL       test_bit
00026e  b920              CBNZ     r0,|L21.634|
;;;1960   	    || test_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags)) {
000270  4621              MOV      r1,r4
000272  2009              MOVS     r0,#9
000274  f7fffffe          BL       test_bit
000278  b130              CBZ      r0,|L21.648|
                  |L21.634|
;;;1961   		ret = assoc_helper_wpa_keys(priv, assoc_req);
00027a  4621              MOV      r1,r4
00027c  4628              MOV      r0,r5
00027e  f7fffffe          BL       assoc_helper_wpa_keys
000282  4606              MOV      r6,r0
;;;1962   		if (ret)
000284  b106              CBZ      r6,|L21.648|
;;;1963   			goto out;
000286  e042              B        |L21.782|
                  |L21.648|
;;;1964   	}
;;;1965   	/* SSID/BSSID should be the _last_ config option set, because they
;;;1966   	 * trigger the association attempt.
;;;1967   	 */
;;;1968   	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)
000288  4621              MOV      r1,r4
00028a  2005              MOVS     r0,#5
00028c  f7fffffe          BL       test_bit
000290  b920              CBNZ     r0,|L21.668|
;;;1969   	    || test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {//真正处理关联的地方
000292  4621              MOV      r1,r4
000294  2001              MOVS     r0,#1
000296  f7fffffe          BL       test_bit
00029a  b398              CBZ      r0,|L21.772|
                  |L21.668|
;;;1970   		int success = 1;
00029c  f04f0801          MOV      r8,#1
;;;1971   
;;;1972   
;;;1973   		 if (assoc_req->mode == 0)
0002a0  f8940028          LDRB     r0,[r4,#0x28]
0002a4  b928              CBNZ     r0,|L21.690|
;;;1974   		 {
;;;1975   		 	lbs_remove_wep_keys(priv);
0002a6  4628              MOV      r0,r5
0002a8  f7fffffe          BL       lbs_remove_wep_keys
;;;1976           	clear_wpa_wpa2_info(priv);
0002ac  4628              MOV      r0,r5
0002ae  f7fffffe          BL       clear_wpa_wpa2_info
                  |L21.690|
;;;1977   		 }
;;;1978   
;;;1979   		ret = assoc_helper_associate(priv, assoc_req);
0002b2  4621              MOV      r1,r4
0002b4  4628              MOV      r0,r5
0002b6  f7fffffe          BL       assoc_helper_associate
0002ba  4606              MOV      r6,r0
;;;1980   		if (ret) {
0002bc  b12e              CBZ      r6,|L21.714|
;;;1981   			lbs_deb_assoc("ASSOC: association unsuccessful: %d\n",
0002be  4631              MOV      r1,r6
0002c0  a04f              ADR      r0,|L21.1024|
0002c2  f7fffffe          BL       __2printf
;;;1982   				ret);
;;;1983   			success = 0;
0002c6  f04f0800          MOV      r8,#0
                  |L21.714|
;;;1984   		}
;;;1985   
;;;1986   		if (priv->connect_status != LBS_CONNECTED) {
0002ca  f8d501dc          LDR      r0,[r5,#0x1dc]
0002ce  b120              CBZ      r0,|L21.730|
;;;1987   			lbs_deb_assoc("ASSOC: association unsuccessful, "
0002d0  a055              ADR      r0,|L21.1064|
0002d2  f7fffffe          BL       __2printf
;;;1988   				"not connected\n");
;;;1989   			success = 0;
0002d6  f04f0800          MOV      r8,#0
                  |L21.730|
;;;1990   		}
;;;1991   
;;;1992   		if (success) {
0002da  f1b80f00          CMP      r8,#0
0002de  d012              BEQ      |L21.774|
;;;1993   			lbs_deb_assoc("associated to %2x:%2x:%2x:%2x:%2x:%2x\n",
0002e0  20b5              MOVS     r0,#0xb5
0002e2  5d43              LDRB     r3,[r0,r5]
0002e4  20b4              MOVS     r0,#0xb4
0002e6  5d42              LDRB     r2,[r0,r5]
0002e8  20b3              MOVS     r0,#0xb3
0002ea  5d41              LDRB     r1,[r0,r5]
0002ec  20b2              MOVS     r0,#0xb2
0002ee  e88d000e          STM      sp,{r1-r3}
0002f2  5d43              LDRB     r3,[r0,r5]
0002f4  20b1              MOVS     r0,#0xb1
0002f6  5d42              LDRB     r2,[r0,r5]
0002f8  f89510b0          LDRB     r1,[r5,#0xb0]
0002fc  a056              ADR      r0,|L21.1112|
0002fe  f7fffffe          BL       __2printf
000302  e002              B        |L21.778|
                  |L21.772|
000304  e002              B        |L21.780|
                  |L21.774|
;;;1994   				priv->curbssparams.bssid[0],priv->curbssparams.bssid[1],
;;;1995   				priv->curbssparams.bssid[2],priv->curbssparams.bssid[3],
;;;1996   				priv->curbssparams.bssid[4],priv->curbssparams.bssid[5]);
;;;1997   /*
;;;1998   			 lbs_prepare_and_send_command(priv,
;;;1999   				CMD_802_11_RSSI,
;;;2000   				0, CMD_OPTION_WAITFORRSP, 0, NULL); 
;;;2001   */
;;;2002   		} else {
;;;2003   			ret = -1;
000306  f04f36ff          MOV      r6,#0xffffffff
                  |L21.778|
;;;2004   		}
;;;2005   	}
00030a  bf00              NOP      
                  |L21.780|
;;;2006   
;;;2007   out:
00030c  bf00              NOP      
                  |L21.782|
;;;2008   	if (ret) {
00030e  b11e              CBZ      r6,|L21.792|
;;;2009   		lbs_deb_assoc("ASSOC: reconfiguration attempt unsuccessful: %d\n",
000310  4631              MOV      r1,r6
000312  a05b              ADR      r0,|L21.1152|
000314  f7fffffe          BL       __2printf
                  |L21.792|
;;;2010   			ret);
;;;2011   	}
;;;2012   	priv->in_progress_assoc_req = NULL;
000318  2000              MOVS     r0,#0
00031a  f8c501fc          STR      r0,[r5,#0x1fc]
;;;2013   done:
00031e  bf00              NOP      
                  |L21.800|
;;;2014   	lbs_deb_leave(LBS_DEB_ASSOC);
;;;2015   }
000320  b012              ADD      sp,sp,#0x48
000322  e8bd81f0          POP      {r4-r8,pc}
;;;2016   
                          ENDP

000326  0000              DCW      0x0000
                  |L21.808|
000328  20574550          DCB      " WEP"
                  |L21.812|
00032c  00                DCB      0
00032d  00                DCB      0
00032e  00                DCB      0
00032f  00                DCB      0
                  |L21.816|
000330  20575041          DCB      " WPA2",0
000334  3200    
000336  00                DCB      0
000337  00                DCB      0
                  |L21.824|
000338  20575041          DCB      " WPA",0
00033c  00      
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L21.832|
                          DCD      ||.constdata||+0x1d8
                  |L21.836|
000344  7765705f          DCB      "wep_tx_keyidx(%d)\n",0
000348  74785f6b
00034c  65796964
000350  78282564
000354  290a00  
000357  00                DCB      0
                  |L21.856|
000358  77706120          DCB      "wpa mcast key!\n",0
00035c  6d636173
000360  74206b65
000364  79210a00
                  |L21.872|
000368  77706120          DCB      "wpa unicase key!\n",0
00036c  756e6963
000370  61736520
000374  6b657921
000378  0a00    
00037a  00                DCB      0
00037b  00                DCB      0
                  |L21.892|
00037c  77706120          DCB      "wpa ie len(%d)!\n",0
000380  6965206c
000384  656e2825
000388  6429210a
00038c  00      
00038d  00                DCB      0
00038e  00                DCB      0
00038f  00                DCB      0
                  |L21.912|
000390  77706120          DCB      "wpa ie",0
000394  696500  
000397  00                DCB      0
                  |L21.920|
                          DCD      bssid_any
                  |L21.924|
                          DCD      bssid_off
                  |L21.928|
0003a0  436f756c          DCB      "Could not find best network\n",0
0003a4  64206e6f
0003a8  74206669
0003ac  6e642062
0003b0  65737420
0003b4  6e657477
0003b8  6f726b0a
0003bc  00      
0003bd  00                DCB      0
0003be  00                DCB      0
0003bf  00                DCB      0
                  |L21.960|
0003c0  44656175          DCB      "Deauthentication due to new configuration request faile"
0003c4  7468656e
0003c8  74696361
0003cc  74696f6e
0003d0  20647565
0003d4  20746f20
0003d8  6e657720
0003dc  636f6e66
0003e0  69677572
0003e4  6174696f
0003e8  6e207265
0003ec  71756573
0003f0  74206661
0003f4  696c65  
0003f7  643a2025          DCB      "d: %d\n",0
0003fb  640a00  
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L21.1024|
000400  4153534f          DCB      "ASSOC: association unsuccessful: %d\n",0
000404  433a2061
000408  73736f63
00040c  69617469
000410  6f6e2075
000414  6e737563
000418  63657373
00041c  66756c3a
000420  2025640a
000424  00      
000425  00                DCB      0
000426  00                DCB      0
000427  00                DCB      0
                  |L21.1064|
000428  4153534f          DCB      "ASSOC: association unsuccessful, not connected\n",0
00042c  433a2061
000430  73736f63
000434  69617469
000438  6f6e2075
00043c  6e737563
000440  63657373
000444  66756c2c
000448  206e6f74
00044c  20636f6e
000450  6e656374
000454  65640a00
                  |L21.1112|
000458  6173736f          DCB      "associated to %2x:%2x:%2x:%2x:%2x:%2x\n",0
00045c  63696174
000460  65642074
000464  6f202532
000468  783a2532
00046c  783a2532
000470  783a2532
000474  783a2532
000478  783a2532
00047c  780a00  
00047f  00                DCB      0
                  |L21.1152|
000480  4153534f          DCB      "ASSOC: reconfiguration attempt unsuccessful: %d\n",0
000484  433a2072
000488  65636f6e
00048c  66696775
000490  72617469
000494  6f6e2061
000498  7474656d
00049c  70742075
0004a0  6e737563
0004a4  63657373
0004a8  66756c3a
0004ac  2025640a
0004b0  00      
0004b1  00                DCB      0
0004b2  00                DCB      0
0004b3  00                DCB      0

                          AREA ||i.lbs_cmd_80211_deauthenticate||, CODE, READONLY, ALIGN=1

                  lbs_cmd_80211_deauthenticate PROC
;;;2026    */
;;;2027   int lbs_cmd_80211_deauthenticate(struct lbs_private *priv, u8 bssid[ETH_ALEN],
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;2028   				 u16 reason)
;;;2029   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;2030   	struct cmd_ds_802_11_deauthenticate cmd;
;;;2031   	int ret;
;;;2032   
;;;2033   	lbs_deb_enter(LBS_DEB_JOIN);
;;;2034   
;;;2035   	memset(&cmd, 0, sizeof(cmd));
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  9001              STR      r0,[sp,#4]
000010  9002              STR      r0,[sp,#8]
000012  9003              STR      r0,[sp,#0xc]
;;;2036   	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
000014  2010              MOVS     r0,#0x10
000016  f8ad0002          STRH     r0,[sp,#2]
;;;2037   	memcpy(cmd.macaddr, &bssid[0], ETH_ALEN);//当前BSSID作为参数传入命令
00001a  6820              LDR      r0,[r4,#0]
00001c  9002              STR      r0,[sp,#8]
00001e  88a0              LDRH     r0,[r4,#4]
000020  f8ad000c          STRH     r0,[sp,#0xc]
;;;2038   	cmd.reasoncode = cpu_to_le16(reason);
000024  f8ad500e          STRH     r5,[sp,#0xe]
;;;2039   
;;;2040   	ret = lbs_cmd_with_response(priv, CMD_802_11_DEAUTHENTICATE, &cmd);//去关联
000028  466a              MOV      r2,sp
00002a  2124              MOVS     r1,#0x24
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       lbs_cmd_with_response
000032  4607              MOV      r7,r0
;;;2041   
;;;2042   	/* Clean up everything even if there was an error; can't assume that
;;;2043   	 * we're still authenticated to the AP after trying to deauth.
;;;2044   	 */
;;;2045   	//lbs_mac_event_disconnected(priv);//通知用户空间，连接已断开
;;;2046   
;;;2047   	lbs_deb_leave(LBS_DEB_JOIN);
;;;2048   	return ret;
000034  4638              MOV      r0,r7
;;;2049   }
000036  b004              ADD      sp,sp,#0x10
000038  e8bd81f0          POP      {r4-r8,pc}
;;;2050   __inline int test_bit(int nr, const unsigned long *vaddr)
                          ENDP


                          AREA ||i.lbs_find_best_network_ssid||, CODE, READONLY, ALIGN=1

                  lbs_find_best_network_ssid PROC
;;;1599   
;;;1600   static int lbs_find_best_network_ssid(struct lbs_private *priv,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1601   	uint8_t *out_ssid, uint8_t *out_ssid_len, uint8_t preferred_mode,
;;;1602   	uint8_t *out_mode)
;;;1603   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1604   	int ret = -1;
000010  f04f3aff          MOV      r10,#0xffffffff
;;;1605   	struct bss_descriptor *found;
;;;1606   
;;;1607   	lbs_deb_enter(LBS_DEB_SCAN);
;;;1608   
;;;1609   	priv->scan_ssid_len = 0;
000014  2000              MOVS     r0,#0
000016  f8850051          STRB     r0,[r5,#0x51]
;;;1610   	lbs_scan_networks(priv, 1);
00001a  2101              MOVS     r1,#1
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       lbs_scan_networks
;;;1611   	if (priv->surpriseremoved)
000022  f89501ec          LDRB     r0,[r5,#0x1ec]
000026  b100              CBZ      r0,|L23.42|
;;;1612   		goto out;
000028  e018              B        |L23.92|
                  |L23.42|
;;;1613   
;;;1614   	found = lbs_find_best_ssid_in_list(priv, preferred_mode);
00002a  4641              MOV      r1,r8
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       lbs_find_best_ssid_in_list
000032  4604              MOV      r4,r0
;;;1615   	if (found && (found->ssid_len > 0)) {
000034  b18c              CBZ      r4,|L23.90|
000036  f8940027          LDRB     r0,[r4,#0x27]
00003a  2800              CMP      r0,#0
00003c  dd0d              BLE      |L23.90|
;;;1616   		memcpy(out_ssid, &found->ssid, IW_ESSID_MAX_SIZE);
00003e  2220              MOVS     r2,#0x20
000040  1da1              ADDS     r1,r4,#6
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       __aeabi_memcpy
;;;1617   		*out_ssid_len = found->ssid_len;
000048  f8940027          LDRB     r0,[r4,#0x27]
00004c  7038              STRB     r0,[r7,#0]
;;;1618   		*out_mode = found->mode;
00004e  f8940038          LDRB     r0,[r4,#0x38]
000052  f8890000          STRB     r0,[r9,#0]
;;;1619   		ret = 0;
000056  f04f0a00          MOV      r10,#0
                  |L23.90|
;;;1620   	}
;;;1621   
;;;1622   out:
00005a  bf00              NOP      
                  |L23.92|
;;;1623   	lbs_deb_leave_args(LBS_DEB_SCAN, ret);
;;;1624   	return ret;
00005c  4650              MOV      r0,r10
;;;1625   }
00005e  e8bd87f0          POP      {r4-r10,pc}
;;;1626   
                          ENDP


                          AREA ||i.lbs_find_best_ssid_in_list||, CODE, READONLY, ALIGN=1

                  lbs_find_best_ssid_in_list PROC
;;;1536    */
;;;1537   static struct bss_descriptor *lbs_find_best_ssid_in_list(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1538   	struct lbs_private *priv, uint8_t mode)
;;;1539   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1540   	uint8_t bestrssi = 0;
000008  2700              MOVS     r7,#0
;;;1541   	struct bss_descriptor *iter_bss;
;;;1542   	struct bss_descriptor *best_bss = NULL;
00000a  46b8              MOV      r8,r7
;;;1543   
;;;1544   	lbs_deb_enter(LBS_DEB_SCAN);
;;;1545   
;;;1546   	//mutex_lock(&priv->lock);
;;;1547   
;;;1548   	list_for_each_entry_bssdes(iter_bss, &priv->network_list, list) {
00000c  f44f70f4          MOV      r0,#0x1e8
000010  f8d510ec          LDR      r1,[r5,#0xec]
000014  1a0c              SUBS     r4,r1,r0
000016  e02d              B        |L24.116|
                  |L24.24|
;;;1549   		switch (mode) {
000018  b1ce              CBZ      r6,|L24.78|
00001a  2e01              CMP      r6,#1
00001c  d002              BEQ      |L24.36|
00001e  2e02              CMP      r6,#2
000020  d114              BNE      |L24.76|
;;;1550   		case IW_MODE_INFRA:
;;;1551   		case IW_MODE_ADHOC:
000022  bf00              NOP      
                  |L24.36|
;;;1552   			if (!is_network_compatible(priv, iter_bss, mode))
000024  4632              MOV      r2,r6
000026  4621              MOV      r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       is_network_compatible
00002e  b900              CBNZ     r0,|L24.50|
;;;1553   				break;
000030  e01a              B        |L24.104|
                  |L24.50|
;;;1554   			if (SCAN_RSSI(iter_bss->rssi) <= bestrssi)
000032  6ae0              LDR      r0,[r4,#0x2c]
000034  b2c0              UXTB     r0,r0
000036  f5c07080          RSB      r0,r0,#0x100
00003a  42b8              CMP      r0,r7
00003c  dc00              BGT      |L24.64|
;;;1555   				break;
00003e  e013              B        |L24.104|
                  |L24.64|
;;;1556   			bestrssi = SCAN_RSSI(iter_bss->rssi);
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  b2c0              UXTB     r0,r0
000044  4240              RSBS     r0,r0,#0
000046  b2c7              UXTB     r7,r0
;;;1557   			best_bss = iter_bss;
000048  46a0              MOV      r8,r4
;;;1558   			break;
00004a  e00d              B        |L24.104|
                  |L24.76|
;;;1559   		case IW_MODE_AUTO:
00004c  bf00              NOP      
                  |L24.78|
;;;1560   		default:
;;;1561   			if (SCAN_RSSI(iter_bss->rssi) <= bestrssi)
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  b2c0              UXTB     r0,r0
000052  f5c07080          RSB      r0,r0,#0x100
000056  42b8              CMP      r0,r7
000058  dc00              BGT      |L24.92|
;;;1562   				break;
00005a  e005              B        |L24.104|
                  |L24.92|
;;;1563   			bestrssi = SCAN_RSSI(iter_bss->rssi);
00005c  6ae0              LDR      r0,[r4,#0x2c]
00005e  b2c0              UXTB     r0,r0
000060  4240              RSBS     r0,r0,#0
000062  b2c7              UXTB     r7,r0
;;;1564   			best_bss = iter_bss;
000064  46a0              MOV      r8,r4
;;;1565   			break;
000066  bf00              NOP      
                  |L24.104|
000068  bf00              NOP                            ;1553
00006a  f44f70f4          MOV      r0,#0x1e8             ;1548
00006e  f8d411e8          LDR      r1,[r4,#0x1e8]        ;1548
000072  1a0c              SUBS     r4,r1,r0              ;1548
                  |L24.116|
000074  f50470f4          ADD      r0,r4,#0x1e8          ;1548
000078  f10501ec          ADD      r1,r5,#0xec           ;1548
00007c  4288              CMP      r0,r1                 ;1548
00007e  d1cb              BNE      |L24.24|
;;;1566   		}
;;;1567   	}
;;;1568   
;;;1569   	//mutex_unlock(&priv->lock);
;;;1570   	lbs_deb_leave_args(LBS_DEB_SCAN, best_bss);
;;;1571   	return best_bss;
000080  4640              MOV      r0,r8
;;;1572   }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;1573   
                          ENDP


                          AREA ||i.lbs_find_bssid_in_list||, CODE, READONLY, ALIGN=1

                  lbs_find_bssid_in_list PROC
;;;494    
;;;495    static struct bss_descriptor *lbs_find_bssid_in_list(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;496    					      uint8_t *bssid, uint8_t mode)
;;;497    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;498    	struct bss_descriptor *iter_bss;
;;;499    	struct bss_descriptor *found_bss = NULL;
00000a  f04f0800          MOV      r8,#0
;;;500    
;;;501    	lbs_deb_enter(LBS_DEB_SCAN);
;;;502    
;;;503    	if (!bssid)
00000e  b906              CBNZ     r6,|L25.18|
;;;504    		goto out;
000010  e029              B        |L25.102|
                  |L25.18|
;;;505    
;;;506    	//lbs_deb_hex(LBS_DEB_SCAN, "looking for", bssid, ETH_ALEN);
;;;507    
;;;508    	/* Look through the scan table for a compatible match.  The loop will
;;;509    	 *   continue past a matched bssid that is not compatible in case there
;;;510    	 *   is an AP with multiple SSIDs assigned to the same BSSID
;;;511    	 */
;;;512    	//mutex_lock(&priv->lock);
;;;513    	list_for_each_entry_bssdes(iter_bss, &priv->network_list,list) {//在扫描到的网络中寻找合适的bssid
000012  f44f70f4          MOV      r0,#0x1e8
000016  f8d510ec          LDR      r1,[r5,#0xec]
00001a  1a0c              SUBS     r4,r1,r0
00001c  e01c              B        |L25.88|
                  |L25.30|
;;;514    		if (compare_ether_addr(iter_bss->bssid, bssid))
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       compare_ether_addr
000026  b100              CBZ      r0,|L25.42|
;;;515    			continue; /* bssid doesn't match */
000028  e011              B        |L25.78|
                  |L25.42|
;;;516    		switch (mode) {
00002a  2f01              CMP      r7,#1
00002c  d002              BEQ      |L25.52|
00002e  2f02              CMP      r7,#2
000030  d109              BNE      |L25.70|
;;;517    		case IW_MODE_INFRA:
;;;518    		case IW_MODE_ADHOC:
000032  bf00              NOP      
                  |L25.52|
;;;519    			if (!is_network_compatible(priv, iter_bss, mode))//网络是否兼容，这里主要检查的是加密信息
000034  463a              MOV      r2,r7
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       is_network_compatible
00003e  b900              CBNZ     r0,|L25.66|
;;;520    				break;
000040  e003              B        |L25.74|
                  |L25.66|
;;;521    			found_bss = iter_bss;
000042  46a0              MOV      r8,r4
;;;522    			break;
000044  e001              B        |L25.74|
                  |L25.70|
;;;523    		default:
;;;524    			found_bss = iter_bss;
000046  46a0              MOV      r8,r4
;;;525    			break;
000048  bf00              NOP      
                  |L25.74|
00004a  bf00              NOP                            ;520
00004c  bf00              NOP                            ;515
                  |L25.78|
00004e  f44f70f4          MOV      r0,#0x1e8             ;513
000052  f8d411e8          LDR      r1,[r4,#0x1e8]        ;513
000056  1a0c              SUBS     r4,r1,r0              ;513
                  |L25.88|
000058  f50470f4          ADD      r0,r4,#0x1e8          ;513
00005c  f10501ec          ADD      r1,r5,#0xec           ;513
000060  4288              CMP      r0,r1                 ;513
000062  d1dc              BNE      |L25.30|
;;;526    		}
;;;527    	}
;;;528    //		mutex_unlock(&priv->lock);
;;;529    
;;;530    out:
000064  bf00              NOP      
                  |L25.102|
;;;531    	lbs_deb_leave_args(LBS_DEB_SCAN, found_bss);
;;;532    	return found_bss;
000066  4640              MOV      r0,r8
;;;533    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;534    
                          ENDP


                          AREA ||i.lbs_find_ssid_in_list||, CODE, READONLY, ALIGN=1

                  lbs_find_ssid_in_list PROC
;;;585    
;;;586    static struct bss_descriptor *lbs_find_ssid_in_list(struct lbs_private *priv,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;587    					     uint8_t *ssid, uint8_t ssid_len,
;;;588    					     uint8_t *bssid, uint8_t mode,
;;;589    					     int channel)
;;;590    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;591    	u32 bestrssi = 0;
000010  f04f0b00          MOV      r11,#0
;;;592    	struct bss_descriptor *iter_bss = NULL;
000014  2400              MOVS     r4,#0
;;;593    	struct bss_descriptor *found_bss = NULL;
000016  2000              MOVS     r0,#0
000018  9001              STR      r0,[sp,#4]
;;;594    	struct bss_descriptor *tmp_oldest = NULL;
00001a  9000              STR      r0,[sp,#0]
;;;595    
;;;596    	lbs_deb_enter(LBS_DEB_SCAN);
;;;597    
;;;598    	//mutex_lock(&priv->lock);
;;;599    
;;;600    	list_for_each_entry_bssdes(iter_bss, &priv->network_list, list) {
00001c  f44f70f4          MOV      r0,#0x1e8
000020  f8d610ec          LDR      r1,[r6,#0xec]
000024  1a0c              SUBS     r4,r1,r0
000026  e052              B        |L26.206|
                  |L26.40|
;;;601    		if (!tmp_oldest ||
000028  9800              LDR      r0,[sp,#0]
00002a  b120              CBZ      r0,|L26.54|
;;;602    		    (iter_bss->last_scanned < tmp_oldest->last_scanned))
00002c  6ca1              LDR      r1,[r4,#0x48]
00002e  9800              LDR      r0,[sp,#0]
000030  6c80              LDR      r0,[r0,#0x48]
000032  4281              CMP      r1,r0
000034  d200              BCS      |L26.56|
                  |L26.54|
;;;603    			tmp_oldest = iter_bss;
000036  9400              STR      r4,[sp,#0]
                  |L26.56|
;;;604    
;;;605    		if (lbs_ssid_cmp(iter_bss->ssid, iter_bss->ssid_len,
000038  f8941027          LDRB     r1,[r4,#0x27]
00003c  4643              MOV      r3,r8
00003e  463a              MOV      r2,r7
000040  1da0              ADDS     r0,r4,#6
000042  f7fffffe          BL       lbs_ssid_cmp
000046  b100              CBZ      r0,|L26.74|
;;;606    				 ssid, ssid_len) != 0)
;;;607    			continue; /* ssid doesn't match */
000048  e03c              B        |L26.196|
                  |L26.74|
;;;608    		if (bssid && compare_ether_addr(iter_bss->bssid, bssid) != 0)
00004a  b12d              CBZ      r5,|L26.88|
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       compare_ether_addr
000054  b100              CBZ      r0,|L26.88|
;;;609    			continue; /* bssid doesn't match */
000056  e035              B        |L26.196|
                  |L26.88|
;;;610    		if ((channel > 0) && (iter_bss->channel != channel))
000058  f1ba0f00          CMP      r10,#0
00005c  dd03              BLE      |L26.102|
00005e  6b20              LDR      r0,[r4,#0x30]
000060  4550              CMP      r0,r10
000062  d000              BEQ      |L26.102|
;;;611    			continue; /* channel doesn't match */
000064  e02e              B        |L26.196|
                  |L26.102|
;;;612    
;;;613    		switch (mode) {
000066  f1b90f00          CMP      r9,#0
00006a  d01d              BEQ      |L26.168|
00006c  f1b90f01          CMP      r9,#1
000070  d003              BEQ      |L26.122|
000072  f1b90f02          CMP      r9,#2
000076  d116              BNE      |L26.166|
;;;614    		case IW_MODE_INFRA:
;;;615    		case IW_MODE_ADHOC:
000078  bf00              NOP      
                  |L26.122|
;;;616    			if (!is_network_compatible(priv, iter_bss, mode))
00007a  464a              MOV      r2,r9
00007c  4621              MOV      r1,r4
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       is_network_compatible
000084  b900              CBNZ     r0,|L26.136|
;;;617    				break;
000086  e01b              B        |L26.192|
                  |L26.136|
;;;618    
;;;619    			if (bssid) {
000088  b10d              CBZ      r5,|L26.142|
;;;620    				/* Found requested BSSID */
;;;621    				found_bss = iter_bss;
00008a  9401              STR      r4,[sp,#4]
;;;622    				goto out;
00008c  e026              B        |L26.220|
                  |L26.142|
;;;623    			}
;;;624    
;;;625    			if (SCAN_RSSI(iter_bss->rssi) > bestrssi) {
00008e  6ae0              LDR      r0,[r4,#0x2c]
000090  b2c0              UXTB     r0,r0
000092  f5c07080          RSB      r0,r0,#0x100
000096  4558              CMP      r0,r11
000098  d904              BLS      |L26.164|
;;;626    				bestrssi = SCAN_RSSI(iter_bss->rssi);
00009a  6ae0              LDR      r0,[r4,#0x2c]
00009c  b2c0              UXTB     r0,r0
00009e  f5c07b80          RSB      r11,r0,#0x100
;;;627    				found_bss = iter_bss;
0000a2  9401              STR      r4,[sp,#4]
                  |L26.164|
;;;628    			}
;;;629    			break;
0000a4  e00c              B        |L26.192|
                  |L26.166|
;;;630    		case IW_MODE_AUTO:
0000a6  bf00              NOP      
                  |L26.168|
;;;631    		default:
;;;632    			if (SCAN_RSSI(iter_bss->rssi) > bestrssi) {
0000a8  6ae0              LDR      r0,[r4,#0x2c]
0000aa  b2c0              UXTB     r0,r0
0000ac  f5c07080          RSB      r0,r0,#0x100
0000b0  4558              CMP      r0,r11
0000b2  d904              BLS      |L26.190|
;;;633    				bestrssi = SCAN_RSSI(iter_bss->rssi);
0000b4  6ae0              LDR      r0,[r4,#0x2c]
0000b6  b2c0              UXTB     r0,r0
0000b8  f5c07b80          RSB      r11,r0,#0x100
;;;634    				found_bss = iter_bss;
0000bc  9401              STR      r4,[sp,#4]
                  |L26.190|
;;;635    			}
;;;636    			break;
0000be  bf00              NOP      
                  |L26.192|
0000c0  bf00              NOP                            ;617
0000c2  bf00              NOP                            ;607
                  |L26.196|
0000c4  f44f70f4          MOV      r0,#0x1e8             ;600
0000c8  f8d411e8          LDR      r1,[r4,#0x1e8]        ;600
0000cc  1a0c              SUBS     r4,r1,r0              ;600
                  |L26.206|
0000ce  f50470f4          ADD      r0,r4,#0x1e8          ;600
0000d2  f10601ec          ADD      r1,r6,#0xec           ;600
0000d6  4288              CMP      r0,r1                 ;600
0000d8  d1a6              BNE      |L26.40|
;;;637    		}
;;;638    	}
;;;639    
;;;640    out:
0000da  bf00              NOP      
                  |L26.220|
;;;641    	//mutex_unlock(&priv->lock);
;;;642    	lbs_deb_leave_args(LBS_DEB_SCAN, found_bss);
;;;643    	return found_bss;
0000dc  9801              LDR      r0,[sp,#4]
;;;644    }
0000de  e8bd9ffc          POP      {r2-r12,pc}
;;;645    
                          ENDP


                          AREA ||i.lbs_set_authentication||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_p
                          REQUIRE _printf_longlong_hex
                  lbs_set_authentication PROC
;;;132     */
;;;133    static int lbs_set_authentication(struct lbs_private *priv, u8 bssid[6], u8 auth)
000000  b5f0              PUSH     {r4-r7,lr}
;;;134    {
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;135    	struct cmd_ds_802_11_authenticate cmd;
;;;136    	int ret = -1;
00000a  f04f37ff          MOV      r7,#0xffffffff
;;;137    
;;;138    	lbs_deb_enter(LBS_DEB_JOIN);
;;;139    
;;;140    	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
00000e  2019              MOVS     r0,#0x19
000010  f8ad0002          STRH     r0,[sp,#2]
;;;141    	memcpy(cmd.bssid, bssid, ETH_ALEN);
000014  6820              LDR      r0,[r4,#0]
000016  9002              STR      r0,[sp,#8]
000018  88a0              LDRH     r0,[r4,#4]
00001a  f8ad000c          STRH     r0,[sp,#0xc]
;;;142    
;;;143    	cmd.authtype = iw_auth_to_ieee_auth(auth);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       iw_auth_to_ieee_auth
000024  f88d000e          STRB     r0,[sp,#0xe]
;;;144    
;;;145    	lbs_deb_join("AUTH_CMD: BSSID %pM, auth 0x%x\n", bssid, cmd.authtype);
000028  f89d200e          LDRB     r2,[sp,#0xe]
00002c  4621              MOV      r1,r4
00002e  a006              ADR      r0,|L27.72|
000030  f7fffffe          BL       __2printf
;;;146    
;;;147    	ret = lbs_cmd_with_response(priv, CMD_802_11_AUTHENTICATE, &cmd);
000034  466a              MOV      r2,sp
000036  2111              MOVS     r1,#0x11
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       lbs_cmd_with_response
00003e  4607              MOV      r7,r0
;;;148    
;;;149    	lbs_deb_leave_args(LBS_DEB_JOIN, ret);
;;;150    	return ret;
000040  4638              MOV      r0,r7
;;;151    }
000042  b007              ADD      sp,sp,#0x1c
000044  bdf0              POP      {r4-r7,pc}
;;;152    
                          ENDP

000046  0000              DCW      0x0000
                  |L27.72|
000048  41555448          DCB      "AUTH_CMD: BSSID %pM, auth 0x%x\n",0
00004c  5f434d44
000050  3a204253
000054  53494420
000058  25704d2c
00005c  20617574
000060  68203078
000064  25780a00

                          AREA ||i.lbs_set_basic_rate_flags||, CODE, READONLY, ALIGN=1

                  lbs_set_basic_rate_flags PROC
;;;98     
;;;99     static void lbs_set_basic_rate_flags(u8 *rates, size_t len)
000000  4602              MOV      r2,r0
;;;100    {
;;;101    	int i;
;;;102    
;;;103    	for (i = 0; i < len; i++) {
000002  2000              MOVS     r0,#0
000004  e010              B        |L28.40|
                  |L28.6|
;;;104    		if (rates[i] == 0x02 || rates[i] == 0x04 ||
000006  5c13              LDRB     r3,[r2,r0]
000008  2b02              CMP      r3,#2
00000a  d008              BEQ      |L28.30|
00000c  5c13              LDRB     r3,[r2,r0]
00000e  2b04              CMP      r3,#4
000010  d005              BEQ      |L28.30|
;;;105    		    rates[i] == 0x0b || rates[i] == 0x16)
000012  5c13              LDRB     r3,[r2,r0]
000014  2b0b              CMP      r3,#0xb
000016  d002              BEQ      |L28.30|
000018  5c13              LDRB     r3,[r2,r0]
00001a  2b16              CMP      r3,#0x16
00001c  d103              BNE      |L28.38|
                  |L28.30|
;;;106    			rates[i] |= 0x80;
00001e  5c13              LDRB     r3,[r2,r0]
000020  f0430380          ORR      r3,r3,#0x80
000024  5413              STRB     r3,[r2,r0]
                  |L28.38|
000026  1c40              ADDS     r0,r0,#1              ;103
                  |L28.40|
000028  4288              CMP      r0,r1                 ;103
00002a  d3ec              BCC      |L28.6|
;;;107    	}
;;;108    }
00002c  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.lbs_try_associate||, CODE, READONLY, ALIGN=1

                  lbs_try_associate PROC
;;;441     */
;;;442    static int lbs_try_associate(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;443    	struct assoc_request *assoc_req)
;;;444    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;445    	int ret;
;;;446    	u8 preamble = RADIO_PREAMBLE_LONG;
000008  2700              MOVS     r7,#0
;;;447    
;;;448    	lbs_deb_enter(LBS_DEB_ASSOC);
;;;449    
;;;450    	/* FW v9 and higher indicate authentication suites as a TLV in the
;;;451    	 * association command, not as a separate authentication command.
;;;452    	 */
;;;453    	if (priv->fwrelease < 0x09000000) {
00000a  6ea0              LDR      r0,[r4,#0x68]
00000c  f1b06f10          CMP      r0,#0x9000000
000010  d20a              BCS      |L29.40|
;;;454    		ret = lbs_set_authentication(priv, assoc_req->bss.bssid,
000012  f2402003          MOV      r0,#0x203
000016  5d02              LDRB     r2,[r0,r4]
000018  f50671b2          ADD      r1,r6,#0x164
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       lbs_set_authentication
000022  4605              MOV      r5,r0
;;;455    					     priv->secinfo.auth_mode);//设置认证
;;;456    		if (ret)
000024  b105              CBZ      r5,|L29.40|
;;;457    			goto out;
000026  e01a              B        |L29.94|
                  |L29.40|
;;;458    	}
;;;459    
;;;460    	/* Use short preamble only when both the BSS and firmware support it */
;;;461    	if ((priv->capability & WLAN_CAPABILITY_SHORT_PREAMBLE) &&
000028  f8b40108          LDRH     r0,[r4,#0x108]
00002c  f0100f20          TST      r0,#0x20
000030  d006              BEQ      |L29.64|
;;;462    	    (assoc_req->bss.capability & WLAN_CAPABILITY_SHORT_PREAMBLE))
000032  f44f70c6          MOV      r0,#0x18c
000036  5b80              LDRH     r0,[r0,r6]
000038  f0100f20          TST      r0,#0x20
00003c  d000              BEQ      |L29.64|
;;;463    		preamble = RADIO_PREAMBLE_SHORT;
00003e  2702              MOVS     r7,#2
                  |L29.64|
;;;464    
;;;465    	ret = lbs_set_radio(priv, preamble, 1);
000040  2201              MOVS     r2,#1
000042  4639              MOV      r1,r7
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       lbs_set_radio
00004a  4605              MOV      r5,r0
;;;466    	if (ret)
00004c  b105              CBZ      r5,|L29.80|
;;;467    		goto out;
00004e  e006              B        |L29.94|
                  |L29.80|
;;;468    
;;;469    	ret = lbs_associate(priv, assoc_req, CMD_802_11_ASSOCIATE);
000050  2250              MOVS     r2,#0x50
000052  4631              MOV      r1,r6
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       lbs_associate
00005a  4605              MOV      r5,r0
;;;470    
;;;471    out:
00005c  bf00              NOP      
                  |L29.94|
;;;472    	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;473    	return ret;
00005e  4628              MOV      r0,r5
;;;474    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;475    
                          ENDP


                          AREA ||i.marvel_assoc_open_network||, CODE, READONLY, ALIGN=2

                  marvel_assoc_open_network PROC
;;;1803   
;;;1804   void marvel_assoc_open_network(struct lbs_private *priv,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1805   	char *ssid,char *key,char mode)
;;;1806   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1807   	static struct assoc_request gmarvel_adhoc_assoc;
;;;1808   	memset(&gmarvel_adhoc_assoc,0,sizeof(struct assoc_request));
00000c  f44f7156          MOV      r1,#0x358
000010  480b              LDR      r0,|L30.64|
000012  f7fffffe          BL       __aeabi_memclr4
;;;1809   	xxx_find_ssid(priv,&gmarvel_adhoc_assoc,ssid,key);
000016  4633              MOV      r3,r6
000018  462a              MOV      r2,r5
00001a  4909              LDR      r1,|L30.64|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xxx_find_ssid
;;;1810   	init_marvel_adhoc_assoc(&gmarvel_adhoc_assoc,ssid,key,mode);
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  4629              MOV      r1,r5
000028  4805              LDR      r0,|L30.64|
00002a  f7fffffe          BL       init_marvel_adhoc_assoc
;;;1811   	priv->pending_assoc_req=&gmarvel_adhoc_assoc;
00002e  4804              LDR      r0,|L30.64|
000030  f8c401f8          STR      r0,[r4,#0x1f8]
;;;1812   	lbs_association_worker(priv);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       lbs_association_worker
;;;1813   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1814   
                          ENDP

00003e  0000              DCW      0x0000
                  |L30.64|
                          DCD      gmarvel_adhoc_assoc

                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.print_enckey||, CODE, READONLY, ALIGN=2

                  print_enckey PROC
;;;1818   
;;;1819   void print_enckey(struct enc_key *key)
000000  b538              PUSH     {r3-r5,lr}
;;;1820   {
000002  4604              MOV      r4,r0
;;;1821   	wpa_printf(MSG_DEBUG,"enc_key:\n"
000004  88a3              LDRH     r3,[r4,#4]
000006  9300              STR      r3,[sp,#0]
000008  8863              LDRH     r3,[r4,#2]
00000a  8822              LDRH     r2,[r4,#0]
00000c  a105              ADR      r1,|L32.36|
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       wpa_printf
;;;1822   				   "len:0x%2x flags:0x%2x type:0x%2x\n",key->len,key->flags,
;;;1823   				   key->type);
;;;1824   	wpa_hexdump_key(MSG_DEBUG,"",key->key,key->len);
000014  8823              LDRH     r3,[r4,#0]
000016  1da2              ADDS     r2,r4,#6
000018  a10d              ADR      r1,|L32.80|
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       wpa_hexdump_key
;;;1825   }
000020  bd38              POP      {r3-r5,pc}
;;;1826   
                          ENDP

000022  0000              DCW      0x0000
                  |L32.36|
000024  656e635f          DCB      "enc_key:\nlen:0x%2x flags:0x%2x type:0x%2x\n",0
000028  6b65793a
00002c  0a6c656e
000030  3a307825
000034  32782066
000038  6c616773
00003c  3a307825
000040  32782074
000044  7970653a
000048  30782532
00004c  780a00  
00004f  00                DCB      0
                  |L32.80|
000050  00                DCB      0
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.set_bssinfo_to_priv||, CODE, READONLY, ALIGN=1

                  set_bssinfo_to_priv PROC
;;;1452   /*这个函数添加的目的是，将一个搜索到的AP，而且匹配合格后的信息，加入到PRIV中，以备关联时用*/
;;;1453   static int set_bssinfo_to_priv(struct lbs_private *priv,
000000  4602              MOV      r2,r0
;;;1454   				 struct bss_descriptor *bss)
;;;1455   {
;;;1456   #if 0 //这里不用这样做，因为后面的过程中，如果找到了当前所要关联的AP，那么将BSS存储到cur_bss中去
;;;1457   	priv->__wpa_ie_len = bss->wpa_ie_len;
;;;1458   	memcpy(priv->__wpa_ie,bss->wpa_ie, priv->__wpa_ie_len);
;;;1459   #endif
;;;1460   	return 0;
000002  2000              MOVS     r0,#0
;;;1461   	//
;;;1462   }
000004  4770              BX       lr
;;;1463   static int is_network_compatible(struct lbs_private *priv,
                          ENDP


                          AREA ||i.should_deauth_infrastructure||, CODE, READONLY, ALIGN=2

                  should_deauth_infrastructure PROC
;;;1627   
;;;1628   static int should_deauth_infrastructure(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;1629                                           struct assoc_request * assoc_req)
;;;1630   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1631   	int ret = 0;
000006  2600              MOVS     r6,#0
;;;1632   
;;;1633   	if (priv->connect_status != LBS_CONNECTED)
000008  f8d401dc          LDR      r0,[r4,#0x1dc]
00000c  b108              CBZ      r0,|L34.18|
;;;1634   		return 0;
00000e  2000              MOVS     r0,#0
                  |L34.16|
;;;1635   
;;;1636   	lbs_deb_enter(LBS_DEB_ASSOC);
;;;1637   	if (test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {//essid改变
;;;1638   		lbs_deb_assoc("Deauthenticating due to new SSID\n");
;;;1639   		ret = 1;
;;;1640   		goto out;
;;;1641   	}
;;;1642   
;;;1643   	if (test_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags)) {//加密信息改变
;;;1644   		if (priv->secinfo.auth_mode != assoc_req->secinfo.auth_mode) {
;;;1645   			lbs_deb_assoc("Deauthenticating due to new security\n");
;;;1646   			ret = 1;
;;;1647   			goto out;
;;;1648   		}
;;;1649   	}
;;;1650   
;;;1651   	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {//bssid改变
;;;1652   		lbs_deb_assoc("Deauthenticating due to new BSSID\n");
;;;1653   		ret = 1;
;;;1654   		goto out;
;;;1655   	}
;;;1656   
;;;1657   	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags)) {//通道改变
;;;1658   		lbs_deb_assoc("Deauthenticating due to channel switch\n");
;;;1659   		ret = 1;
;;;1660   		goto out;
;;;1661   	}
;;;1662   
;;;1663   	/* FIXME: deal with 'auto' mode somehow */
;;;1664   	if (test_bit(ASSOC_FLAG_MODE, &assoc_req->flags)) {//模式改变
;;;1665   		if (assoc_req->mode != IW_MODE_INFRA) {
;;;1666   			lbs_deb_assoc("Deauthenticating due to leaving "
;;;1667   				"infra mode\n");
;;;1668   			ret = 1;
;;;1669   			goto out;
;;;1670   		}
;;;1671   	}
;;;1672   
;;;1673   out:
;;;1674   	lbs_deb_leave_args(LBS_DEB_ASSOC, ret);
;;;1675   	return ret;
;;;1676   }
000010  bd70              POP      {r4-r6,pc}
                  |L34.18|
000012  4629              MOV      r1,r5                 ;1637
000014  2001              MOVS     r0,#1                 ;1637
000016  f7fffffe          BL       test_bit
00001a  b120              CBZ      r0,|L34.38|
00001c  a01d              ADR      r0,|L34.148|
00001e  f7fffffe          BL       __2printf
000022  2601              MOVS     r6,#1                 ;1639
000024  e034              B        |L34.144|
                  |L34.38|
000026  4629              MOV      r1,r5                 ;1643
000028  200a              MOVS     r0,#0xa               ;1643
00002a  f7fffffe          BL       test_bit
00002e  b160              CBZ      r0,|L34.74|
000030  f2402003          MOV      r0,#0x203             ;1644
000034  5d01              LDRB     r1,[r0,r4]            ;1644
000036  f240101b          MOV      r0,#0x11b             ;1644
00003a  5d40              LDRB     r0,[r0,r5]            ;1644
00003c  4281              CMP      r1,r0                 ;1644
00003e  d004              BEQ      |L34.74|
000040  a01d              ADR      r0,|L34.184|
000042  f7fffffe          BL       __2printf
000046  2601              MOVS     r6,#1                 ;1646
000048  e022              B        |L34.144|
                  |L34.74|
00004a  4629              MOV      r1,r5                 ;1651
00004c  2005              MOVS     r0,#5                 ;1651
00004e  f7fffffe          BL       test_bit
000052  b120              CBZ      r0,|L34.94|
000054  a022              ADR      r0,|L34.224|
000056  f7fffffe          BL       __2printf
00005a  2601              MOVS     r6,#1                 ;1653
00005c  e018              B        |L34.144|
                  |L34.94|
00005e  4629              MOV      r1,r5                 ;1657
000060  2002              MOVS     r0,#2                 ;1657
000062  f7fffffe          BL       test_bit
000066  b120              CBZ      r0,|L34.114|
000068  a026              ADR      r0,|L34.260|
00006a  f7fffffe          BL       __2printf
00006e  2601              MOVS     r6,#1                 ;1659
000070  e00e              B        |L34.144|
                  |L34.114|
000072  4629              MOV      r1,r5                 ;1664
000074  2004              MOVS     r0,#4                 ;1664
000076  f7fffffe          BL       test_bit
00007a  b140              CBZ      r0,|L34.142|
00007c  f8950028          LDRB     r0,[r5,#0x28]         ;1665
000080  2802              CMP      r0,#2                 ;1665
000082  d004              BEQ      |L34.142|
000084  a029              ADR      r0,|L34.300|
000086  f7fffffe          BL       __2printf
00008a  2601              MOVS     r6,#1                 ;1668
00008c  e000              B        |L34.144|
                  |L34.142|
00008e  bf00              NOP                            ;1673
                  |L34.144|
000090  4630              MOV      r0,r6                 ;1675
000092  e7bd              B        |L34.16|
;;;1677   
                          ENDP

                  |L34.148|
000094  44656175          DCB      "Deauthenticating due to new SSID\n",0
000098  7468656e
00009c  74696361
0000a0  74696e67
0000a4  20647565
0000a8  20746f20
0000ac  6e657720
0000b0  53534944
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L34.184|
0000b8  44656175          DCB      "Deauthenticating due to new security\n",0
0000bc  7468656e
0000c0  74696361
0000c4  74696e67
0000c8  20647565
0000cc  20746f20
0000d0  6e657720
0000d4  73656375
0000d8  72697479
0000dc  0a00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L34.224|
0000e0  44656175          DCB      "Deauthenticating due to new BSSID\n",0
0000e4  7468656e
0000e8  74696361
0000ec  74696e67
0000f0  20647565
0000f4  20746f20
0000f8  6e657720
0000fc  42535349
000100  440a00  
000103  00                DCB      0
                  |L34.260|
000104  44656175          DCB      "Deauthenticating due to channel switch\n",0
000108  7468656e
00010c  74696361
000110  74696e67
000114  20647565
000118  20746f20
00011c  6368616e
000120  6e656c20
000124  73776974
000128  63680a00
                  |L34.300|
00012c  44656175          DCB      "Deauthenticating due to leaving infra mode\n",0
000130  7468656e
000134  74696361
000138  74696e67
00013c  20647565
000140  20746f20
000144  6c656176
000148  696e6720
00014c  696e6672
000150  61206d6f
000154  64650a00

                          AREA ||i.should_stop_adhoc||, CODE, READONLY, ALIGN=1

                  should_stop_adhoc PROC
;;;1680   
;;;1681   static int should_stop_adhoc(struct lbs_private *priv,
000000  b570              PUSH     {r4-r6,lr}
;;;1682                                struct assoc_request * assoc_req)
;;;1683   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1684   	lbs_deb_enter(LBS_DEB_ASSOC);
;;;1685   
;;;1686   	if (priv->connect_status != LBS_CONNECTED)
000006  f8d401dc          LDR      r0,[r4,#0x1dc]
00000a  b108              CBZ      r0,|L35.16|
;;;1687   		return 0;
00000c  2000              MOVS     r0,#0
                  |L35.14|
;;;1688   
;;;1689   	if (lbs_ssid_cmp(priv->curbssparams.ssid,
;;;1690   	                      priv->curbssparams.ssid_len,
;;;1691   	                      assoc_req->ssid, assoc_req->ssid_len) != 0)
;;;1692   		return 1;
;;;1693   
;;;1694   	/* FIXME: deal with 'auto' mode somehow */
;;;1695   	if (test_bit(ASSOC_FLAG_MODE, &assoc_req->flags)) {
;;;1696   		if (assoc_req->mode != IW_MODE_ADHOC)
;;;1697   			return 1;
;;;1698   	}
;;;1699   
;;;1700   	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags)) {
;;;1701   		if (assoc_req->channel != priv->curbssparams.channel)
;;;1702   			return 1;
;;;1703   	}
;;;1704   
;;;1705   	lbs_deb_leave(LBS_DEB_ASSOC);
;;;1706   	return 0;
;;;1707   }
00000e  bd70              POP      {r4-r6,pc}
                  |L35.16|
000010  f8953025          LDRB     r3,[r5,#0x25]         ;1689
000014  f89410d7          LDRB     r1,[r4,#0xd7]         ;1689
000018  1d2a              ADDS     r2,r5,#4              ;1689
00001a  f10400b6          ADD      r0,r4,#0xb6           ;1689
00001e  f7fffffe          BL       lbs_ssid_cmp
000022  b108              CBZ      r0,|L35.40|
000024  2001              MOVS     r0,#1                 ;1692
000026  e7f2              B        |L35.14|
                  |L35.40|
000028  4629              MOV      r1,r5                 ;1695
00002a  2004              MOVS     r0,#4                 ;1695
00002c  f7fffffe          BL       test_bit
000030  b128              CBZ      r0,|L35.62|
000032  f8950028          LDRB     r0,[r5,#0x28]         ;1696
000036  2801              CMP      r0,#1                 ;1696
000038  d001              BEQ      |L35.62|
00003a  2001              MOVS     r0,#1                 ;1697
00003c  e7e7              B        |L35.14|
                  |L35.62|
00003e  4629              MOV      r1,r5                 ;1700
000040  2002              MOVS     r0,#2                 ;1700
000042  f7fffffe          BL       test_bit
000046  b138              CBZ      r0,|L35.88|
000048  f8951026          LDRB     r1,[r5,#0x26]         ;1701
00004c  f89400d9          LDRB     r0,[r4,#0xd9]         ;1701
000050  4281              CMP      r1,r0                 ;1701
000052  d001              BEQ      |L35.88|
000054  2001              MOVS     r0,#1                 ;1702
000056  e7da              B        |L35.14|
                  |L35.88|
000058  2000              MOVS     r0,#0                 ;1706
00005a  e7d8              B        |L35.14|
;;;1708   
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L36.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L36.32|
                  |L36.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L36.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L36.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L36.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L36.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L36.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L36.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L36.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.xxx_find_ssid||, CODE, READONLY, ALIGN=1

                  xxx_find_ssid PROC
;;;1714   char * psk_out;
;;;1715   static int xxx_find_ssid(struct lbs_private *priv , struct assoc_request * assoc , char *ssid , char *key)
000000  b530              PUSH     {r4,r5,lr}
;;;1716   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1717   	struct bss_descriptor *iter_bss;
;;;1718   	struct bss_descriptor *found_bss = NULL;
000006  2100              MOVS     r1,#0
;;;1719   
;;;1720   #if WPA_ENABLE
;;;1721   	list_for_each_entry_bssdes(iter_bss, &priv->network_list, list) {
;;;1722   
;;;1723   		if (strcmp(iter_bss->ssid,ssid) == 0)
;;;1724   		{
;;;1725   			
;;;1726   			//如果找到了一个SSID相同的,那么就检查他的加密类型然后对其进行设置
;;;1727   			if (iter_bss->wpa_ie[0] == WLAN_EID_GENERIC) //wpa
;;;1728   			{
;;;1729   				assoc->secinfo.wep_enabled=0;
;;;1730   				assoc->secinfo.WPAenabled=1;
;;;1731   
;;;1732   
;;;1733   				assoc->flags|=1<<ASSOC_FLAG_WPA_IE;
;;;1734   				assoc->flags|=1<<ASSOC_FLAG_WPA_MCAST_KEY;
;;;1735   				assoc->flags|=1<<ASSOC_FLAG_SECINFO;
;;;1736   				//
;;;1737   			}
;;;1738   
;;;1739   			if (iter_bss->rsn_ie[0] == WLAN_EID_RSN) //wpa2
;;;1740   			{
;;;1741   				assoc->secinfo.wep_enabled=0;
;;;1742   				assoc->secinfo.WPA2enabled=1;
;;;1743   
;;;1744   				assoc->flags|=1<<ASSOC_FLAG_WPA_IE;
;;;1745   				assoc->flags|=1<<ASSOC_FLAG_WPA_MCAST_KEY;
;;;1746   				assoc->flags|=1<<ASSOC_FLAG_SECINFO;
;;;1747   				//
;;;1748   			}
;;;1749   
;;;1750   			if (assoc->secinfo.WPAenabled || assoc->secinfo.WPA2enabled)
;;;1751   			{
;;;1752   		
;;;1753   				// 这里就是计算真正的WPA密码算法，让其设置到关联中，将密码设置进去
;;;1754   				pbkdf2_sha1(marvel_key, marvel_ssid, strlen(marvel_ssid), 4096, psk_out, 32);
;;;1755   				assoc->psk = psk_out;
;;;1756   				printf("WPA password %s , %s \n",marvel_key,psk_out);
;;;1757   												
;;;1758   			}else
;;;1759   			{
;;;1760   				extern int newpower_time_out_current_state;
;;;1761   				newpower_time_out_current_state = 8; // 由于这里不是WPA加密因此不进行判断就直接进入连接状态
;;;1762   			}
;;;1763   
;;;1764   
;;;1765   		}
;;;1766   	}
;;;1767   	
;;;1768   #endif
;;;1769   	return 0;
000008  2000              MOVS     r0,#0
;;;1770   }
00000a  bd30              POP      {r4,r5,pc}
;;;1771   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gmarvel_adhoc_assoc
                          %        856

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  bssid_any
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  bssid_off
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  __func__
00000c  69775f61          DCB      0x69,0x77,0x5f,0x61
000010  7574685f          DCB      0x75,0x74,0x68,0x5f
000014  746f5f69          DCB      0x74,0x6f,0x5f,0x69
000018  6565655f          DCB      0x65,0x65,0x65,0x5f
00001c  61757468          DCB      0x61,0x75,0x74,0x68
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  69735f6e          DCB      0x69,0x73,0x5f,0x6e
000028  6574776f          DCB      0x65,0x74,0x77,0x6f
00002c  726b5f63          DCB      0x72,0x6b,0x5f,0x63
000030  6f6d7061          DCB      0x6f,0x6d,0x70,0x61
000034  7469626c          DCB      0x74,0x69,0x62,0x6c
000038  65282920          DCB      0x65,0x28,0x29,0x20
00003c  5750413a          DCB      0x57,0x50,0x41,0x3a
000040  20777061          DCB      0x20,0x77,0x70,0x61
000044  5f696520          DCB      0x5f,0x69,0x65,0x20
000048  30782578          DCB      0x30,0x78,0x25,0x78
00004c  20777061          DCB      0x20,0x77,0x70,0x61
000050  325f6965          DCB      0x32,0x5f,0x69,0x65
000054  20307825          DCB      0x20,0x30,0x78,0x25
000058  78205745          DCB      0x78,0x20,0x57,0x45
00005c  50202573          DCB      0x50,0x20,0x25,0x73
000060  20575041          DCB      0x20,0x57,0x50,0x41
000064  20257320          DCB      0x20,0x25,0x73,0x20
000068  57504132          DCB      0x57,0x50,0x41,0x32
00006c  20257320          DCB      0x20,0x25,0x73,0x20
000070  70726976          DCB      0x70,0x72,0x69,0x76
000074  61637920          DCB      0x61,0x63,0x79,0x20
000078  30782578          DCB      0x30,0x78,0x25,0x78
00007c  0a000000          DCB      0x0a,0x00,0x00,0x00
000080  69735f6e          DCB      0x69,0x73,0x5f,0x6e
000084  6574776f          DCB      0x65,0x74,0x77,0x6f
000088  726b5f63          DCB      0x72,0x6b,0x5f,0x63
00008c  6f6d7061          DCB      0x6f,0x6d,0x70,0x61
000090  7469626c          DCB      0x74,0x69,0x62,0x6c
000094  65282920          DCB      0x65,0x28,0x29,0x20
000098  57504132          DCB      0x57,0x50,0x41,0x32
00009c  3a207770          DCB      0x3a,0x20,0x77,0x70
0000a0  615f6965          DCB      0x61,0x5f,0x69,0x65
0000a4  20307825          DCB      0x20,0x30,0x78,0x25
0000a8  78207770          DCB      0x78,0x20,0x77,0x70
0000ac  61325f69          DCB      0x61,0x32,0x5f,0x69
0000b0  65203078          DCB      0x65,0x20,0x30,0x78
0000b4  25782057          DCB      0x25,0x78,0x20,0x57
0000b8  45502025          DCB      0x45,0x50,0x20,0x25
0000bc  73205750          DCB      0x73,0x20,0x57,0x50
0000c0  41202573          DCB      0x41,0x20,0x25,0x73
0000c4  20575041          DCB      0x20,0x57,0x50,0x41
0000c8  32202573          DCB      0x32,0x20,0x25,0x73
0000cc  20707269          DCB      0x20,0x70,0x72,0x69
0000d0  76616379          DCB      0x76,0x61,0x63,0x79
0000d4  20307825          DCB      0x20,0x30,0x78,0x25
0000d8  780a0000          DCB      0x78,0x0a,0x00,0x00
0000dc  69735f6e          DCB      0x69,0x73,0x5f,0x6e
0000e0  6574776f          DCB      0x65,0x74,0x77,0x6f
0000e4  726b5f63          DCB      0x72,0x6b,0x5f,0x63
0000e8  6f6d7061          DCB      0x6f,0x6d,0x70,0x61
0000ec  7469626c          DCB      0x74,0x69,0x62,0x6c
0000f0  65282920          DCB      0x65,0x28,0x29,0x20
0000f4  64796e61          DCB      0x64,0x79,0x6e,0x61
0000f8  6d696320          DCB      0x6d,0x69,0x63,0x20
0000fc  5745503a          DCB      0x57,0x45,0x50,0x3a
000100  20777061          DCB      0x20,0x77,0x70,0x61
000104  5f696520          DCB      0x5f,0x69,0x65,0x20
000108  30782578          DCB      0x30,0x78,0x25,0x78
00010c  20777061          DCB      0x20,0x77,0x70,0x61
000110  325f6965          DCB      0x32,0x5f,0x69,0x65
000114  20307825          DCB      0x20,0x30,0x78,0x25
000118  78207072          DCB      0x78,0x20,0x70,0x72
00011c  69766163          DCB      0x69,0x76,0x61,0x63
000120  79203078          DCB      0x79,0x20,0x30,0x78
000124  25780a00          DCB      0x25,0x78,0x0a,0x00
000128  69735f6e          DCB      0x69,0x73,0x5f,0x6e
00012c  6574776f          DCB      0x65,0x74,0x77,0x6f
000130  726b5f63          DCB      0x72,0x6b,0x5f,0x63
000134  6f6d7061          DCB      0x6f,0x6d,0x70,0x61
000138  7469626c          DCB      0x74,0x69,0x62,0x6c
00013c  65282920          DCB      0x65,0x28,0x29,0x20
000140  4641494c          DCB      0x46,0x41,0x49,0x4c
000144  45443a20          DCB      0x45,0x44,0x3a,0x20
000148  7770615f          DCB      0x77,0x70,0x61,0x5f
00014c  69652030          DCB      0x69,0x65,0x20,0x30
000150  78257820          DCB      0x78,0x25,0x78,0x20
000154  77706132          DCB      0x77,0x70,0x61,0x32
000158  5f696520          DCB      0x5f,0x69,0x65,0x20
00015c  30782578          DCB      0x30,0x78,0x25,0x78
000160  20574550          DCB      0x20,0x57,0x45,0x50
000164  20257320          DCB      0x20,0x25,0x73,0x20
000168  57504120          DCB      0x57,0x50,0x41,0x20
00016c  25732057          DCB      0x25,0x73,0x20,0x57
000170  50413220          DCB      0x50,0x41,0x32,0x20
000174  25732070          DCB      0x25,0x73,0x20,0x70
000178  72697661          DCB      0x72,0x69,0x76,0x61
00017c  63792030          DCB      0x63,0x79,0x20,0x30
000180  7825780a          DCB      0x78,0x25,0x78,0x0a
000184  00000000          DCB      0x00,0x00,0x00,0x00
000188  4144484f          DCB      0x41,0x44,0x48,0x4f
00018c  435f4a5f          DCB      0x43,0x5f,0x4a,0x5f
000190  434d443a          DCB      0x43,0x4d,0x44,0x3a
000194  204e6577          DCB      0x20,0x4e,0x65,0x77
000198  2061642d          DCB      0x20,0x61,0x64,0x2d
00019c  686f6320          DCB      0x68,0x6f,0x63,0x20
0001a0  53534944          DCB      0x53,0x53,0x49,0x44
0001a4  20697320          DCB      0x20,0x69,0x73,0x20
0001a8  74686520          DCB      0x74,0x68,0x65,0x20
0001ac  73616d65          DCB      0x73,0x61,0x6d,0x65
0001b0  20617320          DCB      0x20,0x61,0x73,0x20
0001b4  63757272          DCB      0x63,0x75,0x72,0x72
0001b8  656e742c          DCB      0x65,0x6e,0x74,0x2c
0001bc  206e6f74          DCB      0x20,0x6e,0x6f,0x74
0001c0  20617474          DCB      0x20,0x61,0x74,0x74
0001c4  656d7074          DCB      0x65,0x6d,0x70,0x74
0001c8  696e6720          DCB      0x69,0x6e,0x67,0x20
0001cc  746f2072          DCB      0x74,0x6f,0x20,0x72
0001d0  652d6a6f          DCB      0x65,0x2d,0x6a,0x6f
0001d4  696e0000          DCB      0x69,0x6e,0x00,0x00
0001d8  4173736f          DCB      0x41,0x73,0x73,0x6f
0001dc  63696174          DCB      0x63,0x69,0x61,0x74
0001e0  696f6e20          DCB      0x69,0x6f,0x6e,0x20
0001e4  52657175          DCB      0x52,0x65,0x71,0x75
0001e8  6573743a          DCB      0x65,0x73,0x74,0x3a
0001ec  0a202020          DCB      0x0a,0x20,0x20,0x20
0001f0  20666c61          DCB      0x20,0x66,0x6c,0x61
0001f4  67733a20          DCB      0x67,0x73,0x3a,0x20
0001f8  20202020          DCB      0x20,0x20,0x20,0x20
0001fc  30782530          DCB      0x30,0x78,0x25,0x30
000200  386c780a          DCB      0x38,0x6c,0x78,0x0a
000204  20202020          DCB      0x20,0x20,0x20,0x20
000208  53534944          DCB      0x53,0x53,0x49,0x44
00020c  3a202020          DCB      0x3a,0x20,0x20,0x20
000210  20202027          DCB      0x20,0x20,0x20,0x27
000214  2573270a          DCB      0x25,0x73,0x27,0x0a
000218  20202020          DCB      0x20,0x20,0x20,0x20
00021c  6368616e          DCB      0x63,0x68,0x61,0x6e
000220  6e3a2020          DCB      0x6e,0x3a,0x20,0x20
000224  20202025          DCB      0x20,0x20,0x20,0x25
000228  640a2020          DCB      0x64,0x0a,0x20,0x20
00022c  20206261          DCB      0x20,0x20,0x62,0x61
000230  6e643a20          DCB      0x6e,0x64,0x3a,0x20
000234  20202020          DCB      0x20,0x20,0x20,0x20
000238  2025640a          DCB      0x20,0x25,0x64,0x0a
00023c  20202020          DCB      0x20,0x20,0x20,0x20
000240  6d6f6465          DCB      0x6d,0x6f,0x64,0x65
000244  3a202020          DCB      0x3a,0x20,0x20,0x20
000248  20202025          DCB      0x20,0x20,0x20,0x25
00024c  640a2020          DCB      0x64,0x0a,0x20,0x20
000250  20204253          DCB      0x20,0x20,0x42,0x53
000254  5349443a          DCB      0x53,0x49,0x44,0x3a
000258  20202020          DCB      0x20,0x20,0x20,0x20
00025c  20253032          DCB      0x20,0x25,0x30,0x32
000260  783a2530          DCB      0x78,0x3a,0x25,0x30
000264  32783a25          DCB      0x32,0x78,0x3a,0x25
000268  3032783a          DCB      0x30,0x32,0x78,0x3a
00026c  25303278          DCB      0x25,0x30,0x32,0x78
000270  3a253032          DCB      0x3a,0x25,0x30,0x32
000274  783a2530          DCB      0x78,0x3a,0x25,0x30
000278  32780a20          DCB      0x32,0x78,0x0a,0x20
00027c  20202073          DCB      0x20,0x20,0x20,0x73
000280  6563696e          DCB      0x65,0x63,0x69,0x6e
000284  666f3a20          DCB      0x66,0x6f,0x3a,0x20
000288  20257325          DCB      0x20,0x25,0x73,0x25
00028c  73257309          DCB      0x73,0x25,0x73,0x09
000290  6b65795f          DCB      0x6b,0x65,0x79,0x5f
000294  6d676d74          DCB      0x6d,0x67,0x6d,0x74
000298  3a25640a          DCB      0x3a,0x25,0x64,0x0a
00029c  20202020          DCB      0x20,0x20,0x20,0x20
0002a0  61757468          DCB      0x61,0x75,0x74,0x68
0002a4  5f6d6f64          DCB      0x5f,0x6d,0x6f,0x64
0002a8  653a2025          DCB      0x65,0x3a,0x20,0x25
0002ac  640a0000          DCB      0x64,0x0a,0x00,0x00
0002b0  54656172          DCB      0x54,0x65,0x61,0x72
0002b4  646f776e          DCB      0x64,0x6f,0x77,0x6e
0002b8  206f6620          DCB      0x20,0x6f,0x66,0x20
0002bc  4164486f          DCB      0x41,0x64,0x48,0x6f
0002c0  63206e65          DCB      0x63,0x20,0x6e,0x65
0002c4  74776f72          DCB      0x74,0x77,0x6f,0x72
0002c8  6b206475          DCB      0x6b,0x20,0x64,0x75
0002cc  6520746f          DCB      0x65,0x20,0x74,0x6f
0002d0  206e6577          DCB      0x20,0x6e,0x65,0x77
0002d4  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0002d8  66696775          DCB      0x66,0x69,0x67,0x75
0002dc  72617469          DCB      0x72,0x61,0x74,0x69
0002e0  6f6e2072          DCB      0x6f,0x6e,0x20,0x72
0002e4  65717565          DCB      0x65,0x71,0x75,0x65
0002e8  73742066          DCB      0x73,0x74,0x20,0x66
0002ec  61696c65          DCB      0x61,0x69,0x6c,0x65
0002f0  643a2025          DCB      0x64,0x3a,0x20,0x25
0002f4  640a00            DCB      0x64,0x0a,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  newpower_time_out_current_state
                          DCD      0x00000000
                  wpa_debug_level
                          DCD      0x00000000
                  psk_out
                          DCD      0x00000000

                          AREA ||i.test_bit||, COMGROUP=test_bit, CODE, READONLY, ALIGN=1

                  test_bit PROC
;;;2049   }
;;;2050   __inline int test_bit(int nr, const unsigned long *vaddr)
000000  b510              PUSH     {r4,lr}
;;;2051   {
000002  4602              MOV      r2,r0
;;;2052   	return (vaddr[nr >> 5] & ((unsigned long)1<< (nr & 31))) != 0;
000004  1150              ASRS     r0,r2,#5
000006  f8510020          LDR      r0,[r1,r0,LSL #2]
00000a  f002041f          AND      r4,r2,#0x1f
00000e  2301              MOVS     r3,#1
000010  40a3              LSLS     r3,r3,r4
000012  4218              TST      r0,r3
000014  d001              BEQ      |L202.26|
000016  2001              MOVS     r0,#1
                  |L202.24|
;;;2053   }
000018  bd10              POP      {r4,pc}
                  |L202.26|
00001a  2000              MOVS     r0,#0                 ;2052
00001c  e7fc              B        |L202.24|
;;;2054   __inline void clear_bit(int nr,unsigned long *vaddr)
                          ENDP


                          AREA ||i.set_bit||, COMGROUP=set_bit, CODE, READONLY, ALIGN=1

                  set_bit PROC
;;;2058   
;;;2059   __inline void set_bit(int nr,unsigned long *vaddr)
000000  2301              MOVS     r3,#1
;;;2060   {
;;;2061   	(*vaddr)|=(1<<nr);
000002  4083              LSLS     r3,r3,r0
000004  680a              LDR      r2,[r1,#0]
000006  431a              ORRS     r2,r2,r3
000008  600a              STR      r2,[r1,#0]
;;;2062   }
00000a  4770              BX       lr
;;;2063   
                          ENDP


                          AREA ||i.clear_bit||, COMGROUP=clear_bit, CODE, READONLY, ALIGN=1

                  clear_bit PROC
;;;2053   }
;;;2054   __inline void clear_bit(int nr,unsigned long *vaddr)
000000  2301              MOVS     r3,#1
;;;2055   {
;;;2056   	(*vaddr)&=(~(1<<nr));
000002  4083              LSLS     r3,r3,r0
000004  680a              LDR      r2,[r1,#0]
000006  439a              BICS     r2,r2,r3
000008  600a              STR      r2,[r1,#0]
;;;2057   }
00000a  4770              BX       lr
;;;2058   
                          ENDP

