; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\s3cmci.o --depend=.\obj\s3cmci.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\s3cmci.crf ..\sdio\src\s3cmci.c]
                          THUMB

                          AREA ||i.DMA_RxConfiguration||, CODE, READONLY, ALIGN=2

                  DMA_RxConfiguration PROC
;;;418    
;;;419    static void DMA_RxConfiguration(u32 *BufferDST, u32 BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;420    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;421      DMA_InitTypeDef DMA_InitStructure;
;;;422    
;;;423      DMA_ClearFlag(DMA2_FLAG_TC4 | DMA2_FLAG_TE4 | DMA2_FLAG_HT4 | DMA2_FLAG_GL4);
000008  4813              LDR      r0,|L1.88|
00000a  f7fffffe          BL       DMA_ClearFlag
;;;424    
;;;425      /* DMA2 Channel4 disable */
;;;426      DMA_Cmd(DMA2_Channel4, DISABLE);
00000e  2100              MOVS     r1,#0
000010  4812              LDR      r0,|L1.92|
000012  f7fffffe          BL       DMA_Cmd
;;;427    
;;;428      /* DMA2 Channel4 Config */
;;;429      DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)SDIO_FIFO_Address;
000016  4812              LDR      r0,|L1.96|
000018  9000              STR      r0,[sp,#0]
;;;430      DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BufferDST;
00001a  9501              STR      r5,[sp,#4]
;;;431      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
00001c  2000              MOVS     r0,#0
00001e  9002              STR      r0,[sp,#8]
;;;432      DMA_InitStructure.DMA_BufferSize = BufferSize / 4;
000020  08a0              LSRS     r0,r4,#2
000022  9003              STR      r0,[sp,#0xc]
;;;433      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000024  2000              MOVS     r0,#0
000026  9004              STR      r0,[sp,#0x10]
;;;434      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000028  2080              MOVS     r0,#0x80
00002a  9005              STR      r0,[sp,#0x14]
;;;435      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
00002c  0080              LSLS     r0,r0,#2
00002e  9006              STR      r0,[sp,#0x18]
;;;436      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
000030  0080              LSLS     r0,r0,#2
000032  9007              STR      r0,[sp,#0x1c]
;;;437      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000034  2000              MOVS     r0,#0
000036  9008              STR      r0,[sp,#0x20]
;;;438      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000038  f44f5000          MOV      r0,#0x2000
00003c  9009              STR      r0,[sp,#0x24]
;;;439      DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
00003e  2000              MOVS     r0,#0
000040  900a              STR      r0,[sp,#0x28]
;;;440      DMA_Init(DMA2_Channel4, &DMA_InitStructure);
000042  4669              MOV      r1,sp
000044  4805              LDR      r0,|L1.92|
000046  f7fffffe          BL       DMA_Init
;;;441    
;;;442      /* DMA2 Channel4 enable */
;;;443      DMA_Cmd(DMA2_Channel4, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  4803              LDR      r0,|L1.92|
00004e  f7fffffe          BL       DMA_Cmd
;;;444    }
000052  b00b              ADD      sp,sp,#0x2c
000054  bd30              POP      {r4,r5,pc}
;;;445    
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x1000f000
                  |L1.92|
                          DCD      0x40020444
                  |L1.96|
                          DCD      0x40018080

                          AREA ||i.DMA_TxConfiguration||, CODE, READONLY, ALIGN=2

                  DMA_TxConfiguration PROC
;;;445    
;;;446    static void DMA_TxConfiguration(u32 *BufferSRC, u32 BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;447    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;448      DMA_InitTypeDef DMA_InitStructure;
;;;449    
;;;450      DMA_ClearFlag(DMA2_FLAG_TC4 | DMA2_FLAG_TE4 | DMA2_FLAG_HT4 | DMA2_FLAG_GL4);
000008  4813              LDR      r0,|L2.88|
00000a  f7fffffe          BL       DMA_ClearFlag
;;;451    
;;;452      /* DMA2 Channel4 disable */
;;;453      DMA_Cmd(DMA2_Channel4, DISABLE);
00000e  2100              MOVS     r1,#0
000010  4812              LDR      r0,|L2.92|
000012  f7fffffe          BL       DMA_Cmd
;;;454    
;;;455      /* DMA2 Channel4 Config */
;;;456      DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)SDIO_FIFO_Address;
000016  4812              LDR      r0,|L2.96|
000018  9000              STR      r0,[sp,#0]
;;;457      DMA_InitStructure.DMA_MemoryBaseAddr = (u32)BufferSRC;
00001a  9501              STR      r5,[sp,#4]
;;;458      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
00001c  2010              MOVS     r0,#0x10
00001e  9002              STR      r0,[sp,#8]
;;;459      DMA_InitStructure.DMA_BufferSize = BufferSize / 4;
000020  08a0              LSRS     r0,r4,#2
000022  9003              STR      r0,[sp,#0xc]
;;;460      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000024  2000              MOVS     r0,#0
000026  9004              STR      r0,[sp,#0x10]
;;;461      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000028  2080              MOVS     r0,#0x80
00002a  9005              STR      r0,[sp,#0x14]
;;;462      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
00002c  0080              LSLS     r0,r0,#2
00002e  9006              STR      r0,[sp,#0x18]
;;;463      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
000030  0080              LSLS     r0,r0,#2
000032  9007              STR      r0,[sp,#0x1c]
;;;464      DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000034  2000              MOVS     r0,#0
000036  9008              STR      r0,[sp,#0x20]
;;;465      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000038  f44f5000          MOV      r0,#0x2000
00003c  9009              STR      r0,[sp,#0x24]
;;;466      DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
00003e  2000              MOVS     r0,#0
000040  900a              STR      r0,[sp,#0x28]
;;;467      DMA_Init(DMA2_Channel4, &DMA_InitStructure);
000042  4669              MOV      r1,sp
000044  4805              LDR      r0,|L2.92|
000046  f7fffffe          BL       DMA_Init
;;;468    
;;;469      /* DMA2 Channel4 enable */
;;;470      DMA_Cmd(DMA2_Channel4, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  4803              LDR      r0,|L2.92|
00004e  f7fffffe          BL       DMA_Cmd
;;;471    }
000052  b00b              ADD      sp,sp,#0x2c
000054  bd30              POP      {r4,r5,pc}
;;;472    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      0x1000f000
                  |L2.92|
                          DCD      0x40020444
                  |L2.96|
                          DCD      0x40018080

                          AREA ||i.DisableIrq||, CODE, READONLY, ALIGN=1

                  DisableIrq PROC
;;;60     }
;;;61     void DisableIrq(u32 irq)
000000  b538              PUSH     {r3-r5,lr}
;;;62     {
000002  4604              MOV      r4,r0
;;;63       NVIC_InitTypeDef NVIC_InitStructure;
;;;64       NVIC_InitStructure.NVIC_IRQChannel = irq;
000004  b2e0              UXTB     r0,r4
000006  f88d0000          STRB     r0,[sp,#0]
;;;65       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00000a  2000              MOVS     r0,#0
00000c  f88d0001          STRB     r0,[sp,#1]
;;;66       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000010  f88d0002          STRB     r0,[sp,#2]
;;;67       NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
000014  f88d0003          STRB     r0,[sp,#3]
;;;68       NVIC_Init(&NVIC_InitStructure);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;69     }
00001e  bd38              POP      {r3-r5,pc}
;;;70     
                          ENDP


                          AREA ||i.EnableIrq||, CODE, READONLY, ALIGN=1

                  EnableIrq PROC
;;;51     }
;;;52     void EnableIrq(u32 irq)
000000  b538              PUSH     {r3-r5,lr}
;;;53     {
000002  4604              MOV      r4,r0
;;;54       NVIC_InitTypeDef NVIC_InitStructure;
;;;55       NVIC_InitStructure.NVIC_IRQChannel = irq;
000004  b2e0              UXTB     r0,r4
000006  f88d0000          STRB     r0,[sp,#0]
;;;56       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00000a  2000              MOVS     r0,#0
00000c  f88d0001          STRB     r0,[sp,#1]
;;;57       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000010  f88d0002          STRB     r0,[sp,#2]
;;;58       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;59       NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;60     }
000020  bd38              POP      {r3-r5,pc}
;;;61     void DisableIrq(u32 irq)
                          ENDP


                          AREA ||i.clear_imask||, CODE, READONLY, ALIGN=2

                  clear_imask PROC
;;;132    
;;;133    static void clear_imask(struct stm32_host *host)
000000  4601              MOV      r1,r0
;;;134    {
;;;135    	u32 mask = SDIO->MASK;
000002  4a03              LDR      r2,|L5.16|
000004  6bd0              LDR      r0,[r2,#0x3c]
;;;136    	/* preserve the SDIO IRQ mask state */
;;;137    	mask &= SDIO_IT_SDIOIT;
000006  f4000080          AND      r0,r0,#0x400000
;;;138    	SDIO->MASK=mask;
00000a  63d0              STR      r0,[r2,#0x3c]
;;;139    }
00000c  4770              BX       lr
;;;140    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40018000

                          AREA ||i.disable_imask||, CODE, READONLY, ALIGN=2

                  disable_imask PROC
;;;125    
;;;126    static u32 disable_imask(struct stm32_host *host, u32 imask)
000000  b570              PUSH     {r4-r6,lr}
;;;127    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;128    	u32 mask = SDIO->MASK;
000006  4804              LDR      r0,|L6.24|
000008  6bc5              LDR      r5,[r0,#0x3c]
;;;129    	SDIO_ITConfig(~imask&mask,DISABLE);	
00000a  ea250004          BIC      r0,r5,r4
00000e  2100              MOVS     r1,#0
000010  f7fffffe          BL       SDIO_ITConfig
;;;130    	return 0;
000014  2000              MOVS     r0,#0
;;;131    }
000016  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP

                  |L6.24|
                          DCD      0x40018000

                          AREA ||i.enable_imask||, CODE, READONLY, ALIGN=2

                  enable_imask PROC
;;;118    
;;;119    static u32 enable_imask(struct stm32_host *host, u32 imask)
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;121    	u32 mask = SDIO->MASK;
000006  4804              LDR      r0,|L7.24|
000008  6bc5              LDR      r5,[r0,#0x3c]
;;;122    	SDIO_ITConfig(imask|mask,ENABLE);	
00000a  ea440005          ORR      r0,r4,r5
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       SDIO_ITConfig
;;;123    	return 0;
000014  2000              MOVS     r0,#0
;;;124    }
000016  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

                  |L7.24|
                          DCD      0x40018000

                          AREA ||i.finalize_request||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  finalize_request PROC
;;;624    
;;;625    static void finalize_request(struct stm32_host *host)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;626    {
000004  4604              MOV      r4,r0
;;;627    	struct mmc_request *mrq = host->mrq;
000006  6c26              LDR      r6,[r4,#0x40]
;;;628    	struct mmc_command *cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
000008  6c60              LDR      r0,[r4,#0x44]
00000a  b108              CBZ      r0,|L8.16|
00000c  68b0              LDR      r0,[r6,#8]
00000e  e000              B        |L8.18|
                  |L8.16|
000010  6830              LDR      r0,[r6,#0]
                  |L8.18|
000012  4605              MOV      r5,r0
;;;629    	u32 clkcr;
;;;630    	//pr_debug("finish request!\n");
;;;631    	if (host->complete_what != COMPLETION_FINALIZE)
000014  f8940048          LDRB     r0,[r4,#0x48]
000018  2801              CMP      r0,#1
00001a  d001              BEQ      |L8.32|
                  |L8.28|
;;;632    		return;
;;;633    
;;;634    	if (!mrq)
;;;635    		return;
;;;636    
;;;637    	if (cmd->data && (cmd->error == 0) &&
;;;638    	    (cmd->data->error == 0)) {
;;;639    		if (stm32_host_usedma(host) && (!host->dma_complete)) {
;;;640    			printk( "DMA Missing (%d)!\n",
;;;641    			    host->dma_complete);
;;;642    			return;
;;;643    		}
;;;644    	}
;;;645    
;;;646    	/* Read response from controller. */
;;;647    	cmd->resp[0] =SDIO->RESP1;//readl(host->base + S3C2410_SDIRSP0);
;;;648    	cmd->resp[1] =SDIO->RESP2;// readl(host->base + S3C2410_SDIRSP1);
;;;649    	cmd->resp[2] =SDIO->RESP3;// readl(host->base + S3C2410_SDIRSP2);
;;;650    	cmd->resp[3] =SDIO->RESP4;// readl(host->base + S3C2410_SDIRSP3);
;;;651    
;;;652    	//writel(host->prescaler, host->base + S3C2410_SDIPRE);
;;;653    	clkcr=SDIO->CLKCR&(~(0xFF));
;;;654    	clkcr|=host->prescaler;
;;;655    	SDIO->CLKCR=clkcr;//重新写回分频值
;;;656    
;;;657    /*	if (cmd->error)
;;;658    		debug_as_failure = 1;	  */
;;;659    
;;;660    /*	if (cmd->data && cmd->data->error)
;;;661    		debug_as_failure = 1;  */
;;;662    
;;;663    //	dbg_dumpcmd(host, cmd, debug_as_failure);
;;;664    
;;;665    	/* Cleanup controller */
;;;666    	/*writel(0, host->base + S3C2410_SDICMDARG);
;;;667    	writel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);
;;;668    	writel(0, host->base + S3C2410_SDICMDCON);*/
;;;669    	 SDIO_ClearFlag(SDIO_ICR_MASK);
;;;670    
;;;671    	clear_imask(host);
;;;672    
;;;673    	if (cmd->data && cmd->error)
;;;674    		cmd->data->error = cmd->error;
;;;675    
;;;676    	if (cmd->data && cmd->data->stop && (!host->cmd_is_stop)) {//命令要求停止
;;;677    		host->cmd_is_stop = 1;
;;;678    		stm32_send_request(host->mmc);
;;;679    		return;
;;;680    	}
;;;681    
;;;682    	/* If we have no data transfer we are finished here */
;;;683    	if (!mrq->data)
;;;684    		goto request_done;
;;;685    #ifdef MASK_DEBUG
;;;686    	/* Calulate the amout of bytes transfer if there was no error */
;;;687    	if (mrq->data->error == 0) {
;;;688    		mrq->data->bytes_xfered =
;;;689    			(mrq->data->blocks * mrq->data->blksz);
;;;690    	} else {
;;;691    		mrq->data->bytes_xfered = 0;
;;;692    	}
;;;693    
;;;694    	/* If we had an error while transfering data we flush the
;;;695    	 * DMA channel and the fifo to clear out any garbage. */
;;;696    	if (mrq->data->error != 0) {
;;;697    	/*	if (stm32_host_usedma(host))
;;;698    			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);*/
;;;699    
;;;700    		if (host->is2440) {
;;;701    			/* Clear failure register and reset fifo. */
;;;702    			writel(S3C2440_SDIFSTA_FIFORESET |
;;;703    			       S3C2440_SDIFSTA_FIFOFAIL,
;;;704    			       host->base + S3C2410_SDIFSTA);
;;;705    		} else {
;;;706    			u32 mci_con;
;;;707    
;;;708    			/* reset fifo */
;;;709    			mci_con = readl(host->base + S3C2410_SDICON);
;;;710    			mci_con |= S3C2410_SDICON_FIFORESET;
;;;711    
;;;712    			writel(mci_con, host->base + S3C2410_SDICON);
;;;713    		}
;;;714    	}
;;;715    #endif
;;;716    request_done:
;;;717    	host->complete_what = COMPLETION_NONE;
;;;718    	host->mrq = NULL;
;;;719    
;;;720    	stm32_check_sdio_irq(host);
;;;721    	mmc_request_done(host->mmc, mrq);//正常出口，请求完成交给唤醒正在等待的命令处理函数
;;;722    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L8.32|
000020  b906              CBNZ     r6,|L8.36|
000022  e7fb              B        |L8.28|
                  |L8.36|
000024  6a68              LDR      r0,[r5,#0x24]         ;637
000026  b178              CBZ      r0,|L8.72|
000028  6a28              LDR      r0,[r5,#0x20]         ;637
00002a  b968              CBNZ     r0,|L8.72|
00002c  6a68              LDR      r0,[r5,#0x24]         ;638
00002e  6900              LDR      r0,[r0,#0x10]         ;638
000030  b950              CBNZ     r0,|L8.72|
000032  4620              MOV      r0,r4                 ;639
000034  f7fffffe          BL       stm32_host_usedma
000038  b130              CBZ      r0,|L8.72|
00003a  6ce0              LDR      r0,[r4,#0x4c]         ;639
00003c  b920              CBNZ     r0,|L8.72|
00003e  a021              ADR      r0,|L8.196|
000040  6ce1              LDR      r1,[r4,#0x4c]         ;640
000042  f7fffffe          BL       __2printf
000046  e7e9              B        |L8.28|
                  |L8.72|
000048  4823              LDR      r0,|L8.216|
00004a  6940              LDR      r0,[r0,#0x14]         ;647
00004c  60a8              STR      r0,[r5,#8]            ;647
00004e  4822              LDR      r0,|L8.216|
000050  6981              LDR      r1,[r0,#0x18]         ;648
000052  60e9              STR      r1,[r5,#0xc]          ;648
000054  69c1              LDR      r1,[r0,#0x1c]         ;649
000056  6129              STR      r1,[r5,#0x10]         ;649
000058  6a01              LDR      r1,[r0,#0x20]         ;650
00005a  6169              STR      r1,[r5,#0x14]         ;650
00005c  6840              LDR      r0,[r0,#4]            ;653
00005e  f02007ff          BIC      r7,r0,#0xff           ;653
000062  f8940020          LDRB     r0,[r4,#0x20]         ;654
000066  4307              ORRS     r7,r7,r0              ;654
000068  481b              LDR      r0,|L8.216|
00006a  6047              STR      r7,[r0,#4]            ;655
00006c  f24050ff          MOV      r0,#0x5ff             ;669
000070  f7fffffe          BL       SDIO_ClearFlag
000074  4620              MOV      r0,r4                 ;671
000076  f7fffffe          BL       clear_imask
00007a  6a68              LDR      r0,[r5,#0x24]         ;673
00007c  b120              CBZ      r0,|L8.136|
00007e  6a28              LDR      r0,[r5,#0x20]         ;673
000080  b110              CBZ      r0,|L8.136|
000082  e9d50108          LDRD     r0,r1,[r5,#0x20]      ;674
000086  6108              STR      r0,[r1,#0x10]         ;674
                  |L8.136|
000088  6a68              LDR      r0,[r5,#0x24]         ;676
00008a  b150              CBZ      r0,|L8.162|
00008c  6a68              LDR      r0,[r5,#0x24]         ;676
00008e  69c0              LDR      r0,[r0,#0x1c]         ;676
000090  b138              CBZ      r0,|L8.162|
000092  6c60              LDR      r0,[r4,#0x44]         ;676
000094  b928              CBNZ     r0,|L8.162|
000096  2001              MOVS     r0,#1                 ;677
000098  6460              STR      r0,[r4,#0x44]         ;677
00009a  6820              LDR      r0,[r4,#0]            ;678
00009c  f7fffffe          BL       stm32_send_request
0000a0  e7bc              B        |L8.28|
                  |L8.162|
0000a2  6870              LDR      r0,[r6,#4]            ;683
0000a4  b900              CBNZ     r0,|L8.168|
0000a6  e000              B        |L8.170|
                  |L8.168|
0000a8  bf00              NOP                            ;716
                  |L8.170|
0000aa  2000              MOVS     r0,#0                 ;717
0000ac  f8840048          STRB     r0,[r4,#0x48]         ;717
0000b0  6420              STR      r0,[r4,#0x40]         ;718
0000b2  4620              MOV      r0,r4                 ;720
0000b4  f7fffffe          BL       stm32_check_sdio_irq
0000b8  4631              MOV      r1,r6                 ;721
0000ba  6820              LDR      r0,[r4,#0]            ;721
0000bc  f7fffffe          BL       mmc_request_done
0000c0  bf00              NOP      
0000c2  e7ab              B        |L8.28|
;;;723    
                          ENDP

                  |L8.196|
0000c4  444d4120          DCB      "DMA Missing (%d)!\n",0
0000c8  4d697373
0000cc  696e6720
0000d0  28256429
0000d4  210a00  
0000d7  00                DCB      0
                  |L8.216|
                          DCD      0x40018000

                          AREA ||i.init_stm32_struct||, CODE, READONLY, ALIGN=2

                  init_stm32_struct PROC
;;;1088   
;;;1089    static void init_stm32_struct(struct mmc_host_ops *phost_ops)
000000  4905              LDR      r1,|L9.24|
;;;1090   {
;;;1091   	//static struct s3c24xx_mci_pdata mini2440_mmc_cfg初始化
;;;1092           //pmci_cfg->set_power =NULL;
;;;1093           //pmci_cfg->ocr_avail=MMC_VDD_32_33|MMC_VDD_33_34;
;;;1094   	//static struct mmc_host_ops stm32_ops初始化
;;;1095   
;;;1096   	phost_ops->request	= stm32_request;
000002  6081              STR      r1,[r0,#8]
;;;1097   	phost_ops->set_ios	= stm32_set_ios;
000004  4905              LDR      r1,|L9.28|
000006  60c1              STR      r1,[r0,#0xc]
;;;1098   	phost_ops->get_ro	 	= stm32_get_ro;
000008  4905              LDR      r1,|L9.32|
00000a  6101              STR      r1,[r0,#0x10]
;;;1099   	phost_ops->get_cd		= stm32_card_present;
00000c  4905              LDR      r1,|L9.36|
00000e  6141              STR      r1,[r0,#0x14]
;;;1100   	phost_ops->enable_sdio_irq = stm32_enable_sdio_irq;
000010  4905              LDR      r1,|L9.40|
000012  6181              STR      r1,[r0,#0x18]
;;;1101   
;;;1102   }
000014  4770              BX       lr
;;;1103   struct mmc_host * stm32_probe(void)
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      stm32_request
                  |L9.28|
                          DCD      stm32_set_ios
                  |L9.32|
                          DCD      stm32_get_ro
                  |L9.36|
                          DCD      stm32_card_present
                  |L9.40|
                          DCD      stm32_enable_sdio_irq

                          AREA ||i.mmc_signal_sdio_irq||, CODE, READONLY, ALIGN=1

                  mmc_signal_sdio_irq PROC
;;;220    } */
;;;221    static void mmc_signal_sdio_irq(struct mmc_host *host)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223    	host->ops->enable_sdio_irq(host, 0);
000004  6860              LDR      r0,[r4,#4]
000006  2100              MOVS     r1,#0
000008  6982              LDR      r2,[r0,#0x18]
00000a  4620              MOV      r0,r4
00000c  4790              BLX      r2
;;;224    	sdio_irq_thread(host);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sdio_irq_thread
;;;225    }
000014  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.pio_tasklet||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pio_tasklet PROC
;;;725    
;;;726    static void pio_tasklet(unsigned long data)
000000  b570              PUSH     {r4-r6,lr}
;;;727    {
000002  4605              MOV      r5,r0
;;;728    	struct stm32_host *host = (struct stm32_host *) data;
000004  462c              MOV      r4,r5
;;;729    	//pr_debug("pio_tasklet deal!\n");
;;;730    	stm32_disable_irq(host, true);
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       stm32_disable_irq
;;;731        if(sdio_sys_wait==1)
00000e  4818              LDR      r0,|L11.112|
000010  7800              LDRB     r0,[r0,#0]  ; sdio_sys_wait
000012  2801              CMP      r0,#1
000014  d102              BNE      |L11.28|
;;;732    		udelay(20);
000016  2014              MOVS     r0,#0x14
000018  f7fffffe          BL       udelay
                  |L11.28|
;;;733    /*	//do pio
;;;734    	if (host->pio_active == XFER_WRITE)
;;;735    		do_pio_write(host);
;;;736    
;;;737    	if (host->pio_active == XFER_READ)
;;;738    		do_pio_read(host);*/
;;;739    
;;;740    	if (host->complete_what == COMPLETION_FINALIZE) {
00001c  f8940048          LDRB     r0,[r4,#0x48]
000020  2801              CMP      r0,#1
000022  d120              BNE      |L11.102|
;;;741    		clear_imask(host);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       clear_imask
;;;742    		if (host->pio_active != XFER_NONE) { //XFER_NONE指明没有数据传输
00002a  6e20              LDR      r0,[r4,#0x60]
00002c  b198              CBZ      r0,|L11.86|
;;;743    			printk( "unfinished %s "
00002e  e9d43215          LDRD     r3,r2,[r4,#0x54]
000032  6e20              LDR      r0,[r4,#0x60]
000034  2801              CMP      r0,#1
000036  d101              BNE      |L11.60|
;;;744    			    "- pio_count:[%u] pio_bytes:[%u]\n",
;;;745    			    (host->pio_active == XFER_READ) ? "read" : "write",
000038  a00e              ADR      r0,|L11.116|
00003a  e000              B        |L11.62|
                  |L11.60|
00003c  a00f              ADR      r0,|L11.124|
                  |L11.62|
00003e  4601              MOV      r1,r0
000040  a010              ADR      r0,|L11.132|
000042  f7fffffe          BL       __2printf
;;;746    			    host->pio_count, host->pio_bytes);
;;;747    
;;;748    			if (host->mrq->data)
000046  6c20              LDR      r0,[r4,#0x40]
000048  6840              LDR      r0,[r0,#4]
00004a  b120              CBZ      r0,|L11.86|
;;;749    				host->mrq->data->error = -EINVAL;
00004c  f06f0015          MVN      r0,#0x15
000050  6c21              LDR      r1,[r4,#0x40]
000052  6849              LDR      r1,[r1,#4]
000054  6108              STR      r0,[r1,#0x10]
                  |L11.86|
;;;750    		}
;;;751    
;;;752    		stm32_enable_irq(host, false);
000056  2100              MOVS     r1,#0
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       stm32_enable_irq
;;;753    		finalize_request(host);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       finalize_request
000064  e003              B        |L11.110|
                  |L11.102|
;;;754    	} else
;;;755    		stm32_enable_irq(host, true);
000066  2101              MOVS     r1,#1
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       stm32_enable_irq
                  |L11.110|
;;;756    }
00006e  bd70              POP      {r4-r6,pc}
;;;757    
                          ENDP

                  |L11.112|
                          DCD      sdio_sys_wait
                  |L11.116|
000074  72656164          DCB      "read",0
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L11.124|
00007c  77726974          DCB      "write",0
000080  6500    
000082  00                DCB      0
000083  00                DCB      0
                  |L11.132|
000084  756e6669          DCB      "unfinished %s - pio_count:[%u] pio_bytes:[%u]\n",0
000088  6e697368
00008c  65642025
000090  73202d20
000094  70696f5f
000098  636f756e
00009c  743a5b25
0000a0  755d2070
0000a4  696f5f62
0000a8  79746573
0000ac  3a5b2575
0000b0  5d0a00  
0000b3  00                DCB      0

                          AREA ||i.readl||, CODE, READONLY, ALIGN=1

                  readl PROC
;;;42     }
;;;43     static unsigned int readl(unsigned long addr)
000000  4601              MOV      r1,r0
;;;44     {  
;;;45        return (*(volatile unsigned *)addr);
000002  6808              LDR      r0,[r1,#0]
;;;46     }
000004  4770              BX       lr
;;;47     
                          ENDP


                          AREA ||i.stm32_card_present||, CODE, READONLY, ALIGN=1

                  stm32_card_present PROC
;;;757    
;;;758    static int stm32_card_present(struct mmc_host *mmc) 
000000  4601              MOV      r1,r0
;;;759    {
;;;760    	return 1;
000002  2001              MOVS     r0,#1
;;;761    }
000004  4770              BX       lr
;;;762    
                          ENDP


                          AREA ||i.stm32_check_sdio_irq||, CODE, READONLY, ALIGN=1

                  stm32_check_sdio_irq PROC
;;;152    */
;;;153    static void stm32_check_sdio_irq(struct stm32_host *host)
000000  4770              BX       lr
;;;154    {
;;;155    	#ifdef MASK_DEBUG
;;;156    	if (host->sdio_irqen) {
;;;157    	//	if (gpio_get_value(S3C2410_GPE(8)) == 0) {//这个是sdio中断数据与中断共用的引脚
;;;158    			if((rGPEDAT&&(1<<8))==0){//GPE8
;;;159    			printk(" signalling irq\n");
;;;160    			mmc_signal_sdio_irq(host->mmc);
;;;161    		}
;;;162    	}
;;;163    	#endif
;;;164    }
;;;165    #if 0
                          ENDP


                          AREA ||i.stm32_disable_irq||, CODE, READONLY, ALIGN=1

                  stm32_disable_irq PROC
;;;247     */
;;;248    static void stm32_disable_irq(struct stm32_host *host, bool transfer)
000000  b570              PUSH     {r4-r6,lr}
;;;249    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;250    	host->irq_disabled = transfer;
000006  f8845038          STRB     r5,[r4,#0x38]
;;;251    
;;;252    	if (transfer && host->irq_state) {
00000a  b145              CBZ      r5,|L15.30|
00000c  f894003a          LDRB     r0,[r4,#0x3a]
000010  b128              CBZ      r0,|L15.30|
;;;253    		host->irq_state = false;
000012  2000              MOVS     r0,#0
000014  f884003a          STRB     r0,[r4,#0x3a]
;;;254    		DisableIrq(host->irq);
000018  68a0              LDR      r0,[r4,#8]
00001a  f7fffffe          BL       DisableIrq
                  |L15.30|
;;;255    	}
;;;256    }
00001e  bd70              POP      {r4-r6,pc}
;;;257    #if 0
                          ENDP


                          AREA ||i.stm32_enable_dma||, CODE, READONLY, ALIGN=2

                  stm32_enable_dma PROC
;;;549    
;;;550    static void  stm32_enable_dma(void)
000000  b510              PUSH     {r4,lr}
;;;551    {      
;;;552    	u32 imask=SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND; 
000002  f44f7485          MOV      r4,#0x10a
;;;553    	sdio_deb_enter();
;;;554    	SDIO_ClearFlag(SDIO_ICR_MASK);
000006  f24050ff          MOV      r0,#0x5ff
00000a  f7fffffe          BL       SDIO_ClearFlag
;;;555    	SDIO->DCTRL|=(SDIO_DPSM_Enable|(1<<3));//使能DMA和数据发送
00000e  4808              LDR      r0,|L16.48|
000010  6ac0              LDR      r0,[r0,#0x2c]
000012  f0400009          ORR      r0,r0,#9
000016  4906              LDR      r1,|L16.48|
000018  62c8              STR      r0,[r1,#0x2c]
;;;556        SDIO_ITConfig(imask, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SDIO_ITConfig
;;;557    	 while (DMA_GetFlagStatus(DMA2_FLAG_TC4) == RESET);
000022  bf00              NOP      
                  |L16.36|
000024  4803              LDR      r0,|L16.52|
000026  f7fffffe          BL       DMA_GetFlagStatus
00002a  2800              CMP      r0,#0
00002c  d0fa              BEQ      |L16.36|
;;;558    	 sdio_deb_leave();
;;;559    
;;;560    }
00002e  bd10              POP      {r4,pc}
;;;561    
                          ENDP

                  |L16.48|
                          DCD      0x40018000
                  |L16.52|
                          DCD      0x10002000

                          AREA ||i.stm32_enable_irq||, CODE, READONLY, ALIGN=1

                  stm32_enable_irq PROC
;;;225     */
;;;226    static void stm32_enable_irq(struct stm32_host *host, bool more)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;228    
;;;229    	bool enable = false;
000006  2600              MOVS     r6,#0
;;;230    	host->irq_enabled = more;
000008  f8845039          STRB     r5,[r4,#0x39]
;;;231    	host->irq_disabled = false;
00000c  2000              MOVS     r0,#0
00000e  f8840038          STRB     r0,[r4,#0x38]
;;;232    
;;;233    	enable =(bool) (more ||((bool) host->sdio_irqen));
000012  b91d              CBNZ     r5,|L17.28|
000014  6be0              LDR      r0,[r4,#0x3c]
000016  f0100fff          TST      r0,#0xff
00001a  d001              BEQ      |L17.32|
                  |L17.28|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L17.34|
                  |L17.32|
000020  2000              MOVS     r0,#0
                  |L17.34|
000022  b2c6              UXTB     r6,r0
;;;234    
;;;235    	if (host->irq_state != enable) {
000024  f894003a          LDRB     r0,[r4,#0x3a]
000028  42b0              CMP      r0,r6
00002a  d009              BEQ      |L17.64|
;;;236    		host->irq_state = enable;
00002c  f884603a          STRB     r6,[r4,#0x3a]
;;;237    
;;;238    		if (enable)
000030  b11e              CBZ      r6,|L17.58|
;;;239    			EnableIrq(host->irq);
000032  68a0              LDR      r0,[r4,#8]
000034  f7fffffe          BL       EnableIrq
000038  e002              B        |L17.64|
                  |L17.58|
;;;240    		else
;;;241    			DisableIrq(host->irq);
00003a  68a0              LDR      r0,[r4,#8]
00003c  f7fffffe          BL       DisableIrq
                  |L17.64|
;;;242    	}
;;;243    }
000040  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP


                          AREA ||i.stm32_enable_sdio_irq||, CODE, READONLY, ALIGN=1

                  stm32_enable_sdio_irq PROC
;;;871    
;;;872    static void stm32_enable_sdio_irq(struct mmc_host *mmc, int enable)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;873    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;874    	struct stm32_host *host = mmc_priv(mmc);
000008  f1070468          ADD      r4,r7,#0x68
;;;875    //	unsigned long flags;
;;;876    	u32 con;
;;;877    
;;;878    	//local_irq_save(flags);
;;;879    
;;;880    	con = readl(host->base + S3C2410_SDICON);
00000c  6860              LDR      r0,[r4,#4]
00000e  f7fffffe          BL       readl
000012  4606              MOV      r6,r0
;;;881    	host->sdio_irqen = enable;
000014  63e5              STR      r5,[r4,#0x3c]
;;;882    
;;;883    	if (enable == host->sdio_irqen)
000016  6be0              LDR      r0,[r4,#0x3c]
000018  42a8              CMP      r0,r5
00001a  d100              BNE      |L18.30|
;;;884    		goto same_state;
00001c  e02c              B        |L18.120|
                  |L18.30|
;;;885    
;;;886    	if (enable) {
00001e  b19d              CBZ      r5,|L18.72|
;;;887    		con |= S3C2410_SDICON_SDIOIRQ;
000020  f0460608          ORR      r6,r6,#8
;;;888    		enable_imask(host, S3C2410_SDIIMSK_SDIOIRQ);
000024  f44f5180          MOV      r1,#0x1000
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       enable_imask
;;;889    
;;;890    		if (!host->irq_state && !host->irq_disabled) {
00002e  f894003a          LDRB     r0,[r4,#0x3a]
000032  b9e0              CBNZ     r0,|L18.110|
000034  f8940038          LDRB     r0,[r4,#0x38]
000038  b9c8              CBNZ     r0,|L18.110|
;;;891    			host->irq_state = true;
00003a  2001              MOVS     r0,#1
00003c  f884003a          STRB     r0,[r4,#0x3a]
;;;892    			EnableIrq(host->irq);
000040  68a0              LDR      r0,[r4,#8]
000042  f7fffffe          BL       EnableIrq
000046  e012              B        |L18.110|
                  |L18.72|
;;;893    		}
;;;894    	} else {
;;;895    		disable_imask(host, S3C2410_SDIIMSK_SDIOIRQ);
000048  f44f5180          MOV      r1,#0x1000
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       disable_imask
;;;896    		con &= ~S3C2410_SDICON_SDIOIRQ;
000052  f0260608          BIC      r6,r6,#8
;;;897    
;;;898    		if (!host->irq_enabled && host->irq_state) {
000056  f8940039          LDRB     r0,[r4,#0x39]
00005a  b940              CBNZ     r0,|L18.110|
00005c  f894003a          LDRB     r0,[r4,#0x3a]
000060  b128              CBZ      r0,|L18.110|
;;;899    			DisableIrq(host->irq);
000062  68a0              LDR      r0,[r4,#8]
000064  f7fffffe          BL       DisableIrq
;;;900    			host->irq_state = false;
000068  2000              MOVS     r0,#0
00006a  f884003a          STRB     r0,[r4,#0x3a]
                  |L18.110|
;;;901    		}
;;;902    	}
;;;903    
;;;904    	writel(con, host->base + S3C2410_SDICON);
00006e  4630              MOV      r0,r6
000070  6861              LDR      r1,[r4,#4]
000072  f7fffffe          BL       writel
;;;905    
;;;906     same_state:
000076  bf00              NOP      
                  |L18.120|
;;;907    	stm32_check_sdio_irq(host);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       stm32_check_sdio_irq
;;;908    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;909    
                          ENDP


                          AREA ||i.stm32_get_ro||, CODE, READONLY, ALIGN=1

                  stm32_get_ro PROC
;;;866    
;;;867    static int stm32_get_ro(struct mmc_host *mmc)
000000  4601              MOV      r1,r0
;;;868    {
;;;869    	return 0;//无写保护
000002  2000              MOVS     r0,#0
;;;870    }
000004  4770              BX       lr
;;;871    
                          ENDP


                          AREA ||i.stm32_host_usedma||, CODE, READONLY, ALIGN=1

                  stm32_host_usedma PROC
;;;91      */
;;;92     static int stm32_host_usedma(struct stm32_host *host)
000000  4601              MOV      r1,r0
;;;93     {
;;;94     #ifdef CONFIG_MMC_S3C_PIO
;;;95     	return 0;
000002  2000              MOVS     r0,#0
;;;96     #elif defined(CONFIG_MMC_S3C_DMA)
;;;97     	return 1;
;;;98     #else
;;;99     	return host->dodma;
;;;100    #endif
;;;101    }
000004  4770              BX       lr
;;;102    
                          ENDP


                          AREA ||i.stm32_irq||, CODE, READONLY, ALIGN=2

                  stm32_irq PROC
;;;936    
;;;937    void  stm32_irq(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;938    {
;;;939    	struct stm32_host *host = gpstm32_host;
000004  4874              LDR      r0,|L21.472|
000006  6804              LDR      r4,[r0,#0]  ; gpstm32_host
;;;940    	struct mmc_request *mrq = host->mrq;
000008  f8d49040          LDR      r9,[r4,#0x40]
;;;941    	struct mmc_command *cmd=host->cmd_is_stop ? mrq->stop : mrq->cmd;
00000c  6c60              LDR      r0,[r4,#0x44]
00000e  b110              CBZ      r0,|L21.22|
000010  f8d90008          LDR      r0,[r9,#8]
000014  e001              B        |L21.26|
                  |L21.22|
000016  f8d90000          LDR      r0,[r9,#0]
                  |L21.26|
00001a  4606              MOV      r6,r0
;;;942    	struct mmc_data *data=cmd->data;
00001c  f8d68024          LDR      r8,[r6,#0x24]
;;;943    	u32 stm_sta, stm_imsk;
;;;944    	u32 stm_clear = 0;
000020  2700              MOVS     r7,#0
;;;945    	sdio_deb_enter();
;;;946    	stm_sta = SDIO->STA;//SDI Data Status Register (SDIDatSta)
000022  486e              LDR      r0,|L21.476|
000024  6b45              LDR      r5,[r0,#0x34]
;;;947    	stm_imsk =SDIO->MASK;
000026  f8d0a03c          LDR      r10,[r0,#0x3c]
;;;948    	/*设备中断*/
;;;949    	if (stm_sta & SDIO_IT_SDIOIT) {//检查到sdio中断
00002a  f4150f80          TST      r5,#0x400000
00002e  d00e              BEQ      |L21.78|
;;;950    		if (stm_imsk & SDIO_IT_SDIOIT) {
000030  f41a0f80          TST      r10,#0x400000
000034  d00b              BEQ      |L21.78|
;;;951    			printk("card sdio interupt!\n");
000036  a06a              ADR      r0,|L21.480|
000038  f7fffffe          BL       __2printf
;;;952    			stm_clear= SDIO_IT_SDIOIT;
00003c  f44f0780          MOV      r7,#0x400000
;;;953    			SDIO->ICR=stm_clear;//清标准位
000040  4866              LDR      r0,|L21.476|
000042  6387              STR      r7,[r0,#0x38]
;;;954    			mmc_signal_sdio_irq(host->mmc);//调用线程处理SDIO设备中断,当前处理的是SDIO控制器自身的中断
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       mmc_signal_sdio_irq
                  |L21.74|
;;;955    			//ClearPending(BIT_SDI);
;;;956    			return;
;;;957    		}
;;;958    	}
;;;959    
;;;960    	if ((host->complete_what == COMPLETION_NONE) ||
;;;961    	    (host->complete_what == COMPLETION_FINALIZE)) {//没有发送命令或者数据，不期待的中断。说明异常
;;;962    		host->status = "nothing to complete";
;;;963    		clear_imask(host);
;;;964    		goto irq_out;
;;;965    	}
;;;966    
;;;967    	if (!host->mrq) {
;;;968    		host->status = "no active mrq";
;;;969    		clear_imask(host);
;;;970    		goto irq_out;
;;;971    	}
;;;972    
;;;973    	cmd = host->cmd_is_stop ? host->mrq->stop : host->mrq->cmd;
;;;974    
;;;975    	if (!cmd) {
;;;976    		host->status = "no active cmd";
;;;977    		clear_imask(host);
;;;978    		goto irq_out;
;;;979    	}
;;;980    /*******************************命令传输控制*******************************************************/
;;;981    	if (stm_sta & SDIO_IT_CTIMEOUT) {//命令超时
;;;982    		printk( "CMDSTAT: error CMDTIMEOUT\n");
;;;983    		cmd->error = -ETIMEDOUT;
;;;984    		host->status = "error: command timeout";
;;;985    		goto fail_transfer;
;;;986    	}
;;;987    
;;;988    	if (stm_sta & SDIO_IT_CMDSENT) {//命令发送成功
;;;989    		if (host->complete_what == COMPLETION_CMDSENT) {
;;;990    			host->status = "ok: command sent";
;;;991    			goto close_transfer;
;;;992    		}
;;;993    
;;;994    		stm_clear |= SDIO_IT_CMDSENT;
;;;995    	}
;;;996    
;;;997    	if (stm_sta & SDIO_IT_CCRCFAIL) {//命令CRC校验失败，这就是个bug
;;;998    		if (cmd->flags & MMC_RSP_CRC) { //看命令是否在乎crc
;;;999    			if (host->mrq->cmd->flags & MMC_RSP_136) {
;;;1000   				printk("fixup: ignore CRC fail with long rsp\n");
;;;1001   			} else {
;;;1002   				/* note, we used to fail the transfer
;;;1003   				 * here, but it seems that this is just
;;;1004   				 * the hardware getting it wrong.
;;;1005   				 *
;;;1006   				 * cmd->error = -EILSEQ;
;;;1007   				 * host->status = "error: bad command crc";
;;;1008   				 * goto fail_transfer;
;;;1009   				*/
;;;1010   			}
;;;1011   		}
;;;1012   		stm_clear |= SDIO_IT_CCRCFAIL;
;;;1013   	}
;;;1014   
;;;1015   	if (stm_sta & SDIO_IT_CMDREND) {//命令响应完成
;;;1016   		stm_clear |= SDIO_IT_CMDREND;
;;;1017   		if (host->complete_what == COMPLETION_RSPFIN) {//带有应答的命令响应到此结束
;;;1018   			host->status = "ok: command response received";
;;;1019   			goto close_transfer;
;;;1020   		}
;;;1021   			if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN){//还有一种情况就是传输完成以后也会使用rsp应答
;;;1022   				host->complete_what = COMPLETION_XFERFINISH;
;;;1023   				if(data->flags&MMC_DATA_WRITE){//命令响应
;;;1024   					stm32_enable_dma();//发送数据
;;;1025   					return;
;;;1026   					}				
;;;1027   			}	
;;;1028   	}
;;;1029   
;;;1030   	/* errors handled after this point are only relevant
;;;1031   	   when a data transfer is in progress */
;;;1032   
;;;1033   	if (!cmd->data)
;;;1034   		goto clear_status_bits;
;;;1035   
;;;1036   	if (stm_sta& SDIO_IT_DCRCFAIL) {
;;;1037   		printk( "bad data crc (outgoing)\n");
;;;1038   		cmd->data->error = -EILSEQ;
;;;1039   		host->status = "error: bad data crc (outgoing)";
;;;1040   		goto fail_transfer;
;;;1041   	}
;;;1042   	if (stm_sta & SDIO_IT_DTIMEOUT) {
;;;1043   		printk( "data timeout\n");
;;;1044   		cmd->data->error = -ETIMEDOUT;
;;;1045   		host->status = "error: data timeout";
;;;1046   		goto fail_transfer;
;;;1047   	}
;;;1048   
;;;1049   	if (stm_sta & SDIO_IT_DATAEND) {
;;;1050   		if (host->complete_what == COMPLETION_XFERFINISH) {//发送通道
;;;1051   			host->status = "ok: data transfer completed";
;;;1052   			data->bytes_xfered=data->sg_len;
;;;1053   			host->pio_active = XFER_NONE;
;;;1054   			goto close_transfer;
;;;1055   		}
;;;1056   
;;;1057   		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN){//数据接收通道
;;;1058   			host->complete_what = COMPLETION_RSPFIN;
;;;1059   			while (DMA_GetFlagStatus(DMA2_FLAG_TC4) == RESET);//等待DMA通道无效
;;;1060   			data->bytes_xfered=data->sg_len;
;;;1061   			host->pio_active = XFER_NONE;
;;;1062   			host->status = "ok: data transfer completed";
;;;1063   			SDIO_ClearFlag(SDIO_IT_DATAEND);		
;;;1064   			goto close_transfer;
;;;1065   		}
;;;1066   		stm_clear|=SDIO_IT_DATAEND;
;;;1067   	}
;;;1068   
;;;1069   clear_status_bits:
;;;1070   	SDIO->ICR=stm_clear;
;;;1071   	goto irq_out;
;;;1072   
;;;1073   fail_transfer:
;;;1074   	host->pio_active = XFER_NONE;
;;;1075   close_transfer:
;;;1076   	host->complete_what = COMPLETION_FINALIZE;
;;;1077   	clear_imask(host);
;;;1078   	pio_tasklet((unsigned long)host);//调用PIO模式处理数据及命令的善后工作
;;;1079   	goto irq_out;
;;;1080   irq_out:
;;;1081   	pr_debug("stm state:0x%08x status:%s.\n", stm_sta,host->status);	
;;;1082   	sdio_deb_leave();
;;;1083   	return ;
;;;1084   
;;;1085   }
00004a  e8bd87f0          POP      {r4-r10,pc}
                  |L21.78|
00004e  f8940048          LDRB     r0,[r4,#0x48]         ;960
000052  b118              CBZ      r0,|L21.92|
000054  f8940048          LDRB     r0,[r4,#0x48]         ;961
000058  2801              CMP      r0,#1                 ;961
00005a  d105              BNE      |L21.104|
                  |L21.92|
00005c  a066              ADR      r0,|L21.504|
00005e  66a0              STR      r0,[r4,#0x68]         ;962
000060  4620              MOV      r0,r4                 ;963
000062  f7fffffe          BL       clear_imask
000066  e0b5              B        |L21.468|
                  |L21.104|
000068  6c20              LDR      r0,[r4,#0x40]         ;967
00006a  b928              CBNZ     r0,|L21.120|
00006c  a067              ADR      r0,|L21.524|
00006e  66a0              STR      r0,[r4,#0x68]         ;968
000070  4620              MOV      r0,r4                 ;969
000072  f7fffffe          BL       clear_imask
000076  e0ad              B        |L21.468|
                  |L21.120|
000078  6c60              LDR      r0,[r4,#0x44]         ;973
00007a  b110              CBZ      r0,|L21.130|
00007c  6c20              LDR      r0,[r4,#0x40]         ;973
00007e  6880              LDR      r0,[r0,#8]            ;973
000080  e001              B        |L21.134|
                  |L21.130|
000082  6c20              LDR      r0,[r4,#0x40]         ;973
000084  6800              LDR      r0,[r0,#0]            ;973
                  |L21.134|
000086  4606              MOV      r6,r0                 ;973
000088  b92e              CBNZ     r6,|L21.150|
00008a  a064              ADR      r0,|L21.540|
00008c  66a0              STR      r0,[r4,#0x68]         ;976
00008e  4620              MOV      r0,r4                 ;977
000090  f7fffffe          BL       clear_imask
000094  e09e              B        |L21.468|
                  |L21.150|
000096  f0150f04          TST      r5,#4                 ;981
00009a  d008              BEQ      |L21.174|
00009c  a063              ADR      r0,|L21.556|
00009e  f7fffffe          BL       __2printf
0000a2  f06f003b          MVN      r0,#0x3b              ;983
0000a6  6230              STR      r0,[r6,#0x20]         ;983
0000a8  a067              ADR      r0,|L21.584|
0000aa  66a0              STR      r0,[r4,#0x68]         ;984
0000ac  e085              B        |L21.442|
                  |L21.174|
0000ae  f0150f80          TST      r5,#0x80              ;988
0000b2  d008              BEQ      |L21.198|
0000b4  f8940048          LDRB     r0,[r4,#0x48]         ;989
0000b8  2802              CMP      r0,#2                 ;989
0000ba  d102              BNE      |L21.194|
0000bc  a068              ADR      r0,|L21.608|
0000be  66a0              STR      r0,[r4,#0x68]         ;990
0000c0  e07e              B        |L21.448|
                  |L21.194|
0000c2  f0470780          ORR      r7,r7,#0x80           ;994
                  |L21.198|
0000c6  f0150f01          TST      r5,#1                 ;997
0000ca  d00e              BEQ      |L21.234|
0000cc  69b0              LDR      r0,[r6,#0x18]         ;998
0000ce  f0100f04          TST      r0,#4                 ;998
0000d2  d008              BEQ      |L21.230|
0000d4  6c20              LDR      r0,[r4,#0x40]         ;999
0000d6  6800              LDR      r0,[r0,#0]            ;999
0000d8  6980              LDR      r0,[r0,#0x18]         ;999
0000da  f0100f02          TST      r0,#2                 ;999
0000de  d002              BEQ      |L21.230|
0000e0  a064              ADR      r0,|L21.628|
0000e2  f7fffffe          BL       __2printf
                  |L21.230|
0000e6  f0470701          ORR      r7,r7,#1              ;1012
                  |L21.234|
0000ea  f0150f40          TST      r5,#0x40              ;1015
0000ee  d017              BEQ      |L21.288|
0000f0  f0470740          ORR      r7,r7,#0x40           ;1016
0000f4  f8940048          LDRB     r0,[r4,#0x48]         ;1017
0000f8  2803              CMP      r0,#3                 ;1017
0000fa  d102              BNE      |L21.258|
0000fc  a067              ADR      r0,|L21.668|
0000fe  66a0              STR      r0,[r4,#0x68]         ;1018
000100  e05e              B        |L21.448|
                  |L21.258|
000102  f8940048          LDRB     r0,[r4,#0x48]         ;1021
000106  2805              CMP      r0,#5                 ;1021
000108  d10a              BNE      |L21.288|
00010a  2004              MOVS     r0,#4                 ;1022
00010c  f8840048          STRB     r0,[r4,#0x48]         ;1022
000110  f8d80014          LDR      r0,[r8,#0x14]         ;1023
000114  f4107f80          TST      r0,#0x100             ;1023
000118  d002              BEQ      |L21.288|
00011a  f7fffffe          BL       stm32_enable_dma
00011e  e794              B        |L21.74|
                  |L21.288|
000120  6a70              LDR      r0,[r6,#0x24]         ;1033
000122  b900              CBNZ     r0,|L21.294|
000124  e046              B        |L21.436|
                  |L21.294|
000126  f0150f02          TST      r5,#2                 ;1036
00012a  d009              BEQ      |L21.320|
00012c  a063              ADR      r0,|L21.700|
00012e  f7fffffe          BL       __2printf
000132  f06f0023          MVN      r0,#0x23              ;1038
000136  6a71              LDR      r1,[r6,#0x24]         ;1038
000138  6108              STR      r0,[r1,#0x10]         ;1038
00013a  a067              ADR      r0,|L21.728|
00013c  66a0              STR      r0,[r4,#0x68]         ;1039
00013e  e03c              B        |L21.442|
                  |L21.320|
000140  f0150f08          TST      r5,#8                 ;1042
000144  d009              BEQ      |L21.346|
000146  a06c              ADR      r0,|L21.760|
000148  f7fffffe          BL       __2printf
00014c  f06f003b          MVN      r0,#0x3b              ;1044
000150  6a71              LDR      r1,[r6,#0x24]         ;1044
000152  6108              STR      r0,[r1,#0x10]         ;1044
000154  a06c              ADR      r0,|L21.776|
000156  66a0              STR      r0,[r4,#0x68]         ;1045
000158  e02f              B        |L21.442|
                  |L21.346|
00015a  f4157f80          TST      r5,#0x100             ;1049
00015e  d028              BEQ      |L21.434|
000160  f8940048          LDRB     r0,[r4,#0x48]         ;1050
000164  2804              CMP      r0,#4                 ;1050
000166  d108              BNE      |L21.378|
000168  a06c              ADR      r0,|L21.796|
00016a  66a0              STR      r0,[r4,#0x68]         ;1051
00016c  f8d80024          LDR      r0,[r8,#0x24]         ;1052
000170  f8c80018          STR      r0,[r8,#0x18]         ;1052
000174  2000              MOVS     r0,#0                 ;1053
000176  6620              STR      r0,[r4,#0x60]         ;1053
000178  e022              B        |L21.448|
                  |L21.378|
00017a  f8940048          LDRB     r0,[r4,#0x48]         ;1057
00017e  2805              CMP      r0,#5                 ;1057
000180  d115              BNE      |L21.430|
000182  2003              MOVS     r0,#3                 ;1058
000184  f8840048          STRB     r0,[r4,#0x48]         ;1058
000188  bf00              NOP                            ;1059
                  |L21.394|
00018a  486b              LDR      r0,|L21.824|
00018c  f7fffffe          BL       DMA_GetFlagStatus
000190  2800              CMP      r0,#0                 ;1059
000192  d0fa              BEQ      |L21.394|
000194  f8d80024          LDR      r0,[r8,#0x24]         ;1060
000198  f8c80018          STR      r0,[r8,#0x18]         ;1060
00019c  2000              MOVS     r0,#0                 ;1061
00019e  6620              STR      r0,[r4,#0x60]         ;1061
0001a0  a05e              ADR      r0,|L21.796|
0001a2  66a0              STR      r0,[r4,#0x68]         ;1062
0001a4  f44f7080          MOV      r0,#0x100             ;1063
0001a8  f7fffffe          BL       SDIO_ClearFlag
0001ac  e008              B        |L21.448|
                  |L21.430|
0001ae  f4477780          ORR      r7,r7,#0x100          ;1066
                  |L21.434|
0001b2  bf00              NOP                            ;1069
                  |L21.436|
0001b4  4809              LDR      r0,|L21.476|
0001b6  6387              STR      r7,[r0,#0x38]         ;1070
0001b8  e00c              B        |L21.468|
                  |L21.442|
0001ba  2000              MOVS     r0,#0                 ;1074
0001bc  6620              STR      r0,[r4,#0x60]         ;1074
0001be  bf00              NOP                            ;1075
                  |L21.448|
0001c0  2001              MOVS     r0,#1                 ;1076
0001c2  f8840048          STRB     r0,[r4,#0x48]         ;1076
0001c6  4620              MOV      r0,r4                 ;1077
0001c8  f7fffffe          BL       clear_imask
0001cc  4620              MOV      r0,r4                 ;1078
0001ce  f7fffffe          BL       pio_tasklet
0001d2  bf00              NOP                            ;1079
                  |L21.468|
0001d4  bf00              NOP                            ;1083
0001d6  e738              B        |L21.74|
;;;1086   
                          ENDP

                  |L21.472|
                          DCD      gpstm32_host
                  |L21.476|
                          DCD      0x40018000
                  |L21.480|
0001e0  63617264          DCB      "card sdio interupt!\n",0
0001e4  20736469
0001e8  6f20696e
0001ec  74657275
0001f0  7074210a
0001f4  00      
0001f5  00                DCB      0
0001f6  00                DCB      0
0001f7  00                DCB      0
                  |L21.504|
0001f8  6e6f7468          DCB      "nothing to complete",0
0001fc  696e6720
000200  746f2063
000204  6f6d706c
000208  65746500
                  |L21.524|
00020c  6e6f2061          DCB      "no active mrq",0
000210  63746976
000214  65206d72
000218  7100    
00021a  00                DCB      0
00021b  00                DCB      0
                  |L21.540|
00021c  6e6f2061          DCB      "no active cmd",0
000220  63746976
000224  6520636d
000228  6400    
00022a  00                DCB      0
00022b  00                DCB      0
                  |L21.556|
00022c  434d4453          DCB      "CMDSTAT: error CMDTIMEOUT\n",0
000230  5441543a
000234  20657272
000238  6f722043
00023c  4d445449
000240  4d454f55
000244  540a00  
000247  00                DCB      0
                  |L21.584|
000248  6572726f          DCB      "error: command timeout",0
00024c  723a2063
000250  6f6d6d61
000254  6e642074
000258  696d656f
00025c  757400  
00025f  00                DCB      0
                  |L21.608|
000260  6f6b3a20          DCB      "ok: command sent",0
000264  636f6d6d
000268  616e6420
00026c  73656e74
000270  00      
000271  00                DCB      0
000272  00                DCB      0
000273  00                DCB      0
                  |L21.628|
000274  66697875          DCB      "fixup: ignore CRC fail with long rsp\n",0
000278  703a2069
00027c  676e6f72
000280  65204352
000284  43206661
000288  696c2077
00028c  69746820
000290  6c6f6e67
000294  20727370
000298  0a00    
00029a  00                DCB      0
00029b  00                DCB      0
                  |L21.668|
00029c  6f6b3a20          DCB      "ok: command response received",0
0002a0  636f6d6d
0002a4  616e6420
0002a8  72657370
0002ac  6f6e7365
0002b0  20726563
0002b4  65697665
0002b8  6400    
0002ba  00                DCB      0
0002bb  00                DCB      0
                  |L21.700|
0002bc  62616420          DCB      "bad data crc (outgoing)\n",0
0002c0  64617461
0002c4  20637263
0002c8  20286f75
0002cc  74676f69
0002d0  6e67290a
0002d4  00      
0002d5  00                DCB      0
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L21.728|
0002d8  6572726f          DCB      "error: bad data crc (outgoing)",0
0002dc  723a2062
0002e0  61642064
0002e4  61746120
0002e8  63726320
0002ec  286f7574
0002f0  676f696e
0002f4  672900  
0002f7  00                DCB      0
                  |L21.760|
0002f8  64617461          DCB      "data timeout\n",0
0002fc  2074696d
000300  656f7574
000304  0a00    
000306  00                DCB      0
000307  00                DCB      0
                  |L21.776|
000308  6572726f          DCB      "error: data timeout",0
00030c  723a2064
000310  61746120
000314  74696d65
000318  6f757400
                  |L21.796|
00031c  6f6b3a20          DCB      "ok: data transfer completed",0
000320  64617461
000324  20747261
000328  6e736665
00032c  7220636f
000330  6d706c65
000334  74656400
                  |L21.824|
                          DCD      0x10002000

                          AREA ||i.stm32_probe||, CODE, READONLY, ALIGN=2

                  stm32_probe PROC
;;;1102   }
;;;1103   struct mmc_host * stm32_probe(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1104   {
;;;1105   	struct mmc_host	*mmc;
;;;1106   	struct stm32_host *host;
;;;1107           init_stm32_struct(&stm32_ops);  //注册主机接口
000002  481c              LDR      r0,|L22.116|
000004  f7fffffe          BL       init_stm32_struct
;;;1108           mmc = mmc_alloc_host();         //分配mmc_host，里面内嵌stm32_host 结构
000008  f7fffffe          BL       mmc_alloc_host
00000c  4604              MOV      r4,r0
;;;1109   	host = mmc_priv(mmc);
00000e  f1040568          ADD      r5,r4,#0x68
;;;1110           gpstm32_host=host;              //主要给中断服务程序使用
000012  4819              LDR      r0,|L22.120|
000014  6005              STR      r5,[r0,#0]  ; gpstm32_host
;;;1111           host->mmc = mmc;
000016  602c              STR      r4,[r5,#0]
;;;1112   	host->complete_what = COMPLETION_NONE;
000018  2000              MOVS     r0,#0
00001a  f8850048          STRB     r0,[r5,#0x48]
;;;1113   	host->pio_active 	= XFER_NONE;
00001e  6628              STR      r0,[r5,#0x60]
;;;1114   	host->irq=SDIO_IRQChannel;
000020  2031              MOVS     r0,#0x31
000022  60a8              STR      r0,[r5,#8]
;;;1115           EnableIrq(host->irq);           //Enable sdio irq
000024  68a8              LDR      r0,[r5,#8]
000026  f7fffffe          BL       EnableIrq
;;;1116   	host->irq_state = false;
00002a  2000              MOVS     r0,#0
00002c  f885003a          STRB     r0,[r5,#0x3a]
;;;1117           host->irq_cd = -1;              //不检测
000030  1e40              SUBS     r0,r0,#1
000032  60e8              STR      r0,[r5,#0xc]
;;;1118   	host->clk_div=1;
000034  2001              MOVS     r0,#1
000036  61a8              STR      r0,[r5,#0x18]
;;;1119   	host->clk_rate =128000000;//50Mhz
000038  4810              LDR      r0,|L22.124|
00003a  6168              STR      r0,[r5,#0x14]
;;;1120   	mmc->ops 	= &stm32_ops;
00003c  480d              LDR      r0,|L22.116|
00003e  6060              STR      r0,[r4,#4]
;;;1121   	mmc->ocr_avail	= MMC_VDD_32_33 | MMC_VDD_33_34;
000040  f44f1040          MOV      r0,#0x300000
000044  6120              STR      r0,[r4,#0x10]
;;;1122   #ifdef CONFIG_MMC_S3C_HW_SDIO_IRQ
;;;1123   	mmc->caps	= MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;
000046  2009              MOVS     r0,#9
000048  6160              STR      r0,[r4,#0x14]
;;;1124   #else
;;;1125   	mmc->caps	= MMC_CAP_4_BIT_DATA;
;;;1126   #endif
;;;1127   	mmc->f_min 	= host->clk_rate /257;
00004a  f2401101          MOV      r1,#0x101
00004e  6968              LDR      r0,[r5,#0x14]
000050  fbb0f0f1          UDIV     r0,r0,r1
000054  60a0              STR      r0,[r4,#8]
;;;1128   	mmc->f_max 	= host->clk_rate;
000056  6968              LDR      r0,[r5,#0x14]
000058  60e0              STR      r0,[r4,#0xc]
;;;1129   
;;;1130   	/*if (host->pdata->ocr_avail)
;;;1131   		mmc->ocr_avail = host->pdata->ocr_avail; */
;;;1132   
;;;1133   	mmc->max_blk_count	= 4095;
00005a  f64070ff          MOV      r0,#0xfff
00005e  62e0              STR      r0,[r4,#0x2c]
;;;1134   	mmc->max_blk_size	= 4095;
000060  62a0              STR      r0,[r4,#0x28]
;;;1135   	mmc->max_req_size	= 4095 * 512;
000062  0240              LSLS     r0,r0,#9
000064  6260              STR      r0,[r4,#0x24]
;;;1136   	mmc->max_seg_size	= mmc->max_req_size;
000066  6a60              LDR      r0,[r4,#0x24]
000068  61a0              STR      r0,[r4,#0x18]
;;;1137   	mmc->max_phys_segs	= 128;
00006a  2080              MOVS     r0,#0x80
00006c  83e0              STRH     r0,[r4,#0x1e]
;;;1138   	mmc->max_hw_segs	= 128;
00006e  83a0              STRH     r0,[r4,#0x1c]
;;;1139   
;;;1140   	pr_debug( "probe:stm32f103rc sdio!\n");
;;;1141   	return mmc;
000070  4620              MOV      r0,r4
;;;1142   }
000072  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L22.116|
                          DCD      stm32_ops
                  |L22.120|
                          DCD      gpstm32_host
                  |L22.124|
                          DCD      0x07a12000

                          AREA ||i.stm32_request||, CODE, READONLY, ALIGN=2

                  stm32_request PROC
;;;762    
;;;763    static void stm32_request(struct mmc_host *mmc, struct mmc_request *mrq)
000000  b570              PUSH     {r4-r6,lr}
;;;764    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;765    	struct stm32_host *host = mmc_priv(mmc);
000006  f1060468          ADD      r4,r6,#0x68
;;;766    	pr_debug("stm32_request!\n");
;;;767    	host->status = "mmc request";
00000a  a00b              ADR      r0,|L23.56|
00000c  66a0              STR      r0,[r4,#0x68]
;;;768    	host->cmd_is_stop = 0;
00000e  2000              MOVS     r0,#0
000010  6460              STR      r0,[r4,#0x44]
;;;769    	host->mrq = mrq;
000012  6425              STR      r5,[r4,#0x40]
;;;770    
;;;771    	if (stm32_card_present(mmc) == 0) {
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       stm32_card_present
00001a  b948              CBNZ     r0,|L23.48|
;;;772    		dbg("%s: no medium present\n", __func__);
;;;773    		host->mrq->cmd->error = -ENOMEDIUM;
00001c  f06f007c          MVN      r0,#0x7c
000020  6c21              LDR      r1,[r4,#0x40]
000022  6809              LDR      r1,[r1,#0]
000024  6208              STR      r0,[r1,#0x20]
;;;774    		mmc_request_done(mmc, mrq);
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       mmc_request_done
00002e  e002              B        |L23.54|
                  |L23.48|
;;;775    	} else
;;;776    		stm32_send_request(mmc);
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       stm32_send_request
                  |L23.54|
;;;777    	sdio_deb_leave();
;;;778    }
000036  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

                  |L23.56|
000038  6d6d6320          DCB      "mmc request",0
00003c  72657175
000040  65737400

                          AREA ||i.stm32_send_command||, CODE, READONLY, ALIGN=2

                  stm32_send_command PROC
;;;386    #endif
;;;387    static void stm32_send_command(struct stm32_host *host,
000000  b570              PUSH     {r4-r6,lr}
;;;388    					struct mmc_command *cmd)
;;;389    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;390    	u32 imsk;
;;;391    	SDIO_CmdInitTypeDef SDIO_CmdInitStructure;
;;;392    	sdio_deb_enter();
;;;393    	imsk=SDIO_IT_CCRCFAIL|SDIO_IT_CTIMEOUT|//卡响应的数据
000008  26c5              MOVS     r6,#0xc5
;;;394    		SDIO_IT_CMDREND|SDIO_IT_CMDSENT;
;;;395    	enable_imask(host, imsk);//需要读取的中断
00000a  4631              MOV      r1,r6
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       enable_imask
;;;396    	if (cmd->data)
000012  6a60              LDR      r0,[r4,#0x24]
000014  b118              CBZ      r0,|L24.30|
;;;397    		host->complete_what = COMPLETION_XFERFINISH_RSPFIN;
000016  2005              MOVS     r0,#5
000018  f8850048          STRB     r0,[r5,#0x48]
00001c  e00a              B        |L24.52|
                  |L24.30|
;;;398    	else if (cmd->flags & MMC_RSP_PRESENT)
00001e  69a0              LDR      r0,[r4,#0x18]
000020  f0100f01          TST      r0,#1
000024  d003              BEQ      |L24.46|
;;;399    		host->complete_what = COMPLETION_RSPFIN;
000026  2003              MOVS     r0,#3
000028  f8850048          STRB     r0,[r5,#0x48]
00002c  e002              B        |L24.52|
                  |L24.46|
;;;400    	else
;;;401    		host->complete_what = COMPLETION_CMDSENT;
00002e  2002              MOVS     r0,#2
000030  f8850048          STRB     r0,[r5,#0x48]
                  |L24.52|
;;;402    	  SDIO->DTIMER=0xFFFFFFFF;
000034  f04f30ff          MOV      r0,#0xffffffff
000038  490f              LDR      r1,|L24.120|
00003a  6248              STR      r0,[r1,#0x24]
;;;403    	  SDIO_CmdInitStructure.SDIO_Argument =cmd->arg;
00003c  6860              LDR      r0,[r4,#4]
00003e  9001              STR      r0,[sp,#4]
;;;404    	  SDIO_CmdInitStructure.SDIO_CmdIndex =cmd->opcode;
000040  6820              LDR      r0,[r4,#0]
000042  9002              STR      r0,[sp,#8]
;;;405    	  if (cmd->flags & MMC_RSP_PRESENT)
000044  69a0              LDR      r0,[r4,#0x18]
000046  f0100f01          TST      r0,#1
00004a  d002              BEQ      |L24.82|
;;;406    		  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Short;
00004c  2040              MOVS     r0,#0x40
00004e  9003              STR      r0,[sp,#0xc]
000050  e008              B        |L24.100|
                  |L24.82|
;;;407    	  else if (cmd->flags & MMC_RSP_136)
000052  69a0              LDR      r0,[r4,#0x18]
000054  f0100f02          TST      r0,#2
000058  d002              BEQ      |L24.96|
;;;408    		  SDIO_CmdInitStructure.SDIO_Response = SDIO_Response_Long;
00005a  20c0              MOVS     r0,#0xc0
00005c  9003              STR      r0,[sp,#0xc]
00005e  e001              B        |L24.100|
                  |L24.96|
;;;409    	  else
;;;410    	  	SDIO_CmdInitStructure.SDIO_Response=SDIO_Response_No;
000060  2000              MOVS     r0,#0
000062  9003              STR      r0,[sp,#0xc]
                  |L24.100|
;;;411    	  SDIO_CmdInitStructure.SDIO_Wait = SDIO_Wait_No;
000064  2000              MOVS     r0,#0
000066  9004              STR      r0,[sp,#0x10]
;;;412    	  SDIO_CmdInitStructure.SDIO_CPSM = SDIO_CPSM_Enable;
000068  f44f6080          MOV      r0,#0x400
00006c  9005              STR      r0,[sp,#0x14]
;;;413    	  SDIO_SendCommand(&SDIO_CmdInitStructure);
00006e  a801              ADD      r0,sp,#4
000070  f7fffffe          BL       SDIO_SendCommand
;;;414    	  sdio_deb_leave();
;;;415    }
000074  b006              ADD      sp,sp,#0x18
000076  bd70              POP      {r4-r6,pc}
;;;416    
                          ENDP

                  |L24.120|
                          DCD      0x40018000

                          AREA ||i.stm32_send_request||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  stm32_send_request PROC
;;;596    
;;;597    static void stm32_send_request(struct mmc_host *mmc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;598    {
000004  4680              MOV      r8,r0
;;;599    	struct stm32_host *host = mmc_priv(mmc);
000006  f1080468          ADD      r4,r8,#0x68
;;;600    	struct mmc_request *mrq = host->mrq;
00000a  6c27              LDR      r7,[r4,#0x40]
;;;601    	struct mmc_command *cmd;
;;;602    	//u32 imask;
;;;603    	sdio_deb_enter();
;;;604    	cmd=host->cmd_is_stop ? mrq->stop : mrq->cmd;
00000c  6c60              LDR      r0,[r4,#0x44]
00000e  b108              CBZ      r0,|L25.20|
000010  68b8              LDR      r0,[r7,#8]
000012  e000              B        |L25.22|
                  |L25.20|
000014  6838              LDR      r0,[r7,#0]
                  |L25.22|
000016  4605              MOV      r5,r0
;;;605    	host->ccnt++;
000018  6ee0              LDR      r0,[r4,#0x6c]
00001a  1c40              ADDS     r0,r0,#1
00001c  66e0              STR      r0,[r4,#0x6c]
;;;606    	SDIO_ClearFlag(SDIO_ICR_MASK);
00001e  f24050ff          MOV      r0,#0x5ff
000022  f7fffffe          BL       SDIO_ClearFlag
;;;607    	 if (cmd->data) {//有数据阶段就安装数据
000026  6a68              LDR      r0,[r5,#0x24]
000028  b1b0              CBZ      r0,|L25.88|
;;;608    		int res = stm32_setup_data(host, cmd->data);
00002a  4620              MOV      r0,r4
00002c  6a69              LDR      r1,[r5,#0x24]
00002e  f7fffffe          BL       stm32_setup_data
000032  4606              MOV      r6,r0
;;;609    		host->dcnt++;
000034  6f20              LDR      r0,[r4,#0x70]
000036  1c40              ADDS     r0,r0,#1
000038  6720              STR      r0,[r4,#0x70]
;;;610    		if (res) {
00003a  b166              CBZ      r6,|L25.86|
;;;611    			printk( "setup data error %d\n", res);
00003c  4631              MOV      r1,r6
00003e  a00b              ADR      r0,|L25.108|
000040  f7fffffe          BL       __2printf
;;;612    			cmd->error = res;
000044  622e              STR      r6,[r5,#0x20]
;;;613    			cmd->data->error = res;
000046  6a68              LDR      r0,[r5,#0x24]
000048  6106              STR      r6,[r0,#0x10]
;;;614    			mmc_request_done(mmc, mrq);
00004a  4639              MOV      r1,r7
00004c  4640              MOV      r0,r8
00004e  f7fffffe          BL       mmc_request_done
                  |L25.82|
;;;615    			return;
;;;616    		}
;;;617    	} 
;;;618    	/* Send command */
;;;619    	stm32_send_command(host, cmd);
;;;620    	/* Enable Interrupt */
;;;621    	stm32_enable_irq(host, true);
;;;622    	sdio_deb_leave();
;;;623    }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L25.86|
000056  bf00              NOP                            ;617
                  |L25.88|
000058  4629              MOV      r1,r5                 ;619
00005a  4620              MOV      r0,r4                 ;619
00005c  f7fffffe          BL       stm32_send_command
000060  2101              MOVS     r1,#1                 ;621
000062  4620              MOV      r0,r4                 ;621
000064  f7fffffe          BL       stm32_enable_irq
000068  bf00              NOP      
00006a  e7f2              B        |L25.82|
;;;624    
                          ENDP

                  |L25.108|
00006c  73657475          DCB      "setup data error %d\n",0
000070  70206461
000074  74612065
000078  72726f72
00007c  2025640a
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.stm32_set_clk||, CODE, READONLY, ALIGN=1

                  stm32_set_clk PROC
;;;779    
;;;780    static void stm32_set_clk(struct stm32_host *host, struct mmc_ios *ios)
000000  b570              PUSH     {r4-r6,lr}
;;;781    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;782    	u32 mci_psc;
;;;783    	SDIO_InitTypeDef SDIO_InitStructure;
;;;784    	/* Set clock */
;;;785    	for (mci_psc = 0; mci_psc < 255; mci_psc++) {
000008  2500              MOVS     r5,#0
00000a  e00c              B        |L26.38|
                  |L26.12|
;;;786    		host->real_rate = host->clk_rate / (host->clk_div*(mci_psc+1));
00000c  1c69              ADDS     r1,r5,#1
00000e  e9d42005          LDRD     r2,r0,[r4,#0x14]
000012  4348              MULS     r0,r1,r0
000014  fbb2f0f0          UDIV     r0,r2,r0
000018  61e0              STR      r0,[r4,#0x1c]
;;;787    
;;;788    		if (host->real_rate <= ios->clock)
00001a  69e0              LDR      r0,[r4,#0x1c]
00001c  6831              LDR      r1,[r6,#0]
00001e  4288              CMP      r0,r1
000020  d800              BHI      |L26.36|
;;;789    			break;
000022  e002              B        |L26.42|
                  |L26.36|
000024  1c6d              ADDS     r5,r5,#1              ;785
                  |L26.38|
000026  2dff              CMP      r5,#0xff              ;785
000028  d3f0              BCC      |L26.12|
                  |L26.42|
00002a  bf00              NOP      
;;;790    	}
;;;791    
;;;792    	if (mci_psc > 255)
00002c  2dff              CMP      r5,#0xff
00002e  d900              BLS      |L26.50|
;;;793    		mci_psc = 255;
000030  25ff              MOVS     r5,#0xff
                  |L26.50|
;;;794      /* Power ON Sequence -------------------------------------------------------*/
;;;795      /* Configure the SDIO peripheral */
;;;796      SDIO_InitStructure.SDIO_ClockDiv = mci_psc; /* HCLK = 72MHz, SDIOCLK = 72MHz, SDIO_CK = HCLK/(178 + 2) = 400 KHz */
000032  b2e8              UXTB     r0,r5
000034  f88d0000          STRB     r0,[sp,#0]
;;;797      SDIO_InitStructure.SDIO_ClockEdge = SDIO_ClockEdge_Rising;
000038  2000              MOVS     r0,#0
00003a  9001              STR      r0,[sp,#4]
;;;798      SDIO_InitStructure.SDIO_ClockBypass = SDIO_ClockBypass_Disable;
00003c  9002              STR      r0,[sp,#8]
;;;799      SDIO_InitStructure.SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
00003e  9003              STR      r0,[sp,#0xc]
;;;800      switch(ios->bus_width){//设置总线位宽
000040  7a70              LDRB     r0,[r6,#9]
000042  b120              CBZ      r0,|L26.78|
000044  2802              CMP      r0,#2
000046  d005              BEQ      |L26.84|
000048  2803              CMP      r0,#3
00004a  d10b              BNE      |L26.100|
00004c  e006              B        |L26.92|
                  |L26.78|
;;;801      case MMC_BUS_WIDTH_1:
;;;802    		SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_1b;
00004e  2000              MOVS     r0,#0
000050  9004              STR      r0,[sp,#0x10]
;;;803    		break;
000052  e007              B        |L26.100|
                  |L26.84|
;;;804      case MMC_BUS_WIDTH_4:
;;;805    		SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_4b;
000054  f44f6000          MOV      r0,#0x800
000058  9004              STR      r0,[sp,#0x10]
;;;806    		break;
00005a  e003              B        |L26.100|
                  |L26.92|
;;;807      case MMC_BUS_WIDTH_8:
;;;808    		SDIO_InitStructure.SDIO_BusWide = SDIO_BusWide_8b;
00005c  f44f5080          MOV      r0,#0x1000
000060  9004              STR      r0,[sp,#0x10]
;;;809    		break;	
000062  bf00              NOP      
                  |L26.100|
000064  bf00              NOP                            ;803
;;;810      }
;;;811      SDIO_InitStructure.SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
000066  2000              MOVS     r0,#0
000068  9005              STR      r0,[sp,#0x14]
;;;812      SDIO_Init(&SDIO_InitStructure);
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       SDIO_Init
;;;813    
;;;814      host->prescaler = mci_psc;
000070  f8845020          STRB     r5,[r4,#0x20]
;;;815    	/* If requested clock is 0, real_rate will be 0, too */
;;;816      if (ios->clock == 0)
000074  6830              LDR      r0,[r6,#0]
000076  b908              CBNZ     r0,|L26.124|
;;;817    		host->real_rate = 0;
000078  2000              MOVS     r0,#0
00007a  61e0              STR      r0,[r4,#0x1c]
                  |L26.124|
;;;818    }
00007c  b006              ADD      sp,sp,#0x18
00007e  bd70              POP      {r4-r6,pc}
;;;819    
                          ENDP


                          AREA ||i.stm32_set_ios||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  stm32_set_ios PROC
;;;834    
;;;835    static void stm32_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;836    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;837    	struct stm32_host *host = mmc_priv(mmc);
000008  f1060568          ADD      r5,r6,#0x68
;;;838    //	u32 mci_con;
;;;839    
;;;840    	/* Set the power state */
;;;841    	stm32_set_clk(host, ios);
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       stm32_set_clk
;;;842    
;;;843    	
;;;844    	switch (ios->power_mode) {
000014  7a20              LDRB     r0,[r4,#8]
000016  b160              CBZ      r0,|L27.50|
000018  2801              CMP      r0,#1
00001a  d002              BEQ      |L27.34|
00001c  2802              CMP      r0,#2
00001e  d107              BNE      |L27.48|
;;;845    	case MMC_POWER_ON:
;;;846    	case MMC_POWER_UP:
000020  bf00              NOP      
                  |L27.34|
;;;847    	  	SDIO_SetPowerState(SDIO_PowerState_ON);
000022  2003              MOVS     r0,#3
000024  f7fffffe          BL       SDIO_SetPowerState
;;;848    		SDIO_ClockCmd(ENABLE);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       SDIO_ClockCmd
;;;849    		break;
00002e  e00a              B        |L27.70|
                  |L27.48|
;;;850    
;;;851    	case MMC_POWER_OFF:
000030  bf00              NOP      
                  |L27.50|
;;;852    	default:
;;;853    		SDIO_SetPowerState(SDIO_PowerState_OFF);
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       SDIO_SetPowerState
;;;854    		SDIO_ClockCmd(DISABLE);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       SDIO_ClockCmd
;;;855    		printf("stm32 power off sdio!\n");
00003e  a010              ADR      r0,|L27.128|
000040  f7fffffe          BL       __2printf
000044  bf00              NOP                            ;844
                  |L27.70|
000046  bf00              NOP                            ;849
;;;856    	}
;;;857    	if ((ios->power_mode == MMC_POWER_ON) ||
000048  7a20              LDRB     r0,[r4,#8]
00004a  2802              CMP      r0,#2
00004c  d002              BEQ      |L27.84|
;;;858    	    (ios->power_mode == MMC_POWER_UP)) {
00004e  7a20              LDRB     r0,[r4,#8]
000050  2801              CMP      r0,#1
000052  d10d              BNE      |L27.112|
                  |L27.84|
;;;859    		printk("running at %lukHz (requested: %ukHz).\n",
000054  f44f717a          MOV      r1,#0x3e8
000058  6820              LDR      r0,[r4,#0]
00005a  fbb0f7f1          UDIV     r7,r0,r1
00005e  69e8              LDR      r0,[r5,#0x1c]
000060  fbb0f8f1          UDIV     r8,r0,r1
000064  463a              MOV      r2,r7
000066  4641              MOV      r1,r8
000068  a00b              ADR      r0,|L27.152|
00006a  f7fffffe          BL       __2printf
00006e  e002              B        |L27.118|
                  |L27.112|
;;;860    			host->real_rate/1000, ios->clock/1000);
;;;861    	} else {
;;;862    		printk("powered down.\n");
000070  a013              ADR      r0,|L27.192|
000072  f7fffffe          BL       __2printf
                  |L27.118|
;;;863    	}
;;;864    	host->bus_width = ios->bus_width;
000076  7a60              LDRB     r0,[r4,#9]
000078  6668              STR      r0,[r5,#0x64]
;;;865    }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;866    
                          ENDP

00007e  0000              DCW      0x0000
                  |L27.128|
000080  73746d33          DCB      "stm32 power off sdio!\n",0
000084  3220706f
000088  77657220
00008c  6f666620
000090  7364696f
000094  210a00  
000097  00                DCB      0
                  |L27.152|
000098  72756e6e          DCB      "running at %lukHz (requested: %ukHz).\n",0
00009c  696e6720
0000a0  61742025
0000a4  6c756b48
0000a8  7a202872
0000ac  65717565
0000b0  73746564
0000b4  3a202575
0000b8  6b487a29
0000bc  2e0a00  
0000bf  00                DCB      0
                  |L27.192|
0000c0  706f7765          DCB      "powered down.\n",0
0000c4  72656420
0000c8  646f776e
0000cc  2e0a00  
0000cf  00                DCB      0

                          AREA ||i.stm32_setup_data||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  stm32_setup_data PROC
;;;473    
;;;474    static int stm32_setup_data(struct stm32_host *host, struct mmc_data *data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;475    {
000004  b086              SUB      sp,sp,#0x18
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
;;;476    	SDIO_DataInitTypeDef SDIO_DataInitStructure;
;;;477    	u32 blocks=data->blocks;
00000a  f8d4900c          LDR      r9,[r4,#0xc]
;;;478    	u32 blksz=data->blksz;
00000e  68a5              LDR      r5,[r4,#8]
;;;479    	u32 total_len;
;;;480    	u32 imask;
;;;481    	u8 power = 0;
000010  f04f0a00          MOV      r10,#0
;;;482    	/* write DCON register */
;;;483    	sdio_deb_enter();
;;;484    	if (!data) {
000014  b91c              CBNZ     r4,|L28.30|
;;;485    		return 0;
000016  2000              MOVS     r0,#0
                  |L28.24|
;;;486    	}
;;;487    	if ((data->blksz & 3) != 0) {
;;;488    		/* We cannot deal with unaligned blocks with more than
;;;489    		 * one block being transfered. */
;;;490    
;;;491    		if (data->blocks > 1) {
;;;492    			printk("can't do non-word sized block transfers (blksz %d)\n",data->blksz);
;;;493    			return -EINVAL;
;;;494    		}
;;;495    	}
;;;496    	//reset data config	
;;;497    	  SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;498    	  SDIO_DataInitStructure.SDIO_DataLength = 0;
;;;499    	  SDIO_DataInitStructure.SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
;;;500    	  SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
;;;501    	  SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;502    	  SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Disable;
;;;503    	  SDIO_DataConfig(&SDIO_DataInitStructure);
;;;504    	  SDIO_DMACmd(DISABLE);
;;;505          //reset state 
;;;506          	 SDIO_ClearFlag(SDIO_ICR_MASK);
;;;507    	if (host->bus_width == MMC_BUS_WIDTH_4){//设置sdio总线宽度
;;;508    		SDIO->CLKCR&=~(3<<11);
;;;509    		SDIO->CLKCR|=SDIO_BusWide_4b;
;;;510    	}
;;;511    		/* FIX: set slow clock to prevent timeouts on read */
;;;512    	/*if (data->flags & MMC_DATA_READ)
;;;513    		SDIO->CLKCR|=0xff;*/
;;;514    
;;;515      
;;;516          if ((blksz > 0) && (blksz <= 2048) && (0 == (blksz & (blksz - 1)))){//必须是整数块
;;;517    	    power = convert_from_bytes_to_power_of_two(blksz);
;;;518    	    total_len=blksz*blocks;
;;;519      	}
;;;520         else
;;;521       	   return -EINVAL;
;;;522      
;;;523        /* Common to all modes */
;;;524      if (total_len > SD_MAX_DATA_LENGTH)
;;;525     		 return -EINVAL;
;;;526        SDIO_DataInitStructure.SDIO_DataTimeOut = SD_DATATIMEOUT;
;;;527        SDIO_DataInitStructure.SDIO_DataLength = total_len;
;;;528        SDIO_DataInitStructure.SDIO_DataBlockSize = (u32) power << 4;
;;;529        if (data->flags & MMC_DATA_WRITE)
;;;530        		SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToCard;
;;;531        else if (data->flags & MMC_DATA_READ)
;;;532    		SDIO_DataInitStructure.SDIO_TransferDir = SDIO_TransferDir_ToSDIO;
;;;533        SDIO_DataInitStructure.SDIO_TransferMode = SDIO_TransferMode_Block;
;;;534        SDIO_DataInitStructure.SDIO_DPSM = SDIO_DPSM_Disable;//暂时不使能DPSM
;;;535        SDIO_DataConfig(&SDIO_DataInitStructure);//DMA disable
;;;536        if (data->flags & MMC_DATA_READ){
;;;537    	 	DMA_RxConfiguration((u32 *)data->sg,total_len);//安装DMA参数
;;;538    	 	SDIO->DCTRL|=((1<<3)|SDIO_DPSM_Enable);//接收时先使能DMA和数据状态机
;;;539        	}	 	
;;;540       else  if (data->flags & MMC_DATA_WRITE)
;;;541    		DMA_TxConfiguration((u32 *)data->sg,total_len);
;;;542    	 imask=SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND; //data interrupt
;;;543    	 enable_imask(host, imask);//需要读取的中断
;;;544         sdio_deb_leave();
;;;545    	return 0;
;;;546    }
000018  b006              ADD      sp,sp,#0x18
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L28.30|
00001e  68a0              LDR      r0,[r4,#8]            ;487
000020  f0100f03          TST      r0,#3                 ;487
000024  d009              BEQ      |L28.58|
000026  68e0              LDR      r0,[r4,#0xc]          ;491
000028  2801              CMP      r0,#1                 ;491
00002a  d906              BLS      |L28.58|
00002c  a03a              ADR      r0,|L28.280|
00002e  68a1              LDR      r1,[r4,#8]            ;492
000030  f7fffffe          BL       __2printf
000034  f06f0015          MVN      r0,#0x15              ;493
000038  e7ee              B        |L28.24|
                  |L28.58|
00003a  4844              LDR      r0,|L28.332|
00003c  9000              STR      r0,[sp,#0]            ;497
00003e  2000              MOVS     r0,#0                 ;498
000040  9001              STR      r0,[sp,#4]            ;498
000042  9002              STR      r0,[sp,#8]            ;499
000044  9003              STR      r0,[sp,#0xc]          ;500
000046  9004              STR      r0,[sp,#0x10]         ;501
000048  9005              STR      r0,[sp,#0x14]         ;502
00004a  4668              MOV      r0,sp                 ;503
00004c  f7fffffe          BL       SDIO_DataConfig
000050  2000              MOVS     r0,#0                 ;504
000052  f7fffffe          BL       SDIO_DMACmd
000056  f24050ff          MOV      r0,#0x5ff             ;506
00005a  f7fffffe          BL       SDIO_ClearFlag
00005e  6e78              LDR      r0,[r7,#0x64]         ;507
000060  2802              CMP      r0,#2                 ;507
000062  d10a              BNE      |L28.122|
000064  483a              LDR      r0,|L28.336|
000066  6840              LDR      r0,[r0,#4]            ;508
000068  f42050c0          BIC      r0,r0,#0x1800         ;508
00006c  4938              LDR      r1,|L28.336|
00006e  6048              STR      r0,[r1,#4]            ;508
000070  4608              MOV      r0,r1                 ;509
000072  6840              LDR      r0,[r0,#4]            ;509
000074  f4406000          ORR      r0,r0,#0x800          ;509
000078  6048              STR      r0,[r1,#4]            ;509
                  |L28.122|
00007a  b165              CBZ      r5,|L28.150|
00007c  f5b56f00          CMP      r5,#0x800             ;516
000080  d809              BHI      |L28.150|
000082  1e68              SUBS     r0,r5,#1              ;516
000084  4228              TST      r0,r5                 ;516
000086  d106              BNE      |L28.150|
000088  b2a8              UXTH     r0,r5                 ;517
00008a  f7fffffe          BL       convert_from_bytes_to_power_of_two
00008e  4682              MOV      r10,r0                ;517
000090  fb05f609          MUL      r6,r5,r9              ;518
000094  e002              B        |L28.156|
                  |L28.150|
000096  f06f0015          MVN      r0,#0x15              ;521
00009a  e7bd              B        |L28.24|
                  |L28.156|
00009c  f1b67f00          CMP      r6,#0x2000000         ;524
0000a0  d302              BCC      |L28.168|
0000a2  f06f0015          MVN      r0,#0x15              ;525
0000a6  e7b7              B        |L28.24|
                  |L28.168|
0000a8  4828              LDR      r0,|L28.332|
0000aa  9000              STR      r0,[sp,#0]            ;526
0000ac  9601              STR      r6,[sp,#4]            ;527
0000ae  ea4f100a          LSL      r0,r10,#4             ;528
0000b2  9002              STR      r0,[sp,#8]            ;528
0000b4  6960              LDR      r0,[r4,#0x14]         ;529
0000b6  f4107f80          TST      r0,#0x100             ;529
0000ba  d002              BEQ      |L28.194|
0000bc  2000              MOVS     r0,#0                 ;530
0000be  9003              STR      r0,[sp,#0xc]          ;530
0000c0  e005              B        |L28.206|
                  |L28.194|
0000c2  6960              LDR      r0,[r4,#0x14]         ;531
0000c4  f4107f00          TST      r0,#0x200             ;531
0000c8  d001              BEQ      |L28.206|
0000ca  2002              MOVS     r0,#2                 ;532
0000cc  9003              STR      r0,[sp,#0xc]          ;532
                  |L28.206|
0000ce  2000              MOVS     r0,#0                 ;533
0000d0  9004              STR      r0,[sp,#0x10]         ;533
0000d2  9005              STR      r0,[sp,#0x14]         ;534
0000d4  4668              MOV      r0,sp                 ;535
0000d6  f7fffffe          BL       SDIO_DataConfig
0000da  6960              LDR      r0,[r4,#0x14]         ;536
0000dc  f4107f00          TST      r0,#0x200             ;536
0000e0  d00a              BEQ      |L28.248|
0000e2  4631              MOV      r1,r6                 ;537
0000e4  6aa0              LDR      r0,[r4,#0x28]         ;537
0000e6  f7fffffe          BL       DMA_RxConfiguration
0000ea  4819              LDR      r0,|L28.336|
0000ec  6ac0              LDR      r0,[r0,#0x2c]         ;538
0000ee  f0400009          ORR      r0,r0,#9              ;538
0000f2  4917              LDR      r1,|L28.336|
0000f4  62c8              STR      r0,[r1,#0x2c]         ;538
0000f6  e007              B        |L28.264|
                  |L28.248|
0000f8  6960              LDR      r0,[r4,#0x14]         ;540
0000fa  f4107f80          TST      r0,#0x100             ;540
0000fe  d003              BEQ      |L28.264|
000100  4631              MOV      r1,r6                 ;541
000102  6aa0              LDR      r0,[r4,#0x28]         ;541
000104  f7fffffe          BL       DMA_TxConfiguration
                  |L28.264|
000108  f44f7885          MOV      r8,#0x10a             ;542
00010c  4641              MOV      r1,r8                 ;543
00010e  4638              MOV      r0,r7                 ;543
000110  f7fffffe          BL       enable_imask
000114  2000              MOVS     r0,#0                 ;545
000116  e77f              B        |L28.24|
;;;547    
                          ENDP

                  |L28.280|
000118  63616e27          DCB      "can't do non-word sized block transfers (blksz %d)\n",0
00011c  7420646f
000120  206e6f6e
000124  2d776f72
000128  64207369
00012c  7a656420
000130  626c6f63
000134  6b207472
000138  616e7366
00013c  65727320
000140  28626c6b
000144  737a2025
000148  64290a00
                  |L28.332|
                          DCD      0x000fffff
                  |L28.336|
                          DCD      0x40018000

                          AREA ||i.udelay||, CODE, READONLY, ALIGN=1

                  udelay PROC
;;;34     
;;;35     static void udelay(unsigned int us)
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37     	unsigned long i,ii=500;
000002  f44f72fa          MOV      r2,#0x1f4
;;;38     	for(i=0;i<us;i++){
000006  2100              MOVS     r1,#0
000008  e007              B        |L29.26|
                  |L29.10|
;;;39     		ii=500;
00000a  f44f72fa          MOV      r2,#0x1f4
;;;40     		while(ii--);
00000e  bf00              NOP      
                  |L29.16|
000010  0013              MOVS     r3,r2
000012  f1a20201          SUB      r2,r2,#1
000016  d1fb              BNE      |L29.16|
000018  1c49              ADDS     r1,r1,#1              ;38
                  |L29.26|
00001a  4281              CMP      r1,r0                 ;38
00001c  d3f5              BCC      |L29.10|
;;;41     	}
;;;42     }
00001e  bd10              POP      {r4,pc}
;;;43     static unsigned int readl(unsigned long addr)
                          ENDP


                          AREA ||i.writel||, CODE, READONLY, ALIGN=1

                  writel PROC
;;;47     
;;;48     static unsigned int writel(unsigned int data,unsigned long addr)
000000  6008              STR      r0,[r1,#0]
;;;49     {  
;;;50        return (*(volatile unsigned *)addr)=data;
;;;51     }
000002  4770              BX       lr
;;;52     void EnableIrq(u32 irq)
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L31.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L31.32|
                  |L31.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L31.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L31.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L31.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L31.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L31.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L31.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L31.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  stm32_ops
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  gpstm32_host
                          DCD      0x00000000
