; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\system.o --depend=.\obj\system.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\system.crf ..\target\system.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;140    *******************************************************************************/
;;;141    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;142    {
;;;143        GPIO_InitTypeDef GPIO_InitStructure;
;;;144        /*串口1，引脚功能*/
;;;145        /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;146        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;147        GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AF_PP;//GPIO_Mode_Out_PP; //GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;148        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;149        GPIO_Init(GPIOA, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  483e              LDR      r0,|L1.276|
00001a  f7fffffe          BL       GPIO_Init
;;;150        
;;;151        /* Configure USART1 Rx (PA.10) as input floating */
;;;152        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00001e  f44f6080          MOV      r0,#0x400
000022  f8ad0000          STRH     r0,[sp,#0]
;;;153        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2004              MOVS     r0,#4
000028  f88d0003          STRB     r0,[sp,#3]
;;;154        GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4839              LDR      r0,|L1.276|
000030  f7fffffe          BL       GPIO_Init
;;;155    
;;;156        /*SDIO 管脚配置*/
;;;157        /* Configure PC.08, PC.09, PC.10, PC.11, PC.12 pin: D0, D1, D2, D3, CLK pin */
;;;158        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12;
000034  f44f50f8          MOV      r0,#0x1f00
000038  f8ad0000          STRH     r0,[sp,#0]
;;;159        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003c  2003              MOVS     r0,#3
00003e  f88d0002          STRB     r0,[sp,#2]
;;;160        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000042  2018              MOVS     r0,#0x18
000044  f88d0003          STRB     r0,[sp,#3]
;;;161        GPIO_Init(GPIOC, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  4833              LDR      r0,|L1.280|
00004c  f7fffffe          BL       GPIO_Init
;;;162        /* Configure PD.02 CMD line */
;;;163        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000050  2004              MOVS     r0,#4
000052  f8ad0000          STRH     r0,[sp,#0]
;;;164        GPIO_Init(GPIOD, &GPIO_InitStructure);
000056  4669              MOV      r1,sp
000058  4830              LDR      r0,|L1.284|
00005a  f7fffffe          BL       GPIO_Init
;;;165    
;;;166        /* Power control */
;;;167        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00005e  f44f5080          MOV      r0,#0x1000
000062  f8ad0000          STRH     r0,[sp,#0]
;;;168        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000066  2003              MOVS     r0,#3
000068  f88d0002          STRB     r0,[sp,#2]
;;;169        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00006c  2010              MOVS     r0,#0x10
00006e  f88d0003          STRB     r0,[sp,#3]
;;;170        GPIO_Init(GPIOB, &GPIO_InitStructure);
000072  4669              MOV      r1,sp
000074  482a              LDR      r0,|L1.288|
000076  f7fffffe          BL       GPIO_Init
;;;171    
;;;172    	/*继电器1~6*/
;;;173    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_4 | GPIO_Pin_5;
00007a  2037              MOVS     r0,#0x37
00007c  f8ad0000          STRH     r0,[sp,#0]
;;;174        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000080  2003              MOVS     r0,#3
000082  f88d0002          STRB     r0,[sp,#2]
;;;175        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000086  2010              MOVS     r0,#0x10
000088  f88d0003          STRB     r0,[sp,#3]
;;;176        GPIO_Init(GPIOA, &GPIO_InitStructure);
00008c  4669              MOV      r1,sp
00008e  4821              LDR      r0,|L1.276|
000090  f7fffffe          BL       GPIO_Init
;;;177    	GPIO_SetBits(GPIOA, GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_4 | GPIO_Pin_5);
000094  2137              MOVS     r1,#0x37
000096  481f              LDR      r0,|L1.276|
000098  f7fffffe          BL       GPIO_SetBits
;;;178    
;;;179    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
00009c  2002              MOVS     r0,#2
00009e  f8ad0000          STRH     r0,[sp,#0]
;;;180        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a2  2003              MOVS     r0,#3
0000a4  f88d0002          STRB     r0,[sp,#2]
;;;181        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000a8  2010              MOVS     r0,#0x10
0000aa  f88d0003          STRB     r0,[sp,#3]
;;;182        GPIO_Init(GPIOB, &GPIO_InitStructure);
0000ae  4669              MOV      r1,sp
0000b0  481b              LDR      r0,|L1.288|
0000b2  f7fffffe          BL       GPIO_Init
;;;183    	GPIO_SetBits(GPIOB, GPIO_Pin_1);
0000b6  2102              MOVS     r1,#2
0000b8  4819              LDR      r0,|L1.288|
0000ba  f7fffffe          BL       GPIO_SetBits
;;;184    
;;;185    	/*电平检测1~8*/
;;;186    	/* PD3,4,5,6按键输入*/
;;;187    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_11 | GPIO_Pin_12;
0000be  f44f50c8          MOV      r0,#0x1900
0000c2  f8ad0000          STRH     r0,[sp,#0]
;;;188    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000c6  2002              MOVS     r0,#2
0000c8  f88d0002          STRB     r0,[sp,#2]
;;;189    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//上拉输入
0000cc  2004              MOVS     r0,#4
0000ce  f88d0003          STRB     r0,[sp,#3]
;;;190    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000d2  4669              MOV      r1,sp
0000d4  480f              LDR      r0,|L1.276|
0000d6  f7fffffe          BL       GPIO_Init
;;;191    
;;;192    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_15;
0000da  f2480060          MOV      r0,#0x8060
0000de  f8ad0000          STRH     r0,[sp,#0]
;;;193    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000e2  2002              MOVS     r0,#2
0000e4  f88d0002          STRB     r0,[sp,#2]
;;;194    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//上拉输入
0000e8  2004              MOVS     r0,#4
0000ea  f88d0003          STRB     r0,[sp,#3]
;;;195    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0000ee  4669              MOV      r1,sp
0000f0  480b              LDR      r0,|L1.288|
0000f2  f7fffffe          BL       GPIO_Init
;;;196    
;;;197    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6 | GPIO_Pin_7;
0000f6  20c0              MOVS     r0,#0xc0
0000f8  f8ad0000          STRH     r0,[sp,#0]
;;;198    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000fc  2002              MOVS     r0,#2
0000fe  f88d0002          STRB     r0,[sp,#2]
;;;199    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//上拉输入
000102  2004              MOVS     r0,#4
000104  f88d0003          STRB     r0,[sp,#3]
;;;200    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000108  4669              MOV      r1,sp
00010a  4803              LDR      r0,|L1.280|
00010c  f7fffffe          BL       GPIO_Init
;;;201    }
000110  bd08              POP      {r3,pc}
;;;202    
                          ENDP

000112  0000              DCW      0x0000
                  |L1.276|
                          DCD      0x40010800
                  |L1.280|
                          DCD      0x40011000
                  |L1.284|
                          DCD      0x40011400
                  |L1.288|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;107    *******************************************************************************/
;;;108    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;109    {
;;;110        NVIC_InitTypeDef NVIC_InitStructure;
;;;111    
;;;112    #ifdef  VECT_TAB_RAM  
;;;113        /* Set the Vector Table base location at 0x20000000 */
;;;114        NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;115    #else  /* VECT_TAB_FLASH  */
;;;116        /* Set the Vector Table base location at 0x08000000 */
;;;117        NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;118    #endif
;;;119    
;;;120        NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQChannel;
00000c  201c              MOVS     r0,#0x1c
00000e  f88d0000          STRB     r0,[sp,#0]
;;;121        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000012  2000              MOVS     r0,#0
000014  f88d0001          STRB     r0,[sp,#1]
;;;122        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000018  f88d0002          STRB     r0,[sp,#2]
;;;123        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;124        NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;125    
;;;126    }
000028  bd08              POP      {r3,pc}
;;;127    /*******************************************************************************
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;12     *******************************************************************************/
;;;13     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;14     {
;;;15         ErrorStatus HSEStartUpStatus;
;;;16         /* RCC system reset(for debug purpose) */
;;;17         RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;18     
;;;19         /* Enable HSE */
;;;20         RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;21     
;;;22         /* Wait till HSE is ready */
;;;23         HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4604              MOV      r4,r0
;;;24     
;;;25         if(HSEStartUpStatus == SUCCESS)
000014  2c01              CMP      r4,#1
000016  d127              BNE      |L3.104|
;;;26         {
;;;27             /* HCLK = SYSCLK */
;;;28             RCC_HCLKConfig(RCC_SYSCLK_Div1);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       RCC_HCLKConfig
;;;29     
;;;30             /* PCLK2 = HCLK */
;;;31             RCC_PCLK2Config(RCC_HCLK_Div1);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_PCLK2Config
;;;32     
;;;33             /* PCLK1 = HCLK/2 */
;;;34             RCC_PCLK1Config(RCC_HCLK_Div2);
000024  02a0              LSLS     r0,r4,#10
000026  f7fffffe          BL       RCC_PCLK1Config
;;;35     
;;;36             /* Flash 2 wait state */
;;;37             FLASH_SetLatency(FLASH_Latency_2);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       FLASH_SetLatency
;;;38             /* Enable Prefetch Buffer */
;;;39             FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000030  2010              MOVS     r0,#0x10
000032  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;40     
;;;41             /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;42             RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000036  f44f11e0          MOV      r1,#0x1c0000
00003a  0420              LSLS     r0,r4,#16
00003c  f7fffffe          BL       RCC_PLLConfig
;;;43     
;;;44     	/* ADCCLK = PCLK2/4 */
;;;45             RCC_ADCCLKConfig(RCC_PCLK2_Div4);
000040  03a0              LSLS     r0,r4,#14
000042  f7fffffe          BL       RCC_ADCCLKConfig
;;;46     
;;;47             /* Enable PLL */
;;;48             RCC_PLLCmd(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
;;;49     
;;;50             /* Wait till PLL is ready */
;;;51             while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
00004c  bf00              NOP      
                  |L3.78|
00004e  2039              MOVS     r0,#0x39
000050  f7fffffe          BL       RCC_GetFlagStatus
000054  2800              CMP      r0,#0
000056  d0fa              BEQ      |L3.78|
;;;52             {
;;;53             }
;;;54     
;;;55             /* Select PLL as system clock source */
;;;56             RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000058  2002              MOVS     r0,#2
00005a  f7fffffe          BL       RCC_SYSCLKConfig
;;;57     
;;;58             /* Wait till PLL is used as system clock source */
;;;59             while(RCC_GetSYSCLKSource() != 0x08)
00005e  bf00              NOP      
                  |L3.96|
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L3.96|
                  |L3.104|
;;;60             {
;;;61             }
;;;62         }
;;;63     
;;;64         /* Enable ADC1 and GPIOC clock */
;;;65         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE);
000068  2101              MOVS     r1,#1
00006a  f44f7004          MOV      r0,#0x210
00006e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;66     
;;;67     
;;;68         //这里是模块时钟，需要使用的
;;;69         RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2|RCC_APB1Periph_USART3|\
000072  2101              MOVS     r1,#1
000074  4808              LDR      r0,|L3.152|
000076  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;70                                RCC_APB1Periph_TIM2|RCC_APB1Periph_TIM3,ENABLE);
;;;71         RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|\
00007a  2101              MOVS     r1,#1
00007c  f245003d          MOV      r0,#0x503d
000080  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;72                                RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|\
;;;73                                RCC_APB2Periph_SPI1|RCC_APB2Periph_AFIO,
;;;74                                ENABLE);
;;;75         /* Enable the SDIO AHB Clock */
;;;76         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_SDIO, ENABLE);
000084  2101              MOVS     r1,#1
000086  0288              LSLS     r0,r1,#10
000088  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;77         /* Enable the DMA2 Clock */
;;;78         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
00008c  2101              MOVS     r1,#1
00008e  2002              MOVS     r0,#2
000090  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;79     }
000094  bd10              POP      {r4,pc}
;;;80     /*******************************************************************************
                          ENDP

000096  0000              DCW      0x0000
                  |L3.152|
                          DCD      0x00060003

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=1

                  USART_Configuration PROC
;;;272    *******************************************************************************/
;;;273    void USART_Configuration(USART_TypeDef *USARTx)
000000  b510              PUSH     {r4,lr}
;;;274    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;275        USART_InitTypeDef USART_InitStructure;
;;;276        USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;277        /* USART1 configuration -----------------------------------------------	-------*/
;;;278        /* USART1 configured as follow:
;;;279    	        - BaudRate = 115200 baud  
;;;280    	        - Word Length = 8 Bits
;;;281    	        - One Stop Bit
;;;282    	        - No parity
;;;283    	        - Hardware flow control disabled (RTS and CTS signals)
;;;284    	        - Receive and transmit enabled
;;;285    	        - USART Clock disabled
;;;286    	        - USART CPOL: Clock is active low
;;;287    	        - USART CPHA: Data is captured on the middle 
;;;288    	        - USART LastBit: The clock pulse of the last data bit is not 
;;;289    
;;;290    	output to 
;;;291    	                         the SCLK pin
;;;292    	  */
;;;293        USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000006  2000              MOVS     r0,#0
000008  f8ad0000          STRH     r0,[sp,#0]
;;;294        USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
00000c  f8ad0002          STRH     r0,[sp,#2]
;;;295        USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0004          STRH     r0,[sp,#4]
;;;296        USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
000018  2000              MOVS     r0,#0
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;297        /* Configure the USART1 synchronous paramters */
;;;298        USART_ClockInit(USARTx, &USART_ClockInitStructure);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USART_ClockInit
;;;299        USART_InitStructure.USART_BaudRate = 115200;//115200;
000026  f44f30e1          MOV      r0,#0x1c200
00002a  9002              STR      r0,[sp,#8]
;;;300        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00002c  2000              MOVS     r0,#0
00002e  f8ad000c          STRH     r0,[sp,#0xc]
;;;301        USART_InitStructure.USART_StopBits = USART_StopBits_1;
000032  f8ad000e          STRH     r0,[sp,#0xe]
;;;302        USART_InitStructure.USART_Parity = USART_Parity_No ;
000036  f8ad0010          STRH     r0,[sp,#0x10]
;;;303        USART_InitStructure.USART_HardwareFlowControl=USART_HardwareFlowControl_None;
00003a  f8ad0014          STRH     r0,[sp,#0x14]
;;;304        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00003e  200c              MOVS     r0,#0xc
000040  f8ad0012          STRH     r0,[sp,#0x12]
;;;305        /* Configure USART1 basic and asynchronous paramters */
;;;306        USART_Init(USARTx, &USART_InitStructure);
000044  a902              ADD      r1,sp,#8
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       USART_Init
;;;307        /* Enable USART1 Receive and Transmit interrupts */
;;;308        //USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
;;;309        //USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;310        /* Enable USART1 */
;;;311        USART_Cmd(USARTx, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       USART_Cmd
;;;312    }
000054  b006              ADD      sp,sp,#0x18
000056  bd10              POP      {r4,pc}
;;;313    
                          ENDP


                          AREA ||i.Uart_GetIntNum_GJ||, CODE, READONLY, ALIGN=2

                  Uart_GetIntNum_GJ PROC
;;;444    //*****************************************************************************
;;;445    int Uart_GetIntNum_GJ(void)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;446    {
;;;447        char string[16] ;
;;;448        char *p_string=string ;
000004  466e              MOV      r6,sp
;;;449        int ret=1;
000006  2701              MOVS     r7,#1
;;;450        int i = 0 ;
000008  2400              MOVS     r4,#0
;;;451        int data = 0 ;
00000a  2500              MOVS     r5,#0
;;;452        Uart_GetString(p_string);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       Uart_GetString
;;;453        i = 0 ;
000012  bf00              NOP      
;;;454        if(string[0]=='-' ){
000014  f89d0000          LDRB     r0,[sp,#0]
000018  282d              CMP      r0,#0x2d
00001a  d101              BNE      |L5.32|
;;;455            ret=-1;
00001c  1e67              SUBS     r7,r4,#1
;;;456            i++;
00001e  1c64              ADDS     r4,r4,#1
                  |L5.32|
;;;457        }
;;;458        while( string[i] != '\0' )
000020  e017              B        |L5.82|
                  |L5.34|
;;;459        {
;;;460            data = data * 10 ;
000022  eb050085          ADD      r0,r5,r5,LSL #2
000026  0045              LSLS     r5,r0,#1
;;;461            if( string[i]<'0'||string[i]>'9' ){
000028  f81d0004          LDRB     r0,[sp,r4]
00002c  2830              CMP      r0,#0x30
00002e  db03              BLT      |L5.56|
000030  f81d0004          LDRB     r0,[sp,r4]
000034  2839              CMP      r0,#0x39
000036  dd07              BLE      |L5.72|
                  |L5.56|
;;;462                printf("input error!\n");
000038  a009              ADR      r0,|L5.96|
00003a  f7fffffe          BL       __2printf
;;;463                return -1 ;
00003e  f04f30ff          MOV      r0,#0xffffffff
                  |L5.66|
;;;464            }
;;;465            data = data + ( string[i]-'0' ) ;
;;;466            i++ ;
;;;467        }
;;;468        return (data*ret );
;;;469    }
000042  b004              ADD      sp,sp,#0x10
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L5.72|
000048  f81d0004          LDRB     r0,[sp,r4]            ;465
00004c  3830              SUBS     r0,r0,#0x30           ;465
00004e  4405              ADD      r5,r5,r0              ;465
000050  1c64              ADDS     r4,r4,#1              ;466
                  |L5.82|
000052  f81d0004          LDRB     r0,[sp,r4]            ;458
000056  2800              CMP      r0,#0                 ;458
000058  d1e3              BNE      |L5.34|
00005a  fb05f007          MUL      r0,r5,r7              ;468
00005e  e7f0              B        |L5.66|
;;;470    //*****************************************************************************
                          ENDP

                  |L5.96|
000060  696e7075          DCB      "input error!\n",0
000064  74206572
000068  726f7221
00006c  0a00    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.Uart_GetKey||, CODE, READONLY, ALIGN=2

                  Uart_GetKey PROC
;;;398    
;;;399    char Uart_GetKey(void)
000000  b510              PUSH     {r4,lr}
;;;400    {
;;;401        if((USART_GetFlagStatus(CONSOLE_UART, USART_FLAG_RXNE) == SET))
000002  2120              MOVS     r1,#0x20
000004  4805              LDR      r0,|L6.28|
000006  f7fffffe          BL       USART_GetFlagStatus
00000a  2801              CMP      r0,#1
00000c  d104              BNE      |L6.24|
;;;402            return (USART_ReceiveData(CONSOLE_UART));
00000e  4803              LDR      r0,|L6.28|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c0              UXTB     r0,r0
                  |L6.22|
;;;403        else
;;;404            return 0;
;;;405    }
000016  bd10              POP      {r4,pc}
                  |L6.24|
000018  2000              MOVS     r0,#0                 ;404
00001a  e7fc              B        |L6.22|
;;;406    
                          ENDP

                  |L6.28|
                          DCD      0x40013800

                          AREA ||i.Uart_GetString||, CODE, READONLY, ALIGN=2

                  Uart_GetString PROC
;;;415    //====================================================================
;;;416    void Uart_GetString(char *string)
000000  b570              PUSH     {r4-r6,lr}
;;;417    {
000002  4604              MOV      r4,r0
;;;418        char *string2 = string;
000004  4626              MOV      r6,r4
;;;419        char c;
;;;420        while(1)
000006  e013              B        |L7.48|
                  |L7.8|
;;;421        {
;;;422            c = get_char();
000008  f7fffffe          BL       get_char
00000c  4605              MOV      r5,r0
;;;423            if(c=='\r')
00000e  2d0d              CMP      r5,#0xd
000010  d100              BNE      |L7.20|
;;;424                break;
000012  e00e              B        |L7.50|
                  |L7.20|
;;;425            else if(c=='\b')
000014  2d08              CMP      r5,#8
000016  d106              BNE      |L7.38|
;;;426            {
;;;427                if( (int)string2 < (int)string )
000018  42a6              CMP      r6,r4
00001a  da09              BGE      |L7.48|
;;;428                {
;;;429                    printf("\b \b");
00001c  a008              ADR      r0,|L7.64|
00001e  f7fffffe          BL       __2printf
;;;430                    string--;
000022  1e64              SUBS     r4,r4,#1
000024  e004              B        |L7.48|
                  |L7.38|
;;;431                }
;;;432            }
;;;433            else 
;;;434            {
;;;435                *string++ = c;
000026  f8045b01          STRB     r5,[r4],#1
;;;436                send_char(c);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       send_char
                  |L7.48|
000030  e7ea              B        |L7.8|
                  |L7.50|
000032  bf00              NOP                            ;424
;;;437            }
;;;438        }
;;;439        *string='\0';
000034  2000              MOVS     r0,#0
000036  7020              STRB     r0,[r4,#0]
;;;440        printf("\n");
000038  a002              ADR      r0,|L7.68|
00003a  f7fffffe          BL       __2printf
;;;441    }
00003e  bd70              POP      {r4-r6,pc}
;;;442    //*****************************************************************************
                          ENDP

                  |L7.64|
000040  08200800          DCB      "\b \b",0
                  |L7.68|
000044  0a00              DCB      "\n",0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.Uart_SendByte||, CODE, READONLY, ALIGN=2

                  Uart_SendByte PROC
;;;406    
;;;407    void Uart_SendByte(u8 ch)
000000  b510              PUSH     {r4,lr}
;;;408    {
000002  4604              MOV      r4,r0
;;;409        USART_SendData(CONSOLE_UART, (u8) ch);
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L8.28|
000008  f7fffffe          BL       USART_SendData
;;;410        while(USART_GetFlagStatus(CONSOLE_UART, USART_FLAG_TC) == RESET);
00000c  bf00              NOP      
                  |L8.14|
00000e  2140              MOVS     r1,#0x40
000010  4802              LDR      r0,|L8.28|
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L8.14|
;;;411    }
00001a  bd10              POP      {r4,pc}
;;;412    
                          ENDP

                  |L8.28|
                          DCD      0x40013800

                          AREA ||i.adc_init||, CODE, READONLY, ALIGN=2

                  adc_init PROC
;;;208    ErrorStatus HSEStartUpStatus;
;;;209    void adc_init()
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211        /* DMA1 channel1 configuration*/
;;;212        DMA_DeInit(DMA1_Channel1);
000002  482f              LDR      r0,|L9.192|
000004  f7fffffe          BL       DMA_DeInit
;;;213        DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
000008  482e              LDR      r0,|L9.196|
00000a  492f              LDR      r1,|L9.200|
00000c  6008              STR      r0,[r1,#0]  ; DMA_InitStructure
;;;214        DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADCConvertedValue;
00000e  482f              LDR      r0,|L9.204|
000010  6048              STR      r0,[r1,#4]  ; DMA_InitStructure
;;;215        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000012  2000              MOVS     r0,#0
000014  6088              STR      r0,[r1,#8]  ; DMA_InitStructure
;;;216        DMA_InitStructure.DMA_BufferSize = 1;
000016  2001              MOVS     r0,#1
000018  60c8              STR      r0,[r1,#0xc]  ; DMA_InitStructure
;;;217        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00001a  2000              MOVS     r0,#0
00001c  6108              STR      r0,[r1,#0x10]  ; DMA_InitStructure
;;;218        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
00001e  6148              STR      r0,[r1,#0x14]  ; DMA_InitStructure
;;;219        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000020  f44f7080          MOV      r0,#0x100
000024  6188              STR      r0,[r1,#0x18]  ; DMA_InitStructure
;;;220        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000026  0080              LSLS     r0,r0,#2
000028  61c8              STR      r0,[r1,#0x1c]  ; DMA_InitStructure
;;;221        DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
00002a  2020              MOVS     r0,#0x20
00002c  6208              STR      r0,[r1,#0x20]  ; DMA_InitStructure
;;;222        DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00002e  0200              LSLS     r0,r0,#8
000030  6248              STR      r0,[r1,#0x24]  ; DMA_InitStructure
;;;223        DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000032  2000              MOVS     r0,#0
000034  6288              STR      r0,[r1,#0x28]  ; DMA_InitStructure
;;;224        DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000036  4822              LDR      r0,|L9.192|
000038  f7fffffe          BL       DMA_Init
;;;225    
;;;226        /* Enable DMA1 channel1 */
;;;227        DMA_Cmd(DMA1_Channel1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  4820              LDR      r0,|L9.192|
000040  f7fffffe          BL       DMA_Cmd
;;;228    
;;;229        /* ADC1 configuration ------------------------------------------------------*/
;;;230        ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000044  2000              MOVS     r0,#0
000046  4922              LDR      r1,|L9.208|
000048  6008              STR      r0,[r1,#0]  ; ADC_InitStructure
;;;231        ADC_InitStructure.ADC_ScanConvMode = ENABLE;
00004a  2001              MOVS     r0,#1
00004c  7108              STRB     r0,[r1,#4]
;;;232        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
00004e  7148              STRB     r0,[r1,#5]
;;;233        ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
000050  f44f2060          MOV      r0,#0xe0000
000054  6088              STR      r0,[r1,#8]  ; ADC_InitStructure
;;;234        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000056  2000              MOVS     r0,#0
000058  60c8              STR      r0,[r1,#0xc]  ; ADC_InitStructure
;;;235        ADC_InitStructure.ADC_NbrOfChannel = 1;
00005a  2001              MOVS     r0,#1
00005c  7408              STRB     r0,[r1,#0x10]
;;;236        ADC_Init(ADC1, &ADC_InitStructure);
00005e  4819              LDR      r0,|L9.196|
000060  384c              SUBS     r0,r0,#0x4c
000062  f7fffffe          BL       ADC_Init
;;;237        /* ADC1 regular channel13 configuration */
;;;238        ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 1, ADC_SampleTime_55Cycles5);
000066  2305              MOVS     r3,#5
000068  2201              MOVS     r2,#1
00006a  210d              MOVS     r1,#0xd
00006c  4815              LDR      r0,|L9.196|
00006e  384c              SUBS     r0,r0,#0x4c
000070  f7fffffe          BL       ADC_RegularChannelConfig
;;;239    
;;;240        /* Enable ADC1 DMA */
;;;241        ADC_DMACmd(ADC1, ENABLE);
000074  2101              MOVS     r1,#1
000076  4813              LDR      r0,|L9.196|
000078  384c              SUBS     r0,r0,#0x4c
00007a  f7fffffe          BL       ADC_DMACmd
;;;242    
;;;243        /* Enable ADC1 */
;;;244        ADC_Cmd(ADC1, ENABLE);
00007e  2101              MOVS     r1,#1
000080  4810              LDR      r0,|L9.196|
000082  384c              SUBS     r0,r0,#0x4c
000084  f7fffffe          BL       ADC_Cmd
;;;245    
;;;246        /* Enable ADC1 reset calibaration register */
;;;247        ADC_ResetCalibration(ADC1);
000088  480e              LDR      r0,|L9.196|
00008a  384c              SUBS     r0,r0,#0x4c
00008c  f7fffffe          BL       ADC_ResetCalibration
;;;248        /* Check the end of ADC1 reset calibration register */
;;;249        while(ADC_GetResetCalibrationStatus(ADC1));
000090  bf00              NOP      
                  |L9.146|
000092  480c              LDR      r0,|L9.196|
000094  384c              SUBS     r0,r0,#0x4c
000096  f7fffffe          BL       ADC_GetResetCalibrationStatus
00009a  2800              CMP      r0,#0
00009c  d1f9              BNE      |L9.146|
;;;250    
;;;251        /* Start ADC1 calibaration */
;;;252        ADC_StartCalibration(ADC1);
00009e  4809              LDR      r0,|L9.196|
0000a0  384c              SUBS     r0,r0,#0x4c
0000a2  f7fffffe          BL       ADC_StartCalibration
;;;253        /* Check the end of ADC1 calibration */
;;;254        while(ADC_GetCalibrationStatus(ADC1));
0000a6  bf00              NOP      
                  |L9.168|
0000a8  4806              LDR      r0,|L9.196|
0000aa  384c              SUBS     r0,r0,#0x4c
0000ac  f7fffffe          BL       ADC_GetCalibrationStatus
0000b0  2800              CMP      r0,#0
0000b2  d1f9              BNE      |L9.168|
;;;255    
;;;256        /* Start ADC1 Software Conversion */
;;;257        ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  4803              LDR      r0,|L9.196|
0000b8  384c              SUBS     r0,r0,#0x4c
0000ba  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;258    
;;;259    }
0000be  bd10              POP      {r4,pc}
;;;260    
                          ENDP

                  |L9.192|
                          DCD      0x40020008
                  |L9.196|
                          DCD      0x4001244c
                  |L9.200|
                          DCD      DMA_InitStructure
                  |L9.204|
                          DCD      ADCConvertedValue
                  |L9.208|
                          DCD      ADC_InitStructure

                          AREA ||i.assert_failed||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  assert_failed PROC
;;;373    *******************************************************************************/
;;;374    void assert_failed(u8* file, u32 line)
000000  4604              MOV      r4,r0
;;;375    { 
000002  460d              MOV      r5,r1
;;;376        /* User can add his own implementation to report the file name and line number */
;;;377    
;;;378        printf("\n\r Wrong parameter value detected on\r\n");
000004  a006              ADR      r0,|L10.32|
000006  f7fffffe          BL       __2printf
;;;379        printf("       file  %s\n", file);
00000a  4621              MOV      r1,r4
00000c  a00e              ADR      r0,|L10.72|
00000e  f7fffffe          BL       __2printf
;;;380        printf("       line  %d\n", line);
000012  4629              MOV      r1,r5
000014  a011              ADR      r0,|L10.92|
000016  f7fffffe          BL       __2printf
;;;381        while (1){
00001a  bf00              NOP      
                  |L10.28|
00001c  e7fe              B        |L10.28|
;;;382        }
;;;383    }
;;;384    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
000020  0a0d2057          DCB      "\n\r Wrong parameter value detected on\r\n",0
000024  726f6e67
000028  20706172
00002c  616d6574
000030  65722076
000034  616c7565
000038  20646574
00003c  65637465
000040  64206f6e
000044  0d0a00  
000047  00                DCB      0
                  |L10.72|
000048  20202020          DCB      "       file  %s\n",0
00004c  20202066
000050  696c6520
000054  2025730a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L10.92|
00005c  20202020          DCB      "       line  %d\n",0
000060  2020206c
000064  696e6520
000068  2025640a
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.dbg_void||, CODE, READONLY, ALIGN=1

                  dbg_void PROC
;;;475    /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
;;;476    void dbg_void(void)
000000  4770              BX       lr
;;;477    {
;;;478        return;
;;;479    }
;;;480    void print_void(void *fmt,...)
                          ENDP


                          AREA ||i.debug_data_stream||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  debug_data_stream PROC
;;;483    }
;;;484    void debug_data_stream(char *info,char *pdata,u16 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;485    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;486        u16 i;
;;;487        printf("%s(len=%d):\n",info,len);
00000a  463a              MOV      r2,r7
00000c  4631              MOV      r1,r6
00000e  a00e              ADR      r0,|L12.72|
000010  f7fffffe          BL       __2printf
;;;488        for(i=0;i<len;i++){
000014  2400              MOVS     r4,#0
000016  e010              B        |L12.58|
                  |L12.24|
;;;489            if((!(i%10))&&(i))
000018  200a              MOVS     r0,#0xa
00001a  fb94f1f0          SDIV     r1,r4,r0
00001e  fb004011          MLS      r0,r0,r1,r4
000022  b918              CBNZ     r0,|L12.44|
000024  b114              CBZ      r4,|L12.44|
;;;490                printf("\n");
000026  a00c              ADR      r0,|L12.88|
000028  f7fffffe          BL       __2printf
                  |L12.44|
;;;491            printf("0x%2x     ",*pdata++);
00002c  f8151b01          LDRB     r1,[r5],#1
000030  a00a              ADR      r0,|L12.92|
000032  f7fffffe          BL       __2printf
000036  1c60              ADDS     r0,r4,#1              ;488
000038  b284              UXTH     r4,r0                 ;488
                  |L12.58|
00003a  42bc              CMP      r4,r7                 ;488
00003c  dbec              BLT      |L12.24|
;;;492        }
;;;493        printf("\n");
00003e  a006              ADR      r0,|L12.88|
000040  f7fffffe          BL       __2printf
;;;494    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;495    
                          ENDP

                  |L12.72|
000048  2573286c          DCB      "%s(len=%d):\n",0
00004c  656e3d25
000050  64293a0a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L12.88|
000058  0a00              DCB      "\n",0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L12.92|
00005c  30782532          DCB      "0x%2x     ",0
000060  78202020
000064  202000  
000067  00                DCB      0

                          AREA ||i.disable_timer||, CODE, READONLY, ALIGN=1

                  disable_timer PROC
;;;319    }
;;;320    void disable_timer(void)
000000  b510              PUSH     {r4,lr}
;;;321    {
;;;322        TIM_Cmd(TIM2, DISABLE);
000002  2100              MOVS     r1,#0
000004  f04f4080          MOV      r0,#0x40000000
000008  f7fffffe          BL       TIM_Cmd
;;;323    }
00000c  bd10              POP      {r4,pc}
;;;324    
                          ENDP


                          AREA ||i.enable_timer||, CODE, READONLY, ALIGN=1

                  enable_timer PROC
;;;315    /*********************定时器3供lwip tcp使用*****************************************************/
;;;316    void enable_timer(void)
000000  b510              PUSH     {r4,lr}
;;;317    {
;;;318        TIM_Cmd(TIM2, ENABLE);
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       TIM_Cmd
;;;319    }
00000a  bd10              POP      {r4,pc}
;;;320    void disable_timer(void)
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;349    *******************************************************************************/
;;;350    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;351    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;352        /* Place your implementation of fputc here */
;;;353        /* e.g. write a character to the USART */
;;;354        while(USART_GetFlagStatus(CONSOLE_UART, USART_FLAG_TC) == RESET){
000006  bf00              NOP      
                  |L15.8|
000008  2140              MOVS     r1,#0x40
00000a  480c              LDR      r0,|L15.60|
00000c  f7fffffe          BL       USART_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0f9              BEQ      |L15.8|
;;;355        }
;;;356        if(ch=='\n')
000014  2c0a              CMP      r4,#0xa
000016  d103              BNE      |L15.32|
;;;357            fputc('\r',f);
000018  4629              MOV      r1,r5
00001a  200d              MOVS     r0,#0xd
00001c  f7fffffe          BL       fputc
                  |L15.32|
;;;358        USART_SendData(CONSOLE_UART, (u8)ch);
000020  b2e1              UXTB     r1,r4
000022  4806              LDR      r0,|L15.60|
000024  f7fffffe          BL       USART_SendData
;;;359        /* Loop until the end of transmission */
;;;360        while(USART_GetFlagStatus(CONSOLE_UART, USART_FLAG_TC) == RESET){
000028  bf00              NOP      
                  |L15.42|
00002a  2140              MOVS     r1,#0x40
00002c  4803              LDR      r0,|L15.60|
00002e  f7fffffe          BL       USART_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L15.42|
;;;361        }
;;;362        return ch;
000036  4620              MOV      r0,r4
;;;363    }
000038  bd70              POP      {r4-r6,pc}
;;;364    
                          ENDP

00003a  0000              DCW      0x0000
                  |L15.60|
                          DCD      0x40013800

                          AREA ||i.get_adcval||, CODE, READONLY, ALIGN=2

                  get_adcval PROC
;;;260    
;;;261    int get_adcval()
000000  b510              PUSH     {r4,lr}
;;;262    {
;;;263        return ADC_GetConversionValue(ADC1);
000002  4802              LDR      r0,|L16.12|
000004  f7fffffe          BL       ADC_GetConversionValue
;;;264    }
000008  bd10              POP      {r4,pc}
;;;265    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40012400

                          AREA ||i.get_char||, CODE, READONLY, ALIGN=2

                  get_char PROC
;;;390    
;;;391    char get_char(void)
000000  b510              PUSH     {r4,lr}
;;;392    {
;;;393        while(!(USART_GetFlagStatus(CONSOLE_UART, USART_FLAG_RXNE) == SET)){
000002  bf00              NOP      
                  |L17.4|
000004  2120              MOVS     r1,#0x20
000006  4805              LDR      r0,|L17.28|
000008  f7fffffe          BL       USART_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d1f9              BNE      |L17.4|
;;;394        }
;;;395        return (USART_ReceiveData(CONSOLE_UART));
000010  4802              LDR      r0,|L17.28|
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c0              UXTB     r0,r0
;;;396    }
000018  bd10              POP      {r4,pc}
;;;397    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40013800

                          AREA ||i.print_void||, CODE, READONLY, ALIGN=1

                  print_void PROC
;;;479    }
;;;480    void print_void(void *fmt,...)
000000  4770              BX       lr
;;;481    {
;;;482        return;
;;;483    }
;;;484    void debug_data_stream(char *info,char *pdata,u16 len)
                          ENDP


                          AREA ||i.read_flash||, CODE, READONLY, ALIGN=1

                  read_flash PROC
;;;517    }
;;;518    int read_flash(u32 StartAddr,u16 *buf,u16 len)
000000  b530              PUSH     {r4,r5,lr}
;;;519    {
000002  4603              MOV      r3,r0
;;;520        u16 *p=(u16 *)StartAddr;
000004  461c              MOV      r4,r3
;;;521        len=(len+1)/2;
000006  1c50              ADDS     r0,r2,#1
000008  eb0075d0          ADD      r5,r0,r0,LSR #31
00000c  f3c5024f          UBFX     r2,r5,#1,#16
;;;522        while(len--){
000010  e003              B        |L19.26|
                  |L19.18|
;;;523            *buf++=*p++;
000012  f8340b02          LDRH     r0,[r4],#2
000016  f8210b02          STRH     r0,[r1],#2
                  |L19.26|
00001a  0010              MOVS     r0,r2                 ;522
00001c  f1a20501          SUB      r5,r2,#1              ;522
000020  b2aa              UXTH     r2,r5                 ;522
000022  d1f6              BNE      |L19.18|
;;;524        }
;;;525        return 0;
;;;526    }
000024  bd30              POP      {r4,r5,pc}
;;;527    
                          ENDP


                          AREA ||i.send_char||, CODE, READONLY, ALIGN=2

                  send_char PROC
;;;384    
;;;385    void send_char(char ch)
000000  b510              PUSH     {r4,lr}
;;;386    {
000002  4604              MOV      r4,r0
;;;387        USART_SendData(CONSOLE_UART, (u8) ch);
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L20.28|
000008  f7fffffe          BL       USART_SendData
;;;388        while(USART_GetFlagStatus(CONSOLE_UART, USART_FLAG_TC) == RESET);
00000c  bf00              NOP      
                  |L20.14|
00000e  2140              MOVS     r1,#0x40
000010  4802              LDR      r0,|L20.28|
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L20.14|
;;;389    }
00001a  bd10              POP      {r4,pc}
;;;390    
                          ENDP

                  |L20.28|
                          DCD      0x40013800

                          AREA ||i.timerbase_config||, CODE, READONLY, ALIGN=1

                  timerbase_config PROC
;;;324    
;;;325    void timerbase_config(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;326    {
;;;327        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;328        /*timer2 for uart process*/
;;;329        /* Time base configuration */
;;;330        TIM_TimeBaseStructure.TIM_Period =TCP_TMR_INTERVAL*10;//250ms SYS TIMER
000002  f64010c4          MOV      r0,#0x9c4
000006  f8ad0004          STRH     r0,[sp,#4]
;;;331        TIM_TimeBaseStructure.TIM_Prescaler = 0;//10k
00000a  2000              MOVS     r0,#0
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;332        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000010  f8ad0006          STRH     r0,[sp,#6]
;;;333        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
000014  f8ad0002          STRH     r0,[sp,#2]
;;;334        TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
000018  4669              MOV      r1,sp
00001a  f04f4080          MOV      r0,#0x40000000
00001e  f7fffffe          BL       TIM_TimeBaseInit
;;;335        /* Prescaler configuration 0~65535(128M/(per+1))=128M/(127+1)=1M*/
;;;336        TIM_PrescalerConfig(TIM2,7199, TIM_PSCReloadMode_Immediate); //10k
000022  2201              MOVS     r2,#1
000024  f641411f          MOV      r1,#0x1c1f
000028  0790              LSLS     r0,r2,#30
00002a  f7fffffe          BL       TIM_PrescalerConfig
;;;337        /* TIM IT enable */
;;;338        TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); //TIM_IT_CC1
00002e  2201              MOVS     r2,#1
000030  4611              MOV      r1,r2
000032  0790              LSLS     r0,r2,#30
000034  f7fffffe          BL       TIM_ITConfig
;;;339        TIM_Cmd(TIM2, ENABLE);
000038  2101              MOVS     r1,#1
00003a  0788              LSLS     r0,r1,#30
00003c  f7fffffe          BL       TIM_Cmd
;;;340    }
000040  bd0e              POP      {r1-r3,pc}
;;;341    
                          ENDP


                          AREA ||i.watch_dog_config||, CODE, READONLY, ALIGN=1

                  watch_dog_config PROC
;;;86     *******************************************************************************/
;;;87     void watch_dog_config(void)
000000  b510              PUSH     {r4,lr}
;;;88     {
;;;89         /* Enable write access to IWDG_PR and IWDG_RLR registers */
;;;90         IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
000002  f2455055          MOV      r0,#0x5555
000006  f7fffffe          BL       IWDG_WriteAccessCmd
;;;91         /* IWDG counter clock: 32KHz(LSI) / 32 = 1KHz */
;;;92         IWDG_SetPrescaler(IWDG_Prescaler_128);
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       IWDG_SetPrescaler
;;;93         /* Set counter reload value T=(fn(分频系数)/4)*0.1*RLR(重新装载值)  */
;;;94         IWDG_SetReload(0xffff);	  //500ms
000010  f64f70ff          MOV      r0,#0xffff
000014  f7fffffe          BL       IWDG_SetReload
;;;95         /* Reload IWDG counter喂狗 */
;;;96         IWDG_ReloadCounter();
000018  f7fffffe          BL       IWDG_ReloadCounter
;;;97         //IWDG_Enable();
;;;98     
;;;99     }
00001c  bd10              POP      {r4,pc}
;;;100    
                          ENDP


                          AREA ||i.write_flash||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  write_flash PROC
;;;497    /****************读写默认配置flash***********************************************/
;;;498    int write_flash(u32 StartAddr,u16 *buf,u16 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;499    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;500        volatile FLASH_Status FLASHStatus;
;;;501        u32 FlashAddr;
;;;502        len=(len+1)/2;
00000a  1c70              ADDS     r0,r6,#1
00000c  eb0071d0          ADD      r1,r0,r0,LSR #31
000010  f3c1064f          UBFX     r6,r1,#1,#16
;;;503        FLASH_Unlock();
000014  f7fffffe          BL       FLASH_Unlock
;;;504        FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
000018  2035              MOVS     r0,#0x35
00001a  f7fffffe          BL       FLASH_ClearFlag
;;;505        FlashAddr=StartAddr;
00001e  46b8              MOV      r8,r7
;;;506        FLASH_ErasePage(StartAddr);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       FLASH_ErasePage
;;;507        while(len--){
000026  e011              B        |L23.76|
                  |L23.40|
;;;508            FLASHStatus = FLASH_ProgramHalfWord(FlashAddr,*buf++);
000028  f8351b02          LDRH     r1,[r5],#2
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       FLASH_ProgramHalfWord
000032  4604              MOV      r4,r0
;;;509            if (FLASHStatus != FLASH_COMPLETE){
000034  2c04              CMP      r4,#4
000036  d007              BEQ      |L23.72|
;;;510                printf("FLSH :Error %08X\n\r",FLASHStatus);
000038  4621              MOV      r1,r4
00003a  a009              ADR      r0,|L23.96|
00003c  f7fffffe          BL       __2printf
;;;511                return -1;
000040  f04f30ff          MOV      r0,#0xffffffff
                  |L23.68|
;;;512            }
;;;513            FlashAddr += 2;
;;;514        }
;;;515        FLASH_Lock();
;;;516        return 0;
;;;517    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L23.72|
000048  f1080802          ADD      r8,r8,#2              ;513
                  |L23.76|
00004c  0030              MOVS     r0,r6                 ;507
00004e  f1a60101          SUB      r1,r6,#1              ;507
000052  b28e              UXTH     r6,r1                 ;507
000054  d1e8              BNE      |L23.40|
000056  f7fffffe          BL       FLASH_Lock
00005a  2000              MOVS     r0,#0                 ;516
00005c  e7f2              B        |L23.68|
;;;518    int read_flash(u32 StartAddr,u16 *buf,u16 len)
                          ENDP

00005e  0000              DCW      0x0000
                  |L23.96|
000060  464c5348          DCB      "FLSH :Error %08X\n\r",0
000064  203a4572
000068  726f7220
00006c  25303858
000070  0a0d00  
000073  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ADC_InitStructure
                          %        20
                  DMA_InitStructure
                          %        44

                          AREA ||.data||, DATA, ALIGN=1

                  ADCConvertedValue
000000  0000              DCB      0x00,0x00
                  HSEStartUpStatus
000002  00                DCB      0x00
