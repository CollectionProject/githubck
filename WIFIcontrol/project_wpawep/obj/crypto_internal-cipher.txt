; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\crypto_internal-cipher.o --depend=.\obj\crypto_internal-cipher.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\crypto_internal-cipher.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\crypto\crypto_internal-cipher.c]
                          THUMB

                          AREA ||i.crypto_cipher_decrypt||, CODE, READONLY, ALIGN=1

                  crypto_cipher_decrypt PROC
;;;178    
;;;179    int crypto_cipher_decrypt(struct crypto_cipher *ctx, const u8 *crypt,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;180    			  u8 *plain, size_t len)
;;;181    {
000004  b08a              SUB      sp,sp,#0x28
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;182    	size_t i, j, blocks;
;;;183    	u8 tmp[32];
;;;184    
;;;185    	switch (ctx->alg) {
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d018              BEQ      |L1.70|
000014  2802              CMP      r0,#2
000016  d04a              BEQ      |L1.174|
000018  2803              CMP      r0,#3
00001a  d078              BEQ      |L1.270|
00001c  2805              CMP      r0,#5
00001e  d175              BNE      |L1.268|
;;;186    	case CRYPTO_CIPHER_ALG_RC4:
;;;187    		if (plain != crypt)
000020  454e              CMP      r6,r9
000022  d004              BEQ      |L1.46|
;;;188    			os_memcpy(plain, crypt, len);
000024  463a              MOV      r2,r7
000026  4649              MOV      r1,r9
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       __aeabi_memcpy
                  |L1.46|
;;;189    		rc4_skip(ctx->u.rc4.key, ctx->u.rc4.keylen,
00002e  9700              STR      r7,[sp,#0]
000030  4633              MOV      r3,r6
000032  f1040008          ADD      r0,r4,#8
000036  6862              LDR      r2,[r4,#4]
000038  69a1              LDR      r1,[r4,#0x18]
00003a  f7fffffe          BL       rc4_skip
;;;190    			 ctx->u.rc4.used_bytes, plain, len);
;;;191    		ctx->u.rc4.used_bytes += len;
00003e  6860              LDR      r0,[r4,#4]
000040  4438              ADD      r0,r0,r7
000042  6060              STR      r0,[r4,#4]
;;;192    		break;
000044  e095              B        |L1.370|
                  |L1.70|
;;;193    	case CRYPTO_CIPHER_ALG_AES:
;;;194    		if (len % ctx->u.aes.block_size)
000046  6a60              LDR      r0,[r4,#0x24]
000048  fbb7f1f0          UDIV     r1,r7,r0
00004c  fb007011          MLS      r0,r0,r1,r7
000050  b120              CBZ      r0,|L1.92|
;;;195    			return -1;
000052  f04f30ff          MOV      r0,#0xffffffff
                  |L1.86|
;;;196    		blocks = len / ctx->u.aes.block_size;
;;;197    		for (i = 0; i < blocks; i++) {
;;;198    			os_memcpy(tmp, crypt, ctx->u.aes.block_size);
;;;199    			aes_decrypt(ctx->u.aes.ctx_dec, crypt, plain);
;;;200    			for (j = 0; j < ctx->u.aes.block_size; j++)
;;;201    				plain[j] ^= ctx->u.aes.cbc[j];
;;;202    			os_memcpy(ctx->u.aes.cbc, tmp, ctx->u.aes.block_size);
;;;203    			plain += ctx->u.aes.block_size;
;;;204    			crypt += ctx->u.aes.block_size;
;;;205    		}
;;;206    		break;
;;;207    	case CRYPTO_CIPHER_ALG_3DES:
;;;208    		if (len % 8)
;;;209    			return -1;
;;;210    		blocks = len / 8;
;;;211    		for (i = 0; i < blocks; i++) {
;;;212    			os_memcpy(tmp, crypt, 8);
;;;213    			des3_decrypt(crypt, &ctx->u.des3.key, plain);
;;;214    			for (j = 0; j < 8; j++)
;;;215    				plain[j] ^= ctx->u.des3.cbc[j];
;;;216    			os_memcpy(ctx->u.des3.cbc, tmp, 8);
;;;217    			plain += 8;
;;;218    			crypt += 8;
;;;219    		}
;;;220    		break;
;;;221    	case CRYPTO_CIPHER_ALG_DES:
;;;222    		if (len % 8)
;;;223    			return -1;
;;;224    		blocks = len / 8;
;;;225    		for (i = 0; i < blocks; i++) {
;;;226    			os_memcpy(tmp, crypt, 8);
;;;227    			des_block_decrypt(crypt, ctx->u.des.dk, plain);
;;;228    			for (j = 0; j < 8; j++)
;;;229    				plain[j] ^= ctx->u.des.cbc[j];
;;;230    			os_memcpy(ctx->u.des.cbc, tmp, 8);
;;;231    			plain += 8;
;;;232    			crypt += 8;
;;;233    		}
;;;234    		break;
;;;235    	default:
;;;236    		return -1;
;;;237    	}
;;;238    
;;;239    	return 0;
;;;240    }
000056  b00a              ADD      sp,sp,#0x28
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L1.92|
00005c  6a60              LDR      r0,[r4,#0x24]         ;196
00005e  fbb7faf0          UDIV     r10,r7,r0             ;196
000062  f04f0800          MOV      r8,#0                 ;197
000066  e01f              B        |L1.168|
                  |L1.104|
000068  4649              MOV      r1,r9                 ;198
00006a  a802              ADD      r0,sp,#8              ;198
00006c  6a62              LDR      r2,[r4,#0x24]         ;198
00006e  f7fffffe          BL       __aeabi_memcpy
000072  4632              MOV      r2,r6                 ;199
000074  4649              MOV      r1,r9                 ;199
000076  6ae0              LDR      r0,[r4,#0x2c]         ;199
000078  f7fffffe          BL       aes_decrypt
00007c  2500              MOVS     r5,#0                 ;200
00007e  e005              B        |L1.140|
                  |L1.128|
000080  5d70              LDRB     r0,[r6,r5]            ;201
000082  1d21              ADDS     r1,r4,#4              ;201
000084  5d49              LDRB     r1,[r1,r5]            ;201
000086  4048              EORS     r0,r0,r1              ;201
000088  5570              STRB     r0,[r6,r5]            ;201
00008a  1c6d              ADDS     r5,r5,#1              ;200
                  |L1.140|
00008c  6a60              LDR      r0,[r4,#0x24]         ;200
00008e  42a8              CMP      r0,r5                 ;200
000090  d8f6              BHI      |L1.128|
000092  a902              ADD      r1,sp,#8              ;202
000094  1d20              ADDS     r0,r4,#4              ;202
000096  6a62              LDR      r2,[r4,#0x24]         ;202
000098  f7fffffe          BL       __aeabi_memcpy4
00009c  6a60              LDR      r0,[r4,#0x24]         ;203
00009e  4406              ADD      r6,r6,r0              ;203
0000a0  6a60              LDR      r0,[r4,#0x24]         ;204
0000a2  4481              ADD      r9,r9,r0              ;204
0000a4  f1080801          ADD      r8,r8,#1              ;197
                  |L1.168|
0000a8  45d0              CMP      r8,r10                ;197
0000aa  d3dd              BCC      |L1.104|
0000ac  e061              B        |L1.370|
                  |L1.174|
0000ae  f0170f07          TST      r7,#7                 ;208
0000b2  d002              BEQ      |L1.186|
0000b4  f04f30ff          MOV      r0,#0xffffffff        ;209
0000b8  e7cd              B        |L1.86|
                  |L1.186|
0000ba  ea4f0ad7          LSR      r10,r7,#3             ;210
0000be  f04f0800          MOV      r8,#0                 ;211
0000c2  e01f              B        |L1.260|
                  |L1.196|
0000c4  f8d90000          LDR      r0,[r9,#0]            ;212
0000c8  9002              STR      r0,[sp,#8]            ;212
0000ca  f8d90004          LDR      r0,[r9,#4]            ;212
0000ce  9003              STR      r0,[sp,#0xc]          ;212
0000d0  4632              MOV      r2,r6                 ;213
0000d2  1d21              ADDS     r1,r4,#4              ;213
0000d4  4648              MOV      r0,r9                 ;213
0000d6  f7fffffe          BL       des3_decrypt
0000da  2500              MOVS     r5,#0                 ;214
0000dc  e006              B        |L1.236|
                  |L1.222|
0000de  5d71              LDRB     r1,[r6,r5]            ;215
0000e0  f5047041          ADD      r0,r4,#0x304          ;215
0000e4  5d40              LDRB     r0,[r0,r5]            ;215
0000e6  4048              EORS     r0,r0,r1              ;215
0000e8  5570              STRB     r0,[r6,r5]            ;215
0000ea  1c6d              ADDS     r5,r5,#1              ;214
                  |L1.236|
0000ec  2d08              CMP      r5,#8                 ;214
0000ee  d3f6              BCC      |L1.222|
0000f0  f5047041          ADD      r0,r4,#0x304          ;216
0000f4  e9dd1202          LDRD     r1,r2,[sp,#8]         ;216
0000f8  c006              STM      r0!,{r1,r2}           ;216
0000fa  3608              ADDS     r6,r6,#8              ;217
0000fc  f1090908          ADD      r9,r9,#8              ;218
000100  f1080801          ADD      r8,r8,#1              ;211
                  |L1.260|
000104  45d0              CMP      r8,r10                ;211
000106  d3dd              BCC      |L1.196|
000108  e033              B        |L1.370|
00010a  e000              B        |L1.270|
                  |L1.268|
00010c  e02e              B        |L1.364|
                  |L1.270|
00010e  f0170f07          TST      r7,#7                 ;222
000112  d002              BEQ      |L1.282|
000114  f04f30ff          MOV      r0,#0xffffffff        ;223
000118  e79d              B        |L1.86|
                  |L1.282|
00011a  ea4f0ad7          LSR      r10,r7,#3             ;224
00011e  f04f0800          MOV      r8,#0                 ;225
000122  e020              B        |L1.358|
                  |L1.292|
000124  f8d90000          LDR      r0,[r9,#0]            ;226
000128  9002              STR      r0,[sp,#8]            ;226
00012a  f8d90004          LDR      r0,[r9,#4]            ;226
00012e  9003              STR      r0,[sp,#0xc]          ;226
000130  4632              MOV      r2,r6                 ;227
000132  f1040184          ADD      r1,r4,#0x84           ;227
000136  4648              MOV      r0,r9                 ;227
000138  f7fffffe          BL       des_block_decrypt
00013c  2500              MOVS     r5,#0                 ;228
00013e  e006              B        |L1.334|
                  |L1.320|
000140  5d71              LDRB     r1,[r6,r5]            ;229
000142  f5047082          ADD      r0,r4,#0x104          ;229
000146  5d40              LDRB     r0,[r0,r5]            ;229
000148  4048              EORS     r0,r0,r1              ;229
00014a  5570              STRB     r0,[r6,r5]            ;229
00014c  1c6d              ADDS     r5,r5,#1              ;228
                  |L1.334|
00014e  2d08              CMP      r5,#8                 ;228
000150  d3f6              BCC      |L1.320|
000152  f5047082          ADD      r0,r4,#0x104          ;230
000156  e9dd1202          LDRD     r1,r2,[sp,#8]         ;230
00015a  c006              STM      r0!,{r1,r2}           ;230
00015c  3608              ADDS     r6,r6,#8              ;231
00015e  f1090908          ADD      r9,r9,#8              ;232
000162  f1080801          ADD      r8,r8,#1              ;225
                  |L1.358|
000166  45d0              CMP      r8,r10                ;225
000168  d3dc              BCC      |L1.292|
00016a  e002              B        |L1.370|
                  |L1.364|
00016c  f04f30ff          MOV      r0,#0xffffffff        ;236
000170  e771              B        |L1.86|
                  |L1.370|
000172  bf00              NOP                            ;192
000174  2000              MOVS     r0,#0                 ;239
000176  e76e              B        |L1.86|
;;;241    
                          ENDP


                          AREA ||i.crypto_cipher_deinit||, CODE, READONLY, ALIGN=1

                  crypto_cipher_deinit PROC
;;;242    
;;;243    void crypto_cipher_deinit(struct crypto_cipher *ctx)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245    	switch (ctx->alg) {
000004  7820              LDRB     r0,[r4,#0]
000006  2801              CMP      r0,#1
000008  d002              BEQ      |L2.16|
00000a  2802              CMP      r0,#2
00000c  d108              BNE      |L2.32|
00000e  e006              B        |L2.30|
                  |L2.16|
;;;246    	case CRYPTO_CIPHER_ALG_AES:
;;;247    		aes_encrypt_deinit(ctx->u.aes.ctx_enc);
000010  6aa0              LDR      r0,[r4,#0x28]
000012  f7fffffe          BL       aes_encrypt_deinit
;;;248    		aes_decrypt_deinit(ctx->u.aes.ctx_dec);
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  f7fffffe          BL       aes_decrypt_deinit
;;;249    		break;
00001c  e001              B        |L2.34|
                  |L2.30|
;;;250    	case CRYPTO_CIPHER_ALG_3DES:
;;;251    		break;
00001e  e000              B        |L2.34|
                  |L2.32|
;;;252    	default:
;;;253    		break;
000020  bf00              NOP      
                  |L2.34|
000022  bf00              NOP                            ;249
;;;254    	}
;;;255    	os_free(ctx);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       os_free
;;;256    }
00002a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.crypto_cipher_encrypt||, CODE, READONLY, ALIGN=1

                  crypto_cipher_encrypt PROC
;;;114    
;;;115    int crypto_cipher_encrypt(struct crypto_cipher *ctx, const u8 *plain,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;116    			  u8 *crypt, size_t len)
;;;117    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;118    	size_t i, j, blocks;
;;;119    
;;;120    	switch (ctx->alg) {
00000c  7820              LDRB     r0,[r4,#0]
00000e  2801              CMP      r0,#1
000010  d018              BEQ      |L3.68|
000012  2802              CMP      r0,#2
000014  d046              BEQ      |L3.164|
000016  2803              CMP      r0,#3
000018  d073              BEQ      |L3.258|
00001a  2805              CMP      r0,#5
00001c  d170              BNE      |L3.256|
;;;121    	case CRYPTO_CIPHER_ALG_RC4:
;;;122    		if (plain != crypt)
00001e  45b1              CMP      r9,r6
000020  d004              BEQ      |L3.44|
;;;123    			os_memcpy(crypt, plain, len);
000022  463a              MOV      r2,r7
000024  4649              MOV      r1,r9
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       __aeabi_memcpy
                  |L3.44|
;;;124    		rc4_skip(ctx->u.rc4.key, ctx->u.rc4.keylen,
00002c  9700              STR      r7,[sp,#0]
00002e  4633              MOV      r3,r6
000030  f1040008          ADD      r0,r4,#8
000034  6862              LDR      r2,[r4,#4]
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       rc4_skip
;;;125    			 ctx->u.rc4.used_bytes, crypt, len);
;;;126    		ctx->u.rc4.used_bytes += len;
00003c  6860              LDR      r0,[r4,#4]
00003e  4438              ADD      r0,r0,r7
000040  6060              STR      r0,[r4,#4]
;;;127    		break;
000042  e08e              B        |L3.354|
                  |L3.68|
;;;128    	case CRYPTO_CIPHER_ALG_AES:
;;;129    		if (len % ctx->u.aes.block_size)
000044  6a60              LDR      r0,[r4,#0x24]
000046  fbb7f1f0          UDIV     r1,r7,r0
00004a  fb007011          MLS      r0,r0,r1,r7
00004e  b118              CBZ      r0,|L3.88|
;;;130    			return -1;
000050  f04f30ff          MOV      r0,#0xffffffff
                  |L3.84|
;;;131    		blocks = len / ctx->u.aes.block_size;
;;;132    		for (i = 0; i < blocks; i++) {
;;;133    			for (j = 0; j < ctx->u.aes.block_size; j++)
;;;134    				ctx->u.aes.cbc[j] ^= plain[j];
;;;135    			aes_encrypt(ctx->u.aes.ctx_enc, ctx->u.aes.cbc,
;;;136    				    ctx->u.aes.cbc);
;;;137    			os_memcpy(crypt, ctx->u.aes.cbc,
;;;138    				  ctx->u.aes.block_size);
;;;139    			plain += ctx->u.aes.block_size;
;;;140    			crypt += ctx->u.aes.block_size;
;;;141    		}
;;;142    		break;
;;;143    	case CRYPTO_CIPHER_ALG_3DES:
;;;144    		if (len % 8)
;;;145    			return -1;
;;;146    		blocks = len / 8;
;;;147    		for (i = 0; i < blocks; i++) {
;;;148    			for (j = 0; j < 8; j++)
;;;149    				ctx->u.des3.cbc[j] ^= plain[j];
;;;150    			des3_encrypt(ctx->u.des3.cbc, &ctx->u.des3.key,
;;;151    				     ctx->u.des3.cbc);
;;;152    			os_memcpy(crypt, ctx->u.des3.cbc, 8);
;;;153    			plain += 8;
;;;154    			crypt += 8;
;;;155    		}
;;;156    		break;
;;;157    	case CRYPTO_CIPHER_ALG_DES:
;;;158    		if (len % 8)
;;;159    			return -1;
;;;160    		blocks = len / 8;
;;;161    		for (i = 0; i < blocks; i++) {
;;;162    			for (j = 0; j < 8; j++)
;;;163    				ctx->u.des3.cbc[j] ^= plain[j];
;;;164    			des_block_encrypt(ctx->u.des.cbc, ctx->u.des.ek,
;;;165    					  ctx->u.des.cbc);
;;;166    			os_memcpy(crypt, ctx->u.des.cbc, 8);
;;;167    			plain += 8;
;;;168    			crypt += 8;
;;;169    		}
;;;170    		break;
;;;171    	default:
;;;172    		return -1;
;;;173    	}
;;;174    
;;;175    	return 0;
;;;176    }
000054  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.88|
000058  6a60              LDR      r0,[r4,#0x24]         ;131
00005a  fbb7faf0          UDIV     r10,r7,r0             ;131
00005e  f04f0800          MOV      r8,#0                 ;132
000062  e01c              B        |L3.158|
                  |L3.100|
000064  2500              MOVS     r5,#0                 ;133
000066  e007              B        |L3.120|
                  |L3.104|
000068  1d20              ADDS     r0,r4,#4              ;134
00006a  5d40              LDRB     r0,[r0,r5]            ;134
00006c  f8191005          LDRB     r1,[r9,r5]            ;134
000070  4048              EORS     r0,r0,r1              ;134
000072  1d21              ADDS     r1,r4,#4              ;134
000074  5548              STRB     r0,[r1,r5]            ;134
000076  1c6d              ADDS     r5,r5,#1              ;133
                  |L3.120|
000078  6a60              LDR      r0,[r4,#0x24]         ;133
00007a  42a8              CMP      r0,r5                 ;133
00007c  d8f4              BHI      |L3.104|
00007e  1d22              ADDS     r2,r4,#4              ;135
000080  1d21              ADDS     r1,r4,#4              ;135
000082  6aa0              LDR      r0,[r4,#0x28]         ;135
000084  f7fffffe          BL       aes_encrypt
000088  1d21              ADDS     r1,r4,#4              ;137
00008a  4630              MOV      r0,r6                 ;137
00008c  6a62              LDR      r2,[r4,#0x24]         ;137
00008e  f7fffffe          BL       __aeabi_memcpy
000092  6a60              LDR      r0,[r4,#0x24]         ;139
000094  4481              ADD      r9,r9,r0              ;139
000096  6a60              LDR      r0,[r4,#0x24]         ;140
000098  4406              ADD      r6,r6,r0              ;140
00009a  f1080801          ADD      r8,r8,#1              ;132
                  |L3.158|
00009e  45d0              CMP      r8,r10                ;132
0000a0  d3e0              BCC      |L3.100|
0000a2  e05e              B        |L3.354|
                  |L3.164|
0000a4  f0170f07          TST      r7,#7                 ;144
0000a8  d002              BEQ      |L3.176|
0000aa  f04f30ff          MOV      r0,#0xffffffff        ;145
0000ae  e7d1              B        |L3.84|
                  |L3.176|
0000b0  ea4f0ad7          LSR      r10,r7,#3             ;146
0000b4  f04f0800          MOV      r8,#0                 ;147
0000b8  e01e              B        |L3.248|
                  |L3.186|
0000ba  2500              MOVS     r5,#0                 ;148
0000bc  e009              B        |L3.210|
                  |L3.190|
0000be  f5047041          ADD      r0,r4,#0x304          ;149
0000c2  5d40              LDRB     r0,[r0,r5]            ;149
0000c4  f8191005          LDRB     r1,[r9,r5]            ;149
0000c8  4041              EORS     r1,r1,r0              ;149
0000ca  f5047041          ADD      r0,r4,#0x304          ;149
0000ce  5541              STRB     r1,[r0,r5]            ;149
0000d0  1c6d              ADDS     r5,r5,#1              ;148
                  |L3.210|
0000d2  2d08              CMP      r5,#8                 ;148
0000d4  d3f3              BCC      |L3.190|
0000d6  f5047241          ADD      r2,r4,#0x304          ;150
0000da  1d21              ADDS     r1,r4,#4              ;150
0000dc  4610              MOV      r0,r2                 ;150
0000de  f7fffffe          BL       des3_encrypt
0000e2  f8d41304          LDR      r1,[r4,#0x304]        ;152
0000e6  6031              STR      r1,[r6,#0]            ;152
0000e8  f8d40308          LDR      r0,[r4,#0x308]        ;152
0000ec  6070              STR      r0,[r6,#4]            ;152
0000ee  f1090908          ADD      r9,r9,#8              ;153
0000f2  3608              ADDS     r6,r6,#8              ;154
0000f4  f1080801          ADD      r8,r8,#1              ;147
                  |L3.248|
0000f8  45d0              CMP      r8,r10                ;147
0000fa  d3de              BCC      |L3.186|
0000fc  e031              B        |L3.354|
0000fe  e000              B        |L3.258|
                  |L3.256|
000100  e02c              B        |L3.348|
                  |L3.258|
000102  f0170f07          TST      r7,#7                 ;158
000106  d002              BEQ      |L3.270|
000108  f04f30ff          MOV      r0,#0xffffffff        ;159
00010c  e7a2              B        |L3.84|
                  |L3.270|
00010e  ea4f0ad7          LSR      r10,r7,#3             ;160
000112  f04f0800          MOV      r8,#0                 ;161
000116  e01e              B        |L3.342|
                  |L3.280|
000118  2500              MOVS     r5,#0                 ;162
00011a  e009              B        |L3.304|
                  |L3.284|
00011c  f5047041          ADD      r0,r4,#0x304          ;163
000120  5d40              LDRB     r0,[r0,r5]            ;163
000122  f8191005          LDRB     r1,[r9,r5]            ;163
000126  4041              EORS     r1,r1,r0              ;163
000128  f5047041          ADD      r0,r4,#0x304          ;163
00012c  5541              STRB     r1,[r0,r5]            ;163
00012e  1c6d              ADDS     r5,r5,#1              ;162
                  |L3.304|
000130  2d08              CMP      r5,#8                 ;162
000132  d3f3              BCC      |L3.284|
000134  f5047282          ADD      r2,r4,#0x104          ;164
000138  1d21              ADDS     r1,r4,#4              ;164
00013a  4610              MOV      r0,r2                 ;164
00013c  f7fffffe          BL       des_block_encrypt
000140  f8d41104          LDR      r1,[r4,#0x104]        ;166
000144  6031              STR      r1,[r6,#0]            ;166
000146  f8d40108          LDR      r0,[r4,#0x108]        ;166
00014a  6070              STR      r0,[r6,#4]            ;166
00014c  f1090908          ADD      r9,r9,#8              ;167
000150  3608              ADDS     r6,r6,#8              ;168
000152  f1080801          ADD      r8,r8,#1              ;161
                  |L3.342|
000156  45d0              CMP      r8,r10                ;161
000158  d3de              BCC      |L3.280|
00015a  e002              B        |L3.354|
                  |L3.348|
00015c  f04f30ff          MOV      r0,#0xffffffff        ;172
000160  e778              B        |L3.84|
                  |L3.354|
000162  bf00              NOP                            ;127
000164  2000              MOVS     r0,#0                 ;175
000166  e775              B        |L3.84|
;;;177    
                          ENDP


                          AREA ||i.crypto_cipher_init||, CODE, READONLY, ALIGN=1

                  crypto_cipher_init PROC
;;;49     
;;;50     struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;51     					  const u8 *iv, const u8 *key,
;;;52     					  size_t key_len)
;;;53     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;54     	struct crypto_cipher *ctx;
;;;55     
;;;56     	ctx = os_zalloc(sizeof(*ctx));
00000c  f44f7043          MOV      r0,#0x30c
000010  f7fffffe          BL       os_zalloc
000014  4604              MOV      r4,r0
;;;57     	if (ctx == NULL)
000016  b914              CBNZ     r4,|L4.30|
;;;58     		return NULL;
000018  2000              MOVS     r0,#0
                  |L4.26|
;;;59     
;;;60     	ctx->alg = alg;
;;;61     
;;;62     	switch (alg) {
;;;63     	case CRYPTO_CIPHER_ALG_RC4:
;;;64     		if (key_len > sizeof(ctx->u.rc4.key)) {
;;;65     			os_free(ctx);
;;;66     			return NULL;
;;;67     		}
;;;68     		ctx->u.rc4.keylen = key_len;
;;;69     		os_memcpy(ctx->u.rc4.key, key, key_len);
;;;70     		break;
;;;71     	case CRYPTO_CIPHER_ALG_AES:
;;;72     		if (key_len > sizeof(ctx->u.aes.cbc)) {
;;;73     			os_free(ctx);
;;;74     			return NULL;
;;;75     		}
;;;76     		ctx->u.aes.ctx_enc = aes_encrypt_init(key, key_len);
;;;77     		if (ctx->u.aes.ctx_enc == NULL) {
;;;78     			os_free(ctx);
;;;79     			return NULL;
;;;80     		}
;;;81     		ctx->u.aes.ctx_dec = aes_decrypt_init(key, key_len);
;;;82     		if (ctx->u.aes.ctx_dec == NULL) {
;;;83     			aes_encrypt_deinit(ctx->u.aes.ctx_enc);
;;;84     			os_free(ctx);
;;;85     			return NULL;
;;;86     		}
;;;87     		ctx->u.aes.block_size = key_len;
;;;88     		os_memcpy(ctx->u.aes.cbc, iv, ctx->u.aes.block_size);
;;;89     		break;
;;;90     	case CRYPTO_CIPHER_ALG_3DES:
;;;91     		if (key_len != 24) {
;;;92     			os_free(ctx);
;;;93     			return NULL;
;;;94     		}
;;;95     		des3_key_setup(key, &ctx->u.des3.key);
;;;96     		os_memcpy(ctx->u.des3.cbc, iv, 8);
;;;97     		break;
;;;98     	case CRYPTO_CIPHER_ALG_DES:
;;;99     		if (key_len != 8) {
;;;100    			os_free(ctx);
;;;101    			return NULL;
;;;102    		}
;;;103    		des_key_setup(key, ctx->u.des.ek, ctx->u.des.dk);
;;;104    		os_memcpy(ctx->u.des.cbc, iv, 8);
;;;105    		break;
;;;106    	default:
;;;107    		os_free(ctx);
;;;108    		return NULL;
;;;109    	}
;;;110    
;;;111    	return ctx;
;;;112    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.30|
00001e  7026              STRB     r6,[r4,#0]            ;60
000020  2e01              CMP      r6,#1                 ;62
000022  d014              BEQ      |L4.78|
000024  2e02              CMP      r6,#2                 ;62
000026  d03b              BEQ      |L4.160|
000028  2e03              CMP      r6,#3                 ;62
00002a  d04b              BEQ      |L4.196|
00002c  2e05              CMP      r6,#5                 ;62
00002e  d15d              BNE      |L4.236|
000030  2d10              CMP      r5,#0x10              ;64
000032  d904              BLS      |L4.62|
000034  4620              MOV      r0,r4                 ;65
000036  f7fffffe          BL       os_free
00003a  2000              MOVS     r0,#0                 ;66
00003c  e7ed              B        |L4.26|
                  |L4.62|
00003e  61a5              STR      r5,[r4,#0x18]         ;68
000040  462a              MOV      r2,r5                 ;69
000042  4641              MOV      r1,r8                 ;69
000044  f1040008          ADD      r0,r4,#8              ;69
000048  f7fffffe          BL       __aeabi_memcpy
00004c  e053              B        |L4.246|
                  |L4.78|
00004e  2d20              CMP      r5,#0x20              ;72
000050  d904              BLS      |L4.92|
000052  4620              MOV      r0,r4                 ;73
000054  f7fffffe          BL       os_free
000058  2000              MOVS     r0,#0                 ;74
00005a  e7de              B        |L4.26|
                  |L4.92|
00005c  4629              MOV      r1,r5                 ;76
00005e  4640              MOV      r0,r8                 ;76
000060  f7fffffe          BL       aes_encrypt_init
000064  62a0              STR      r0,[r4,#0x28]         ;76
000066  6aa0              LDR      r0,[r4,#0x28]         ;77
000068  b920              CBNZ     r0,|L4.116|
00006a  4620              MOV      r0,r4                 ;78
00006c  f7fffffe          BL       os_free
000070  2000              MOVS     r0,#0                 ;79
000072  e7d2              B        |L4.26|
                  |L4.116|
000074  4629              MOV      r1,r5                 ;81
000076  4640              MOV      r0,r8                 ;81
000078  f7fffffe          BL       aes_decrypt_init
00007c  62e0              STR      r0,[r4,#0x2c]         ;81
00007e  6ae0              LDR      r0,[r4,#0x2c]         ;82
000080  b938              CBNZ     r0,|L4.146|
000082  6aa0              LDR      r0,[r4,#0x28]         ;83
000084  f7fffffe          BL       aes_encrypt_deinit
000088  4620              MOV      r0,r4                 ;84
00008a  f7fffffe          BL       os_free
00008e  2000              MOVS     r0,#0                 ;85
000090  e7c3              B        |L4.26|
                  |L4.146|
000092  6265              STR      r5,[r4,#0x24]         ;87
000094  4639              MOV      r1,r7                 ;88
000096  1d20              ADDS     r0,r4,#4              ;88
000098  6a62              LDR      r2,[r4,#0x24]         ;88
00009a  f7fffffe          BL       __aeabi_memcpy
00009e  e02a              B        |L4.246|
                  |L4.160|
0000a0  2d18              CMP      r5,#0x18              ;91
0000a2  d004              BEQ      |L4.174|
0000a4  4620              MOV      r0,r4                 ;92
0000a6  f7fffffe          BL       os_free
0000aa  2000              MOVS     r0,#0                 ;93
0000ac  e7b5              B        |L4.26|
                  |L4.174|
0000ae  1d21              ADDS     r1,r4,#4              ;95
0000b0  4640              MOV      r0,r8                 ;95
0000b2  f7fffffe          BL       des3_key_setup
0000b6  6839              LDR      r1,[r7,#0]            ;96
0000b8  f8c41304          STR      r1,[r4,#0x304]        ;96
0000bc  6879              LDR      r1,[r7,#4]            ;96
0000be  f8c41308          STR      r1,[r4,#0x308]        ;96
0000c2  e018              B        |L4.246|
                  |L4.196|
0000c4  2d08              CMP      r5,#8                 ;99
0000c6  d004              BEQ      |L4.210|
0000c8  4620              MOV      r0,r4                 ;100
0000ca  f7fffffe          BL       os_free
0000ce  2000              MOVS     r0,#0                 ;101
0000d0  e7a3              B        |L4.26|
                  |L4.210|
0000d2  f1040284          ADD      r2,r4,#0x84           ;103
0000d6  1d21              ADDS     r1,r4,#4              ;103
0000d8  4640              MOV      r0,r8                 ;103
0000da  f7fffffe          BL       des_key_setup
0000de  6839              LDR      r1,[r7,#0]            ;104
0000e0  f8c41104          STR      r1,[r4,#0x104]        ;104
0000e4  6879              LDR      r1,[r7,#4]            ;104
0000e6  f8c41108          STR      r1,[r4,#0x108]        ;104
0000ea  e004              B        |L4.246|
                  |L4.236|
0000ec  4620              MOV      r0,r4                 ;107
0000ee  f7fffffe          BL       os_free
0000f2  2000              MOVS     r0,#0                 ;108
0000f4  e791              B        |L4.26|
                  |L4.246|
0000f6  bf00              NOP                            ;70
0000f8  4620              MOV      r0,r4                 ;111
0000fa  e78e              B        |L4.26|
;;;113    
                          ENDP


                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L6.30|
00001a  2001              MOVS     r0,#1
                  |L6.28|
;;;495    }
00001c  4770              BX       lr
                  |L6.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L6.28|
;;;496    
                          ENDP


                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L11.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L11.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L11.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L11.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L14.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L14.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L14.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L14.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L20.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       __aeabi_memcpy
                  |L20.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.xdbug_buf||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  xdbug_buf PROC
;;;147    #define RUN_TEST printk("RUN_TEST >>> LINE:%d ,,, FUNCTION:%s ,,, FILE:%s \r\n",__LINE__,__FUNCTION__,__FILE__);
;;;148    static void xdbug_buf(const char * name , const unsigned char * buf , const int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	int i = 0;
00000a  2400              MOVS     r4,#0
;;;151    	printf("dbug buf [%s]\n",name);
00000c  4629              MOV      r1,r5
00000e  a008              ADR      r0,|L27.48|
000010  f7fffffe          BL       __2printf
;;;152    	for(;i<len;i++)
000014  e004              B        |L27.32|
                  |L27.22|
;;;153    	{
;;;154    		printf("0x%02x,",buf[i]);
000016  5d31              LDRB     r1,[r6,r4]
000018  a009              ADR      r0,|L27.64|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1              ;152
                  |L27.32|
000020  42bc              CMP      r4,r7                 ;152
000022  dbf8              BLT      |L27.22|
;;;155    	}
;;;156    	printf("\n");
000024  a008              ADR      r0,|L27.72|
000026  f7fffffe          BL       __2printf
;;;157    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;158    #define DEBUG_PARAM_SDIO
                          ENDP

00002e  0000              DCW      0x0000
                  |L27.48|
000030  64627567          DCB      "dbug buf [%s]\n",0
000034  20627566
000038  205b2573
00003c  5d0a00  
00003f  00                DCB      0
                  |L27.64|
000040  30782530          DCB      "0x%02x,",0
000044  32782c00
                  |L27.72|
000048  0a00              DCB      "\n",0
00004a  00                DCB      0
00004b  00                DCB      0
