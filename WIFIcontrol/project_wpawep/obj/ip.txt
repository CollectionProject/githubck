; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\ip.o --depend=.\obj\ip.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\ip.crf ..\lwIP\src\core\ipv4\ip.c]
                          THUMB

                          AREA ||i.ip_current_header||, CODE, READONLY, ALIGN=2

                  ip_current_header PROC
;;;94     const struct ip_hdr *
;;;95     ip_current_header(void)
000000  4801              LDR      r0,|L1.8|
;;;96     {
;;;97       return current_header;
000002  6800              LDR      r0,[r0,#0]  ; current_header
;;;98     }
000004  4770              BX       lr
;;;99     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      current_header

                          AREA ||i.ip_current_netif||, CODE, READONLY, ALIGN=2

                  ip_current_netif PROC
;;;80     struct netif *
;;;81     ip_current_netif(void)
000000  4801              LDR      r0,|L2.8|
;;;82     {
;;;83       return current_netif;
000002  6800              LDR      r0,[r0,#0]  ; current_netif
;;;84     }
000004  4770              BX       lr
;;;85     
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      current_netif

                          AREA ||i.ip_forward||, CODE, READONLY, ALIGN=1

                  ip_forward PROC
;;;145    static struct netif *
;;;146    ip_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;147    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;148      struct netif *netif;
;;;149    
;;;150      PERF_START;
;;;151      /* Find network interface where to forward this IP packet to. */
;;;152      netif = ip_route((struct ip_addr *)&(iphdr->dest));
00000a  f1040010          ADD      r0,r4,#0x10
00000e  f7fffffe          BL       ip_route
000012  4605              MOV      r5,r0
;;;153      if (netif == NULL) {
000014  b925              CBNZ     r5,|L3.32|
;;;154        LWIP_DEBUGF(IP_DEBUG, ("ip_forward: no forwarding route for 0x%"X32_F" found\n",
000016  bf00              NOP      
000018  bf00              NOP      
;;;155                          iphdr->dest.addr));
;;;156        snmp_inc_ipoutnoroutes();
;;;157        return (struct netif *)NULL;
00001a  2000              MOVS     r0,#0
                  |L3.28|
;;;158      }
;;;159      /* Do not forward packets onto the same network interface on which
;;;160       * they arrived. */
;;;161      if (netif == inp) {
;;;162        LWIP_DEBUGF(IP_DEBUG, ("ip_forward: not bouncing packets back on incoming interface.\n"));
;;;163        snmp_inc_ipoutnoroutes();
;;;164        return (struct netif *)NULL;
;;;165      }
;;;166    
;;;167      /* decrement TTL */
;;;168      IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
;;;169      /* send ICMP if TTL == 0 */
;;;170      if (IPH_TTL(iphdr) == 0) {
;;;171        snmp_inc_ipinhdrerrors();
;;;172    #if LWIP_ICMP
;;;173        /* Don't send ICMP messages in response to ICMP messages */
;;;174        if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
;;;175          icmp_time_exceeded(p, ICMP_TE_TTL);
;;;176        }
;;;177    #endif /* LWIP_ICMP */
;;;178        return (struct netif *)NULL;
;;;179      }
;;;180    
;;;181      /* Incrementally update the IP checksum. */
;;;182      if (IPH_CHKSUM(iphdr) >= htons(0xffff - 0x100)) {
;;;183        IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100) + 1);
;;;184      } else {
;;;185        IPH_CHKSUM_SET(iphdr, IPH_CHKSUM(iphdr) + htons(0x100));
;;;186      }
;;;187    
;;;188      LWIP_DEBUGF(IP_DEBUG, ("ip_forward: forwarding packet to 0x%"X32_F"\n",
;;;189                        iphdr->dest.addr));
;;;190    
;;;191      IP_STATS_INC(ip.fw);
;;;192      IP_STATS_INC(ip.xmit);
;;;193      snmp_inc_ipforwdatagrams();
;;;194    
;;;195      PERF_STOP("ip_forward");
;;;196      /* transmit pbuf on chosen interface */
;;;197      netif->output(netif, p, (struct ip_addr *)&(iphdr->dest));
;;;198      return netif;
;;;199    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L3.32|
000020  42bd              CMP      r5,r7                 ;161
000022  d103              BNE      |L3.44|
000024  bf00              NOP                            ;162
000026  bf00              NOP                            ;162
000028  2000              MOVS     r0,#0                 ;164
00002a  e7f7              B        |L3.28|
                  |L3.44|
00002c  8920              LDRH     r0,[r4,#8]            ;168
00002e  f7fffffe          BL       ntohs
000032  2101              MOVS     r1,#1                 ;168
000034  ebc12020          RSB      r0,r1,r0,ASR #8       ;168
000038  fa1ff980          UXTH     r9,r0                 ;168
00003c  8920              LDRH     r0,[r4,#8]            ;168
00003e  f7fffffe          BL       ntohs
000042  f369201f          BFI      r0,r9,#8,#24          ;168
000046  fa1ff880          UXTH     r8,r0                 ;168
00004a  4640              MOV      r0,r8                 ;168
00004c  f7fffffe          BL       htons
000050  8120              STRH     r0,[r4,#8]            ;168
000052  8920              LDRH     r0,[r4,#8]            ;170
000054  f7fffffe          BL       ntohs
000058  1200              ASRS     r0,r0,#8              ;170
00005a  d10b              BNE      |L3.116|
00005c  8920              LDRH     r0,[r4,#8]            ;174
00005e  f7fffffe          BL       ntohs
000062  b2c0              UXTB     r0,r0                 ;174
000064  2801              CMP      r0,#1                 ;174
000066  d003              BEQ      |L3.112|
000068  2100              MOVS     r1,#0                 ;175
00006a  4630              MOV      r0,r6                 ;175
00006c  f7fffffe          BL       icmp_time_exceeded
                  |L3.112|
000070  2000              MOVS     r0,#0                 ;178
000072  e7d3              B        |L3.28|
                  |L3.116|
000074  f64f60ff          MOV      r0,#0xfeff            ;182
000078  f7fffffe          BL       htons
00007c  8961              LDRH     r1,[r4,#0xa]          ;182
00007e  4288              CMP      r0,r1                 ;182
000080  dc08              BGT      |L3.148|
000082  f44f7080          MOV      r0,#0x100             ;183
000086  f7fffffe          BL       htons
00008a  8961              LDRH     r1,[r4,#0xa]          ;183
00008c  4408              ADD      r0,r0,r1              ;183
00008e  1c40              ADDS     r0,r0,#1              ;183
000090  8160              STRH     r0,[r4,#0xa]          ;183
000092  e006              B        |L3.162|
                  |L3.148|
000094  f44f7080          MOV      r0,#0x100             ;185
000098  f7fffffe          BL       htons
00009c  8961              LDRH     r1,[r4,#0xa]          ;185
00009e  4408              ADD      r0,r0,r1              ;185
0000a0  8160              STRH     r0,[r4,#0xa]          ;185
                  |L3.162|
0000a2  bf00              NOP                            ;188
0000a4  bf00              NOP                            ;188
0000a6  f1040210          ADD      r2,r4,#0x10           ;197
0000aa  4631              MOV      r1,r6                 ;197
0000ac  4628              MOV      r0,r5                 ;197
0000ae  696b              LDR      r3,[r5,#0x14]         ;197
0000b0  4798              BLX      r3                    ;197
0000b2  4628              MOV      r0,r5                 ;198
0000b4  e7b2              B        |L3.28|
;;;200    #endif /* IP_FORWARD */
                          ENDP


                          AREA ||i.ip_input||, CODE, READONLY, ALIGN=2

                  ip_input PROC
;;;216    err_t
;;;217    ip_input(struct pbuf *p, struct netif *inp)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;218    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;219      struct ip_hdr *iphdr;
;;;220      struct netif *netif;
;;;221      u16_t iphdr_hlen;
;;;222      u16_t iphdr_len;
;;;223    #if LWIP_DHCP
;;;224      int check_ip_src=1;
000008  f04f0a01          MOV      r10,#1
;;;225    #endif /* LWIP_DHCP */
;;;226    
;;;227      IP_STATS_INC(ip.recv);
;;;228      snmp_inc_ipinreceives();
;;;229    
;;;230      /* identify the IP header */
;;;231      iphdr = p->payload;
00000c  6874              LDR      r4,[r6,#4]
;;;232      if (IPH_V(iphdr) != 4) {
00000e  8820              LDRH     r0,[r4,#0]
000010  f7fffffe          BL       ntohs
000014  2104              MOVS     r1,#4
000016  ebb13f20          CMP      r1,r0,ASR #12
00001a  d007              BEQ      |L4.44|
;;;233        LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;234        ip_debug_print(p);
;;;235        pbuf_free(p);
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       pbuf_free
;;;236        IP_STATS_INC(ip.err);
;;;237        IP_STATS_INC(ip.drop);
;;;238        snmp_inc_ipinhdrerrors();
;;;239        return ERR_OK;
000026  2000              MOVS     r0,#0
                  |L4.40|
;;;240      }
;;;241    
;;;242      /* obtain IP header length in number of 32-bit words */
;;;243      iphdr_hlen = IPH_HL(iphdr);
;;;244      /* calculate IP header length in bytes */
;;;245      iphdr_hlen *= 4;
;;;246      /* obtain ip length in bytes */
;;;247      iphdr_len = ntohs(IPH_LEN(iphdr));
;;;248    
;;;249      /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
;;;250      if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
;;;251        if (iphdr_hlen > p->len)
;;;252        LWIP_DEBUGF(IP_DEBUG | 2, ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
;;;253                                   iphdr_hlen, p->len));
;;;254        if (iphdr_len > p->tot_len)
;;;255        LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
;;;256                                   "IP packet dropped.\n",
;;;257                                   iphdr_len, p->tot_len));
;;;258        /* free (drop) packet pbufs */
;;;259        pbuf_free(p);
;;;260        IP_STATS_INC(ip.lenerr);
;;;261        IP_STATS_INC(ip.drop);
;;;262        snmp_inc_ipindiscards();
;;;263        return ERR_OK;
;;;264      }
;;;265    
;;;266      /* verify checksum */
;;;267    #if CHECKSUM_CHECK_IP
;;;268      if (inet_chksum(iphdr, iphdr_hlen) != 0) {
;;;269    
;;;270        LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
;;;271        ip_debug_print(p);
;;;272        pbuf_free(p);
;;;273        IP_STATS_INC(ip.chkerr);
;;;274        IP_STATS_INC(ip.drop);
;;;275        snmp_inc_ipinhdrerrors();
;;;276        return ERR_OK;
;;;277      }
;;;278    #endif
;;;279    
;;;280      /* Trim pbuf. This should have been done at the netif layer,
;;;281       * but we'll do it anyway just to be sure that its done. */
;;;282      pbuf_realloc(p, iphdr_len);
;;;283    
;;;284      /* match packet against an interface, i.e. is this packet for us? */
;;;285    #if LWIP_IGMP
;;;286      if (ip_addr_ismulticast(&(iphdr->dest))) {
;;;287        if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &(iphdr->dest)))) {
;;;288          netif = inp;
;;;289        } else {
;;;290          netif = NULL;
;;;291        }
;;;292      } else
;;;293    #endif /* LWIP_IGMP */
;;;294      {
;;;295        /* start trying with inp. if that's not acceptable, start walking the
;;;296           list of configured netifs.
;;;297           'first' is used as a boolean to mark whether we started walking the list */
;;;298        int first = 1;
;;;299        netif = inp;
;;;300        do {
;;;301          LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
;;;302              iphdr->dest.addr, netif->ip_addr.addr,
;;;303              iphdr->dest.addr & netif->netmask.addr,
;;;304              netif->ip_addr.addr & netif->netmask.addr,
;;;305              iphdr->dest.addr & ~(netif->netmask.addr)));
;;;306    
;;;307          /* interface is up and configured? */
;;;308          if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
;;;309            /* unicast to this interface address? */
;;;310            if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
;;;311                /* or broadcast on this interface network address? */
;;;312                ip_addr_isbroadcast(&(iphdr->dest), netif)) {
;;;313              LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
;;;314                  netif->name[0], netif->name[1]));
;;;315              /* break out of for loop */
;;;316              break;
;;;317            }
;;;318          }
;;;319          if (first) {
;;;320            first = 0;
;;;321            netif = netif_list;
;;;322          } else {
;;;323            netif = netif->next;
;;;324          }
;;;325          if (netif == inp) {
;;;326            netif = netif->next;
;;;327          }
;;;328        } while(netif != NULL);
;;;329      }
;;;330    
;;;331    #if LWIP_DHCP
;;;332      /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
;;;333       * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
;;;334       * According to RFC 1542 section 3.1.1, referred by RFC 2131).
;;;335       */
;;;336      //if (netif == NULL) {
;;;337        /* remote port is DHCP server? */
;;;338        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
;;;339          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
;;;340            ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
;;;341          if ((ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT)||
;;;342    	  	(ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_SERVER_PORT)){
;;;343            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
;;;344            netif = inp;
;;;345            check_ip_src = 0;
;;;346          }
;;;347        }
;;;348     // }
;;;349    #endif /* LWIP_DHCP */
;;;350    
;;;351      /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
;;;352    #if LWIP_DHCP
;;;353      if (check_ip_src)
;;;354    #endif /* LWIP_DHCP */
;;;355      {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
;;;356             (ip_addr_ismulticast(&(iphdr->src)))) {
;;;357          /* packet source is not valid */
;;;358          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
;;;359          /* free (drop) packet pbufs */
;;;360          pbuf_free(p);
;;;361          IP_STATS_INC(ip.drop);
;;;362          snmp_inc_ipinaddrerrors();
;;;363          snmp_inc_ipindiscards();
;;;364          return ERR_OK;
;;;365        }
;;;366      }
;;;367    
;;;368      /* packet not for us? */
;;;369      if (netif == NULL) {
;;;370        /* packet not for us, route or discard */
;;;371        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet not for us.\n"));
;;;372    #if IP_FORWARD
;;;373        /* non-broadcast packet? */
;;;374        if (!ip_addr_isbroadcast(&(iphdr->dest), inp)) {
;;;375          /* try to forward IP packet on (other) interfaces */
;;;376          ip_forward(p, iphdr, inp);
;;;377        } else
;;;378    #endif /* IP_FORWARD */
;;;379        {
;;;380          snmp_inc_ipinaddrerrors();
;;;381          snmp_inc_ipindiscards();
;;;382        }
;;;383        pbuf_free(p);
;;;384        return ERR_OK;
;;;385      }
;;;386      /* packet consists of multiple fragments? */
;;;387      if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
;;;388    #if IP_REASSEMBLY /* packet fragment reassembly code present? */
;;;389        LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
;;;390          ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
;;;391        /* reassemble the packet*/
;;;392        p = ip_reass(p);
;;;393        /* packet not fully reassembled yet? */
;;;394        if (p == NULL) {
;;;395          return ERR_OK;
;;;396        }
;;;397        iphdr = p->payload;
;;;398    #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
;;;399        pbuf_free(p);
;;;400        LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
;;;401          ntohs(IPH_OFFSET(iphdr))));
;;;402        IP_STATS_INC(ip.opterr);
;;;403        IP_STATS_INC(ip.drop);
;;;404        /* unsupported protocol feature */
;;;405        snmp_inc_ipinunknownprotos();
;;;406        return ERR_OK;
;;;407    #endif /* IP_REASSEMBLY */
;;;408      }
;;;409    
;;;410    #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
;;;411    
;;;412    #if LWIP_IGMP
;;;413      /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
;;;414      if((iphdr_hlen > IP_HLEN &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
;;;415    #else
;;;416      if (iphdr_hlen > IP_HLEN) {
;;;417    #endif /* LWIP_IGMP */
;;;418        LWIP_DEBUGF(IP_DEBUG | 2, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
;;;419        pbuf_free(p);
;;;420        IP_STATS_INC(ip.opterr);
;;;421        IP_STATS_INC(ip.drop);
;;;422        /* unsupported protocol feature */
;;;423        snmp_inc_ipinunknownprotos();
;;;424        return ERR_OK;
;;;425      }
;;;426    #endif /* IP_OPTIONS_ALLOWED == 0 */
;;;427    
;;;428      /* send to upper layers */
;;;429      LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
;;;430      ip_debug_print(p);
;;;431      LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
;;;432    
;;;433      current_netif = inp;
;;;434      current_header = iphdr;
;;;435    
;;;436    #if LWIP_RAW
;;;437      /* raw input did not eat the packet? */
;;;438      if (raw_input(p, inp) == 0)
;;;439    #endif /* LWIP_RAW */
;;;440      {
;;;441    
;;;442        switch (IPH_PROTO(iphdr)) {
;;;443    #if LWIP_UDP
;;;444        case IP_PROTO_UDP:
;;;445    #if LWIP_UDPLITE
;;;446        case IP_PROTO_UDPLITE:
;;;447    #endif /* LWIP_UDPLITE */
;;;448          snmp_inc_ipindelivers();
;;;449          udp_input(p, inp);
;;;450          break;
;;;451    #endif /* LWIP_UDP */
;;;452    #if LWIP_TCP
;;;453        case IP_PROTO_TCP:
;;;454          snmp_inc_ipindelivers();
;;;455          tcp_input(p, inp);
;;;456          break;
;;;457    #endif /* LWIP_TCP */
;;;458    #if LWIP_ICMP
;;;459        case IP_PROTO_ICMP:
;;;460          snmp_inc_ipindelivers();
;;;461          icmp_input(p, inp);
;;;462          break;
;;;463    #endif /* LWIP_ICMP */
;;;464    #if LWIP_IGMP
;;;465        case IP_PROTO_IGMP:
;;;466          igmp_input(p,inp,&(iphdr->dest));
;;;467          break;
;;;468    #endif /* LWIP_IGMP */
;;;469        default:
;;;470    #if LWIP_ICMP
;;;471          /* send ICMP destination protocol unreachable unless is was a broadcast */
;;;472          if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
;;;473              !ip_addr_ismulticast(&(iphdr->dest))) {
;;;474            p->payload = iphdr;
;;;475            icmp_dest_unreach(p, ICMP_DUR_PROTO);
;;;476          }
;;;477    #endif /* LWIP_ICMP */
;;;478          pbuf_free(p);
;;;479    
;;;480          LWIP_DEBUGF(IP_DEBUG | 2, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));
;;;481    
;;;482          IP_STATS_INC(ip.proterr);
;;;483          IP_STATS_INC(ip.drop);
;;;484          snmp_inc_ipinunknownprotos();
;;;485        }
;;;486      }
;;;487    
;;;488      current_netif = NULL;
;;;489      current_header = NULL;
;;;490    
;;;491      return ERR_OK;
;;;492    }
000028  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.44|
00002c  8820              LDRH     r0,[r4,#0]            ;243
00002e  f7fffffe          BL       ntohs
000032  f3c02803          UBFX     r8,r0,#8,#4           ;243
000036  ea4f0888          LSL      r8,r8,#2              ;245
00003a  8860              LDRH     r0,[r4,#2]            ;247
00003c  f7fffffe          BL       ntohs
000040  4681              MOV      r9,r0                 ;247
000042  8970              LDRH     r0,[r6,#0xa]          ;250
000044  4540              CMP      r0,r8                 ;250
000046  db02              BLT      |L4.78|
000048  8930              LDRH     r0,[r6,#8]            ;250
00004a  4548              CMP      r0,r9                 ;250
00004c  da0e              BGE      |L4.108|
                  |L4.78|
00004e  8970              LDRH     r0,[r6,#0xa]          ;251
000050  4540              CMP      r0,r8                 ;251
000052  da01              BGE      |L4.88|
000054  bf00              NOP                            ;252
000056  bf00              NOP                            ;252
                  |L4.88|
000058  8930              LDRH     r0,[r6,#8]            ;254
00005a  4548              CMP      r0,r9                 ;254
00005c  da01              BGE      |L4.98|
00005e  bf00              NOP                            ;255
000060  bf00              NOP                            ;255
                  |L4.98|
000062  4630              MOV      r0,r6                 ;259
000064  f7fffffe          BL       pbuf_free
000068  2000              MOVS     r0,#0                 ;263
00006a  e7dd              B        |L4.40|
                  |L4.108|
00006c  4641              MOV      r1,r8                 ;268
00006e  4620              MOV      r0,r4                 ;268
000070  f7fffffe          BL       inet_chksum
000074  b130              CBZ      r0,|L4.132|
000076  bf00              NOP                            ;270
000078  bf00              NOP                            ;270
00007a  4630              MOV      r0,r6                 ;272
00007c  f7fffffe          BL       pbuf_free
000080  2000              MOVS     r0,#0                 ;276
000082  e7d1              B        |L4.40|
                  |L4.132|
000084  4649              MOV      r1,r9                 ;282
000086  4630              MOV      r0,r6                 ;282
000088  f7fffffe          BL       pbuf_realloc
00008c  f04f0b01          MOV      r11,#1                ;298
000090  463d              MOV      r5,r7                 ;299
000092  bf00              NOP                            ;300
                  |L4.148|
000094  bf00              NOP                            ;301
000096  bf00              NOP                            ;301
000098  4628              MOV      r0,r5                 ;308
00009a  f7fffffe          BL       netif_is_up
00009e  b180              CBZ      r0,|L4.194|
0000a0  1d28              ADDS     r0,r5,#4              ;308
0000a2  d00e              BEQ      |L4.194|
0000a4  6868              LDR      r0,[r5,#4]            ;308
0000a6  b160              CBZ      r0,|L4.194|
0000a8  6920              LDR      r0,[r4,#0x10]         ;310
0000aa  6869              LDR      r1,[r5,#4]            ;310
0000ac  4288              CMP      r0,r1                 ;310
0000ae  d005              BEQ      |L4.188|
0000b0  4629              MOV      r1,r5                 ;312
0000b2  f1040010          ADD      r0,r4,#0x10           ;312
0000b6  f7fffffe          BL       ip_addr_isbroadcast
0000ba  b110              CBZ      r0,|L4.194|
                  |L4.188|
0000bc  bf00              NOP                            ;313
0000be  bf00              NOP                            ;313
0000c0  e00d              B        |L4.222|
                  |L4.194|
0000c2  f1bb0f00          CMP      r11,#0                ;319
0000c6  d004              BEQ      |L4.210|
0000c8  f04f0b00          MOV      r11,#0                ;320
0000cc  4858              LDR      r0,|L4.560|
0000ce  6805              LDR      r5,[r0,#0]            ;321  ; netif_list
0000d0  e000              B        |L4.212|
                  |L4.210|
0000d2  682d              LDR      r5,[r5,#0]            ;323
                  |L4.212|
0000d4  42bd              CMP      r5,r7                 ;325
0000d6  d100              BNE      |L4.218|
0000d8  682d              LDR      r5,[r5,#0]            ;326
                  |L4.218|
0000da  2d00              CMP      r5,#0                 ;328
0000dc  d1da              BNE      |L4.148|
                  |L4.222|
0000de  bf00              NOP                            ;316
0000e0  8920              LDRH     r0,[r4,#8]            ;338
0000e2  f7fffffe          BL       ntohs
0000e6  b2c0              UXTB     r0,r0                 ;338
0000e8  2811              CMP      r0,#0x11              ;338
0000ea  d114              BNE      |L4.278|
0000ec  bf00              NOP                            ;339
0000ee  bf00              NOP                            ;339
0000f0  eb040108          ADD      r1,r4,r8              ;341
0000f4  8848              LDRH     r0,[r1,#2]            ;341
0000f6  f7fffffe          BL       ntohs
0000fa  2844              CMP      r0,#0x44              ;341
0000fc  d006              BEQ      |L4.268|
0000fe  eb040108          ADD      r1,r4,r8              ;342
000102  8848              LDRH     r0,[r1,#2]            ;342
000104  f7fffffe          BL       ntohs
000108  2843              CMP      r0,#0x43              ;342
00010a  d104              BNE      |L4.278|
                  |L4.268|
00010c  bf00              NOP                            ;343
00010e  bf00              NOP                            ;343
000110  463d              MOV      r5,r7                 ;344
000112  f04f0a00          MOV      r10,#0                ;345
                  |L4.278|
000116  f1ba0f00          CMP      r10,#0                ;353
00011a  d019              BEQ      |L4.336|
00011c  4639              MOV      r1,r7                 ;355
00011e  f104000c          ADD      r0,r4,#0xc            ;355
000122  f7fffffe          BL       ip_addr_isbroadcast
000126  b960              CBNZ     r0,|L4.322|
000128  f04f4070          MOV      r0,#0xf0000000        ;356
00012c  f7fffffe          BL       ntohl
000130  68e1              LDR      r1,[r4,#0xc]          ;356
000132  ea000b01          AND      r11,r0,r1             ;356
000136  f04f4060          MOV      r0,#0xe0000000        ;356
00013a  f7fffffe          BL       ntohl
00013e  4583              CMP      r11,r0                ;356
000140  d106              BNE      |L4.336|
                  |L4.322|
000142  bf00              NOP                            ;358
000144  bf00              NOP                            ;358
000146  4630              MOV      r0,r6                 ;360
000148  f7fffffe          BL       pbuf_free
00014c  2000              MOVS     r0,#0                 ;364
00014e  e76b              B        |L4.40|
                  |L4.336|
000150  b98d              CBNZ     r5,|L4.374|
000152  bf00              NOP                            ;371
000154  bf00              NOP                            ;371
000156  4639              MOV      r1,r7                 ;374
000158  f1040010          ADD      r0,r4,#0x10           ;374
00015c  f7fffffe          BL       ip_addr_isbroadcast
000160  b920              CBNZ     r0,|L4.364|
000162  463a              MOV      r2,r7                 ;376
000164  4621              MOV      r1,r4                 ;376
000166  4630              MOV      r0,r6                 ;376
000168  f7fffffe          BL       ip_forward
                  |L4.364|
00016c  4630              MOV      r0,r6                 ;383
00016e  f7fffffe          BL       pbuf_free
000172  2000              MOVS     r0,#0                 ;384
000174  e758              B        |L4.40|
                  |L4.374|
000176  f64370ff          MOV      r0,#0x3fff            ;387
00017a  f7fffffe          BL       htons
00017e  88e1              LDRH     r1,[r4,#6]            ;387
000180  4208              TST      r0,r1                 ;387
000182  d009              BEQ      |L4.408|
000184  bf00              NOP                            ;389
000186  bf00              NOP                            ;389
000188  4630              MOV      r0,r6                 ;392
00018a  f7fffffe          BL       ip_reass
00018e  4606              MOV      r6,r0                 ;392
000190  b90e              CBNZ     r6,|L4.406|
000192  2000              MOVS     r0,#0                 ;395
000194  e748              B        |L4.40|
                  |L4.406|
000196  6874              LDR      r4,[r6,#4]            ;397
                  |L4.408|
000198  bf00              NOP                            ;429
00019a  bf00              NOP                            ;429
00019c  bf00              NOP                            ;431
00019e  bf00              NOP                            ;431
0001a0  4824              LDR      r0,|L4.564|
0001a2  6007              STR      r7,[r0,#0]            ;433  ; current_netif
0001a4  4824              LDR      r0,|L4.568|
0001a6  6004              STR      r4,[r0,#0]            ;434  ; current_header
0001a8  4639              MOV      r1,r7                 ;438
0001aa  4630              MOV      r0,r6                 ;438
0001ac  f7fffffe          BL       raw_input
0001b0  bbb8              CBNZ     r0,|L4.546|
0001b2  8920              LDRH     r0,[r4,#8]            ;442
0001b4  f7fffffe          BL       ntohs
0001b8  b2c0              UXTB     r0,r0                 ;442
0001ba  2801              CMP      r0,#1                 ;442
0001bc  d00d              BEQ      |L4.474|
0001be  2806              CMP      r0,#6                 ;442
0001c0  d006              BEQ      |L4.464|
0001c2  2811              CMP      r0,#0x11              ;442
0001c4  d10e              BNE      |L4.484|
0001c6  4639              MOV      r1,r7                 ;449
0001c8  4630              MOV      r0,r6                 ;449
0001ca  f7fffffe          BL       udp_input
0001ce  e027              B        |L4.544|
                  |L4.464|
0001d0  4639              MOV      r1,r7                 ;455
0001d2  4630              MOV      r0,r6                 ;455
0001d4  f7fffffe          BL       tcp_input
0001d8  e022              B        |L4.544|
                  |L4.474|
0001da  4639              MOV      r1,r7                 ;461
0001dc  4630              MOV      r0,r6                 ;461
0001de  f7fffffe          BL       icmp_input
0001e2  e01d              B        |L4.544|
                  |L4.484|
0001e4  4639              MOV      r1,r7                 ;472
0001e6  f1040010          ADD      r0,r4,#0x10           ;472
0001ea  f7fffffe          BL       ip_addr_isbroadcast
0001ee  b988              CBNZ     r0,|L4.532|
0001f0  f04f4070          MOV      r0,#0xf0000000        ;473
0001f4  f7fffffe          BL       ntohl
0001f8  6921              LDR      r1,[r4,#0x10]         ;473
0001fa  ea000b01          AND      r11,r0,r1             ;473
0001fe  f04f4060          MOV      r0,#0xe0000000        ;473
000202  f7fffffe          BL       ntohl
000206  4583              CMP      r11,r0                ;473
000208  d004              BEQ      |L4.532|
00020a  6074              STR      r4,[r6,#4]            ;474
00020c  2102              MOVS     r1,#2                 ;475
00020e  4630              MOV      r0,r6                 ;475
000210  f7fffffe          BL       icmp_dest_unreach
                  |L4.532|
000214  4630              MOV      r0,r6                 ;478
000216  f7fffffe          BL       pbuf_free
00021a  bf00              NOP                            ;480
00021c  bf00              NOP                            ;480
00021e  bf00              NOP                            ;442
                  |L4.544|
000220  bf00              NOP                            ;450
                  |L4.546|
000222  2000              MOVS     r0,#0                 ;488
000224  4903              LDR      r1,|L4.564|
000226  6008              STR      r0,[r1,#0]            ;488  ; current_netif
000228  4903              LDR      r1,|L4.568|
00022a  6008              STR      r0,[r1,#0]            ;489  ; current_header
00022c  bf00              NOP                            ;491
00022e  e6fb              B        |L4.40|
;;;493    
                          ENDP

                  |L4.560|
                          DCD      netif_list
                  |L4.564|
                          DCD      current_netif
                  |L4.568|
                          DCD      current_header

                          AREA ||i.ip_output||, CODE, READONLY, ALIGN=1

                  ip_output PROC
;;;650    err_t
;;;651    ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;652              u8_t ttl, u8_t tos, u8_t proto)
;;;653    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
00000c  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;654      struct netif *netif;
;;;655    
;;;656      if ((netif = ip_route(dest)) == NULL) {
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       ip_route
000016  ea5f0a00          MOVS     r10,r0
00001a  d104              BNE      |L5.38|
;;;657        LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to 0x%"X32_F"\n", dest->addr));
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;658        IP_STATS_INC(ip.rterr);
;;;659        return ERR_RTE;
000020  1f00              SUBS     r0,r0,#4
                  |L5.34|
;;;660      }
;;;661    
;;;662      return ip_output_if(p, src, dest, ttl, tos, proto, netif);
;;;663    }
000022  e8bd8ffe          POP      {r1-r11,pc}
                  |L5.38|
000026  463b              MOV      r3,r7                 ;662
000028  4622              MOV      r2,r4                 ;662
00002a  4631              MOV      r1,r6                 ;662
00002c  4628              MOV      r0,r5                 ;662
00002e  e88d0700          STM      sp,{r8-r10}           ;662
000032  f7fffffe          BL       ip_output_if
000036  e7f4              B        |L5.34|
;;;664    
                          ENDP


                          AREA ||i.ip_output_if||, CODE, READONLY, ALIGN=2

                  ip_output_if PROC
;;;519    err_t
;;;520    ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;521                 u8_t ttl, u8_t tos,
;;;522                 u8_t proto, struct netif *netif)
;;;523    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  469a              MOV      r10,r3
00000c  9d10              LDR      r5,[sp,#0x40]
;;;524    #if IP_OPTIONS_SEND
;;;525      return ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;526    }
;;;527    
;;;528    /**
;;;529     * Same as ip_output_if() but with the possibility to include IP options:
;;;530     *
;;;531     * @ param ip_options pointer to the IP options, copied into the IP header
;;;532     * @ param optlen length of ip_options
;;;533     */
;;;534    err_t ip_output_if_opt(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
;;;535           u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;536           u16_t optlen)
;;;537    {
;;;538    #endif /* IP_OPTIONS_SEND */
;;;539      struct ip_hdr *iphdr;
;;;540      static u16_t ip_id = 0;
;;;541    
;;;542      snmp_inc_ipoutrequests();
;;;543    
;;;544      /* Should the IP header be generated or is it already included in p? */
;;;545      if (dest != IP_HDRINCL) {
00000e  f1b80f00          CMP      r8,#0
000012  d060              BEQ      |L6.214|
;;;546        u16_t ip_hlen = IP_HLEN;
000014  f04f0914          MOV      r9,#0x14
;;;547    #if IP_OPTIONS_SEND
;;;548        u16_t optlen_aligned = 0;
;;;549        if (optlen != 0) {
;;;550          /* round up to a multiple of 4 */
;;;551          optlen_aligned = ((optlen + 3) & ~3);
;;;552          ip_hlen += optlen_aligned;
;;;553          /* First write in the IP options */
;;;554          if (pbuf_header(p, optlen_aligned)) {
;;;555            LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
;;;556            IP_STATS_INC(ip.err);
;;;557            snmp_inc_ipoutdiscards();
;;;558            return ERR_BUF;
;;;559          }
;;;560          MEMCPY(p->payload, ip_options, optlen);
;;;561          if (optlen < optlen_aligned) {
;;;562            /* zero the remaining bytes */
;;;563            memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
;;;564          }
;;;565        }
;;;566    #endif /* IP_OPTIONS_SEND */
;;;567        /* generate IP header */
;;;568        if (pbuf_header(p, IP_HLEN)) {
000018  2114              MOVS     r1,#0x14
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       pbuf_header
000020  b130              CBZ      r0,|L6.48|
;;;569          LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));
000022  bf00              NOP      
000024  bf00              NOP      
;;;570    
;;;571          IP_STATS_INC(ip.err);
;;;572          snmp_inc_ipoutdiscards();
;;;573          return ERR_BUF;
000026  f06f0001          MVN      r0,#1
                  |L6.42|
;;;574        }
;;;575    
;;;576        iphdr = p->payload;
;;;577        LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
;;;578                   (p->len >= sizeof(struct ip_hdr)));
;;;579    
;;;580        IPH_TTL_SET(iphdr, ttl);
;;;581        IPH_PROTO_SET(iphdr, proto);
;;;582    
;;;583        ip_addr_set(&(iphdr->dest), dest);
;;;584    
;;;585        IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
;;;586        IPH_LEN_SET(iphdr, htons(p->tot_len));
;;;587        IPH_OFFSET_SET(iphdr, 0);
;;;588        IPH_ID_SET(iphdr, htons(ip_id));
;;;589        ++ip_id;
;;;590    
;;;591        if (ip_addr_isany(src)) {
;;;592          ip_addr_set(&(iphdr->src), &(netif->ip_addr));
;;;593        } else {
;;;594          ip_addr_set(&(iphdr->src), src);
;;;595        }
;;;596    
;;;597        IPH_CHKSUM_SET(iphdr, 0);
;;;598    #if CHECKSUM_GEN_IP
;;;599        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
;;;600    #endif
;;;601      } else {
;;;602        /* IP header already included in p */
;;;603        iphdr = p->payload;
;;;604        dest = &(iphdr->dest);
;;;605      }
;;;606    
;;;607    #if IP_FRAG
;;;608      /* don't fragment if interface has mtu set to 0 [loopif] */
;;;609      if (netif->mtu && (p->tot_len > netif->mtu))
;;;610        return ip_frag(p,netif,dest);
;;;611    #endif
;;;612    
;;;613      IP_STATS_INC(ip.xmit);
;;;614    
;;;615      LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
;;;616      ip_debug_print(p);
;;;617    
;;;618    #if (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
;;;619      if (ip_addr_cmp(dest, &netif->ip_addr)) {
;;;620        /* Packet to self, enqueue it for loopback */
;;;621        LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
;;;622    
;;;623        return netif_loop_output(netif, p, dest);
;;;624      } else
;;;625    #endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
;;;626      {
;;;627        LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
;;;628    
;;;629        return netif->output(netif, p, dest);
;;;630      }
;;;631    }
00002a  b004              ADD      sp,sp,#0x10
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L6.48|
000030  6874              LDR      r4,[r6,#4]            ;576
000032  8920              LDRH     r0,[r4,#8]            ;580
000034  f7fffffe          BL       ntohs
000038  f36a201f          BFI      r0,r10,#8,#24         ;580
00003c  4683              MOV      r11,r0                ;580
00003e  f7fffffe          BL       htons
000042  8120              STRH     r0,[r4,#8]            ;580
000044  8920              LDRH     r0,[r4,#8]            ;581
000046  f7fffffe          BL       ntohs
00004a  1201              ASRS     r1,r0,#8              ;581
00004c  980f              LDR      r0,[sp,#0x3c]         ;581
00004e  ea402b01          ORR      r11,r0,r1,LSL #8      ;581
000052  4658              MOV      r0,r11                ;581
000054  f7fffffe          BL       htons
000058  8120              STRH     r0,[r4,#8]            ;581
00005a  f1b80f00          CMP      r8,#0                 ;583
00005e  d101              BNE      |L6.100|
000060  2000              MOVS     r0,#0                 ;583
000062  e001              B        |L6.104|
                  |L6.100|
000064  f8d80000          LDR      r0,[r8,#0]            ;583
                  |L6.104|
000068  6120              STR      r0,[r4,#0x10]         ;583
00006a  46cb              MOV      r11,r9                ;585
00006c  ea4f71e9          ASR      r1,r9,#31             ;585
000070  eb097191          ADD      r1,r9,r1,LSR #30      ;585
000074  1089              ASRS     r1,r1,#2              ;585
000076  f44f4280          MOV      r2,#0x4000            ;585
00007a  ea422101          ORR      r1,r2,r1,LSL #8       ;585
00007e  9a0e              LDR      r2,[sp,#0x38]         ;585
000080  4311              ORRS     r1,r1,r2              ;585
000082  b288              UXTH     r0,r1                 ;585
000084  f7fffffe          BL       htons
000088  8020              STRH     r0,[r4,#0]            ;585
00008a  8930              LDRH     r0,[r6,#8]            ;586
00008c  f7fffffe          BL       htons
000090  8060              STRH     r0,[r4,#2]            ;586
000092  2000              MOVS     r0,#0                 ;587
000094  80e0              STRH     r0,[r4,#6]            ;587
000096  481c              LDR      r0,|L6.264|
000098  8800              LDRH     r0,[r0,#0]            ;588  ; ip_id
00009a  f7fffffe          BL       htons
00009e  80a0              STRH     r0,[r4,#4]            ;588
0000a0  4819              LDR      r0,|L6.264|
0000a2  8800              LDRH     r0,[r0,#0]            ;589  ; ip_id
0000a4  1c40              ADDS     r0,r0,#1              ;589
0000a6  4918              LDR      r1,|L6.264|
0000a8  8008              STRH     r0,[r1,#0]            ;589
0000aa  b10f              CBZ      r7,|L6.176|
0000ac  6838              LDR      r0,[r7,#0]            ;591
0000ae  b928              CBNZ     r0,|L6.188|
                  |L6.176|
0000b0  1d28              ADDS     r0,r5,#4              ;592
0000b2  d100              BNE      |L6.182|
0000b4  e000              B        |L6.184|
                  |L6.182|
0000b6  6868              LDR      r0,[r5,#4]            ;592
                  |L6.184|
0000b8  60e0              STR      r0,[r4,#0xc]          ;592
0000ba  e004              B        |L6.198|
                  |L6.188|
0000bc  b90f              CBNZ     r7,|L6.194|
0000be  2000              MOVS     r0,#0                 ;594
0000c0  e000              B        |L6.196|
                  |L6.194|
0000c2  6838              LDR      r0,[r7,#0]            ;594
                  |L6.196|
0000c4  60e0              STR      r0,[r4,#0xc]          ;594
                  |L6.198|
0000c6  2000              MOVS     r0,#0                 ;597
0000c8  8160              STRH     r0,[r4,#0xa]          ;597
0000ca  4649              MOV      r1,r9                 ;599
0000cc  4620              MOV      r0,r4                 ;599
0000ce  f7fffffe          BL       inet_chksum
0000d2  8160              STRH     r0,[r4,#0xa]          ;599
0000d4  e002              B        |L6.220|
                  |L6.214|
0000d6  6874              LDR      r4,[r6,#4]            ;603
0000d8  f1040810          ADD      r8,r4,#0x10           ;604
                  |L6.220|
0000dc  8e28              LDRH     r0,[r5,#0x30]         ;609
0000de  b148              CBZ      r0,|L6.244|
0000e0  8930              LDRH     r0,[r6,#8]            ;609
0000e2  8e29              LDRH     r1,[r5,#0x30]         ;609
0000e4  4288              CMP      r0,r1                 ;609
0000e6  dd05              BLE      |L6.244|
0000e8  4642              MOV      r2,r8                 ;610
0000ea  4629              MOV      r1,r5                 ;610
0000ec  4630              MOV      r0,r6                 ;610
0000ee  f7fffffe          BL       ip_frag
0000f2  e79a              B        |L6.42|
                  |L6.244|
0000f4  bf00              NOP                            ;615
0000f6  bf00              NOP                            ;615
0000f8  bf00              NOP                            ;627
0000fa  bf00              NOP                            ;627
0000fc  4642              MOV      r2,r8                 ;629
0000fe  4631              MOV      r1,r6                 ;629
000100  4628              MOV      r0,r5                 ;629
000102  696b              LDR      r3,[r5,#0x14]         ;629
000104  4798              BLX      r3                    ;629
000106  e790              B        |L6.42|
;;;632    
                          ENDP

                  |L6.264|
                          DCD      ip_id

                          AREA ||i.ip_route||, CODE, READONLY, ALIGN=2

                  ip_route PROC
;;;109    struct netif *
;;;110    ip_route(struct ip_addr *dest)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4605              MOV      r5,r0
;;;112      struct netif *netif;
;;;113    
;;;114      /* iterate through netifs */
;;;115      for(netif = netif_list; netif != NULL; netif = netif->next) {
000004  4811              LDR      r0,|L7.76|
000006  6804              LDR      r4,[r0,#0]  ; netif_list
000008  e00e              B        |L7.40|
                  |L7.10|
;;;116        /* network mask matches? */
;;;117        if (netif_is_up(netif)) {
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       netif_is_up
000010  b148              CBZ      r0,|L7.38|
;;;118          if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
000012  6828              LDR      r0,[r5,#0]
000014  68a1              LDR      r1,[r4,#8]
000016  4008              ANDS     r0,r0,r1
000018  e9d41201          LDRD     r1,r2,[r4,#4]
00001c  4011              ANDS     r1,r1,r2
00001e  4288              CMP      r0,r1
000020  d101              BNE      |L7.38|
;;;119            /* return netif on which to forward IP packet */
;;;120            return netif;
000022  4620              MOV      r0,r4
                  |L7.36|
;;;121          }
;;;122        }
;;;123      }
;;;124      if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
;;;125        LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
;;;126        IP_STATS_INC(ip.rterr);
;;;127        snmp_inc_ipoutnoroutes();
;;;128        return NULL;
;;;129      }
;;;130      /* no matching netif found, use default netif */
;;;131      return netif_default;
;;;132    }
000024  bd70              POP      {r4-r6,pc}
                  |L7.38|
000026  6824              LDR      r4,[r4,#0]            ;115
                  |L7.40|
000028  2c00              CMP      r4,#0                 ;115
00002a  d1ee              BNE      |L7.10|
00002c  4808              LDR      r0,|L7.80|
00002e  6800              LDR      r0,[r0,#0]            ;124  ; netif_default
000030  b120              CBZ      r0,|L7.60|
000032  4807              LDR      r0,|L7.80|
000034  6800              LDR      r0,[r0,#0]            ;124  ; netif_default
000036  f7fffffe          BL       netif_is_up
00003a  b918              CBNZ     r0,|L7.68|
                  |L7.60|
00003c  bf00              NOP                            ;125
00003e  bf00              NOP                            ;125
000040  2000              MOVS     r0,#0                 ;128
000042  e7ef              B        |L7.36|
                  |L7.68|
000044  4802              LDR      r0,|L7.80|
000046  6800              LDR      r0,[r0,#0]            ;131  ; netif_default
000048  e7ec              B        |L7.36|
;;;133    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      netif_list
                  |L7.80|
                          DCD      netif_default

                          AREA ||.data||, DATA, ALIGN=2

                  ip_id
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  current_netif
                          DCD      0x00000000
                  current_header
                          DCD      0x00000000
