; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\eap.o --depend=.\obj\eap.d --feedback=.\obj\wifi.fed --cpu=Cortex-M3 --apcs=interwork -O0 -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\wpa_supp_linux_plat -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\utils -I..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer -I..\lwIP\src\include -I..\lwIP\port\include -I..\lwIP\src\include\ipv4 -I..\target -I..\netapp -I..\marvel\driver\inc -I..\marvel\wpa\inc -I..\sdio\inc -I..\main -ID:\keilarm\ARM\INC -ID:\keilarm\ARM\INC\ST\STM32F10x -D__MICROLIB -DIEEE8021X_EAPOL -DOS_NO_C_LIB_DEFINES -DCONFIG_PEERKEY -DCONFIG_IEEE80211W -DCONFIG_IEEE80211R -DxCLOSE_WPA_LIMIT --omf_browse=.\obj\eap.crf ..\wpa_supplicant-0.7.3\wpa_supplicant-0.7.3\src\eap_peer\eap.c]
                          THUMB

                          AREA ||i.dbug_buf||, CODE, READONLY, ALIGN=1

                  dbug_buf PROC
;;;22     #define WPA_RUN_TEST //wpa_printf(MSG_DEBUG,"WPA_RUN_TEST ### [%s:%d] FILE:%s .\r\n",__FUNCTION__,__LINE__,__FILE__);
;;;23     static void dbug_buf(const char * name , const unsigned char * buf , const int len)
000000  4770              BX       lr
;;;24     {
;;;25     	
;;;26     #if 0
;;;27     	int i = 0;
;;;28     	printf("dbug buf [%s]\n",name);
;;;29     	for(;i<len;i++)
;;;30     	{
;;;31     		printf("0x%02x,",buf[i]);
;;;32     	}
;;;33     	printf("\n");
;;;34     #endif
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.eap_allowed_method||, CODE, READONLY, ALIGN=1

                  eap_allowed_method PROC
;;;109     */
;;;110    int eap_allowed_method(struct eap_sm *sm, int vendor, u32 method)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;111    {
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;112    	struct eap_peer_config *config = eap_get_config(sm);
00000a  4648              MOV      r0,r9
00000c  f7fffffe          BL       eap_get_config
000010  4606              MOV      r6,r0
;;;113    	int i;
;;;114    	struct eap_method_type *m;
;;;115    
;;;116    	if (config == NULL || config->eap_methods == NULL)
000012  b10e              CBZ      r6,|L2.24|
000014  6db0              LDR      r0,[r6,#0x58]
000016  b910              CBNZ     r0,|L2.30|
                  |L2.24|
;;;117    		return 1;
000018  2001              MOVS     r0,#1
                  |L2.26|
;;;118    
;;;119    	m = config->eap_methods;
;;;120    	for (i = 0; m[i].vendor != EAP_VENDOR_IETF ||
;;;121    		     m[i].method != EAP_TYPE_NONE; i++) {
;;;122    		if (m[i].vendor == vendor && m[i].method == method)
;;;123    			return 1;
;;;124    	}
;;;125    	return 0;
;;;126    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L2.30|
00001e  6db5              LDR      r5,[r6,#0x58]         ;119
000020  2400              MOVS     r4,#0                 ;120
000022  e00b              B        |L2.60|
                  |L2.36|
000024  f8550034          LDR      r0,[r5,r4,LSL #3]     ;122
000028  42b8              CMP      r0,r7                 ;122
00002a  d106              BNE      |L2.58|
00002c  eb0500c4          ADD      r0,r5,r4,LSL #3       ;122
000030  6840              LDR      r0,[r0,#4]            ;122
000032  4540              CMP      r0,r8                 ;122
000034  d101              BNE      |L2.58|
000036  2001              MOVS     r0,#1                 ;123
000038  e7ef              B        |L2.26|
                  |L2.58|
00003a  1c64              ADDS     r4,r4,#1              ;121
                  |L2.60|
00003c  f8550034          LDR      r0,[r5,r4,LSL #3]     ;120
000040  2800              CMP      r0,#0                 ;120
000042  d1ef              BNE      |L2.36|
000044  eb0500c4          ADD      r0,r5,r4,LSL #3       ;121
000048  6840              LDR      r0,[r0,#4]            ;121
00004a  2800              CMP      r0,#0                 ;121
00004c  d1ea              BNE      |L2.36|
00004e  bf00              NOP                            ;125
000050  e7e3              B        |L2.26|
;;;127    
                          ENDP


                          AREA ||i.eap_allowed_phase2_type||, CODE, READONLY, ALIGN=1

                  eap_allowed_phase2_type PROC
;;;1679   
;;;1680   static int eap_allowed_phase2_type(int vendor, int type)
000000  4602              MOV      r2,r0
;;;1681   {
;;;1682   	if (vendor != EAP_VENDOR_IETF)
000002  b10a              CBZ      r2,|L3.8|
;;;1683   		return 0;
000004  2000              MOVS     r0,#0
                  |L3.6|
;;;1684   	return type != EAP_TYPE_PEAP && type != EAP_TYPE_TTLS &&
;;;1685   		type != EAP_TYPE_FAST;
;;;1686   }
000006  4770              BX       lr
                  |L3.8|
000008  2919              CMP      r1,#0x19              ;1684
00000a  d005              BEQ      |L3.24|
00000c  2915              CMP      r1,#0x15              ;1684
00000e  d003              BEQ      |L3.24|
000010  292b              CMP      r1,#0x2b              ;1685
000012  d001              BEQ      |L3.24|
000014  2001              MOVS     r0,#1                 ;1684
000016  e7f6              B        |L3.6|
                  |L3.24|
000018  2000              MOVS     r0,#0                 ;1684
00001a  e7f4              B        |L3.6|
;;;1687   
                          ENDP


                          AREA ||i.eap_clear_config_otp||, CODE, READONLY, ALIGN=1

                  eap_clear_config_otp PROC
;;;1886    */
;;;1887   void eap_clear_config_otp(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;1888   {
000002  4605              MOV      r5,r0
;;;1889   	struct eap_peer_config *config = eap_get_config(sm);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       eap_get_config
00000a  4604              MOV      r4,r0
;;;1890   	if (config == NULL)
00000c  b904              CBNZ     r4,|L4.16|
                  |L4.14|
;;;1891   		return;
;;;1892   	os_memset(config->otp, 0, config->otp_len);
;;;1893   	os_free(config->otp);
;;;1894   	config->otp = NULL;
;;;1895   	config->otp_len = 0;
;;;1896   }
00000e  bd70              POP      {r4-r6,pc}
                  |L4.16|
000010  f1040498          ADD      r4,r4,#0x98           ;1892
000014  f04f0100          MOV      r1,#0                 ;1892
000018  e9d40200          LDRD     r0,r2,[r4,#0]         ;1892
00001c  f7fffffe          BL       os_memset
000020  6820              LDR      r0,[r4,#0]            ;1893
000022  f7fffffe          BL       os_free
000026  2000              MOVS     r0,#0                 ;1894
000028  6020              STR      r0,[r4,#0]            ;1894
00002a  6060              STR      r0,[r4,#4]            ;1895
00002c  f1a40498          SUB      r4,r4,#0x98           ;1895
000030  bf00              NOP      
000032  e7ec              B        |L4.14|
;;;1897   
                          ENDP


                          AREA ||i.eap_deinit_prev_method||, CODE, READONLY, ALIGN=2

                  eap_deinit_prev_method PROC
;;;89     
;;;90     static void eap_deinit_prev_method(struct eap_sm *sm, const char *txt)
000000  b538              PUSH     {r3-r5,lr}
;;;91     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;92     	if (sm->m == NULL || sm->eap_method_priv == NULL)
000006  6ca0              LDR      r0,[r4,#0x48]
000008  b108              CBZ      r0,|L5.14|
00000a  6da0              LDR      r0,[r4,#0x58]
00000c  b900              CBNZ     r0,|L5.16|
                  |L5.14|
;;;93     		return;
;;;94     
;;;95     	wpa_printf(MSG_DEBUG, "EAP: deinitialize previously used EAP method "
;;;96     		   "(%d, %s) at %s", sm->selectedMethod, sm->m->name, txt);
;;;97     	sm->m->deinit(sm, sm->eap_method_priv);
;;;98     	sm->eap_method_priv = NULL;
;;;99     	sm->m = NULL;
;;;100    }
00000e  bd38              POP      {r3-r5,pc}
                  |L5.16|
000010  9500              STR      r5,[sp,#0]            ;95
000012  6ca0              LDR      r0,[r4,#0x48]         ;95
000014  7862              LDRB     r2,[r4,#1]            ;95
000016  a107              ADR      r1,|L5.52|
000018  6883              LDR      r3,[r0,#8]            ;95
00001a  2000              MOVS     r0,#0                 ;95
00001c  f7fffffe          BL       wpa_printf
000020  6da1              LDR      r1,[r4,#0x58]         ;97
000022  6ca0              LDR      r0,[r4,#0x48]         ;97
000024  6902              LDR      r2,[r0,#0x10]         ;97
000026  4620              MOV      r0,r4                 ;97
000028  4790              BLX      r2                    ;97
00002a  2000              MOVS     r0,#0                 ;98
00002c  65a0              STR      r0,[r4,#0x58]         ;98
00002e  64a0              STR      r0,[r4,#0x48]         ;99
000030  bf00              NOP      
000032  e7ec              B        |L5.14|
;;;101    
                          ENDP

                  |L5.52|
000034  4541503a          DCB      "EAP: deinitialize previously used EAP method (%d, %s) a"
000038  20646569
00003c  6e697469
000040  616c697a
000044  65207072
000048  6576696f
00004c  75736c79
000050  20757365
000054  64204541
000058  50206d65
00005c  74686f64
000060  20282564
000064  2c202573
000068  292061  
00006b  74202573          DCB      "t %s",0
00006f  00      

                          AREA ||i.eap_get_config||, CODE, READONLY, ALIGN=1

                  eap_get_config PROC
;;;1787    */
;;;1788   struct eap_peer_config * eap_get_config(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1789   {
000002  4604              MOV      r4,r0
;;;1790   	return sm->eapol_cb->get_config(sm->eapol_ctx);
000004  e9d40214          LDRD     r0,r2,[r4,#0x50]
000008  6811              LDR      r1,[r2,#0]
00000a  4788              BLX      r1
;;;1791   }
00000c  bd10              POP      {r4,pc}
;;;1792   
                          ENDP


                          AREA ||i.eap_get_config_blob||, CODE, READONLY, ALIGN=1

                  eap_get_config_blob PROC
;;;2067    */
;;;2068   const struct wpa_config_blob * eap_get_config_blob(struct eap_sm *sm,
000000  b570              PUSH     {r4-r6,lr}
;;;2069   						   const char *name)
;;;2070   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2071   #ifndef CONFIG_NO_CONFIG_BLOBS
;;;2072   	return sm->eapol_cb->get_config_blob(sm->eapol_ctx, name);
000006  e9d40114          LDRD     r0,r1,[r4,#0x50]
00000a  69ca              LDR      r2,[r1,#0x1c]
00000c  4629              MOV      r1,r5
00000e  4790              BLX      r2
;;;2073   #else /* CONFIG_NO_CONFIG_BLOBS */
;;;2074   	return NULL;
;;;2075   #endif /* CONFIG_NO_CONFIG_BLOBS */
;;;2076   }
000010  bd70              POP      {r4-r6,pc}
;;;2077   
                          ENDP


                          AREA ||i.eap_get_config_identity||, CODE, READONLY, ALIGN=1

                  eap_get_config_identity PROC
;;;1799    */
;;;1800   const u8 * eap_get_config_identity(struct eap_sm *sm, size_t *len)
000000  b570              PUSH     {r4-r6,lr}
;;;1801   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1802   	struct eap_peer_config *config = eap_get_config(sm);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       eap_get_config
00000c  4604              MOV      r4,r0
;;;1803   	if (config == NULL)
00000e  b90c              CBNZ     r4,|L8.20|
;;;1804   		return NULL;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;1805   	*len = config->identity_len;
;;;1806   	return config->identity;
;;;1807   }
000012  bd70              POP      {r4-r6,pc}
                  |L8.20|
000014  6860              LDR      r0,[r4,#4]            ;1805
000016  6028              STR      r0,[r5,#0]            ;1805
000018  6820              LDR      r0,[r4,#0]            ;1806
00001a  e7fa              B        |L8.18|
;;;1808   
                          ENDP


                          AREA ||i.eap_get_config_new_password||, CODE, READONLY, ALIGN=1

                  eap_get_config_new_password PROC
;;;1852    */
;;;1853   const u8 * eap_get_config_new_password(struct eap_sm *sm, size_t *len)
000000  b570              PUSH     {r4-r6,lr}
;;;1854   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1855   	struct eap_peer_config *config = eap_get_config(sm);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       eap_get_config
00000c  4604              MOV      r4,r0
;;;1856   	if (config == NULL)
00000e  b90c              CBNZ     r4,|L9.20|
;;;1857   		return NULL;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1858   	*len = config->new_password_len;
;;;1859   	return config->new_password;
;;;1860   }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  f8d400c8          LDR      r0,[r4,#0xc8]         ;1858
000018  6028              STR      r0,[r5,#0]            ;1858
00001a  f8d400c4          LDR      r0,[r4,#0xc4]         ;1859
00001e  e7f8              B        |L9.18|
;;;1861   
                          ENDP


                          AREA ||i.eap_get_config_otp||, CODE, READONLY, ALIGN=1

                  eap_get_config_otp PROC
;;;1868    */
;;;1869   const u8 * eap_get_config_otp(struct eap_sm *sm, size_t *len)
000000  b570              PUSH     {r4-r6,lr}
;;;1870   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1871   	struct eap_peer_config *config = eap_get_config(sm);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       eap_get_config
00000c  4604              MOV      r4,r0
;;;1872   	if (config == NULL)
00000e  b90c              CBNZ     r4,|L10.20|
;;;1873   		return NULL;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1874   	*len = config->otp_len;
;;;1875   	return config->otp;
;;;1876   }
000012  bd70              POP      {r4-r6,pc}
                  |L10.20|
000014  f8d4009c          LDR      r0,[r4,#0x9c]         ;1874
000018  6028              STR      r0,[r5,#0]            ;1874
00001a  f8d40098          LDR      r0,[r4,#0x98]         ;1875
00001e  e7f8              B        |L10.18|
;;;1877   
                          ENDP


                          AREA ||i.eap_get_config_password||, CODE, READONLY, ALIGN=1

                  eap_get_config_password PROC
;;;1815    */
;;;1816   const u8 * eap_get_config_password(struct eap_sm *sm, size_t *len)
000000  b570              PUSH     {r4-r6,lr}
;;;1817   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1818   	struct eap_peer_config *config = eap_get_config(sm);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       eap_get_config
00000c  4604              MOV      r4,r0
;;;1819   	if (config == NULL)
00000e  b90c              CBNZ     r4,|L11.20|
;;;1820   		return NULL;
000010  2000              MOVS     r0,#0
                  |L11.18|
;;;1821   	*len = config->password_len;
;;;1822   	return config->password;
;;;1823   }
000012  bd70              POP      {r4-r6,pc}
                  |L11.20|
000014  6960              LDR      r0,[r4,#0x14]         ;1821
000016  6028              STR      r0,[r5,#0]            ;1821
000018  6920              LDR      r0,[r4,#0x10]         ;1822
00001a  e7fa              B        |L11.18|
;;;1824   
                          ENDP


                          AREA ||i.eap_get_config_password2||, CODE, READONLY, ALIGN=1

                  eap_get_config_password2 PROC
;;;1834    */
;;;1835   const u8 * eap_get_config_password2(struct eap_sm *sm, size_t *len, int *hash)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1836   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1837   	struct eap_peer_config *config = eap_get_config(sm);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       eap_get_config
000010  4604              MOV      r4,r0
;;;1838   	if (config == NULL)
000012  b914              CBNZ     r4,|L12.26|
;;;1839   		return NULL;
000014  2000              MOVS     r0,#0
                  |L12.22|
;;;1840   	*len = config->password_len;
;;;1841   	if (hash)
;;;1842   		*hash = !!(config->flags & EAP_CONFIG_FLAGS_PASSWORD_NTHASH);
;;;1843   	return config->password;
;;;1844   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L12.26|
00001a  6960              LDR      r0,[r4,#0x14]         ;1840
00001c  6030              STR      r0,[r6,#0]            ;1840
00001e  b125              CBZ      r5,|L12.42|
000020  f8d400d0          LDR      r0,[r4,#0xd0]         ;1842
000024  f0000001          AND      r0,r0,#1              ;1842
000028  6028              STR      r0,[r5,#0]            ;1842
                  |L12.42|
00002a  6920              LDR      r0,[r4,#0x10]         ;1843
00002c  e7f3              B        |L12.22|
;;;1845   
                          ENDP


                          AREA ||i.eap_get_config_phase1||, CODE, READONLY, ALIGN=1

                  eap_get_config_phase1 PROC
;;;1903    */
;;;1904   const char * eap_get_config_phase1(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;1905   {
000002  4605              MOV      r5,r0
;;;1906   	struct eap_peer_config *config = eap_get_config(sm);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       eap_get_config
00000a  4604              MOV      r4,r0
;;;1907   	if (config == NULL)
00000c  b90c              CBNZ     r4,|L13.18|
;;;1908   		return NULL;
00000e  2000              MOVS     r0,#0
                  |L13.16|
;;;1909   	return config->phase1;
;;;1910   }
000010  bd70              POP      {r4-r6,pc}
                  |L13.18|
000012  6de0              LDR      r0,[r4,#0x5c]         ;1909
000014  e7fc              B        |L13.16|
;;;1911   
                          ENDP


                          AREA ||i.eap_get_config_phase2||, CODE, READONLY, ALIGN=1

                  eap_get_config_phase2 PROC
;;;1917    */
;;;1918   const char * eap_get_config_phase2(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;1919   {
000002  4605              MOV      r5,r0
;;;1920   	struct eap_peer_config *config = eap_get_config(sm);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       eap_get_config
00000a  4604              MOV      r4,r0
;;;1921   	if (config == NULL)
00000c  b90c              CBNZ     r4,|L14.18|
;;;1922   		return NULL;
00000e  2000              MOVS     r0,#0
                  |L14.16|
;;;1923   	return config->phase2;
;;;1924   }
000010  bd70              POP      {r4-r6,pc}
                  |L14.18|
000012  6e20              LDR      r0,[r4,#0x60]         ;1923
000014  e7fc              B        |L14.16|
;;;1925   
                          ENDP


                          AREA ||i.eap_get_eapKeyData||, CODE, READONLY, ALIGN=1

                  eap_get_eapKeyData PROC
;;;1994    */
;;;1995   const u8 * eap_get_eapKeyData(struct eap_sm *sm, size_t *len)
000000  4602              MOV      r2,r0
;;;1996   {
;;;1997   	if (sm == NULL || sm->eapKeyData == NULL) {
000002  b10a              CBZ      r2,|L15.8|
000004  6c10              LDR      r0,[r2,#0x40]
000006  b910              CBNZ     r0,|L15.14|
                  |L15.8|
;;;1998   		*len = 0;
000008  2000              MOVS     r0,#0
00000a  6008              STR      r0,[r1,#0]
                  |L15.12|
;;;1999   		return NULL;
;;;2000   	}
;;;2001   
;;;2002   	*len = sm->eapKeyDataLen;
;;;2003   	return sm->eapKeyData;
;;;2004   }
00000c  4770              BX       lr
                  |L15.14|
00000e  6c50              LDR      r0,[r2,#0x44]         ;2002
000010  6008              STR      r0,[r1,#0]            ;2002
000012  6c10              LDR      r0,[r2,#0x40]         ;2003
000014  e7fa              B        |L15.12|
;;;2005   
                          ENDP


                          AREA ||i.eap_get_eapRespData||, CODE, READONLY, ALIGN=1

                  eap_get_eapRespData PROC
;;;2016    */
;;;2017   struct wpabuf * eap_get_eapRespData(struct eap_sm *sm)
000000  4601              MOV      r1,r0
;;;2018   {
;;;2019   	struct wpabuf *resp;
;;;2020   
;;;2021   	if (sm == NULL || sm->eapRespData == NULL)
000002  b109              CBZ      r1,|L16.8|
000004  6b88              LDR      r0,[r1,#0x38]
000006  b908              CBNZ     r0,|L16.12|
                  |L16.8|
;;;2022   		return NULL;
000008  2000              MOVS     r0,#0
                  |L16.10|
;;;2023   
;;;2024   	resp = sm->eapRespData;
;;;2025   	sm->eapRespData = NULL;
;;;2026   
;;;2027   	return resp;
;;;2028   }
00000a  4770              BX       lr
                  |L16.12|
00000c  6b8a              LDR      r2,[r1,#0x38]         ;2024
00000e  2000              MOVS     r0,#0                 ;2025
000010  6388              STR      r0,[r1,#0x38]         ;2025
000012  4610              MOV      r0,r2                 ;2027
000014  e7f9              B        |L16.10|
;;;2029   
                          ENDP


                          AREA ||i.eap_get_phase2_type||, CODE, READONLY, ALIGN=1

                  eap_get_phase2_type PROC
;;;1698    */
;;;1699   u32 eap_get_phase2_type(const char *name, int *vendor)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1700   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1701   	int v;
;;;1702   	u8 type = eap_peer_get_type(name, &v);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       eap_peer_get_type
00000e  4606              MOV      r6,r0
;;;1703   	if (eap_allowed_phase2_type(v, type)) {
000010  4631              MOV      r1,r6
000012  9800              LDR      r0,[sp,#0]
000014  f7fffffe          BL       eap_allowed_phase2_type
000018  b118              CBZ      r0,|L17.34|
;;;1704   		*vendor = v;
00001a  9800              LDR      r0,[sp,#0]
00001c  6020              STR      r0,[r4,#0]
;;;1705   		return type;
00001e  4630              MOV      r0,r6
                  |L17.32|
;;;1706   	}
;;;1707   	*vendor = EAP_VENDOR_IETF;
;;;1708   	return EAP_TYPE_NONE;
;;;1709   }
000020  bdf8              POP      {r3-r7,pc}
                  |L17.34|
000022  2000              MOVS     r0,#0                 ;1707
000024  6020              STR      r0,[r4,#0]            ;1707
000026  bf00              NOP                            ;1708
000028  e7fa              B        |L17.32|
;;;1710   
                          ENDP


                          AREA ||i.eap_get_phase2_types||, CODE, READONLY, ALIGN=1

                  eap_get_phase2_types PROC
;;;1720    */
;;;1721   struct eap_method_type * eap_get_phase2_types(struct eap_peer_config *config,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1722   					      size_t *count)
;;;1723   {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
;;;1724   	struct eap_method_type *buf;
;;;1725   	u32 method;
;;;1726   	int vendor;
;;;1727   	size_t mcount;
;;;1728   	const struct eap_method *methods, *m;
;;;1729   
;;;1730   	methods = eap_peer_get_methods(&mcount);
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       eap_peer_get_methods
00000e  4682              MOV      r10,r0
;;;1731   	if (methods == NULL)
000010  f1ba0f00          CMP      r10,#0
000014  d102              BNE      |L18.28|
;;;1732   		return NULL;
000016  2000              MOVS     r0,#0
                  |L18.24|
;;;1733   	*count = 0;
;;;1734   	buf = os_malloc(mcount * sizeof(struct eap_method_type));
;;;1735   	if (buf == NULL)
;;;1736   		return NULL;
;;;1737   
;;;1738   	for (m = methods; m; m = m->next) {
;;;1739   		vendor = m->vendor;
;;;1740   		method = m->method;
;;;1741   		if (eap_allowed_phase2_type(vendor, method)) {
;;;1742   			if (vendor == EAP_VENDOR_IETF &&
;;;1743   			    method == EAP_TYPE_TLS && config &&
;;;1744   			    config->private_key2 == NULL)
;;;1745   				continue;
;;;1746   			buf[*count].vendor = vendor;
;;;1747   			buf[*count].method = method;
;;;1748   			(*count)++;
;;;1749   		}
;;;1750   	}
;;;1751   
;;;1752   	return buf;
;;;1753   }
000018  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.28|
00001c  2000              MOVS     r0,#0                 ;1733
00001e  6020              STR      r0,[r4,#0]            ;1733
000020  9900              LDR      r1,[sp,#0]            ;1734
000022  00c8              LSLS     r0,r1,#3              ;1734
000024  f7fffffe          BL       os_malloc
000028  4605              MOV      r5,r0                 ;1734
00002a  b90d              CBNZ     r5,|L18.48|
00002c  2000              MOVS     r0,#0                 ;1736
00002e  e7f3              B        |L18.24|
                  |L18.48|
000030  4656              MOV      r6,r10                ;1738
000032  e01f              B        |L18.116|
                  |L18.52|
000034  f8d68000          LDR      r8,[r6,#0]            ;1739
000038  7937              LDRB     r7,[r6,#4]            ;1740
00003a  4639              MOV      r1,r7                 ;1741
00003c  4640              MOV      r0,r8                 ;1741
00003e  f7fffffe          BL       eap_allowed_phase2_type
000042  b1a8              CBZ      r0,|L18.112|
000044  f1b80f00          CMP      r8,#0                 ;1742
000048  d108              BNE      |L18.92|
00004a  2f0d              CMP      r7,#0xd               ;1743
00004c  d106              BNE      |L18.92|
00004e  f1b90f00          CMP      r9,#0                 ;1743
000052  d003              BEQ      |L18.92|
000054  f8d90044          LDR      r0,[r9,#0x44]         ;1744
000058  b900              CBNZ     r0,|L18.92|
00005a  e00a              B        |L18.114|
                  |L18.92|
00005c  6820              LDR      r0,[r4,#0]            ;1746
00005e  f8458030          STR      r8,[r5,r0,LSL #3]     ;1746
000062  6820              LDR      r0,[r4,#0]            ;1747
000064  eb0500c0          ADD      r0,r5,r0,LSL #3       ;1747
000068  6047              STR      r7,[r0,#4]            ;1747
00006a  6820              LDR      r0,[r4,#0]            ;1748
00006c  1c40              ADDS     r0,r0,#1              ;1748
00006e  6020              STR      r0,[r4,#0]            ;1748
                  |L18.112|
000070  bf00              NOP                            ;1745
                  |L18.114|
000072  6bf6              LDR      r6,[r6,#0x3c]         ;1738
                  |L18.116|
000074  2e00              CMP      r6,#0                 ;1738
000076  d1dd              BNE      |L18.52|
000078  4628              MOV      r0,r5                 ;1752
00007a  e7cd              B        |L18.24|
;;;1754   
                          ENDP


                          AREA ||i.eap_invalidate_cached_session||, CODE, READONLY, ALIGN=2

                  eap_invalidate_cached_session PROC
;;;2111    */
;;;2112   void eap_invalidate_cached_session(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;2113   {
000002  4604              MOV      r4,r0
;;;2114   	if (sm)
000004  b11c              CBZ      r4,|L19.14|
;;;2115   		eap_deinit_prev_method(sm, "invalidate");
000006  a102              ADR      r1,|L19.16|
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       eap_deinit_prev_method
                  |L19.14|
;;;2116   }
00000e  bd10              POP      {r4,pc}
;;;2117   
                          ENDP

                  |L19.16|
000010  696e7661          DCB      "invalidate",0
000014  6c696461
000018  746500  
00001b  00                DCB      0

                          AREA ||i.eap_is_wps_pbc_enrollee||, CODE, READONLY, ALIGN=2

                  eap_is_wps_pbc_enrollee PROC
;;;2118   
;;;2119   int eap_is_wps_pbc_enrollee(struct eap_peer_config *conf)
000000  b510              PUSH     {r4,lr}
;;;2120   {
000002  4604              MOV      r4,r0
;;;2121   	if (conf->identity_len != WSC_ID_ENROLLEE_LEN ||
000004  6860              LDR      r0,[r4,#4]
000006  281d              CMP      r0,#0x1d
000008  d105              BNE      |L20.22|
;;;2122   	    os_memcmp(conf->identity, WSC_ID_ENROLLEE, WSC_ID_ENROLLEE_LEN))
00000a  221d              MOVS     r2,#0x1d
00000c  a108              ADR      r1,|L20.48|
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       os_memcmp
000014  b108              CBZ      r0,|L20.26|
                  |L20.22|
;;;2123   		return 0; /* Not a WPS Enrollee */
000016  2000              MOVS     r0,#0
                  |L20.24|
;;;2124   
;;;2125   	if (conf->phase1 == NULL || os_strstr(conf->phase1, "pbc=1") == NULL)
;;;2126   		return 0; /* Not using PBC */
;;;2127   
;;;2128   	return 1;
;;;2129   }
000018  bd10              POP      {r4,pc}
                  |L20.26|
00001a  6de0              LDR      r0,[r4,#0x5c]         ;2125
00001c  b120              CBZ      r0,|L20.40|
00001e  a10c              ADR      r1,|L20.80|
000020  6de0              LDR      r0,[r4,#0x5c]         ;2125
000022  f7fffffe          BL       os_strstr
000026  b908              CBNZ     r0,|L20.44|
                  |L20.40|
000028  2000              MOVS     r0,#0                 ;2126
00002a  e7f5              B        |L20.24|
                  |L20.44|
00002c  2001              MOVS     r0,#1                 ;2128
00002e  e7f3              B        |L20.24|
;;;2130   
                          ENDP

                  |L20.48|
000030  5746412d          DCB      "WFA-SimpleConfig-Enrollee-1-0",0
000034  53696d70
000038  6c65436f
00003c  6e666967
000040  2d456e72
000044  6f6c6c65
000048  652d312d
00004c  3000    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L20.80|
000050  7062633d          DCB      "pbc=1",0
000054  3100    
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.eap_is_wps_pin_enrollee||, CODE, READONLY, ALIGN=2

                  eap_is_wps_pin_enrollee PROC
;;;2131   
;;;2132   int eap_is_wps_pin_enrollee(struct eap_peer_config *conf)
000000  b510              PUSH     {r4,lr}
;;;2133   {
000002  4604              MOV      r4,r0
;;;2134   	if (conf->identity_len != WSC_ID_ENROLLEE_LEN ||
000004  6860              LDR      r0,[r4,#4]
000006  281d              CMP      r0,#0x1d
000008  d105              BNE      |L21.22|
;;;2135   	    os_memcmp(conf->identity, WSC_ID_ENROLLEE, WSC_ID_ENROLLEE_LEN))
00000a  221d              MOVS     r2,#0x1d
00000c  a108              ADR      r1,|L21.48|
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       os_memcmp
000014  b108              CBZ      r0,|L21.26|
                  |L21.22|
;;;2136   		return 0; /* Not a WPS Enrollee */
000016  2000              MOVS     r0,#0
                  |L21.24|
;;;2137   
;;;2138   	if (conf->phase1 == NULL || os_strstr(conf->phase1, "pin=") == NULL)
;;;2139   		return 0; /* Not using PIN */
;;;2140   
;;;2141   	return 1;
;;;2142   }
000018  bd10              POP      {r4,pc}
                  |L21.26|
00001a  6de0              LDR      r0,[r4,#0x5c]         ;2138
00001c  b120              CBZ      r0,|L21.40|
00001e  a10c              ADR      r1,|L21.80|
000020  6de0              LDR      r0,[r4,#0x5c]         ;2138
000022  f7fffffe          BL       os_strstr
000026  b908              CBNZ     r0,|L21.44|
                  |L21.40|
000028  2000              MOVS     r0,#0                 ;2139
00002a  e7f5              B        |L21.24|
                  |L21.44|
00002c  2001              MOVS     r0,#1                 ;2141
00002e  e7f3              B        |L21.24|
                          ENDP

                  |L21.48|
000030  5746412d          DCB      "WFA-SimpleConfig-Enrollee-1-0",0
000034  53696d70
000038  6c65436f
00003c  6e666967
000040  2d456e72
000044  6f6c6c65
000048  652d312d
00004c  3000    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L21.80|
000050  70696e3d          DCB      "pin=",0
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.eap_key_available||, CODE, READONLY, ALIGN=1

                  eap_key_available PROC
;;;1931    */
;;;1932   int eap_key_available(struct eap_sm *sm)
000000  4601              MOV      r1,r0
;;;1933   {
;;;1934   	return sm ? sm->eapKeyAvailable : 0;
000002  b109              CBZ      r1,|L22.8|
000004  6bc8              LDR      r0,[r1,#0x3c]
                  |L22.6|
;;;1935   }
000006  4770              BX       lr
                  |L22.8|
000008  2000              MOVS     r0,#0                 ;1934
00000a  e7fc              B        |L22.6|
;;;1936   
                          ENDP


                          AREA ||i.eap_notify_lower_layer_success||, CODE, READONLY, ALIGN=2

                  eap_notify_lower_layer_success PROC
;;;1962    */
;;;1963   void eap_notify_lower_layer_success(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1964   {
000002  4604              MOV      r4,r0
;;;1965   	if (sm == NULL)
000004  b904              CBNZ     r4,|L23.8|
                  |L23.6|
;;;1966   		return;
;;;1967   
;;;1968   
;;;1969   	if (eapol_get_bool(sm, EAPOL_eapSuccess) ||
;;;1970   	    sm->decision == DECISION_FAIL ||
;;;1971   	    (sm->methodState != METHOD_MAY_CONT &&
;;;1972   	     sm->methodState != METHOD_DONE))
;;;1973   		return;
;;;1974   
;;;1975   	if (sm->eapKeyData != NULL)
;;;1976   		sm->eapKeyAvailable = TRUE;
;;;1977   	eapol_set_bool(sm, EAPOL_eapSuccess, TRUE);
;;;1978   	wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_SUCCESS
;;;1979   		"EAP authentication completed successfully (based on lower "
;;;1980   		"layer success)");
;;;1981   }
000006  bd10              POP      {r4,pc}
                  |L23.8|
000008  2100              MOVS     r1,#0                 ;1969
00000a  4620              MOV      r0,r4                 ;1969
00000c  f7fffffe          BL       eapol_get_bool
000010  b938              CBNZ     r0,|L23.34|
000012  7b20              LDRB     r0,[r4,#0xc]          ;1970
000014  b128              CBZ      r0,|L23.34|
000016  78a0              LDRB     r0,[r4,#2]            ;1971
000018  2803              CMP      r0,#3                 ;1971
00001a  d003              BEQ      |L23.36|
00001c  78a0              LDRB     r0,[r4,#2]            ;1972
00001e  2804              CMP      r0,#4                 ;1972
000020  d000              BEQ      |L23.36|
                  |L23.34|
000022  e7f0              B        |L23.6|
                  |L23.36|
000024  6c20              LDR      r0,[r4,#0x40]         ;1975
000026  b108              CBZ      r0,|L23.44|
000028  2001              MOVS     r0,#1                 ;1976
00002a  63e0              STR      r0,[r4,#0x3c]         ;1976
                  |L23.44|
00002c  2201              MOVS     r2,#1                 ;1977
00002e  2100              MOVS     r1,#0                 ;1977
000030  4620              MOV      r0,r4                 ;1977
000032  f7fffffe          BL       eapol_set_bool
000036  4a04              LDR      r2,|L23.72|
000038  2100              MOVS     r1,#0                 ;1978
00003a  f8d40090          LDR      r0,[r4,#0x90]         ;1978
00003e  f7fffffe          BL       wpa_msg
000042  bf00              NOP      
000044  e7df              B        |L23.6|
;;;1982   
                          ENDP

000046  0000              DCW      0x0000
                  |L23.72|
                          DCD      ||.constdata||+0x1d4

                          AREA ||i.eap_notify_pending||, CODE, READONLY, ALIGN=1

                  eap_notify_pending PROC
;;;2101    */
;;;2102   void eap_notify_pending(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;2103   {
000002  4604              MOV      r4,r0
;;;2104   	sm->eapol_cb->notify_pending(sm->eapol_ctx);
000004  e9d40214          LDRD     r0,r2,[r4,#0x50]
000008  6a11              LDR      r1,[r2,#0x20]
00000a  4788              BLX      r1
;;;2105   }
00000c  bd10              POP      {r4,pc}
;;;2106   
                          ENDP


                          AREA ||i.eap_notify_success||, CODE, READONLY, ALIGN=1

                  eap_notify_success PROC
;;;1946    */
;;;1947   void eap_notify_success(struct eap_sm *sm)
000000  b118              CBZ      r0,|L25.10|
;;;1948   {
;;;1949   	if (sm) {
;;;1950   		sm->decision = DECISION_COND_SUCC;
000002  2101              MOVS     r1,#1
000004  7301              STRB     r1,[r0,#0xc]
;;;1951   		sm->EAP_state = EAP_SUCCESS;
000006  210b              MOVS     r1,#0xb
000008  7001              STRB     r1,[r0,#0]
                  |L25.10|
;;;1952   	}
;;;1953   }
00000a  4770              BX       lr
;;;1954   
                          ENDP


                          AREA ||i.eap_peer_method_load||, CODE, READONLY, ALIGN=1

                  eap_peer_method_load PROC
;;;78     
;;;79     static inline int eap_peer_method_load(const char *so)
000000  4601              MOV      r1,r0
;;;80     {
;;;81     	return 0;
000002  2000              MOVS     r0,#0
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.eap_peer_method_unload||, CODE, READONLY, ALIGN=1

                  eap_peer_method_unload PROC
;;;83     
;;;84     static inline int eap_peer_method_unload(struct eap_method *method)
000000  4601              MOV      r1,r0
;;;85     {
;;;86     	return 0;
000002  2000              MOVS     r0,#0
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.eap_peer_req_is_duplicate||, CODE, READONLY, ALIGN=2

                  eap_peer_req_is_duplicate PROC
;;;583    
;;;584    static int eap_peer_req_is_duplicate(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;585    {
000002  4604              MOV      r4,r0
;;;586    	int duplicate;
;;;587    
;;;588    	duplicate = (sm->reqId == sm->lastId) && sm->rxReq;
000004  6861              LDR      r1,[r4,#4]
000006  69e0              LDR      r0,[r4,#0x1c]
000008  4288              CMP      r0,r1
00000a  d103              BNE      |L28.20|
00000c  6920              LDR      r0,[r4,#0x10]
00000e  b108              CBZ      r0,|L28.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L28.22|
                  |L28.20|
000014  2000              MOVS     r0,#0
                  |L28.22|
000016  4605              MOV      r5,r0
;;;589    	if (sm->workaround && duplicate &&
000018  f8d4009c          LDR      r0,[r4,#0x9c]
00001c  b188              CBZ      r0,|L28.66|
00001e  b185              CBZ      r5,|L28.66|
;;;590    	    os_memcmp(sm->req_md5, sm->last_md5, 16) != 0) {
000020  2210              MOVS     r2,#0x10
000022  f1040180          ADD      r1,r4,#0x80
000026  f1040070          ADD      r0,r4,#0x70
00002a  f7fffffe          BL       os_memcmp
00002e  b140              CBZ      r0,|L28.66|
;;;591    		/*
;;;592    		 * RFC 4137 uses (reqId == lastId) as the only verification for
;;;593    		 * duplicate EAP requests. However, this misses cases where the
;;;594    		 * AS is incorrectly using the same id again; and
;;;595    		 * unfortunately, such implementations exist. Use MD5 hash as
;;;596    		 * an extra verification for the packets being duplicate to
;;;597    		 * workaround these issues.
;;;598    		 */
;;;599    		wpa_printf(MSG_DEBUG, "EAP: AS used the same Id again, but "
000030  4905              LDR      r1,|L28.72|
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       wpa_printf
;;;600    			   "EAP packets were not identical");
;;;601    		wpa_printf(MSG_DEBUG, "EAP: workaround - assume this is not a "
000038  a104              ADR      r1,|L28.76|
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       wpa_printf
;;;602    			   "duplicate packet");
;;;603    		duplicate = 0;
000040  2500              MOVS     r5,#0
                  |L28.66|
;;;604    	}
;;;605    
;;;606    	return duplicate;
000042  4628              MOV      r0,r5
;;;607    }
000044  bd70              POP      {r4-r6,pc}
;;;608    
                          ENDP

000046  0000              DCW      0x0000
                  |L28.72|
                          DCD      ||.constdata||+0x148
                  |L28.76|
00004c  4541503a          DCB      "EAP: workaround - assume this is not a duplicate packet"
000050  20776f72
000054  6b61726f
000058  756e6420
00005c  2d206173
000060  73756d65
000064  20746869
000068  73206973
00006c  206e6f74
000070  20612064
000074  75706c69
000078  63617465
00007c  20706163
000080  6b6574  
000083  00                DCB      0

                          AREA ||i.eap_peer_sm_deinit||, CODE, READONLY, ALIGN=2

                  eap_peer_sm_deinit PROC
;;;1275    */
;;;1276   void eap_peer_sm_deinit(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1277   {
000002  4604              MOV      r4,r0
;;;1278   	if (sm == NULL)
000004  b904              CBNZ     r4,|L29.8|
                  |L29.6|
;;;1279   		return;
;;;1280   	eap_deinit_prev_method(sm, "EAP deinit");
;;;1281   	eap_sm_abort(sm);
;;;1282   	tls_deinit(sm->ssl_ctx);
;;;1283   	os_free(sm);
;;;1284   }
000006  bd10              POP      {r4,pc}
                  |L29.8|
000008  a107              ADR      r1,|L29.40|
00000a  4620              MOV      r0,r4                 ;1280
00000c  f7fffffe          BL       eap_deinit_prev_method
000010  4620              MOV      r0,r4                 ;1281
000012  f7fffffe          BL       eap_sm_abort
000016  f8d40098          LDR      r0,[r4,#0x98]         ;1282
00001a  f7fffffe          BL       tls_deinit
00001e  4620              MOV      r0,r4                 ;1283
000020  f7fffffe          BL       os_free
000024  bf00              NOP      
000026  e7ee              B        |L29.6|
;;;1285   
                          ENDP

                  |L29.40|
000028  45415020          DCB      "EAP deinit",0
00002c  6465696e
000030  697400  
000033  00                DCB      0

                          AREA ||i.eap_peer_sm_init||, CODE, READONLY, ALIGN=2

                  eap_peer_sm_init PROC
;;;1231    */
;;;1232   struct eap_sm * eap_peer_sm_init(void *eapol_ctx,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1233   				 struct eapol_callbacks *eapol_cb,
;;;1234   				 void *msg_ctx, struct eap_config *conf)
;;;1235   {
000004  b086              SUB      sp,sp,#0x18
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  461d              MOV      r5,r3
;;;1236   	struct eap_sm *sm;
;;;1237   	struct tls_config tlsconf;
;;;1238   
;;;1239   	sm = os_zalloc(sizeof(*sm));
00000e  20b8              MOVS     r0,#0xb8
000010  f7fffffe          BL       os_zalloc
000014  4604              MOV      r4,r0
;;;1240   	if (sm == NULL)
000016  b91c              CBNZ     r4,|L30.32|
;;;1241   		return NULL;
000018  2000              MOVS     r0,#0
                  |L30.26|
;;;1242   	sm->eapol_ctx = eapol_ctx;
;;;1243   	sm->eapol_cb = eapol_cb;
;;;1244   	sm->msg_ctx = msg_ctx;
;;;1245   	sm->ClientTimeout = 60;
;;;1246   	sm->wps = conf->wps;
;;;1247   
;;;1248   	os_memset(&tlsconf, 0, sizeof(tlsconf));
;;;1249   	tlsconf.opensc_engine_path = conf->opensc_engine_path;
;;;1250   	tlsconf.pkcs11_engine_path = conf->pkcs11_engine_path;
;;;1251   	tlsconf.pkcs11_module_path = conf->pkcs11_module_path;
;;;1252   #ifdef CONFIG_FIPS
;;;1253   	tlsconf.fips_mode = 1;
;;;1254   #endif /* CONFIG_FIPS */
;;;1255   	tlsconf.event_cb = eap_peer_sm_tls_event;
;;;1256   	tlsconf.cb_ctx = sm;
;;;1257   	sm->ssl_ctx = tls_init(&tlsconf);
;;;1258   	if (sm->ssl_ctx == NULL) {
;;;1259   		wpa_printf(MSG_WARNING, "SSL: Failed to initialize TLS "
;;;1260   			   "context.");
;;;1261   		os_free(sm);
;;;1262   		return NULL;
;;;1263   	}
;;;1264   
;;;1265   	return sm;
;;;1266   }
00001a  b006              ADD      sp,sp,#0x18
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L30.32|
000020  6527              STR      r7,[r4,#0x50]         ;1242
000022  f8c48054          STR      r8,[r4,#0x54]         ;1243
000026  f8c46090          STR      r6,[r4,#0x90]         ;1244
00002a  203c              MOVS     r0,#0x3c              ;1245
00002c  6320              STR      r0,[r4,#0x30]         ;1245
00002e  68e8              LDR      r0,[r5,#0xc]          ;1246
000030  f8c400b0          STR      r0,[r4,#0xb0]         ;1246
000034  2218              MOVS     r2,#0x18              ;1248
000036  2100              MOVS     r1,#0                 ;1248
000038  4668              MOV      r0,sp                 ;1248
00003a  f7fffffe          BL       os_memset
00003e  6828              LDR      r0,[r5,#0]            ;1249
000040  9000              STR      r0,[sp,#0]            ;1249
000042  6868              LDR      r0,[r5,#4]            ;1250
000044  9001              STR      r0,[sp,#4]            ;1250
000046  68a8              LDR      r0,[r5,#8]            ;1251
000048  9002              STR      r0,[sp,#8]            ;1251
00004a  480b              LDR      r0,|L30.120|
00004c  9004              STR      r0,[sp,#0x10]         ;1255
00004e  9405              STR      r4,[sp,#0x14]         ;1256
000050  4668              MOV      r0,sp                 ;1257
000052  f7fffffe          BL       tls_init
000056  f8c40098          STR      r0,[r4,#0x98]         ;1257
00005a  f8d40098          LDR      r0,[r4,#0x98]         ;1258
00005e  b940              CBNZ     r0,|L30.114|
000060  a106              ADR      r1,|L30.124|
000062  2000              MOVS     r0,#0                 ;1259
000064  f7fffffe          BL       wpa_printf
000068  4620              MOV      r0,r4                 ;1261
00006a  f7fffffe          BL       os_free
00006e  2000              MOVS     r0,#0                 ;1262
000070  e7d3              B        |L30.26|
                  |L30.114|
000072  4620              MOV      r0,r4                 ;1265
000074  e7d1              B        |L30.26|
;;;1267   
                          ENDP

000076  0000              DCW      0x0000
                  |L30.120|
                          DCD      eap_peer_sm_tls_event
                  |L30.124|
00007c  53534c3a          DCB      "SSL: Failed to initialize TLS context.",0
000080  20466169
000084  6c656420
000088  746f2069
00008c  6e697469
000090  616c697a
000094  6520544c
000098  5320636f
00009c  6e746578
0000a0  742e00  
0000a3  00                DCB      0

                          AREA ||i.eap_peer_sm_step||, CODE, READONLY, ALIGN=1

                  eap_peer_sm_step PROC
;;;1295    */
;;;1296   int eap_peer_sm_step(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;1297   {
000002  4604              MOV      r4,r0
;;;1298   	int res = 0;
000004  2500              MOVS     r5,#0
;;;1299   	do {
000006  bf00              NOP      
                  |L31.8|
;;;1300   		sm->changed = FALSE;
000008  2000              MOVS     r0,#0
00000a  64e0              STR      r0,[r4,#0x4c]
;;;1301   		SM_STEP_RUN(EAP);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       sm_EAP_Step
;;;1302   		if (sm->changed)
000012  6ce0              LDR      r0,[r4,#0x4c]
000014  b100              CBZ      r0,|L31.24|
;;;1303   			res = 1;
000016  2501              MOVS     r5,#1
                  |L31.24|
;;;1304   	} while (sm->changed);
000018  6ce0              LDR      r0,[r4,#0x4c]
00001a  2800              CMP      r0,#0
00001c  d1f4              BNE      |L31.8|
;;;1305   	return res;
00001e  4628              MOV      r0,r5
;;;1306   }
000020  bd70              POP      {r4-r6,pc}
;;;1307   
                          ENDP


                          AREA ||i.eap_peer_sm_step_idle||, CODE, READONLY, ALIGN=1

                  eap_peer_sm_step_idle PROC
;;;551    
;;;552    static void eap_peer_sm_step_idle(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;553    {
000002  4604              MOV      r4,r0
;;;554    	/*
;;;555    	 * The first three transitions are from RFC 4137. The last two are
;;;556    	 * local additions to handle special cases with LEAP and PEAP server
;;;557    	 * not sending EAP-Success in some cases.
;;;558    	 */
;;;559    	if (eapol_get_bool(sm, EAPOL_eapReq))
000004  2105              MOVS     r1,#5
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       eapol_get_bool
00000c  b120              CBZ      r0,|L32.24|
;;;560    		SM_ENTER(EAP, RECEIVED);
00000e  2100              MOVS     r1,#0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       sm_EAP_RECEIVED_Enter
000016  e04c              B        |L32.178|
                  |L32.24|
;;;561    	else if ((eapol_get_bool(sm, EAPOL_altAccept) &&
000018  2107              MOVS     r1,#7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       eapol_get_bool
000020  b108              CBZ      r0,|L32.38|
;;;562    		  sm->decision != DECISION_FAIL) ||
000022  7b20              LDRB     r0,[r4,#0xc]
000024  b938              CBNZ     r0,|L32.54|
                  |L32.38|
;;;563    		 (eapol_get_int(sm, EAPOL_idleWhile) == 0 &&
000026  2100              MOVS     r1,#0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       eapol_get_int
00002e  b938              CBNZ     r0,|L32.64|
;;;564    		  sm->decision == DECISION_UNCOND_SUCC))
000030  7b20              LDRB     r0,[r4,#0xc]
000032  2802              CMP      r0,#2
000034  d104              BNE      |L32.64|
                  |L32.54|
;;;565    		SM_ENTER(EAP, SUCCESS);
000036  2100              MOVS     r1,#0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       sm_EAP_SUCCESS_Enter
00003e  e038              B        |L32.178|
                  |L32.64|
;;;566    	else if (eapol_get_bool(sm, EAPOL_altReject) ||
000040  2108              MOVS     r1,#8
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       eapol_get_bool
000048  b988              CBNZ     r0,|L32.110|
;;;567    		 (eapol_get_int(sm, EAPOL_idleWhile) == 0 &&
00004a  2100              MOVS     r1,#0
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       eapol_get_int
000052  b910              CBNZ     r0,|L32.90|
;;;568    		  sm->decision != DECISION_UNCOND_SUCC) ||
000054  7b20              LDRB     r0,[r4,#0xc]
000056  2802              CMP      r0,#2
000058  d109              BNE      |L32.110|
                  |L32.90|
;;;569    		 (eapol_get_bool(sm, EAPOL_altAccept) &&
00005a  2107              MOVS     r1,#7
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       eapol_get_bool
000062  b148              CBZ      r0,|L32.120|
;;;570    		  sm->methodState != METHOD_CONT &&
000064  78a0              LDRB     r0,[r4,#2]
000066  2802              CMP      r0,#2
000068  d006              BEQ      |L32.120|
;;;571    		  sm->decision == DECISION_FAIL))
00006a  7b20              LDRB     r0,[r4,#0xc]
00006c  b920              CBNZ     r0,|L32.120|
                  |L32.110|
;;;572    		SM_ENTER(EAP, FAILURE);
00006e  2100              MOVS     r1,#0
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       sm_EAP_FAILURE_Enter
000076  e01c              B        |L32.178|
                  |L32.120|
;;;573    	else if (sm->selectedMethod == EAP_TYPE_LEAP &&
000078  7860              LDRB     r0,[r4,#1]
00007a  2811              CMP      r0,#0x11
00007c  d10b              BNE      |L32.150|
;;;574    		 sm->leap_done && sm->decision != DECISION_FAIL &&
00007e  6ea0              LDR      r0,[r4,#0x68]
000080  b148              CBZ      r0,|L32.150|
000082  7b20              LDRB     r0,[r4,#0xc]
000084  b138              CBZ      r0,|L32.150|
;;;575    		 sm->methodState == METHOD_DONE)
000086  78a0              LDRB     r0,[r4,#2]
000088  2804              CMP      r0,#4
00008a  d104              BNE      |L32.150|
;;;576    		SM_ENTER(EAP, SUCCESS);
00008c  2100              MOVS     r1,#0
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       sm_EAP_SUCCESS_Enter
000094  e00d              B        |L32.178|
                  |L32.150|
;;;577    	else if (sm->selectedMethod == EAP_TYPE_PEAP &&
000096  7860              LDRB     r0,[r4,#1]
000098  2819              CMP      r0,#0x19
00009a  d10a              BNE      |L32.178|
;;;578    		 sm->peap_done && sm->decision != DECISION_FAIL &&
00009c  6ee0              LDR      r0,[r4,#0x6c]
00009e  b140              CBZ      r0,|L32.178|
0000a0  7b20              LDRB     r0,[r4,#0xc]
0000a2  b130              CBZ      r0,|L32.178|
;;;579    		 sm->methodState == METHOD_DONE)
0000a4  78a0              LDRB     r0,[r4,#2]
0000a6  2804              CMP      r0,#4
0000a8  d103              BNE      |L32.178|
;;;580    		SM_ENTER(EAP, SUCCESS);
0000aa  2100              MOVS     r1,#0
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       sm_EAP_SUCCESS_Enter
                  |L32.178|
;;;581    }
0000b2  bd10              POP      {r4,pc}
;;;582    
                          ENDP


                          AREA ||i.eap_peer_sm_step_local||, CODE, READONLY, ALIGN=1

                  eap_peer_sm_step_local PROC
;;;658    
;;;659    static void eap_peer_sm_step_local(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;660    {
000002  4604              MOV      r4,r0
;;;661    	switch (sm->EAP_state) {
000004  7820              LDRB     r0,[r4,#0]
000006  280d              CMP      r0,#0xd
000008  d258              BCS      |L33.188|
00000a  e8dff000          TBB      [pc,r0]
00000e  070c              DCB      0x07,0x0c
000010  191d2130          DCB      0x19,0x1d,0x21,0x30
000014  3c41464b          DCB      0x3c,0x41,0x46,0x4b
000018  50555600          DCB      0x50,0x55,0x56,0x00
;;;662    	case EAP_INITIALIZE:
;;;663    		SM_ENTER(EAP, IDLE);
00001c  2100              MOVS     r1,#0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       sm_EAP_IDLE_Enter
;;;664    		break;
000024  e04a              B        |L33.188|
;;;665    	case EAP_DISABLED:
;;;666    		if (eapol_get_bool(sm, EAPOL_portEnabled) &&
000026  2106              MOVS     r1,#6
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       eapol_get_bool
00002e  b130              CBZ      r0,|L33.62|
;;;667    		    !sm->force_disabled)
000030  f8d400ac          LDR      r0,[r4,#0xac]
000034  b918              CBNZ     r0,|L33.62|
;;;668    			SM_ENTER(EAP, INITIALIZE);
000036  2100              MOVS     r1,#0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       sm_EAP_INITIALIZE_Enter
                  |L33.62|
;;;669    		break;
00003e  e03d              B        |L33.188|
;;;670    	case EAP_IDLE:
;;;671    		eap_peer_sm_step_idle(sm);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       eap_peer_sm_step_idle
;;;672    		break;
000046  e039              B        |L33.188|
;;;673    	case EAP_RECEIVED:
;;;674    		eap_peer_sm_step_received(sm);
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       eap_peer_sm_step_received
;;;675    		break;
00004e  e035              B        |L33.188|
;;;676    	case EAP_GET_METHOD:
;;;677    		if (sm->selectedMethod == sm->reqMethod)
000050  7860              LDRB     r0,[r4,#1]
000052  f8941020          LDRB     r1,[r4,#0x20]
000056  4288              CMP      r0,r1
000058  d104              BNE      |L33.100|
;;;678    			SM_ENTER(EAP, METHOD);
00005a  2100              MOVS     r1,#0
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       sm_EAP_METHOD_Enter
000062  e003              B        |L33.108|
                  |L33.100|
;;;679    		else
;;;680    			SM_ENTER(EAP, SEND_RESPONSE);
000064  2100              MOVS     r1,#0
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       sm_EAP_SEND_RESPONSE_Enter
                  |L33.108|
;;;681    		break;
00006c  e026              B        |L33.188|
;;;682    	case EAP_METHOD:
;;;683    		if (sm->ignore)
00006e  6ae0              LDR      r0,[r4,#0x2c]
000070  b120              CBZ      r0,|L33.124|
;;;684    			SM_ENTER(EAP, DISCARD);
000072  2100              MOVS     r1,#0
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       sm_EAP_DISCARD_Enter
00007a  e003              B        |L33.132|
                  |L33.124|
;;;685    		else
;;;686    			SM_ENTER(EAP, SEND_RESPONSE);
00007c  2100              MOVS     r1,#0
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       sm_EAP_SEND_RESPONSE_Enter
                  |L33.132|
;;;687    		break;
000084  e01a              B        |L33.188|
;;;688    	case EAP_SEND_RESPONSE:
;;;689    		SM_ENTER(EAP, IDLE);
000086  2100              MOVS     r1,#0
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       sm_EAP_IDLE_Enter
;;;690    		break;
00008e  e015              B        |L33.188|
;;;691    	case EAP_DISCARD:
;;;692    		SM_ENTER(EAP, IDLE);
000090  2100              MOVS     r1,#0
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       sm_EAP_IDLE_Enter
;;;693    		break;
000098  e010              B        |L33.188|
;;;694    	case EAP_IDENTITY:
;;;695    		SM_ENTER(EAP, SEND_RESPONSE);
00009a  2100              MOVS     r1,#0
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       sm_EAP_SEND_RESPONSE_Enter
;;;696    		break;
0000a2  e00b              B        |L33.188|
;;;697    	case EAP_NOTIFICATION:
;;;698    		SM_ENTER(EAP, SEND_RESPONSE);
0000a4  2100              MOVS     r1,#0
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       sm_EAP_SEND_RESPONSE_Enter
;;;699    		break;
0000ac  e006              B        |L33.188|
;;;700    	case EAP_RETRANSMIT:
;;;701    		SM_ENTER(EAP, SEND_RESPONSE);
0000ae  2100              MOVS     r1,#0
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       sm_EAP_SEND_RESPONSE_Enter
;;;702    		break;
0000b6  e001              B        |L33.188|
;;;703    	case EAP_SUCCESS:
;;;704    		break;
0000b8  e000              B        |L33.188|
;;;705    	case EAP_FAILURE:
;;;706    		break;
0000ba  bf00              NOP      
                  |L33.188|
0000bc  bf00              NOP                            ;664
;;;707    	}
;;;708    }
0000be  bd10              POP      {r4,pc}
;;;709    
                          ENDP


                          AREA ||i.eap_peer_sm_step_received||, CODE, READONLY, ALIGN=1

                  eap_peer_sm_step_received PROC
;;;609    
;;;610    static void eap_peer_sm_step_received(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;611    {
000002  4604              MOV      r4,r0
;;;612    	int duplicate = eap_peer_req_is_duplicate(sm);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       eap_peer_req_is_duplicate
00000a  4605              MOV      r5,r0
;;;613    
;;;614    	/*
;;;615    	 * Two special cases below for LEAP are local additions to work around
;;;616    	 * odd LEAP behavior (EAP-Success in the middle of authentication and
;;;617    	 * then swapped roles). Other transitions are based on RFC 4137.
;;;618    	 */
;;;619    	if (sm->rxSuccess && sm->decision != DECISION_FAIL &&
00000c  6960              LDR      r0,[r4,#0x14]
00000e  b180              CBZ      r0,|L34.50|
000010  7b20              LDRB     r0,[r4,#0xc]
000012  b170              CBZ      r0,|L34.50|
;;;620    	    (sm->reqId == sm->lastId ||
000014  6861              LDR      r1,[r4,#4]
000016  69e0              LDR      r0,[r4,#0x1c]
000018  4288              CMP      r0,r1
00001a  d005              BEQ      |L34.40|
;;;621    	     eap_success_workaround(sm, sm->reqId, sm->lastId)))
00001c  4620              MOV      r0,r4
00001e  6862              LDR      r2,[r4,#4]
000020  69e1              LDR      r1,[r4,#0x1c]
000022  f7fffffe          BL       eap_success_workaround
000026  b120              CBZ      r0,|L34.50|
                  |L34.40|
;;;622    		SM_ENTER(EAP, SUCCESS);
000028  2100              MOVS     r1,#0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       sm_EAP_SUCCESS_Enter
000030  e076              B        |L34.288|
                  |L34.50|
;;;623    	else if (sm->methodState != METHOD_CONT &&
000032  78a0              LDRB     r0,[r4,#2]
000034  2802              CMP      r0,#2
000036  d01d              BEQ      |L34.116|
;;;624    		 ((sm->rxFailure &&
000038  69a0              LDR      r0,[r4,#0x18]
00003a  b110              CBZ      r0,|L34.66|
;;;625    		   sm->decision != DECISION_UNCOND_SUCC) ||
00003c  7b20              LDRB     r0,[r4,#0xc]
00003e  2802              CMP      r0,#2
000040  d109              BNE      |L34.86|
                  |L34.66|
;;;626    		  (sm->rxSuccess && sm->decision == DECISION_FAIL &&
000042  6960              LDR      r0,[r4,#0x14]
000044  b1b0              CBZ      r0,|L34.116|
000046  7b20              LDRB     r0,[r4,#0xc]
000048  b9a0              CBNZ     r0,|L34.116|
;;;627    		   (sm->selectedMethod != EAP_TYPE_LEAP ||
00004a  7860              LDRB     r0,[r4,#1]
00004c  2811              CMP      r0,#0x11
00004e  d102              BNE      |L34.86|
;;;628    		    sm->methodState != METHOD_MAY_CONT))) &&
000050  78a0              LDRB     r0,[r4,#2]
000052  2803              CMP      r0,#3
000054  d00e              BEQ      |L34.116|
                  |L34.86|
;;;629    		 (sm->reqId == sm->lastId ||
000056  6861              LDR      r1,[r4,#4]
000058  69e0              LDR      r0,[r4,#0x1c]
00005a  4288              CMP      r0,r1
00005c  d005              BEQ      |L34.106|
;;;630    		  eap_success_workaround(sm, sm->reqId, sm->lastId)))
00005e  4620              MOV      r0,r4
000060  6862              LDR      r2,[r4,#4]
000062  69e1              LDR      r1,[r4,#0x1c]
000064  f7fffffe          BL       eap_success_workaround
000068  b120              CBZ      r0,|L34.116|
                  |L34.106|
;;;631    		SM_ENTER(EAP, FAILURE);
00006a  2100              MOVS     r1,#0
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       sm_EAP_FAILURE_Enter
000072  e055              B        |L34.288|
                  |L34.116|
;;;632    	else if (sm->rxReq && duplicate)
000074  6920              LDR      r0,[r4,#0x10]
000076  b128              CBZ      r0,|L34.132|
000078  b125              CBZ      r5,|L34.132|
;;;633    		SM_ENTER(EAP, RETRANSMIT);
00007a  2100              MOVS     r1,#0
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       sm_EAP_RETRANSMIT_Enter
000082  e04d              B        |L34.288|
                  |L34.132|
;;;634    	else if (sm->rxReq && !duplicate &&
000084  6920              LDR      r0,[r4,#0x10]
000086  b158              CBZ      r0,|L34.160|
000088  b955              CBNZ     r5,|L34.160|
;;;635    		 sm->reqMethod == EAP_TYPE_NOTIFICATION &&
00008a  f8940020          LDRB     r0,[r4,#0x20]
00008e  2802              CMP      r0,#2
000090  d106              BNE      |L34.160|
;;;636    		 sm->allowNotifications)
000092  6b60              LDR      r0,[r4,#0x34]
000094  b120              CBZ      r0,|L34.160|
;;;637    		SM_ENTER(EAP, NOTIFICATION);
000096  2100              MOVS     r1,#0
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       sm_EAP_NOTIFICATION_Enter
00009e  e03f              B        |L34.288|
                  |L34.160|
;;;638    	else if (sm->rxReq && !duplicate &&
0000a0  6920              LDR      r0,[r4,#0x10]
0000a2  b158              CBZ      r0,|L34.188|
0000a4  b955              CBNZ     r5,|L34.188|
;;;639    		 sm->selectedMethod == EAP_TYPE_NONE &&
0000a6  7860              LDRB     r0,[r4,#1]
0000a8  b940              CBNZ     r0,|L34.188|
;;;640    		 sm->reqMethod == EAP_TYPE_IDENTITY)
0000aa  f8940020          LDRB     r0,[r4,#0x20]
0000ae  2801              CMP      r0,#1
0000b0  d104              BNE      |L34.188|
;;;641    		SM_ENTER(EAP, IDENTITY);
0000b2  2100              MOVS     r1,#0
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       sm_EAP_IDENTITY_Enter
0000ba  e031              B        |L34.288|
                  |L34.188|
;;;642    	else if (sm->rxReq && !duplicate &&
0000bc  6920              LDR      r0,[r4,#0x10]
0000be  b178              CBZ      r0,|L34.224|
0000c0  b975              CBNZ     r5,|L34.224|
;;;643    		 sm->selectedMethod == EAP_TYPE_NONE &&
0000c2  7860              LDRB     r0,[r4,#1]
0000c4  b960              CBNZ     r0,|L34.224|
;;;644    		 sm->reqMethod != EAP_TYPE_IDENTITY &&
0000c6  f8940020          LDRB     r0,[r4,#0x20]
0000ca  2801              CMP      r0,#1
0000cc  d008              BEQ      |L34.224|
;;;645    		 sm->reqMethod != EAP_TYPE_NOTIFICATION)
0000ce  f8940020          LDRB     r0,[r4,#0x20]
0000d2  2802              CMP      r0,#2
0000d4  d004              BEQ      |L34.224|
;;;646    		SM_ENTER(EAP, GET_METHOD);
0000d6  2100              MOVS     r1,#0
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       sm_EAP_GET_METHOD_Enter
0000de  e01f              B        |L34.288|
                  |L34.224|
;;;647    	else if (sm->rxReq && !duplicate &&
0000e0  6920              LDR      r0,[r4,#0x10]
0000e2  b168              CBZ      r0,|L34.256|
0000e4  b965              CBNZ     r5,|L34.256|
;;;648    		 sm->reqMethod == sm->selectedMethod &&
0000e6  f8940020          LDRB     r0,[r4,#0x20]
0000ea  7861              LDRB     r1,[r4,#1]
0000ec  4288              CMP      r0,r1
0000ee  d107              BNE      |L34.256|
;;;649    		 sm->methodState != METHOD_DONE)
0000f0  78a0              LDRB     r0,[r4,#2]
0000f2  2804              CMP      r0,#4
0000f4  d004              BEQ      |L34.256|
;;;650    		SM_ENTER(EAP, METHOD);
0000f6  2100              MOVS     r1,#0
0000f8  4620              MOV      r0,r4
0000fa  f7fffffe          BL       sm_EAP_METHOD_Enter
0000fe  e00f              B        |L34.288|
                  |L34.256|
;;;651    	else if (sm->selectedMethod == EAP_TYPE_LEAP &&
000100  7860              LDRB     r0,[r4,#1]
000102  2811              CMP      r0,#0x11
000104  d108              BNE      |L34.280|
;;;652    		 (sm->rxSuccess || sm->rxResp))
000106  6960              LDR      r0,[r4,#0x14]
000108  b908              CBNZ     r0,|L34.270|
00010a  6e60              LDR      r0,[r4,#0x64]
00010c  b120              CBZ      r0,|L34.280|
                  |L34.270|
;;;653    		SM_ENTER(EAP, METHOD);
00010e  2100              MOVS     r1,#0
000110  4620              MOV      r0,r4
000112  f7fffffe          BL       sm_EAP_METHOD_Enter
000116  e003              B        |L34.288|
                  |L34.280|
;;;654    	else
;;;655    		SM_ENTER(EAP, DISCARD);
000118  2100              MOVS     r1,#0
00011a  4620              MOV      r0,r4
00011c  f7fffffe          BL       sm_EAP_DISCARD_Enter
                  |L34.288|
;;;656    }
000120  bd70              POP      {r4-r6,pc}
;;;657    
                          ENDP


                          AREA ||i.eap_peer_sm_tls_event||, CODE, READONLY, ALIGN=2

                  eap_peer_sm_tls_event PROC
;;;1163   
;;;1164   static void eap_peer_sm_tls_event(void *ctx, enum tls_event ev,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1165   				  union tls_event_data *data)
;;;1166   {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
;;;1167   	struct eap_sm *sm = ctx;
00000a  4646              MOV      r6,r8
;;;1168   	char *hash_hex = NULL;
00000c  2500              MOVS     r5,#0
;;;1169   	char *cert_hex = NULL;
00000e  2700              MOVS     r7,#0
;;;1170   
;;;1171   	switch (ev) {
000010  f1b90f00          CMP      r9,#0
000014  d003              BEQ      |L35.30|
000016  f1b90f01          CMP      r9,#1
00001a  d159              BNE      |L35.208|
00001c  e00c              B        |L35.56|
                  |L35.30|
;;;1172   	case TLS_CERT_CHAIN_FAILURE:
;;;1173   		wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_TLS_CERT_ERROR
00001e  68e3              LDR      r3,[r4,#0xc]
000020  e9d41200          LDRD     r1,r2,[r4,#0]
000024  e88d000e          STM      sp,{r1-r3}
000028  7a23              LDRB     r3,[r4,#8]
00002a  4a2e              LDR      r2,|L35.228|
00002c  2100              MOVS     r1,#0
00002e  f8d60090          LDR      r0,[r6,#0x90]
000032  f7fffffe          BL       wpa_msg
;;;1174   			"reason=%d depth=%d subject='%s' err='%s'",
;;;1175   			data->cert_fail.reason,
;;;1176   			data->cert_fail.depth,
;;;1177   			data->cert_fail.subject,
;;;1178   			data->cert_fail.reason_txt);
;;;1179   		break;
000036  e04b              B        |L35.208|
                  |L35.56|
;;;1180   	case TLS_PEER_CERTIFICATE:
;;;1181   		if (data->peer_cert.hash) {
000038  68e0              LDR      r0,[r4,#0xc]
00003a  b178              CBZ      r0,|L35.92|
;;;1182   			size_t len = data->peer_cert.hash_len * 2 + 1;
00003c  2101              MOVS     r1,#1
00003e  6920              LDR      r0,[r4,#0x10]
000040  eb010a40          ADD      r10,r1,r0,LSL #1
;;;1183   			hash_hex = os_malloc(len);
000044  4650              MOV      r0,r10
000046  f7fffffe          BL       os_malloc
00004a  4605              MOV      r5,r0
;;;1184   			if (hash_hex) {
00004c  b12d              CBZ      r5,|L35.90|
;;;1185   				wpa_snprintf_hex(hash_hex, len,
00004e  4651              MOV      r1,r10
000050  4628              MOV      r0,r5
000052  e9d42303          LDRD     r2,r3,[r4,#0xc]
000056  f7fffffe          BL       wpa_snprintf_hex
                  |L35.90|
;;;1186   						 data->peer_cert.hash,
;;;1187   						 data->peer_cert.hash_len);
;;;1188   			}
;;;1189   		}
00005a  bf00              NOP      
                  |L35.92|
;;;1190   		wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_PEER_CERT
00005c  b10d              CBZ      r5,|L35.98|
;;;1191   			"depth=%d subject='%s'%s%s",
;;;1192   			data->peer_cert.depth, data->peer_cert.subject,
;;;1193   			hash_hex ? " hash=" : "", hash_hex ? hash_hex : "");
00005e  462b              MOV      r3,r5
000060  e000              B        |L35.100|
                  |L35.98|
000062  a321              ADR      r3,|L35.232|
                  |L35.100|
000064  b10d              CBZ      r5,|L35.106|
000066  a221              ADR      r2,|L35.236|
000068  e000              B        |L35.108|
                  |L35.106|
00006a  a21f              ADR      r2,|L35.232|
                  |L35.108|
00006c  6861              LDR      r1,[r4,#4]
00006e  e88d000e          STM      sp,{r1-r3}
000072  6823              LDR      r3,[r4,#0]
000074  a21f              ADR      r2,|L35.244|
000076  2100              MOVS     r1,#0
000078  f8d60090          LDR      r0,[r6,#0x90]
00007c  f7fffffe          BL       wpa_msg
;;;1194   
;;;1195   		if (data->peer_cert.cert) {
000080  68a0              LDR      r0,[r4,#8]
000082  b320              CBZ      r0,|L35.206|
;;;1196   			size_t len = wpabuf_len(data->peer_cert.cert) * 2 + 1;
000084  68a0              LDR      r0,[r4,#8]
000086  f7fffffe          BL       wpabuf_len
00008a  2101              MOVS     r1,#1
00008c  eb010a40          ADD      r10,r1,r0,LSL #1
;;;1197   			cert_hex = os_malloc(len);
000090  4650              MOV      r0,r10
000092  f7fffffe          BL       os_malloc
000096  4607              MOV      r7,r0
;;;1198   			if (cert_hex == NULL)
000098  b907              CBNZ     r7,|L35.156|
;;;1199   				break;
00009a  e019              B        |L35.208|
                  |L35.156|
;;;1200   			wpa_snprintf_hex(cert_hex, len,
00009c  68a0              LDR      r0,[r4,#8]
00009e  f7fffffe          BL       wpabuf_len
0000a2  4683              MOV      r11,r0
0000a4  68a0              LDR      r0,[r4,#8]
0000a6  f7fffffe          BL       wpabuf_head
0000aa  465b              MOV      r3,r11
0000ac  4602              MOV      r2,r0
0000ae  4651              MOV      r1,r10
0000b0  9002              STR      r0,[sp,#8]
0000b2  4638              MOV      r0,r7
0000b4  f7fffffe          BL       wpa_snprintf_hex
;;;1201   					 wpabuf_head(data->peer_cert.cert),
;;;1202   					 wpabuf_len(data->peer_cert.cert));
;;;1203   			wpa_msg_ctrl(sm->msg_ctx, MSG_INFO,
0000b8  6862              LDR      r2,[r4,#4]
0000ba  e9cd2700          STRD     r2,r7,[sp,#0]
0000be  6823              LDR      r3,[r4,#0]
0000c0  a219              ADR      r2,|L35.296|
0000c2  2100              MOVS     r1,#0
0000c4  f8d60090          LDR      r0,[r6,#0x90]
0000c8  f7fffffe          BL       wpa_msg_ctrl
;;;1204   				     WPA_EVENT_EAP_PEER_CERT
;;;1205   				     "depth=%d subject='%s' cert=%s",
;;;1206   				     data->peer_cert.depth,
;;;1207   				     data->peer_cert.subject,
;;;1208   				     cert_hex);
;;;1209   		}
0000cc  bf00              NOP      
                  |L35.206|
;;;1210   		break;
0000ce  bf00              NOP      
                  |L35.208|
0000d0  bf00              NOP                            ;1179
;;;1211   	}
;;;1212   
;;;1213   	os_free(hash_hex);
0000d2  4628              MOV      r0,r5
0000d4  f7fffffe          BL       os_free
;;;1214   	os_free(cert_hex);
0000d8  4638              MOV      r0,r7
0000da  f7fffffe          BL       os_free
;;;1215   }
0000de  e8bd8ffe          POP      {r1-r11,pc}
;;;1216   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L35.228|
                          DCD      ||.constdata||+0x18c
                  |L35.232|
0000e8  00                DCB      0
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L35.236|
0000ec  20686173          DCB      " hash=",0
0000f0  683d00  
0000f3  00                DCB      0
                  |L35.244|
0000f4  4354524c          DCB      "CTRL-EVENT-EAP-PEER-CERT depth=%d subject='%s'%s%s",0
0000f8  2d455645
0000fc  4e542d45
000100  41502d50
000104  4545522d
000108  43455254
00010c  20646570
000110  74683d25
000114  64207375
000118  626a6563
00011c  743d2725
000120  73272573
000124  257300  
000127  00                DCB      0
                  |L35.296|
000128  4354524c          DCB      "CTRL-EVENT-EAP-PEER-CERT depth=%d subject='%s' cert=%s",0
00012c  2d455645
000130  4e542d45
000134  41502d50
000138  4545522d
00013c  43455254
000140  20646570
000144  74683d25
000148  64207375
00014c  626a6563
000150  743d2725
000154  73272063
000158  6572743d
00015c  257300  
00015f  00                DCB      0

                          AREA ||i.eap_register_scard_ctx||, CODE, READONLY, ALIGN=1

                  eap_register_scard_ctx PROC
;;;2038    */
;;;2039   void eap_register_scard_ctx(struct eap_sm *sm, void *ctx)
000000  b108              CBZ      r0,|L36.6|
;;;2040   {
;;;2041   	if (sm)
;;;2042   		sm->scard_ctx = ctx;
000002  f8c01094          STR      r1,[r0,#0x94]
                  |L36.6|
;;;2043   }
000006  4770              BX       lr
;;;2044   
                          ENDP


                          AREA ||i.eap_set_config_blob||, CODE, READONLY, ALIGN=1

                  eap_set_config_blob PROC
;;;2053    */
;;;2054   void eap_set_config_blob(struct eap_sm *sm, struct wpa_config_blob *blob)
000000  b570              PUSH     {r4-r6,lr}
;;;2055   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2056   #ifndef CONFIG_NO_CONFIG_BLOBS
;;;2057   	sm->eapol_cb->set_config_blob(sm->eapol_ctx, blob);
000006  e9d40114          LDRD     r0,r1,[r4,#0x50]
00000a  698a              LDR      r2,[r1,#0x18]
00000c  4629              MOV      r1,r5
00000e  4790              BLX      r2
;;;2058   #endif /* CONFIG_NO_CONFIG_BLOBS */
;;;2059   }
000010  bd70              POP      {r4-r6,pc}
;;;2060   
                          ENDP


                          AREA ||i.eap_set_fast_reauth||, CODE, READONLY, ALIGN=1

                  eap_set_fast_reauth PROC
;;;1760    */
;;;1761   void eap_set_fast_reauth(struct eap_sm *sm, int enabled)
000000  6601              STR      r1,[r0,#0x60]
;;;1762   {
;;;1763   	sm->fast_reauth = enabled;
;;;1764   }
000002  4770              BX       lr
;;;1765   
                          ENDP


                          AREA ||i.eap_set_force_disabled||, CODE, READONLY, ALIGN=1

                  eap_set_force_disabled PROC
;;;2086    */
;;;2087   void eap_set_force_disabled(struct eap_sm *sm, int disabled)
000000  f8c010ac          STR      r1,[r0,#0xac]
;;;2088   {
;;;2089   	sm->force_disabled = disabled;
;;;2090   }
000004  4770              BX       lr
;;;2091   
                          ENDP


                          AREA ||i.eap_set_workaround||, CODE, READONLY, ALIGN=1

                  eap_set_workaround PROC
;;;1771    */
;;;1772   void eap_set_workaround(struct eap_sm *sm, unsigned int workaround)
000000  f8c0109c          STR      r1,[r0,#0x9c]
;;;1773   {
;;;1774   	sm->workaround = workaround;
;;;1775   }
000004  4770              BX       lr
;;;1776   
                          ENDP


                          AREA ||i.eap_sm_abort||, CODE, READONLY, ALIGN=1

                  eap_sm_abort PROC
;;;1315    */
;;;1316   void eap_sm_abort(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1317   {
000002  4604              MOV      r4,r0
;;;1318   	wpabuf_free(sm->lastRespData);
000004  68a0              LDR      r0,[r4,#8]
000006  f7fffffe          BL       wpabuf_free
;;;1319   	sm->lastRespData = NULL;
00000a  2000              MOVS     r0,#0
00000c  60a0              STR      r0,[r4,#8]
;;;1320   	wpabuf_free(sm->eapRespData);
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  f7fffffe          BL       wpabuf_free
;;;1321   	sm->eapRespData = NULL;
000014  2000              MOVS     r0,#0
000016  63a0              STR      r0,[r4,#0x38]
;;;1322   	os_free(sm->eapKeyData);
000018  6c20              LDR      r0,[r4,#0x40]
00001a  f7fffffe          BL       os_free
;;;1323   	sm->eapKeyData = NULL;
00001e  2000              MOVS     r0,#0
000020  6420              STR      r0,[r4,#0x40]
;;;1324   
;;;1325   	/* This is not clearly specified in the EAP statemachines draft, but
;;;1326   	 * it seems necessary to make sure that some of the EAPOL variables get
;;;1327   	 * cleared for the next authentication. */
;;;1328   	eapol_set_bool(sm, EAPOL_eapSuccess, FALSE);
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       eapol_set_bool
;;;1329   }
00002c  bd10              POP      {r4,pc}
;;;1330   
                          ENDP


                          AREA ||i.eap_sm_allowMethod||, CODE, READONLY, ALIGN=2

                  eap_sm_allowMethod PROC
;;;741    
;;;742    static Boolean eap_sm_allowMethod(struct eap_sm *sm, int vendor,
000000  b570              PUSH     {r4-r6,lr}
;;;743    				  EapType method)
;;;744    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;745    	if (!eap_allowed_method(sm, vendor, method)) {
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       eap_allowed_method
000012  b938              CBNZ     r0,|L42.36|
;;;746    		wpa_printf(MSG_DEBUG, "EAP: configuration does not allow: "
000014  462b              MOV      r3,r5
000016  4622              MOV      r2,r4
000018  a10a              ADR      r1,|L42.68|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       wpa_printf
;;;747    			   "vendor %u method %u", vendor, method);
;;;748    		return FALSE;
000020  2000              MOVS     r0,#0
                  |L42.34|
;;;749    	}
;;;750    	if (eap_peer_get_eap_method(vendor, method))
;;;751    		return TRUE;
;;;752    	wpa_printf(MSG_DEBUG, "EAP: not included in build: "
;;;753    		   "vendor %u method %u", vendor, method);
;;;754    	return FALSE;
;;;755    }
000022  bd70              POP      {r4-r6,pc}
                  |L42.36|
000024  4629              MOV      r1,r5                 ;750
000026  4620              MOV      r0,r4                 ;750
000028  f7fffffe          BL       eap_peer_get_eap_method
00002c  b108              CBZ      r0,|L42.50|
00002e  2001              MOVS     r0,#1                 ;751
000030  e7f7              B        |L42.34|
                  |L42.50|
000032  462b              MOV      r3,r5                 ;752
000034  4622              MOV      r2,r4                 ;752
000036  a111              ADR      r1,|L42.124|
000038  2000              MOVS     r0,#0                 ;752
00003a  f7fffffe          BL       wpa_printf
00003e  2000              MOVS     r0,#0                 ;754
000040  e7ef              B        |L42.34|
;;;756    
                          ENDP

000042  0000              DCW      0x0000
                  |L42.68|
000044  4541503a          DCB      "EAP: configuration does not allow: vendor %u method %u",0
000048  20636f6e
00004c  66696775
000050  72617469
000054  6f6e2064
000058  6f657320
00005c  6e6f7420
000060  616c6c6f
000064  773a2076
000068  656e646f
00006c  72202575
000070  206d6574
000074  686f6420
000078  257500  
00007b  00                DCB      0
                  |L42.124|
00007c  4541503a          DCB      "EAP: not included in build: vendor %u method %u",0
000080  206e6f74
000084  20696e63
000088  6c756465
00008c  6420696e
000090  20627569
000094  6c643a20
000098  76656e64
00009c  6f722025
0000a0  75206d65
0000a4  74686f64
0000a8  20257500

                          AREA ||i.eap_sm_buildIdentity||, CODE, READONLY, ALIGN=2

                  eap_sm_buildIdentity PROC
;;;967     */
;;;968    struct wpabuf * eap_sm_buildIdentity(struct eap_sm *sm, int id, int encrypted)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;969    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;970    	struct eap_peer_config *config = eap_get_config(sm);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       eap_get_config
000010  4604              MOV      r4,r0
;;;971    	struct wpabuf *resp;
;;;972    	const u8 *identity;
;;;973    	size_t identity_len;
;;;974    
;;;975    	if (config == NULL) {
000012  b934              CBNZ     r4,|L43.34|
;;;976    		wpa_printf(MSG_WARNING, "EAP: buildIdentity: configuration "
000014  a137              ADR      r1,|L43.244|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       wpa_printf
;;;977    			   "was not available");
;;;978    		return NULL;
00001c  2000              MOVS     r0,#0
                  |L43.30|
;;;979    	}
;;;980    
;;;981    	if (sm->m && sm->m->get_identity &&
;;;982    	    (identity = sm->m->get_identity(sm, sm->eap_method_priv,
;;;983    					    &identity_len)) != NULL) {
;;;984    		wpa_hexdump_ascii(MSG_DEBUG, "EAP: using method re-auth "
;;;985    				  "identity", identity, identity_len);
;;;986    	} else if (!encrypted && config->anonymous_identity) {
;;;987    		identity = config->anonymous_identity;
;;;988    		identity_len = config->anonymous_identity_len;
;;;989    		wpa_hexdump_ascii(MSG_DEBUG, "EAP: using anonymous identity",
;;;990    				  identity, identity_len);
;;;991    	} else {
;;;992    		identity = config->identity;
;;;993    		identity_len = config->identity_len;
;;;994    		wpa_hexdump_ascii(MSG_DEBUG, "EAP: using real identity",
;;;995    				  identity, identity_len);
;;;996    	}
;;;997    
;;;998    	if (identity == NULL) {
;;;999    		wpa_printf(MSG_WARNING, "EAP: buildIdentity: identity "
;;;1000   			   "configuration was not available");
;;;1001   		if (config->pcsc) {
;;;1002   			if (eap_sm_get_scard_identity(sm, config) < 0)
;;;1003   				return NULL;
;;;1004   			identity = config->identity;
;;;1005   			identity_len = config->identity_len;
;;;1006   			wpa_hexdump_ascii(MSG_DEBUG, "permanent identity from "
;;;1007   					  "IMSI", identity, identity_len);
;;;1008   		} else {
;;;1009   			eap_sm_request_identity(sm);
;;;1010   			return NULL;
;;;1011   		}
;;;1012   	} else if (config->pcsc) {
;;;1013   		if (eap_sm_set_scard_pin(sm, config) < 0)
;;;1014   			return NULL;
;;;1015   	}
;;;1016   
;;;1017   	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IDENTITY, identity_len,
;;;1018   			     EAP_CODE_RESPONSE, id);
;;;1019   	if (resp == NULL)
;;;1020   		return NULL;
;;;1021   
;;;1022   	wpabuf_put_data(resp, identity, identity_len);
;;;1023   
;;;1024   	return resp;
;;;1025   }
00001e  e8bd87fc          POP      {r2-r10,pc}
                  |L43.34|
000022  6ca8              LDR      r0,[r5,#0x48]         ;981
000024  b188              CBZ      r0,|L43.74|
000026  6ca8              LDR      r0,[r5,#0x48]         ;981
000028  6b00              LDR      r0,[r0,#0x30]         ;981
00002a  b170              CBZ      r0,|L43.74|
00002c  6da9              LDR      r1,[r5,#0x58]         ;982
00002e  6ca8              LDR      r0,[r5,#0x48]         ;982
000030  aa01              ADD      r2,sp,#4              ;982
000032  6b03              LDR      r3,[r0,#0x30]         ;982
000034  4628              MOV      r0,r5                 ;982
000036  4798              BLX      r3                    ;982
000038  0006              MOVS     r6,r0                 ;982
00003a  d006              BEQ      |L43.74|
00003c  4632              MOV      r2,r6                 ;984
00003e  a13a              ADR      r1,|L43.296|
000040  2000              MOVS     r0,#0                 ;984
000042  9b01              LDR      r3,[sp,#4]            ;984
000044  f7fffffe          BL       wpa_hexdump_ascii
000048  e017              B        |L43.122|
                  |L43.74|
00004a  f1b90f00          CMP      r9,#0                 ;986
00004e  d10b              BNE      |L43.104|
000050  68a0              LDR      r0,[r4,#8]            ;986
000052  b148              CBZ      r0,|L43.104|
000054  68a6              LDR      r6,[r4,#8]            ;987
000056  68e0              LDR      r0,[r4,#0xc]          ;988
000058  9001              STR      r0,[sp,#4]            ;988
00005a  4632              MOV      r2,r6                 ;989
00005c  a13b              ADR      r1,|L43.332|
00005e  2000              MOVS     r0,#0                 ;989
000060  9b01              LDR      r3,[sp,#4]            ;989
000062  f7fffffe          BL       wpa_hexdump_ascii
000066  e008              B        |L43.122|
                  |L43.104|
000068  6826              LDR      r6,[r4,#0]            ;992
00006a  6860              LDR      r0,[r4,#4]            ;993
00006c  9001              STR      r0,[sp,#4]            ;993
00006e  4632              MOV      r2,r6                 ;994
000070  a13e              ADR      r1,|L43.364|
000072  2000              MOVS     r0,#0                 ;994
000074  9b01              LDR      r3,[sp,#4]            ;994
000076  f7fffffe          BL       wpa_hexdump_ascii
                  |L43.122|
00007a  b9e6              CBNZ     r6,|L43.182|
00007c  a142              ADR      r1,|L43.392|
00007e  2000              MOVS     r0,#0                 ;999
000080  f7fffffe          BL       wpa_printf
000084  6e60              LDR      r0,[r4,#0x64]         ;1001
000086  b188              CBZ      r0,|L43.172|
000088  4621              MOV      r1,r4                 ;1002
00008a  4628              MOV      r0,r5                 ;1002
00008c  f7fffffe          BL       eap_sm_get_scard_identity
000090  2800              CMP      r0,#0                 ;1002
000092  da01              BGE      |L43.152|
000094  2000              MOVS     r0,#0                 ;1003
000096  e7c2              B        |L43.30|
                  |L43.152|
000098  6826              LDR      r6,[r4,#0]            ;1004
00009a  6860              LDR      r0,[r4,#4]            ;1005
00009c  9001              STR      r0,[sp,#4]            ;1005
00009e  4632              MOV      r2,r6                 ;1006
0000a0  a149              ADR      r1,|L43.456|
0000a2  2000              MOVS     r0,#0                 ;1006
0000a4  9b01              LDR      r3,[sp,#4]            ;1006
0000a6  f7fffffe          BL       wpa_hexdump_ascii
0000aa  e00e              B        |L43.202|
                  |L43.172|
0000ac  4628              MOV      r0,r5                 ;1009
0000ae  f7fffffe          BL       eap_sm_request_identity
0000b2  2000              MOVS     r0,#0                 ;1010
0000b4  e7b3              B        |L43.30|
                  |L43.182|
0000b6  6e60              LDR      r0,[r4,#0x64]         ;1012
0000b8  b138              CBZ      r0,|L43.202|
0000ba  4621              MOV      r1,r4                 ;1013
0000bc  4628              MOV      r0,r5                 ;1013
0000be  f7fffffe          BL       eap_sm_set_scard_pin
0000c2  2800              CMP      r0,#0                 ;1013
0000c4  da01              BGE      |L43.202|
0000c6  2000              MOVS     r0,#0                 ;1014
0000c8  e7a9              B        |L43.30|
                  |L43.202|
0000ca  f00803ff          AND      r3,r8,#0xff           ;1017
0000ce  9300              STR      r3,[sp,#0]            ;1017
0000d0  2302              MOVS     r3,#2                 ;1017
0000d2  2101              MOVS     r1,#1                 ;1017
0000d4  2000              MOVS     r0,#0                 ;1017
0000d6  9a01              LDR      r2,[sp,#4]            ;1017
0000d8  f7fffffe          BL       eap_msg_alloc
0000dc  4607              MOV      r7,r0                 ;1017
0000de  b90f              CBNZ     r7,|L43.228|
0000e0  2000              MOVS     r0,#0                 ;1020
0000e2  e79c              B        |L43.30|
                  |L43.228|
0000e4  4631              MOV      r1,r6                 ;1022
0000e6  4638              MOV      r0,r7                 ;1022
0000e8  9a01              LDR      r2,[sp,#4]            ;1022
0000ea  f7fffffe          BL       wpabuf_put_data
0000ee  4638              MOV      r0,r7                 ;1024
0000f0  e795              B        |L43.30|
;;;1026   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L43.244|
0000f4  4541503a          DCB      "EAP: buildIdentity: configuration was not available",0
0000f8  20627569
0000fc  6c644964
000100  656e7469
000104  74793a20
000108  636f6e66
00010c  69677572
000110  6174696f
000114  6e207761
000118  73206e6f
00011c  74206176
000120  61696c61
000124  626c6500
                  |L43.296|
000128  4541503a          DCB      "EAP: using method re-auth identity",0
00012c  20757369
000130  6e67206d
000134  6574686f
000138  64207265
00013c  2d617574
000140  68206964
000144  656e7469
000148  747900  
00014b  00                DCB      0
                  |L43.332|
00014c  4541503a          DCB      "EAP: using anonymous identity",0
000150  20757369
000154  6e672061
000158  6e6f6e79
00015c  6d6f7573
000160  20696465
000164  6e746974
000168  7900    
00016a  00                DCB      0
00016b  00                DCB      0
                  |L43.364|
00016c  4541503a          DCB      "EAP: using real identity",0
000170  20757369
000174  6e672072
000178  65616c20
00017c  6964656e
000180  74697479
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L43.392|
000188  4541503a          DCB      "EAP: buildIdentity: identity configuration was not avai"
00018c  20627569
000190  6c644964
000194  656e7469
000198  74793a20
00019c  6964656e
0001a0  74697479
0001a4  20636f6e
0001a8  66696775
0001ac  72617469
0001b0  6f6e2077
0001b4  6173206e
0001b8  6f742061
0001bc  766169  
0001bf  6c61626c          DCB      "lable",0
0001c3  6500    
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L43.456|
0001c8  7065726d          DCB      "permanent identity from IMSI",0
0001cc  616e656e
0001d0  74206964
0001d4  656e7469
0001d8  74792066
0001dc  726f6d20
0001e0  494d5349
0001e4  00      
0001e5  00                DCB      0
0001e6  00                DCB      0
0001e7  00                DCB      0

                          AREA ||i.eap_sm_buildNak||, CODE, READONLY, ALIGN=2

                  eap_sm_buildNak PROC
;;;804    
;;;805    static struct wpabuf * eap_sm_buildNak(struct eap_sm *sm, int id)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;806    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
;;;807    	struct wpabuf *resp;
;;;808    	u8 *start;
;;;809    	int found = 0, expanded_found = 0;
000008  2700              MOVS     r7,#0
00000a  46ba              MOV      r10,r7
;;;810    	size_t count;
;;;811    	const struct eap_method *methods, *m;
;;;812    
;;;813    	wpa_printf(MSG_DEBUG, "EAP: Building EAP-Nak (requested type %u "
00000c  6aab              LDR      r3,[r5,#0x28]
00000e  9300              STR      r3,[sp,#0]
000010  f8952020          LDRB     r2,[r5,#0x20]
000014  4931              LDR      r1,|L44.220|
000016  2000              MOVS     r0,#0
000018  6a6b              LDR      r3,[r5,#0x24]
00001a  f7fffffe          BL       wpa_printf
;;;814    		   "vendor=%u method=%u not allowed)", sm->reqMethod,
;;;815    		   sm->reqVendor, sm->reqVendorMethod);
;;;816    	methods = eap_peer_get_methods(&count);
00001e  a801              ADD      r0,sp,#4
000020  f7fffffe          BL       eap_peer_get_methods
000024  4680              MOV      r8,r0
;;;817    	if (methods == NULL)
000026  f1b80f00          CMP      r8,#0
00002a  d102              BNE      |L44.50|
;;;818    		return NULL;
00002c  2000              MOVS     r0,#0
                  |L44.46|
;;;819    	if (sm->reqMethod == EAP_TYPE_EXPANDED)
;;;820    		return eap_sm_build_expanded_nak(sm, id, methods, count);
;;;821    
;;;822    	/* RFC 3748 - 5.3.1: Legacy Nak */
;;;823    	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_NAK,
;;;824    			     sizeof(struct eap_hdr) + 1 + count + 1,
;;;825    			     EAP_CODE_RESPONSE, id);
;;;826    	if (resp == NULL)
;;;827    		return NULL;
;;;828    
;;;829    	start = wpabuf_put(resp, 0);
;;;830    	for (m = methods; m; m = m->next) {
;;;831    		if (m->vendor == EAP_VENDOR_IETF && m->method == sm->reqMethod)
;;;832    			continue; /* do not allow the current method again */
;;;833    		if (eap_allowed_method(sm, m->vendor, m->method)) {
;;;834    			if (m->vendor != EAP_VENDOR_IETF) {
;;;835    				if (expanded_found)
;;;836    					continue;
;;;837    				expanded_found = 1;
;;;838    				wpabuf_put_u8(resp, EAP_TYPE_EXPANDED);
;;;839    			} else
;;;840    				wpabuf_put_u8(resp, m->method);
;;;841    			found++;
;;;842    		}
;;;843    	}
;;;844    	if (!found)
;;;845    		wpabuf_put_u8(resp, EAP_TYPE_NONE);
;;;846    	wpa_hexdump(MSG_DEBUG, "EAP: allowed methods", start, found);
;;;847    
;;;848    	eap_update_len(resp);
;;;849    
;;;850    	return resp;
;;;851    }
00002e  e8bd9ffc          POP      {r2-r12,pc}
                  |L44.50|
000032  f8950020          LDRB     r0,[r5,#0x20]         ;819
000036  28fe              CMP      r0,#0xfe              ;819
000038  d106              BNE      |L44.72|
00003a  4642              MOV      r2,r8                 ;820
00003c  4649              MOV      r1,r9                 ;820
00003e  4628              MOV      r0,r5                 ;820
000040  9b01              LDR      r3,[sp,#4]            ;820
000042  f7fffffe          BL       eap_sm_build_expanded_nak
000046  e7f2              B        |L44.46|
                  |L44.72|
000048  f00903ff          AND      r3,r9,#0xff           ;823
00004c  9300              STR      r3,[sp,#0]            ;823
00004e  9801              LDR      r0,[sp,#4]            ;823
000050  1d82              ADDS     r2,r0,#6              ;823
000052  2302              MOVS     r3,#2                 ;823
000054  2103              MOVS     r1,#3                 ;823
000056  2000              MOVS     r0,#0                 ;823
000058  f7fffffe          BL       eap_msg_alloc
00005c  4606              MOV      r6,r0                 ;823
00005e  b90e              CBNZ     r6,|L44.100|
000060  2000              MOVS     r0,#0                 ;827
000062  e7e4              B        |L44.46|
                  |L44.100|
000064  2100              MOVS     r1,#0                 ;829
000066  4630              MOV      r0,r6                 ;829
000068  f7fffffe          BL       wpabuf_put
00006c  4683              MOV      r11,r0                ;829
00006e  4644              MOV      r4,r8                 ;830
000070  e021              B        |L44.182|
                  |L44.114|
000072  6820              LDR      r0,[r4,#0]            ;831
000074  b928              CBNZ     r0,|L44.130|
000076  7920              LDRB     r0,[r4,#4]            ;831
000078  f8951020          LDRB     r1,[r5,#0x20]         ;831
00007c  4288              CMP      r0,r1                 ;831
00007e  d100              BNE      |L44.130|
000080  e018              B        |L44.180|
                  |L44.130|
000082  7922              LDRB     r2,[r4,#4]            ;833
000084  4628              MOV      r0,r5                 ;833
000086  6821              LDR      r1,[r4,#0]            ;833
000088  f7fffffe          BL       eap_allowed_method
00008c  b188              CBZ      r0,|L44.178|
00008e  6820              LDR      r0,[r4,#0]            ;834
000090  b150              CBZ      r0,|L44.168|
000092  f1ba0f00          CMP      r10,#0                ;835
000096  d000              BEQ      |L44.154|
000098  e00c              B        |L44.180|
                  |L44.154|
00009a  f04f0a01          MOV      r10,#1                ;837
00009e  21fe              MOVS     r1,#0xfe              ;838
0000a0  4630              MOV      r0,r6                 ;838
0000a2  f7fffffe          BL       wpabuf_put_u8
0000a6  e003              B        |L44.176|
                  |L44.168|
0000a8  7921              LDRB     r1,[r4,#4]            ;840
0000aa  4630              MOV      r0,r6                 ;840
0000ac  f7fffffe          BL       wpabuf_put_u8
                  |L44.176|
0000b0  1c7f              ADDS     r7,r7,#1              ;841
                  |L44.178|
0000b2  bf00              NOP                            ;832
                  |L44.180|
0000b4  6be4              LDR      r4,[r4,#0x3c]         ;830
                  |L44.182|
0000b6  2c00              CMP      r4,#0                 ;830
0000b8  d1db              BNE      |L44.114|
0000ba  b91f              CBNZ     r7,|L44.196|
0000bc  2100              MOVS     r1,#0                 ;845
0000be  4630              MOV      r0,r6                 ;845
0000c0  f7fffffe          BL       wpabuf_put_u8
                  |L44.196|
0000c4  463b              MOV      r3,r7                 ;846
0000c6  465a              MOV      r2,r11                ;846
0000c8  a105              ADR      r1,|L44.224|
0000ca  2000              MOVS     r0,#0                 ;846
0000cc  f7fffffe          BL       wpa_hexdump
0000d0  4630              MOV      r0,r6                 ;848
0000d2  f7fffffe          BL       eap_update_len
0000d6  4630              MOV      r0,r6                 ;850
0000d8  e7a9              B        |L44.46|
;;;852    
                          ENDP

0000da  0000              DCW      0x0000
                  |L44.220|
                          DCD      ||.constdata||+0x44
                  |L44.224|
0000e0  4541503a          DCB      "EAP: allowed methods",0
0000e4  20616c6c
0000e8  6f776564
0000ec  206d6574
0000f0  686f6473
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||i.eap_sm_buildNotify||, CODE, READONLY, ALIGN=2

                  eap_sm_buildNotify PROC
;;;1052   
;;;1053   static struct wpabuf * eap_sm_buildNotify(int id)
000000  b538              PUSH     {r3-r5,lr}
;;;1054   {
000002  4604              MOV      r4,r0
;;;1055   	struct wpabuf *resp;
;;;1056   
;;;1057   	wpa_printf(MSG_DEBUG, "EAP: Generating EAP-Response Notification");
000004  a108              ADR      r1,|L45.40|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       wpa_printf
;;;1058   	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_NOTIFICATION, 0,
00000c  b2e3              UXTB     r3,r4
00000e  9300              STR      r3,[sp,#0]
000010  2302              MOVS     r3,#2
000012  2200              MOVS     r2,#0
000014  4619              MOV      r1,r3
000016  4610              MOV      r0,r2
000018  f7fffffe          BL       eap_msg_alloc
00001c  4605              MOV      r5,r0
;;;1059   			     EAP_CODE_RESPONSE, id);
;;;1060   	if (resp == NULL)
00001e  b90d              CBNZ     r5,|L45.36|
;;;1061   		return NULL;
000020  2000              MOVS     r0,#0
                  |L45.34|
;;;1062   
;;;1063   	return resp;
;;;1064   }
000022  bd38              POP      {r3-r5,pc}
                  |L45.36|
000024  4628              MOV      r0,r5                 ;1063
000026  e7fc              B        |L45.34|
;;;1065   
                          ENDP

                  |L45.40|
000028  4541503a          DCB      "EAP: Generating EAP-Response Notification",0
00002c  2047656e
000030  65726174
000034  696e6720
000038  4541502d
00003c  52657370
000040  6f6e7365
000044  204e6f74
000048  69666963
00004c  6174696f
000050  6e00    
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.eap_sm_build_expanded_nak||, CODE, READONLY, ALIGN=2

                  eap_sm_build_expanded_nak PROC
;;;757    
;;;758    static struct wpabuf * eap_sm_build_expanded_nak(
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;759    	struct eap_sm *sm, int id, const struct eap_method *methods,
;;;760    	size_t count)
;;;761    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;762    	struct wpabuf *resp;
;;;763    	int found = 0;
00000c  f04f0a00          MOV      r10,#0
;;;764    	const struct eap_method *m;
;;;765    
;;;766    	wpa_printf(MSG_DEBUG, "EAP: Building expanded EAP-Nak");
000010  a12f              ADR      r1,|L46.208|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
;;;767    
;;;768    	/* RFC 3748 - 5.3.2: Expanded Nak */
;;;769    	resp = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_EXPANDED,
000018  b2f3              UXTB     r3,r6
00001a  f1080001          ADD      r0,r8,#1
00001e  00c0              LSLS     r0,r0,#3
000020  f1000208          ADD      r2,r0,#8
000024  9300              STR      r3,[sp,#0]
000026  2302              MOVS     r3,#2
000028  21fe              MOVS     r1,#0xfe
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       eap_msg_alloc
000030  4681              MOV      r9,r0
;;;770    			     8 + 8 * (count + 1), EAP_CODE_RESPONSE, id);
;;;771    	if (resp == NULL)
000032  f1b90f00          CMP      r9,#0
000036  d102              BNE      |L46.62|
;;;772    		return NULL;
000038  2000              MOVS     r0,#0
                  |L46.58|
;;;773    
;;;774    	wpabuf_put_be24(resp, EAP_VENDOR_IETF);
;;;775    	wpabuf_put_be32(resp, EAP_TYPE_NAK);
;;;776    
;;;777    	for (m = methods; m; m = m->next) {
;;;778    		if (sm->reqVendor == m->vendor &&
;;;779    		    sm->reqVendorMethod == m->method)
;;;780    			continue; /* do not allow the current method again */
;;;781    		if (eap_allowed_method(sm, m->vendor, m->method)) {
;;;782    			wpa_printf(MSG_DEBUG, "EAP: allowed type: "
;;;783    				   "vendor=%u method=%u",
;;;784    				   m->vendor, m->method);
;;;785    			wpabuf_put_u8(resp, EAP_TYPE_EXPANDED);
;;;786    			wpabuf_put_be24(resp, m->vendor);
;;;787    			wpabuf_put_be32(resp, m->method);
;;;788    
;;;789    			found++;
;;;790    		}
;;;791    	}
;;;792    	if (!found) {
;;;793    		wpa_printf(MSG_DEBUG, "EAP: no more allowed methods");
;;;794    		wpabuf_put_u8(resp, EAP_TYPE_EXPANDED);
;;;795    		wpabuf_put_be24(resp, EAP_VENDOR_IETF);
;;;796    		wpabuf_put_be32(resp, EAP_TYPE_NONE);
;;;797    	}
;;;798    
;;;799    	eap_update_len(resp);
;;;800    
;;;801    	return resp;
;;;802    }
00003a  e8bd8ff8          POP      {r3-r11,pc}
                  |L46.62|
00003e  2100              MOVS     r1,#0                 ;774
000040  4648              MOV      r0,r9                 ;774
000042  f7fffffe          BL       wpabuf_put_be24
000046  2103              MOVS     r1,#3                 ;775
000048  4648              MOV      r0,r9                 ;775
00004a  f7fffffe          BL       wpabuf_put_be32
00004e  463c              MOV      r4,r7                 ;777
000050  e024              B        |L46.156|
                  |L46.82|
000052  6a68              LDR      r0,[r5,#0x24]         ;778
000054  6821              LDR      r1,[r4,#0]            ;778
000056  4288              CMP      r0,r1                 ;778
000058  d104              BNE      |L46.100|
00005a  7921              LDRB     r1,[r4,#4]            ;779
00005c  6aa8              LDR      r0,[r5,#0x28]         ;779
00005e  4288              CMP      r0,r1                 ;779
000060  d100              BNE      |L46.100|
000062  e01a              B        |L46.154|
                  |L46.100|
000064  7922              LDRB     r2,[r4,#4]            ;781
000066  4628              MOV      r0,r5                 ;781
000068  6821              LDR      r1,[r4,#0]            ;781
00006a  f7fffffe          BL       eap_allowed_method
00006e  b198              CBZ      r0,|L46.152|
000070  7923              LDRB     r3,[r4,#4]            ;782
000072  a11f              ADR      r1,|L46.240|
000074  2000              MOVS     r0,#0                 ;782
000076  6822              LDR      r2,[r4,#0]            ;782
000078  f7fffffe          BL       wpa_printf
00007c  21fe              MOVS     r1,#0xfe              ;785
00007e  4648              MOV      r0,r9                 ;785
000080  f7fffffe          BL       wpabuf_put_u8
000084  4648              MOV      r0,r9                 ;786
000086  6821              LDR      r1,[r4,#0]            ;786
000088  f7fffffe          BL       wpabuf_put_be24
00008c  7921              LDRB     r1,[r4,#4]            ;787
00008e  4648              MOV      r0,r9                 ;787
000090  f7fffffe          BL       wpabuf_put_be32
000094  f10a0a01          ADD      r10,r10,#1            ;789
                  |L46.152|
000098  bf00              NOP                            ;780
                  |L46.154|
00009a  6be4              LDR      r4,[r4,#0x3c]         ;777
                  |L46.156|
00009c  2c00              CMP      r4,#0                 ;777
00009e  d1d8              BNE      |L46.82|
0000a0  f1ba0f00          CMP      r10,#0                ;792
0000a4  d10f              BNE      |L46.198|
0000a6  a11c              ADR      r1,|L46.280|
0000a8  2000              MOVS     r0,#0                 ;793
0000aa  f7fffffe          BL       wpa_printf
0000ae  21fe              MOVS     r1,#0xfe              ;794
0000b0  4648              MOV      r0,r9                 ;794
0000b2  f7fffffe          BL       wpabuf_put_u8
0000b6  2100              MOVS     r1,#0                 ;795
0000b8  4648              MOV      r0,r9                 ;795
0000ba  f7fffffe          BL       wpabuf_put_be24
0000be  2100              MOVS     r1,#0                 ;796
0000c0  4648              MOV      r0,r9                 ;796
0000c2  f7fffffe          BL       wpabuf_put_be32
                  |L46.198|
0000c6  4648              MOV      r0,r9                 ;799
0000c8  f7fffffe          BL       eap_update_len
0000cc  4648              MOV      r0,r9                 ;801
0000ce  e7b4              B        |L46.58|
;;;803    
                          ENDP

                  |L46.208|
0000d0  4541503a          DCB      "EAP: Building expanded EAP-Nak",0
0000d4  20427569
0000d8  6c64696e
0000dc  67206578
0000e0  70616e64
0000e4  65642045
0000e8  41502d4e
0000ec  616b00  
0000ef  00                DCB      0
                  |L46.240|
0000f0  4541503a          DCB      "EAP: allowed type: vendor=%u method=%u",0
0000f4  20616c6c
0000f8  6f776564
0000fc  20747970
000100  653a2076
000104  656e646f
000108  723d2575
00010c  206d6574
000110  686f643d
000114  257500  
000117  00                DCB      0
                  |L46.280|
000118  4541503a          DCB      "EAP: no more allowed methods",0
00011c  206e6f20
000120  6d6f7265
000124  20616c6c
000128  6f776564
00012c  206d6574
000130  686f6473
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||i.eap_sm_decision_txt||, CODE, READONLY, ALIGN=2

                  eap_sm_decision_txt PROC
;;;1388   
;;;1389   static const char * eap_sm_decision_txt(EapDecision decision)
000000  4601              MOV      r1,r0
;;;1390   {
;;;1391   	switch (decision) {
000002  b121              CBZ      r1,|L47.14|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L47.18|
000008  2902              CMP      r1,#2
00000a  d106              BNE      |L47.26|
00000c  e003              B        |L47.22|
                  |L47.14|
;;;1392   	case DECISION_FAIL:
;;;1393   		return "FAIL";
00000e  a004              ADR      r0,|L47.32|
                  |L47.16|
;;;1394   	case DECISION_COND_SUCC:
;;;1395   		return "COND_SUCC";
;;;1396   	case DECISION_UNCOND_SUCC:
;;;1397   		return "UNCOND_SUCC";
;;;1398   	default:
;;;1399   		return "UNKNOWN";
;;;1400   	}
;;;1401   }
000010  4770              BX       lr
                  |L47.18|
000012  a005              ADR      r0,|L47.40|
000014  e7fc              B        |L47.16|
                  |L47.22|
000016  a007              ADR      r0,|L47.52|
000018  e7fa              B        |L47.16|
                  |L47.26|
00001a  a009              ADR      r0,|L47.64|
00001c  e7f8              B        |L47.16|
;;;1402   #endif /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
                          ENDP

00001e  0000              DCW      0x0000
                  |L47.32|
000020  4641494c          DCB      "FAIL",0
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
                  |L47.40|
000028  434f4e44          DCB      "COND_SUCC",0
00002c  5f535543
000030  4300    
000032  00                DCB      0
000033  00                DCB      0
                  |L47.52|
000034  554e434f          DCB      "UNCOND_SUCC",0
000038  4e445f53
00003c  55434300
                  |L47.64|
000040  554e4b4e          DCB      "UNKNOWN",0
000044  4f574e00

                          AREA ||i.eap_sm_get_scard_identity||, CODE, READONLY, ALIGN=1

                  eap_sm_get_scard_identity PROC
;;;942    
;;;943    static int eap_sm_get_scard_identity(struct eap_sm *sm,
000000  4602              MOV      r2,r0
;;;944    				     struct eap_peer_config *conf)
;;;945    {
;;;946    #ifdef PCSC_FUNCS
;;;947    	if (eap_sm_set_scard_pin(sm, conf))
;;;948    		return -1;
;;;949    
;;;950    	return eap_sm_imsi_identity(sm, conf);
;;;951    #else /* PCSC_FUNCS */
;;;952    	return -1;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;953    #endif /* PCSC_FUNCS */
;;;954    }
000006  4770              BX       lr
;;;955    
                          ENDP


                          AREA ||i.eap_sm_method_state_txt||, CODE, READONLY, ALIGN=2

                  eap_sm_method_state_txt PROC
;;;1369   #if defined(CONFIG_CTRL_IFACE) || !defined(CONFIG_NO_STDOUT_DEBUG)
;;;1370   static const char * eap_sm_method_state_txt(EapMethodState state)
000000  4601              MOV      r1,r0
;;;1371   {
;;;1372   	switch (state) {
000002  2905              CMP      r1,#5
000004  d20e              BCS      |L49.36|
000006  e8dff001          TBB      [pc,r1]
00000a  0305              DCB      0x03,0x05
00000c  07090b00          DCB      0x07,0x09,0x0b,0x00
;;;1373   	case METHOD_NONE:
;;;1374   		return "NONE";
000010  a005              ADR      r0,|L49.40|
                  |L49.18|
;;;1375   	case METHOD_INIT:
;;;1376   		return "INIT";
;;;1377   	case METHOD_CONT:
;;;1378   		return "CONT";
;;;1379   	case METHOD_MAY_CONT:
;;;1380   		return "MAY_CONT";
;;;1381   	case METHOD_DONE:
;;;1382   		return "DONE";
;;;1383   	default:
;;;1384   		return "UNKNOWN";
;;;1385   	}
;;;1386   }
000012  4770              BX       lr
000014  a006              ADR      r0,|L49.48|
000016  e7fc              B        |L49.18|
000018  a007              ADR      r0,|L49.56|
00001a  e7fa              B        |L49.18|
00001c  a008              ADR      r0,|L49.64|
00001e  e7f8              B        |L49.18|
000020  a00a              ADR      r0,|L49.76|
000022  e7f6              B        |L49.18|
                  |L49.36|
000024  a00b              ADR      r0,|L49.84|
000026  e7f4              B        |L49.18|
;;;1387   
                          ENDP

                  |L49.40|
000028  4e4f4e45          DCB      "NONE",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0
                  |L49.48|
000030  494e4954          DCB      "INIT",0
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0
                  |L49.56|
000038  434f4e54          DCB      "CONT",0
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L49.64|
000040  4d41595f          DCB      "MAY_CONT",0
000044  434f4e54
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0
                  |L49.76|
00004c  444f4e45          DCB      "DONE",0
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L49.84|
000054  554e4b4e          DCB      "UNKNOWN",0
000058  4f574e00

                          AREA ||i.eap_sm_notify_ctrl_attached||, CODE, READONLY, ALIGN=1

                  eap_sm_notify_ctrl_attached PROC
;;;1653    */
;;;1654   void eap_sm_notify_ctrl_attached(struct eap_sm *sm)
000000  b570              PUSH     {r4-r6,lr}
;;;1655   {
000002  4605              MOV      r5,r0
;;;1656   	struct eap_peer_config *config = eap_get_config(sm);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       eap_get_config
00000a  4604              MOV      r4,r0
;;;1657   
;;;1658   	if (config == NULL)
00000c  b904              CBNZ     r4,|L50.16|
                  |L50.14|
;;;1659   		return;
;;;1660   
;;;1661   	/* Re-send any pending requests for user data since a new control
;;;1662   	 * interface was added. This handles cases where the EAP authentication
;;;1663   	 * starts immediately after system startup when the user interface is
;;;1664   	 * not yet running. */
;;;1665   	if (config->pending_req_identity)
;;;1666   		eap_sm_request_identity(sm);
;;;1667   	if (config->pending_req_password)
;;;1668   		eap_sm_request_password(sm);
;;;1669   	if (config->pending_req_new_password)
;;;1670   		eap_sm_request_new_password(sm);
;;;1671   	if (config->pending_req_otp)
;;;1672   		eap_sm_request_otp(sm, NULL, 0);
;;;1673   	if (config->pending_req_pin)
;;;1674   		eap_sm_request_pin(sm);
;;;1675   	if (config->pending_req_passphrase)
;;;1676   		eap_sm_request_passphrase(sm);
;;;1677   }
00000e  bd70              POP      {r4-r6,pc}
                  |L50.16|
000010  f8d400a0          LDR      r0,[r4,#0xa0]         ;1665
000014  b110              CBZ      r0,|L50.28|
000016  4628              MOV      r0,r5                 ;1666
000018  f7fffffe          BL       eap_sm_request_identity
                  |L50.28|
00001c  f8d400a4          LDR      r0,[r4,#0xa4]         ;1667
000020  b110              CBZ      r0,|L50.40|
000022  4628              MOV      r0,r5                 ;1668
000024  f7fffffe          BL       eap_sm_request_password
                  |L50.40|
000028  f8d400ac          LDR      r0,[r4,#0xac]         ;1669
00002c  b110              CBZ      r0,|L50.52|
00002e  4628              MOV      r0,r5                 ;1670
000030  f7fffffe          BL       eap_sm_request_new_password
                  |L50.52|
000034  f8d400b4          LDR      r0,[r4,#0xb4]         ;1671
000038  b120              CBZ      r0,|L50.68|
00003a  2200              MOVS     r2,#0                 ;1672
00003c  4611              MOV      r1,r2                 ;1672
00003e  4628              MOV      r0,r5                 ;1672
000040  f7fffffe          BL       eap_sm_request_otp
                  |L50.68|
000044  f8d400a8          LDR      r0,[r4,#0xa8]         ;1673
000048  b110              CBZ      r0,|L50.80|
00004a  4628              MOV      r0,r5                 ;1674
00004c  f7fffffe          BL       eap_sm_request_pin
                  |L50.80|
000050  f8d400b0          LDR      r0,[r4,#0xb0]         ;1675
000054  b110              CBZ      r0,|L50.92|
000056  4628              MOV      r0,r5                 ;1676
000058  f7fffffe          BL       eap_sm_request_passphrase
                  |L50.92|
00005c  bf00              NOP      
00005e  e7d6              B        |L50.14|
;;;1678   
                          ENDP


                          AREA ||i.eap_sm_parseEapReq||, CODE, READONLY, ALIGN=2

                  eap_sm_parseEapReq PROC
;;;1066   
;;;1067   static void eap_sm_parseEapReq(struct eap_sm *sm, const struct wpabuf *req)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1068   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1069   	const struct eap_hdr *hdr;
;;;1070   	size_t plen;
;;;1071   	const u8 *pos;
;;;1072   
;;;1073   	sm->rxReq = sm->rxResp = sm->rxSuccess = sm->rxFailure = FALSE;
000008  2000              MOVS     r0,#0
00000a  61a0              STR      r0,[r4,#0x18]
00000c  6160              STR      r0,[r4,#0x14]
00000e  6660              STR      r0,[r4,#0x64]
000010  6120              STR      r0,[r4,#0x10]
;;;1074   	sm->reqId = 0;
000012  61e0              STR      r0,[r4,#0x1c]
;;;1075   	sm->reqMethod = EAP_TYPE_NONE;
000014  f8840020          STRB     r0,[r4,#0x20]
;;;1076   	sm->reqVendor = EAP_VENDOR_IETF;
000018  6260              STR      r0,[r4,#0x24]
;;;1077   	sm->reqVendorMethod = EAP_TYPE_NONE;
00001a  62a0              STR      r0,[r4,#0x28]
;;;1078   
;;;1079   	if (req == NULL || wpabuf_len(req) < sizeof(*hdr))
00001c  b127              CBZ      r7,|L51.40|
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       wpabuf_len
000024  2804              CMP      r0,#4
000026  d201              BCS      |L51.44|
                  |L51.40|
;;;1080   		return;
;;;1081   
;;;1082   	hdr = wpabuf_head(req);
;;;1083   	plen = be_to_host16(hdr->length);
;;;1084   	if (plen > wpabuf_len(req)) {
;;;1085   		wpa_printf(MSG_DEBUG, "EAP: Ignored truncated EAP-Packet "
;;;1086   			   "(len=%lu plen=%lu)",
;;;1087   			   (unsigned long) wpabuf_len(req),
;;;1088   			   (unsigned long) plen);
;;;1089   		return;
;;;1090   	}
;;;1091   
;;;1092   	sm->reqId = hdr->identifier;
;;;1093   
;;;1094   	if (sm->workaround) {
;;;1095   		const u8 *addr[1];
;;;1096   		addr[0] = wpabuf_head(req);
;;;1097   		md5_vector(1, addr, &plen, sm->req_md5);
;;;1098   	}
;;;1099   
;;;1100   	switch (hdr->code) {
;;;1101   	case EAP_CODE_REQUEST:
;;;1102   		if (plen < sizeof(*hdr) + 1) {
;;;1103   			wpa_printf(MSG_DEBUG, "EAP: Too short EAP-Request - "
;;;1104   				   "no Type field");
;;;1105   			return;
;;;1106   		}
;;;1107   		sm->rxReq = TRUE;
;;;1108   		pos = (const u8 *) (hdr + 1);
;;;1109   		sm->reqMethod = *pos++;
;;;1110   		if (sm->reqMethod == EAP_TYPE_EXPANDED) {
;;;1111   			if (plen < sizeof(*hdr) + 8) {
;;;1112   				wpa_printf(MSG_DEBUG, "EAP: Ignored truncated "
;;;1113   					   "expanded EAP-Packet (plen=%lu)",
;;;1114   					   (unsigned long) plen);
;;;1115   				return;
;;;1116   			}
;;;1117   			sm->reqVendor = WPA_GET_BE24(pos);
;;;1118   			pos += 3;
;;;1119   			sm->reqVendorMethod = WPA_GET_BE32(pos);
;;;1120   		}
;;;1121   		wpa_printf(MSG_DEBUG, "EAP: Received EAP-Request id=%d "
;;;1122   			   "method=%u vendor=%u vendorMethod=%u",
;;;1123   			   sm->reqId, sm->reqMethod, sm->reqVendor,
;;;1124   			   sm->reqVendorMethod);
;;;1125   		break;
;;;1126   	case EAP_CODE_RESPONSE:
;;;1127   		if (sm->selectedMethod == EAP_TYPE_LEAP) {
;;;1128   			/*
;;;1129   			 * LEAP differs from RFC 4137 by using reversed roles
;;;1130   			 * for mutual authentication and because of this, we
;;;1131   			 * need to accept EAP-Response frames if LEAP is used.
;;;1132   			 */
;;;1133   			if (plen < sizeof(*hdr) + 1) {
;;;1134   				wpa_printf(MSG_DEBUG, "EAP: Too short "
;;;1135   					   "EAP-Response - no Type field");
;;;1136   				return;
;;;1137   			}
;;;1138   			sm->rxResp = TRUE;
;;;1139   			pos = (const u8 *) (hdr + 1);
;;;1140   			sm->reqMethod = *pos;
;;;1141   			wpa_printf(MSG_DEBUG, "EAP: Received EAP-Response for "
;;;1142   				   "LEAP method=%d id=%d",
;;;1143   				   sm->reqMethod, sm->reqId);
;;;1144   			break;
;;;1145   		}
;;;1146   		wpa_printf(MSG_DEBUG, "EAP: Ignored EAP-Response");
;;;1147   		break;
;;;1148   	case EAP_CODE_SUCCESS:
;;;1149   		wpa_printf(MSG_DEBUG, "EAP: Received EAP-Success");
;;;1150   		sm->rxSuccess = TRUE;
;;;1151   		break;
;;;1152   	case EAP_CODE_FAILURE:
;;;1153   		wpa_printf(MSG_DEBUG, "EAP: Received EAP-Failure");
;;;1154   		sm->rxFailure = TRUE;
;;;1155   		break;
;;;1156   	default:
;;;1157   		wpa_printf(MSG_DEBUG, "EAP: Ignored EAP-Packet with unknown "
;;;1158   			   "code %d", hdr->code);
;;;1159   		break;
;;;1160   	}
;;;1161   }
000028  e8bd83fe          POP      {r1-r9,pc}
                  |L51.44|
00002c  4638              MOV      r0,r7                 ;1082
00002e  f7fffffe          BL       wpabuf_head
000032  4606              MOV      r6,r0                 ;1082
000034  8870              LDRH     r0,[r6,#2]            ;1083
000036  f44f417f          MOV      r1,#0xff00            ;1083
00003a  ea012000          AND      r0,r1,r0,LSL #8       ;1083
00003e  8871              LDRH     r1,[r6,#2]            ;1083
000040  ea402011          ORR      r0,r0,r1,LSR #8       ;1083
000044  9002              STR      r0,[sp,#8]            ;1083
000046  4638              MOV      r0,r7                 ;1084
000048  f7fffffe          BL       wpabuf_len
00004c  9902              LDR      r1,[sp,#8]            ;1084
00004e  4288              CMP      r0,r1                 ;1084
000050  d20a              BCS      |L51.104|
000052  4638              MOV      r0,r7                 ;1085
000054  f7fffffe          BL       wpabuf_len
000058  4680              MOV      r8,r0                 ;1085
00005a  4602              MOV      r2,r0                 ;1085
00005c  a148              ADR      r1,|L51.384|
00005e  2000              MOVS     r0,#0                 ;1085
000060  9b02              LDR      r3,[sp,#8]            ;1085
000062  f7fffffe          BL       wpa_printf
000066  e7df              B        |L51.40|
                  |L51.104|
000068  7870              LDRB     r0,[r6,#1]            ;1092
00006a  61e0              STR      r0,[r4,#0x1c]         ;1092
00006c  f8d4009c          LDR      r0,[r4,#0x9c]         ;1094
000070  b158              CBZ      r0,|L51.138|
000072  4638              MOV      r0,r7                 ;1096
000074  f7fffffe          BL       wpabuf_head
000078  9001              STR      r0,[sp,#4]            ;1096
00007a  f1040370          ADD      r3,r4,#0x70           ;1097
00007e  aa02              ADD      r2,sp,#8              ;1097
000080  a901              ADD      r1,sp,#4              ;1097
000082  2001              MOVS     r0,#1                 ;1097
000084  f7fffffe          BL       md5_vector
000088  bf00              NOP                            ;1098
                  |L51.138|
00008a  7830              LDRB     r0,[r6,#0]            ;1100
00008c  2801              CMP      r0,#1                 ;1100
00008e  d006              BEQ      |L51.158|
000090  2802              CMP      r0,#2                 ;1100
000092  d040              BEQ      |L51.278|
000094  2803              CMP      r0,#3                 ;1100
000096  d05c              BEQ      |L51.338|
000098  2804              CMP      r0,#4                 ;1100
00009a  d168              BNE      |L51.366|
00009c  e060              B        |L51.352|
                  |L51.158|
00009e  9802              LDR      r0,[sp,#8]            ;1102
0000a0  2805              CMP      r0,#5                 ;1102
0000a2  d204              BCS      |L51.174|
0000a4  a144              ADR      r1,|L51.440|
0000a6  2000              MOVS     r0,#0                 ;1103
0000a8  f7fffffe          BL       wpa_printf
0000ac  e7bc              B        |L51.40|
                  |L51.174|
0000ae  2001              MOVS     r0,#1                 ;1107
0000b0  6120              STR      r0,[r4,#0x10]         ;1107
0000b2  1d35              ADDS     r5,r6,#4              ;1108
0000b4  f8150b01          LDRB     r0,[r5],#1            ;1109
0000b8  f8840020          STRB     r0,[r4,#0x20]         ;1109
0000bc  f8940020          LDRB     r0,[r4,#0x20]         ;1110
0000c0  28fe              CMP      r0,#0xfe              ;1110
0000c2  d11c              BNE      |L51.254|
0000c4  9802              LDR      r0,[sp,#8]            ;1111
0000c6  280c              CMP      r0,#0xc               ;1111
0000c8  d205              BCS      |L51.214|
0000ca  a146              ADR      r1,|L51.484|
0000cc  2000              MOVS     r0,#0                 ;1112
0000ce  9a02              LDR      r2,[sp,#8]            ;1112
0000d0  f7fffffe          BL       wpa_printf
0000d4  e7a8              B        |L51.40|
                  |L51.214|
0000d6  7828              LDRB     r0,[r5,#0]            ;1117
0000d8  0400              LSLS     r0,r0,#16             ;1117
0000da  7869              LDRB     r1,[r5,#1]            ;1117
0000dc  ea402001          ORR      r0,r0,r1,LSL #8       ;1117
0000e0  78a9              LDRB     r1,[r5,#2]            ;1117
0000e2  4308              ORRS     r0,r0,r1              ;1117
0000e4  6260              STR      r0,[r4,#0x24]         ;1117
0000e6  1ced              ADDS     r5,r5,#3              ;1118
0000e8  7828              LDRB     r0,[r5,#0]            ;1119
0000ea  0600              LSLS     r0,r0,#24             ;1119
0000ec  7869              LDRB     r1,[r5,#1]            ;1119
0000ee  ea404001          ORR      r0,r0,r1,LSL #16      ;1119
0000f2  78a9              LDRB     r1,[r5,#2]            ;1119
0000f4  ea402001          ORR      r0,r0,r1,LSL #8       ;1119
0000f8  78e9              LDRB     r1,[r5,#3]            ;1119
0000fa  4308              ORRS     r0,r0,r1              ;1119
0000fc  62a0              STR      r0,[r4,#0x28]         ;1119
                  |L51.254|
0000fe  e9d42309          LDRD     r2,r3,[r4,#0x24]      ;1121
000102  e9cd2300          STRD     r2,r3,[sp,#0]         ;1121
000106  f8943020          LDRB     r3,[r4,#0x20]         ;1121
00010a  4944              LDR      r1,|L51.540|
00010c  2000              MOVS     r0,#0                 ;1121
00010e  69e2              LDR      r2,[r4,#0x1c]         ;1121
000110  f7fffffe          BL       wpa_printf
000114  e031              B        |L51.378|
                  |L51.278|
000116  7860              LDRB     r0,[r4,#1]            ;1127
000118  2811              CMP      r0,#0x11              ;1127
00011a  d115              BNE      |L51.328|
00011c  9802              LDR      r0,[sp,#8]            ;1133
00011e  2805              CMP      r0,#5                 ;1133
000120  d204              BCS      |L51.300|
000122  a13f              ADR      r1,|L51.544|
000124  2000              MOVS     r0,#0                 ;1134
000126  f7fffffe          BL       wpa_printf
00012a  e77d              B        |L51.40|
                  |L51.300|
00012c  2001              MOVS     r0,#1                 ;1138
00012e  6660              STR      r0,[r4,#0x64]         ;1138
000130  1d35              ADDS     r5,r6,#4              ;1139
000132  7828              LDRB     r0,[r5,#0]            ;1140
000134  f8840020          STRB     r0,[r4,#0x20]         ;1140
000138  f8942020          LDRB     r2,[r4,#0x20]         ;1141
00013c  a143              ADR      r1,|L51.588|
00013e  2000              MOVS     r0,#0                 ;1141
000140  69e3              LDR      r3,[r4,#0x1c]         ;1141
000142  f7fffffe          BL       wpa_printf
000146  e018              B        |L51.378|
                  |L51.328|
000148  a14d              ADR      r1,|L51.640|
00014a  2000              MOVS     r0,#0                 ;1146
00014c  f7fffffe          BL       wpa_printf
000150  e013              B        |L51.378|
                  |L51.338|
000152  a152              ADR      r1,|L51.668|
000154  2000              MOVS     r0,#0                 ;1149
000156  f7fffffe          BL       wpa_printf
00015a  2001              MOVS     r0,#1                 ;1150
00015c  6160              STR      r0,[r4,#0x14]         ;1150
00015e  e00c              B        |L51.378|
                  |L51.352|
000160  a155              ADR      r1,|L51.696|
000162  2000              MOVS     r0,#0                 ;1153
000164  f7fffffe          BL       wpa_printf
000168  2001              MOVS     r0,#1                 ;1154
00016a  61a0              STR      r0,[r4,#0x18]         ;1154
00016c  e005              B        |L51.378|
                  |L51.366|
00016e  7832              LDRB     r2,[r6,#0]            ;1157
000170  a158              ADR      r1,|L51.724|
000172  2000              MOVS     r0,#0                 ;1157
000174  f7fffffe          BL       wpa_printf
000178  bf00              NOP                            ;1159
                  |L51.378|
00017a  bf00              NOP                            ;1125
00017c  bf00              NOP      
00017e  e753              B        |L51.40|
;;;1162   
                          ENDP

                  |L51.384|
000180  4541503a          DCB      "EAP: Ignored truncated EAP-Packet (len=%lu plen=%lu)",0
000184  2049676e
000188  6f726564
00018c  20747275
000190  6e636174
000194  65642045
000198  41502d50
00019c  61636b65
0001a0  7420286c
0001a4  656e3d25
0001a8  6c752070
0001ac  6c656e3d
0001b0  256c7529
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L51.440|
0001b8  4541503a          DCB      "EAP: Too short EAP-Request - no Type field",0
0001bc  20546f6f
0001c0  2073686f
0001c4  72742045
0001c8  41502d52
0001cc  65717565
0001d0  7374202d
0001d4  206e6f20
0001d8  54797065
0001dc  20666965
0001e0  6c6400  
0001e3  00                DCB      0
                  |L51.484|
0001e4  4541503a          DCB      "EAP: Ignored truncated expanded EAP-Packet (plen=%lu)",0
0001e8  2049676e
0001ec  6f726564
0001f0  20747275
0001f4  6e636174
0001f8  65642065
0001fc  7870616e
000200  64656420
000204  4541502d
000208  5061636b
00020c  65742028
000210  706c656e
000214  3d256c75
000218  2900    
00021a  00                DCB      0
00021b  00                DCB      0
                  |L51.540|
                          DCD      ||.constdata||
                  |L51.544|
000220  4541503a          DCB      "EAP: Too short EAP-Response - no Type field",0
000224  20546f6f
000228  2073686f
00022c  72742045
000230  41502d52
000234  6573706f
000238  6e736520
00023c  2d206e6f
000240  20547970
000244  65206669
000248  656c6400
                  |L51.588|
00024c  4541503a          DCB      "EAP: Received EAP-Response for LEAP method=%d id=%d",0
000250  20526563
000254  65697665
000258  64204541
00025c  502d5265
000260  73706f6e
000264  73652066
000268  6f72204c
00026c  45415020
000270  6d657468
000274  6f643d25
000278  64206964
00027c  3d256400
                  |L51.640|
000280  4541503a          DCB      "EAP: Ignored EAP-Response",0
000284  2049676e
000288  6f726564
00028c  20454150
000290  2d526573
000294  706f6e73
000298  6500    
00029a  00                DCB      0
00029b  00                DCB      0
                  |L51.668|
00029c  4541503a          DCB      "EAP: Received EAP-Success",0
0002a0  20526563
0002a4  65697665
0002a8  64204541
0002ac  502d5375
0002b0  63636573
0002b4  7300    
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L51.696|
0002b8  4541503a          DCB      "EAP: Received EAP-Failure",0
0002bc  20526563
0002c0  65697665
0002c4  64204541
0002c8  502d4661
0002cc  696c7572
0002d0  6500    
0002d2  00                DCB      0
0002d3  00                DCB      0
                  |L51.724|
0002d4  4541503a          DCB      "EAP: Ignored EAP-Packet with unknown code %d",0
0002d8  2049676e
0002dc  6f726564
0002e0  20454150
0002e4  2d506163
0002e8  6b657420
0002ec  77697468
0002f0  20756e6b
0002f4  6e6f776e
0002f8  20636f64
0002fc  65202564
000300  00      
000301  00                DCB      0
000302  00                DCB      0
000303  00                DCB      0

                          AREA ||i.eap_sm_processIdentity||, CODE, READONLY, ALIGN=2

                  eap_sm_processIdentity PROC
;;;853    
;;;854    static void eap_sm_processIdentity(struct eap_sm *sm, const struct wpabuf *req)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;855    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;856    	const struct eap_hdr *hdr = wpabuf_head(req);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_head
00000e  4604              MOV      r4,r0
;;;857    	const u8 *pos = (const u8 *) (hdr + 1);
000010  1d27              ADDS     r7,r4,#4
;;;858    	pos++;
000012  1c7f              ADDS     r7,r7,#1
;;;859    
;;;860    	wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_STARTED
000014  a20a              ADR      r2,|L52.64|
000016  2100              MOVS     r1,#0
000018  f8d50090          LDR      r0,[r5,#0x90]
00001c  f7fffffe          BL       wpa_msg
;;;861    		"EAP authentication started");
;;;862    
;;;863    	/*
;;;864    	 * RFC 3748 - 5.1: Identity
;;;865    	 * Data field may contain a displayable message in UTF-8. If this
;;;866    	 * includes NUL-character, only the data before that should be
;;;867    	 * displayed. Some EAP implementasitons may piggy-back additional
;;;868    	 * options after the NUL.
;;;869    	 */
;;;870    	/* TODO: could save displayable message so that it can be shown to the
;;;871    	 * user in case of interaction is required */
;;;872    	wpa_hexdump_ascii(MSG_DEBUG, "EAP: EAP-Request Identity data",
000020  8860              LDRH     r0,[r4,#2]
000022  f44f417f          MOV      r1,#0xff00
000026  ea012000          AND      r0,r1,r0,LSL #8
00002a  8861              LDRH     r1,[r4,#2]
00002c  ea402011          ORR      r0,r0,r1,LSR #8
000030  1f43              SUBS     r3,r0,#5
000032  463a              MOV      r2,r7
000034  a10f              ADR      r1,|L52.116|
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       wpa_hexdump_ascii
;;;873    			  pos, be_to_host16(hdr->length) - 5);
;;;874    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;875    
                          ENDP

                  |L52.64|
000040  4354524c          DCB      "CTRL-EVENT-EAP-STARTED EAP authentication started",0
000044  2d455645
000048  4e542d45
00004c  41502d53
000050  54415254
000054  45442045
000058  41502061
00005c  75746865
000060  6e746963
000064  6174696f
000068  6e207374
00006c  61727465
000070  6400    
000072  00                DCB      0
000073  00                DCB      0
                  |L52.116|
000074  4541503a          DCB      "EAP: EAP-Request Identity data",0
000078  20454150
00007c  2d526571
000080  75657374
000084  20496465
000088  6e746974
00008c  79206461
000090  746100  
000093  00                DCB      0

                          AREA ||i.eap_sm_processNotify||, CODE, READONLY, ALIGN=2

                  eap_sm_processNotify PROC
;;;1027   
;;;1028   static void eap_sm_processNotify(struct eap_sm *sm, const struct wpabuf *req)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1029   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;1030   	const u8 *pos;
;;;1031   	char *msg;
;;;1032   	size_t i, msg_len;
;;;1033   
;;;1034   	pos = eap_hdr_validate(EAP_VENDOR_IETF, EAP_TYPE_NOTIFICATION, req,
000008  ab01              ADD      r3,sp,#4
00000a  4642              MOV      r2,r8
00000c  2102              MOVS     r1,#2
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       eap_hdr_validate
000014  4606              MOV      r6,r0
;;;1035   			       &msg_len);
;;;1036   	if (pos == NULL)
000016  b90e              CBNZ     r6,|L53.28|
                  |L53.24|
;;;1037   		return;
;;;1038   	wpa_hexdump_ascii(MSG_DEBUG, "EAP: EAP-Request Notification data",
;;;1039   			  pos, msg_len);
;;;1040   
;;;1041   	msg = os_malloc(msg_len + 1);
;;;1042   	if (msg == NULL)
;;;1043   		return;
;;;1044   	for (i = 0; i < msg_len; i++)
;;;1045   		msg[i] = isprint(pos[i]) ? (char) pos[i] : '_';
;;;1046   	msg[msg_len] = '\0';
;;;1047   	wpa_msg(sm->msg_ctx, MSG_INFO, "%s%s",
;;;1048   		WPA_EVENT_EAP_NOTIFICATION, msg);
;;;1049   	os_free(msg);
;;;1050   }
000018  e8bd81fc          POP      {r2-r8,pc}
                  |L53.28|
00001c  4632              MOV      r2,r6                 ;1038
00001e  a117              ADR      r1,|L53.124|
000020  2000              MOVS     r0,#0                 ;1038
000022  9b01              LDR      r3,[sp,#4]            ;1038
000024  f7fffffe          BL       wpa_hexdump_ascii
000028  9801              LDR      r0,[sp,#4]            ;1041
00002a  1c40              ADDS     r0,r0,#1              ;1041
00002c  f7fffffe          BL       os_malloc
000030  4604              MOV      r4,r0                 ;1041
000032  b904              CBNZ     r4,|L53.54|
000034  e7f0              B        |L53.24|
                  |L53.54|
000036  2500              MOVS     r5,#0                 ;1044
000038  e00c              B        |L53.84|
                  |L53.58|
00003a  f7fffffe          BL       __rt_ctype_table
00003e  6800              LDR      r0,[r0,#0]            ;1045
000040  5d71              LDRB     r1,[r6,r5]            ;1045
000042  5c40              LDRB     r0,[r0,r1]            ;1045
000044  f0100f3e          TST      r0,#0x3e              ;1045
000048  d001              BEQ      |L53.78|
00004a  5d70              LDRB     r0,[r6,r5]            ;1045
00004c  e000              B        |L53.80|
                  |L53.78|
00004e  205f              MOVS     r0,#0x5f              ;1045
                  |L53.80|
000050  5560              STRB     r0,[r4,r5]            ;1045
000052  1c6d              ADDS     r5,r5,#1              ;1044
                  |L53.84|
000054  9801              LDR      r0,[sp,#4]            ;1044
000056  4285              CMP      r5,r0                 ;1044
000058  d3ef              BCC      |L53.58|
00005a  2000              MOVS     r0,#0                 ;1046
00005c  9901              LDR      r1,[sp,#4]            ;1046
00005e  5460              STRB     r0,[r4,r1]            ;1046
000060  9400              STR      r4,[sp,#0]            ;1047
000062  a30f              ADR      r3,|L53.160|
000064  a216              ADR      r2,|L53.192|
000066  2100              MOVS     r1,#0                 ;1047
000068  f8d70090          LDR      r0,[r7,#0x90]         ;1047
00006c  f7fffffe          BL       wpa_msg
000070  4620              MOV      r0,r4                 ;1049
000072  f7fffffe          BL       os_free
000076  bf00              NOP      
000078  e7ce              B        |L53.24|
;;;1051   
                          ENDP

00007a  0000              DCW      0x0000
                  |L53.124|
00007c  4541503a          DCB      "EAP: EAP-Request Notification data",0
000080  20454150
000084  2d526571
000088  75657374
00008c  204e6f74
000090  69666963
000094  6174696f
000098  6e206461
00009c  746100  
00009f  00                DCB      0
                  |L53.160|
0000a0  4354524c          DCB      "CTRL-EVENT-EAP-NOTIFICATION ",0
0000a4  2d455645
0000a8  4e542d45
0000ac  41502d4e
0000b0  4f544946
0000b4  49434154
0000b8  494f4e20
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L53.192|
0000c0  25732573          DCB      "%s%s",0
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.eap_sm_request||, CODE, READONLY, ALIGN=2

                  eap_sm_request PROC
;;;1485   
;;;1486   static void eap_sm_request(struct eap_sm *sm, eap_ctrl_req_type type,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1487   			   const char *msg, size_t msglen)
;;;1488   {
000004  4681              MOV      r9,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
00000a  4698              MOV      r8,r3
;;;1489   	struct eap_peer_config *config;
;;;1490   	char *field, *txt, *tmp;
;;;1491   
;;;1492   	if (sm == NULL)
00000c  f1b90f00          CMP      r9,#0
000010  d101              BNE      |L54.22|
                  |L54.18|
;;;1493   		return;
;;;1494   	config = eap_get_config(sm);
;;;1495   	if (config == NULL)
;;;1496   		return;
;;;1497   
;;;1498   	switch (type) {
;;;1499   	case TYPE_IDENTITY:
;;;1500   		field = "IDENTITY";
;;;1501   		txt = "Identity";
;;;1502   		config->pending_req_identity++;
;;;1503   		break;
;;;1504   	case TYPE_PASSWORD:
;;;1505   		field = "PASSWORD";
;;;1506   		txt = "Password";
;;;1507   		config->pending_req_password++;
;;;1508   		break;
;;;1509   	case TYPE_NEW_PASSWORD:
;;;1510   		field = "NEW_PASSWORD";
;;;1511   		txt = "New Password";
;;;1512   		config->pending_req_new_password++;
;;;1513   		break;
;;;1514   	case TYPE_PIN:
;;;1515   		field = "PIN";
;;;1516   		txt = "PIN";
;;;1517   		config->pending_req_pin++;
;;;1518   		break;
;;;1519   	case TYPE_OTP:
;;;1520   		field = "OTP";
;;;1521   		if (msg) {
;;;1522   			tmp = os_malloc(msglen + 3);
;;;1523   			if (tmp == NULL)
;;;1524   				return;
;;;1525   			tmp[0] = '[';
;;;1526   			os_memcpy(tmp + 1, msg, msglen);
;;;1527   			tmp[msglen + 1] = ']';
;;;1528   			tmp[msglen + 2] = '\0';
;;;1529   			txt = tmp;
;;;1530   			os_free(config->pending_req_otp);
;;;1531   			config->pending_req_otp = tmp;
;;;1532   			config->pending_req_otp_len = msglen + 3;
;;;1533   		} else {
;;;1534   			if (config->pending_req_otp == NULL)
;;;1535   				return;
;;;1536   			txt = config->pending_req_otp;
;;;1537   		}
;;;1538   		break;
;;;1539   	case TYPE_PASSPHRASE:
;;;1540   		field = "PASSPHRASE";
;;;1541   		txt = "Private key passphrase";
;;;1542   		config->pending_req_passphrase++;
;;;1543   		break;
;;;1544   	default:
;;;1545   		return;
;;;1546   	}
;;;1547   
;;;1548   	if (sm->eapol_cb->eap_param_needed)
;;;1549   		sm->eapol_cb->eap_param_needed(sm->eapol_ctx, field, txt);
;;;1550   }
000012  e8bd9ff0          POP      {r4-r12,pc}
                  |L54.22|
000016  4648              MOV      r0,r9                 ;1494
000018  f7fffffe          BL       eap_get_config
00001c  4604              MOV      r4,r0                 ;1494
00001e  b904              CBNZ     r4,|L54.34|
000020  e7f7              B        |L54.18|
                  |L54.34|
000022  f1ba0f06          CMP      r10,#6                ;1498
000026  d259              BCS      |L54.220|
000028  e8dff00a          TBB      [pc,r10]              ;1498
00002c  030b231b          DCB      0x03,0x0b,0x23,0x1b
000030  1350              DCB      0x13,0x50
000032  a731              ADR      r7,|L54.248|
000034  a533              ADR      r5,|L54.260|
000036  f8d400a0          LDR      r0,[r4,#0xa0]         ;1502
00003a  1c40              ADDS     r0,r0,#1              ;1502
00003c  f8c400a0          STR      r0,[r4,#0xa0]         ;1502
000040  e04d              B        |L54.222|
000042  a733              ADR      r7,|L54.272|
000044  a535              ADR      r5,|L54.284|
000046  f8d400a4          LDR      r0,[r4,#0xa4]         ;1507
00004a  1c40              ADDS     r0,r0,#1              ;1507
00004c  f8c400a4          STR      r0,[r4,#0xa4]         ;1507
000050  e045              B        |L54.222|
000052  a735              ADR      r7,|L54.296|
000054  a538              ADR      r5,|L54.312|
000056  f8d400ac          LDR      r0,[r4,#0xac]         ;1512
00005a  1c40              ADDS     r0,r0,#1              ;1512
00005c  f8c400ac          STR      r0,[r4,#0xac]         ;1512
000060  e03d              B        |L54.222|
000062  a739              ADR      r7,|L54.328|
000064  a538              ADR      r5,|L54.328|
000066  f8d400a8          LDR      r0,[r4,#0xa8]         ;1517
00006a  1c40              ADDS     r0,r0,#1              ;1517
00006c  f8c400a8          STR      r0,[r4,#0xa8]         ;1517
000070  e035              B        |L54.222|
000072  a736              ADR      r7,|L54.332|
000074  f1bb0f00          CMP      r11,#0                ;1521
000078  d021              BEQ      |L54.190|
00007a  f1080003          ADD      r0,r8,#3              ;1522
00007e  f7fffffe          BL       os_malloc
000082  4606              MOV      r6,r0                 ;1522
000084  b906              CBNZ     r6,|L54.136|
000086  e7c4              B        |L54.18|
                  |L54.136|
000088  205b              MOVS     r0,#0x5b              ;1525
00008a  7030              STRB     r0,[r6,#0]            ;1525
00008c  4642              MOV      r2,r8                 ;1526
00008e  4659              MOV      r1,r11                ;1526
000090  1c70              ADDS     r0,r6,#1              ;1526
000092  f7fffffe          BL       os_memcpy
000096  215d              MOVS     r1,#0x5d              ;1527
000098  f1080001          ADD      r0,r8,#1              ;1527
00009c  5431              STRB     r1,[r6,r0]            ;1527
00009e  2100              MOVS     r1,#0                 ;1528
0000a0  1c40              ADDS     r0,r0,#1              ;1528
0000a2  5431              STRB     r1,[r6,r0]            ;1528
0000a4  4635              MOV      r5,r6                 ;1529
0000a6  f8540fb4          LDR      r0,[r4,#0xb4]!        ;1530
0000aa  f7fffffe          BL       os_free
0000ae  4635              MOV      r5,r6                 ;1531
0000b0  6026              STR      r6,[r4,#0]            ;1531
0000b2  f1080003          ADD      r0,r8,#3              ;1532
0000b6  6060              STR      r0,[r4,#4]            ;1532
0000b8  f1a404b4          SUB      r4,r4,#0xb4           ;1532
0000bc  e005              B        |L54.202|
                  |L54.190|
0000be  f8d400b4          LDR      r0,[r4,#0xb4]         ;1534
0000c2  b900              CBNZ     r0,|L54.198|
0000c4  e7a5              B        |L54.18|
                  |L54.198|
0000c6  f8d450b4          LDR      r5,[r4,#0xb4]         ;1536
                  |L54.202|
0000ca  e008              B        |L54.222|
0000cc  a720              ADR      r7,|L54.336|
0000ce  a523              ADR      r5,|L54.348|
0000d0  f8d400b0          LDR      r0,[r4,#0xb0]         ;1542
0000d4  1c40              ADDS     r0,r0,#1              ;1542
0000d6  f8c400b0          STR      r0,[r4,#0xb0]         ;1542
0000da  e000              B        |L54.222|
                  |L54.220|
0000dc  e799              B        |L54.18|
                  |L54.222|
0000de  bf00              NOP                            ;1503
0000e0  f8d90054          LDR      r0,[r9,#0x54]         ;1548
0000e4  6a40              LDR      r0,[r0,#0x24]         ;1548
0000e6  b128              CBZ      r0,|L54.244|
0000e8  e9d90114          LDRD     r0,r1,[r9,#0x50]      ;1549
0000ec  462a              MOV      r2,r5                 ;1549
0000ee  6a4b              LDR      r3,[r1,#0x24]         ;1549
0000f0  4639              MOV      r1,r7                 ;1549
0000f2  4798              BLX      r3                    ;1549
                  |L54.244|
0000f4  bf00              NOP      
0000f6  e78c              B        |L54.18|
;;;1551   #else /* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
                          ENDP

                  |L54.248|
0000f8  4944454e          DCB      "IDENTITY",0
0000fc  54495459
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L54.260|
000104  4964656e          DCB      "Identity",0
000108  74697479
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L54.272|
000110  50415353          DCB      "PASSWORD",0
000114  574f5244
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L54.284|
00011c  50617373          DCB      "Password",0
000120  776f7264
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L54.296|
000128  4e45575f          DCB      "NEW_PASSWORD",0
00012c  50415353
000130  574f5244
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L54.312|
000138  4e657720          DCB      "New Password",0
00013c  50617373
000140  776f7264
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L54.328|
000148  50494e00          DCB      "PIN",0
                  |L54.332|
00014c  4f545000          DCB      "OTP",0
                  |L54.336|
000150  50415353          DCB      "PASSPHRASE",0
000154  50485241
000158  534500  
00015b  00                DCB      0
                  |L54.348|
00015c  50726976          DCB      "Private key passphrase",0
000160  61746520
000164  6b657920
000168  70617373
00016c  70687261
000170  736500  
000173  00                DCB      0

                          AREA ||i.eap_sm_request_identity||, CODE, READONLY, ALIGN=1

                  eap_sm_request_identity PROC
;;;1564    */
;;;1565   void eap_sm_request_identity(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1566   {
000002  4604              MOV      r4,r0
;;;1567   	eap_sm_request(sm, TYPE_IDENTITY, NULL, 0);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  4619              MOV      r1,r3
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eap_sm_request
;;;1568   }
000010  bd10              POP      {r4,pc}
;;;1569   
                          ENDP


                          AREA ||i.eap_sm_request_new_password||, CODE, READONLY, ALIGN=1

                  eap_sm_request_new_password PROC
;;;1594    */
;;;1595   void eap_sm_request_new_password(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1596   {
000002  4604              MOV      r4,r0
;;;1597   	eap_sm_request(sm, TYPE_NEW_PASSWORD, NULL, 0);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  2104              MOVS     r1,#4
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eap_sm_request
;;;1598   }
000010  bd10              POP      {r4,pc}
;;;1599   
                          ENDP


                          AREA ||i.eap_sm_request_otp||, CODE, READONLY, ALIGN=1

                  eap_sm_request_otp PROC
;;;1625    */
;;;1626   void eap_sm_request_otp(struct eap_sm *sm, const char *msg, size_t msg_len)
000000  b570              PUSH     {r4-r6,lr}
;;;1627   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1628   	eap_sm_request(sm, TYPE_OTP, msg, msg_len);
000008  462b              MOV      r3,r5
00000a  4622              MOV      r2,r4
00000c  2102              MOVS     r1,#2
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       eap_sm_request
;;;1629   }
000014  bd70              POP      {r4-r6,pc}
;;;1630   
                          ENDP


                          AREA ||i.eap_sm_request_passphrase||, CODE, READONLY, ALIGN=1

                  eap_sm_request_passphrase PROC
;;;1640    */
;;;1641   void eap_sm_request_passphrase(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1642   {
000002  4604              MOV      r4,r0
;;;1643   	eap_sm_request(sm, TYPE_PASSPHRASE, NULL, 0);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  2105              MOVS     r1,#5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eap_sm_request
;;;1644   }
000010  bd10              POP      {r4,pc}
;;;1645   
                          ENDP


                          AREA ||i.eap_sm_request_password||, CODE, READONLY, ALIGN=1

                  eap_sm_request_password PROC
;;;1579    */
;;;1580   void eap_sm_request_password(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1581   {
000002  4604              MOV      r4,r0
;;;1582   	eap_sm_request(sm, TYPE_PASSWORD, NULL, 0);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  2101              MOVS     r1,#1
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eap_sm_request
;;;1583   }
000010  bd10              POP      {r4,pc}
;;;1584   
                          ENDP


                          AREA ||i.eap_sm_request_pin||, CODE, READONLY, ALIGN=1

                  eap_sm_request_pin PROC
;;;1609    */
;;;1610   void eap_sm_request_pin(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;1611   {
000002  4604              MOV      r4,r0
;;;1612   	eap_sm_request(sm, TYPE_PIN, NULL, 0);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  2103              MOVS     r1,#3
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       eap_sm_request
;;;1613   }
000010  bd10              POP      {r4,pc}
;;;1614   
                          ENDP


                          AREA ||i.eap_sm_set_scard_pin||, CODE, READONLY, ALIGN=1

                  eap_sm_set_scard_pin PROC
;;;920    
;;;921    static int eap_sm_set_scard_pin(struct eap_sm *sm,
000000  4602              MOV      r2,r0
;;;922    				struct eap_peer_config *conf)
;;;923    {
;;;924    #ifdef PCSC_FUNCS
;;;925    	if (scard_set_pin(sm->scard_ctx, conf->pin)) {
;;;926    		/*
;;;927    		 * Make sure the same PIN is not tried again in order to avoid
;;;928    		 * blocking SIM.
;;;929    		 */
;;;930    		os_free(conf->pin);
;;;931    		conf->pin = NULL;
;;;932    
;;;933    		wpa_printf(MSG_WARNING, "PIN validation failed");
;;;934    		eap_sm_request_pin(sm);
;;;935    		return -1;
;;;936    	}
;;;937    	return 0;
;;;938    #else /* PCSC_FUNCS */
;;;939    	return -1;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;940    #endif /* PCSC_FUNCS */
;;;941    }
000006  4770              BX       lr
;;;942    
                          ENDP


                          AREA ||i.eap_success_workaround||, CODE, READONLY, ALIGN=2

                  eap_success_workaround PROC
;;;521    
;;;522    static int eap_success_workaround(struct eap_sm *sm, int reqId, int lastId)
000000  b570              PUSH     {r4-r6,lr}
;;;523    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;524    	/*
;;;525    	 * At least Microsoft IAS and Meetinghouse Aegis seem to be sending
;;;526    	 * EAP-Success/Failure with lastId + 1 even though RFC 3748 and
;;;527    	 * RFC 4137 require that reqId == lastId. In addition, it looks like
;;;528    	 * Ringmaster v2.1.2.0 would be using lastId + 2 in EAP-Success.
;;;529    	 *
;;;530    	 * Accept this kind of Id if EAP workarounds are enabled. These are
;;;531    	 * unauthenticated plaintext messages, so this should have minimal
;;;532    	 * security implications (bit easier to fake EAP-Success/Failure).
;;;533    	 */
;;;534    	if (sm->workaround && (reqId == ((lastId + 1) & 0xff) ||
000008  f8d6009c          LDR      r0,[r6,#0x9c]
00000c  b178              CBZ      r0,|L62.46|
00000e  1c68              ADDS     r0,r5,#1
000010  b2c0              UXTB     r0,r0
000012  42a0              CMP      r0,r4
000014  d003              BEQ      |L62.30|
;;;535    			       reqId == ((lastId + 2) & 0xff))) {
000016  1ca8              ADDS     r0,r5,#2
000018  b2c0              UXTB     r0,r0
00001a  42a0              CMP      r0,r4
00001c  d107              BNE      |L62.46|
                  |L62.30|
;;;536    		wpa_printf(MSG_DEBUG, "EAP: Workaround for unexpected "
00001e  462b              MOV      r3,r5
000020  4622              MOV      r2,r4
000022  4907              LDR      r1,|L62.64|
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       wpa_printf
;;;537    			   "identifier field in EAP Success: "
;;;538    			   "reqId=%d lastId=%d (these are supposed to be "
;;;539    			   "same)", reqId, lastId);
;;;540    		return 1;
00002a  2001              MOVS     r0,#1
                  |L62.44|
;;;541    	}
;;;542    	wpa_printf(MSG_DEBUG, "EAP: EAP-Success Id mismatch - reqId=%d "
;;;543    		   "lastId=%d", reqId, lastId);
;;;544    	return 0;
;;;545    }
00002c  bd70              POP      {r4-r6,pc}
                  |L62.46|
00002e  462b              MOV      r3,r5                 ;542
000030  4622              MOV      r2,r4                 ;542
000032  a104              ADR      r1,|L62.68|
000034  2000              MOVS     r0,#0                 ;542
000036  f7fffffe          BL       wpa_printf
00003a  2000              MOVS     r0,#0                 ;544
00003c  e7f6              B        |L62.44|
;;;546    
                          ENDP

00003e  0000              DCW      0x0000
                  |L62.64|
                          DCD      ||.constdata||+0xd4
                  |L62.68|
000044  4541503a          DCB      "EAP: EAP-Success Id mismatch - reqId=%d lastId=%d",0
000048  20454150
00004c  2d537563
000050  63657373
000054  20496420
000058  6d69736d
00005c  61746368
000060  202d2072
000064  65714964
000068  3d256420
00006c  6c617374
000070  49643d25
000074  6400    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.eapol_get_bool||, CODE, READONLY, ALIGN=1

                  eapol_get_bool PROC
;;;55     
;;;56     static Boolean eapol_get_bool(struct eap_sm *sm, enum eapol_bool_var var)
000000  b570              PUSH     {r4-r6,lr}
;;;57     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;58     	struct eapol_callbacks * cb = sm->eapol_cb;
000006  6d66              LDR      r6,[r4,#0x54]
;;;59     	return cb->get_bool(sm->eapol_ctx, var);
000008  6d20              LDR      r0,[r4,#0x50]
00000a  4629              MOV      r1,r5
00000c  6872              LDR      r2,[r6,#4]
00000e  4790              BLX      r2
;;;60     }
000010  bd70              POP      {r4-r6,pc}
;;;61     
                          ENDP


                          AREA ||i.eapol_get_eapReqData||, CODE, READONLY, ALIGN=1

                  eapol_get_eapReqData PROC
;;;83     
;;;84     static struct wpabuf * eapol_get_eapReqData(struct eap_sm *sm)
000000  b510              PUSH     {r4,lr}
;;;85     {
000002  4604              MOV      r4,r0
;;;86     	return sm->eapol_cb->get_eapReqData(sm->eapol_ctx);
000004  e9d40214          LDRD     r0,r2,[r4,#0x50]
000008  6951              LDR      r1,[r2,#0x14]
00000a  4788              BLX      r1
;;;87     }
00000c  bd10              POP      {r4,pc}
;;;88     
                          ENDP


                          AREA ||i.eapol_get_int||, CODE, READONLY, ALIGN=1

                  eapol_get_int PROC
;;;70     
;;;71     static unsigned int eapol_get_int(struct eap_sm *sm, enum eapol_int_var var)
000000  b570              PUSH     {r4-r6,lr}
;;;72     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;73     	return sm->eapol_cb->get_int(sm->eapol_ctx, var);
000006  e9d40114          LDRD     r0,r1,[r4,#0x50]
00000a  68ca              LDR      r2,[r1,#0xc]
00000c  4629              MOV      r1,r5
00000e  4790              BLX      r2
;;;74     }
000010  bd70              POP      {r4-r6,pc}
;;;75     
                          ENDP


                          AREA ||i.eapol_set_bool||, CODE, READONLY, ALIGN=1

                  eapol_set_bool PROC
;;;62     
;;;63     static void eapol_set_bool(struct eap_sm *sm, enum eapol_bool_var var,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;64     			   Boolean value)
;;;65     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;66     	struct eapol_callbacks * cb = sm->eapol_cb;
00000a  6d67              LDR      r7,[r4,#0x54]
;;;67     	cb->set_bool(sm->eapol_ctx, var, value);
00000c  6d20              LDR      r0,[r4,#0x50]
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  68bb              LDR      r3,[r7,#8]
000014  4798              BLX      r3
;;;68     }
000016  e8bd81f0          POP      {r4-r8,pc}
;;;69     
                          ENDP


                          AREA ||i.eapol_set_int||, CODE, READONLY, ALIGN=1

                  eapol_set_int PROC
;;;76     
;;;77     static void eapol_set_int(struct eap_sm *sm, enum eapol_int_var var,
000000  b570              PUSH     {r4-r6,lr}
;;;78     			  unsigned int value)
;;;79     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;80     	sm->eapol_cb->set_int(sm->eapol_ctx, var, value);
000008  e9d40114          LDRD     r0,r1,[r4,#0x50]
00000c  4632              MOV      r2,r6
00000e  690b              LDR      r3,[r1,#0x10]
000010  4629              MOV      r1,r5
000012  4798              BLX      r3
;;;81     }
000014  bd70              POP      {r4-r6,pc}
;;;82     
                          ENDP


                          AREA ||i.is_zero_ether_addr||, CODE, READONLY, ALIGN=1

                  is_zero_ether_addr PROC
;;;491    
;;;492    static int is_zero_ether_addr(const u8 *a)
000000  4601              MOV      r1,r0
;;;493    {
;;;494    	return !(a[0] | a[1] | a[2] | a[3] | a[4] | a[5]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  4310              ORRS     r0,r0,r2
000008  788a              LDRB     r2,[r1,#2]
00000a  4310              ORRS     r0,r0,r2
00000c  78ca              LDRB     r2,[r1,#3]
00000e  4310              ORRS     r0,r0,r2
000010  790a              LDRB     r2,[r1,#4]
000012  4310              ORRS     r0,r0,r2
000014  794a              LDRB     r2,[r1,#5]
000016  4310              ORRS     r0,r0,r2
000018  d101              BNE      |L68.30|
00001a  2001              MOVS     r0,#1
                  |L68.28|
;;;495    }
00001c  4770              BX       lr
                  |L68.30|
00001e  2000              MOVS     r0,#0                 ;494
000020  e7fc              B        |L68.28|
;;;496    
                          ENDP


                          AREA ||i.sm_EAP_DISABLED_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_DISABLED_Enter PROC
;;;178     */
;;;179    SM_STATE(EAP, DISABLED)
000000  b570              PUSH     {r4-r6,lr}
;;;180    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;181    	SM_ENTRY(EAP, DISABLED);
000006  b115              CBZ      r5,|L69.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2801              CMP      r0,#1
00000c  d005              BEQ      |L69.26|
                  |L69.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a105              ADR      r1,|L69.40|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L69.26|
00001a  2001              MOVS     r0,#1
00001c  7020              STRB     r0,[r4,#0]
;;;182    	sm->num_rounds = 0;
00001e  2000              MOVS     r0,#0
000020  f8c400a8          STR      r0,[r4,#0xa8]
;;;183    }
000024  bd70              POP      {r4-r6,pc}
;;;184    
                          ENDP

000026  0000              DCW      0x0000
                  |L69.40|
000028  4541503a          DCB      "EAP: EAP entering state DISABLED",0
00002c  20454150
000030  20656e74
000034  6572696e
000038  67207374
00003c  61746520
000040  44495341
000044  424c4544
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.sm_EAP_DISCARD_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_DISCARD_Enter PROC
;;;405     */
;;;406    SM_STATE(EAP, DISCARD)
000000  b570              PUSH     {r4-r6,lr}
;;;407    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;408    	SM_ENTRY(EAP, DISCARD);
000006  b115              CBZ      r5,|L70.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2807              CMP      r0,#7
00000c  d005              BEQ      |L70.26|
                  |L70.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a108              ADR      r1,|L70.52|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L70.26|
00001a  2007              MOVS     r0,#7
00001c  7020              STRB     r0,[r4,#0]
;;;409    	eapol_set_bool(sm, EAPOL_eapReq, FALSE);
00001e  2200              MOVS     r2,#0
000020  2105              MOVS     r1,#5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       eapol_set_bool
;;;410    	eapol_set_bool(sm, EAPOL_eapNoResp, TRUE);
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       eapol_set_bool
;;;411    }
000032  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

                  |L70.52|
000034  4541503a          DCB      "EAP: EAP entering state DISCARD",0
000038  20454150
00003c  20656e74
000040  6572696e
000044  67207374
000048  61746520
00004c  44495343
000050  41524400

                          AREA ||i.sm_EAP_FAILURE_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_FAILURE_Enter PROC
;;;495     */
;;;496    SM_STATE(EAP, FAILURE)
000000  b570              PUSH     {r4-r6,lr}
;;;497    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;498    	SM_ENTRY(EAP, FAILURE);
000006  b115              CBZ      r5,|L71.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  280c              CMP      r0,#0xc
00000c  d005              BEQ      |L71.26|
                  |L71.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a10f              ADR      r1,|L71.80|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L71.26|
00001a  200c              MOVS     r0,#0xc
00001c  7020              STRB     r0,[r4,#0]
;;;499    	eapol_set_bool(sm, EAPOL_eapFail, TRUE);
00001e  2201              MOVS     r2,#1
000020  2102              MOVS     r1,#2
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       eapol_set_bool
;;;500    
;;;501    	/*
;;;502    	 * RFC 4137 does not clear eapReq here, but this seems to be required
;;;503    	 * to avoid processing the same request twice when state machine is
;;;504    	 * initialized.
;;;505    	 */
;;;506    	eapol_set_bool(sm, EAPOL_eapReq, FALSE);
000028  2200              MOVS     r2,#0
00002a  2105              MOVS     r1,#5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       eapol_set_bool
;;;507    
;;;508    	/*
;;;509    	 * RFC 4137 does not set eapNoResp here. However, either eapResp or
;;;510    	 * eapNoResp is required to be set after processing the received EAP
;;;511    	 * frame.
;;;512    	 */
;;;513    	eapol_set_bool(sm, EAPOL_eapNoResp, TRUE);
000032  2201              MOVS     r2,#1
000034  2104              MOVS     r1,#4
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       eapol_set_bool
;;;514    
;;;515    	wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_FAILURE
00003c  a20c              ADR      r2,|L71.112|
00003e  2100              MOVS     r1,#0
000040  f8d40090          LDR      r0,[r4,#0x90]
000044  f7fffffe          BL       wpa_msg
;;;516    		"EAP authentication failed");
;;;517    
;;;518    	sm->prev_failure = 1;
000048  2001              MOVS     r0,#1
00004a  f8c400b4          STR      r0,[r4,#0xb4]
;;;519    }
00004e  bd70              POP      {r4-r6,pc}
;;;520    
                          ENDP

                  |L71.80|
000050  4541503a          DCB      "EAP: EAP entering state FAILURE",0
000054  20454150
000058  20656e74
00005c  6572696e
000060  67207374
000064  61746520
000068  4641494c
00006c  55524500
                  |L71.112|
000070  4354524c          DCB      "CTRL-EVENT-EAP-FAILURE EAP authentication failed",0
000074  2d455645
000078  4e542d45
00007c  41502d46
000080  41494c55
000084  52452045
000088  41502061
00008c  75746865
000090  6e746963
000094  6174696f
000098  6e206661
00009c  696c6564
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.sm_EAP_GET_METHOD_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_GET_METHOD_Enter PROC
;;;216     */
;;;217    SM_STATE(EAP, GET_METHOD)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;218    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;219    	int reinit;
;;;220    	EapType method;
;;;221    
;;;222    	SM_ENTRY(EAP, GET_METHOD);
000008  f1b80f00          CMP      r8,#0
00000c  d002              BEQ      |L72.20|
00000e  7820              LDRB     r0,[r4,#0]
000010  2804              CMP      r0,#4
000012  d005              BEQ      |L72.32|
                  |L72.20|
000014  2001              MOVS     r0,#1
000016  64e0              STR      r0,[r4,#0x4c]
000018  a15b              ADR      r1,|L72.392|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       wpa_printf
                  |L72.32|
000020  2004              MOVS     r0,#4
000022  7020              STRB     r0,[r4,#0]
;;;223    
;;;224    	if (sm->reqMethod == EAP_TYPE_EXPANDED)
000024  f8940020          LDRB     r0,[r4,#0x20]
000028  28fe              CMP      r0,#0xfe
00002a  d102              BNE      |L72.50|
;;;225    		method = sm->reqVendorMethod;
00002c  6aa0              LDR      r0,[r4,#0x28]
00002e  b2c5              UXTB     r5,r0
000030  e001              B        |L72.54|
                  |L72.50|
;;;226    	else
;;;227    		method = sm->reqMethod;
000032  f8945020          LDRB     r5,[r4,#0x20]
                  |L72.54|
;;;228    
;;;229    	if (!eap_sm_allowMethod(sm, sm->reqVendor, method)) {
000036  462a              MOV      r2,r5
000038  4620              MOV      r0,r4
00003a  6a61              LDR      r1,[r4,#0x24]
00003c  f7fffffe          BL       eap_sm_allowMethod
000040  b970              CBNZ     r0,|L72.96|
;;;230    		wpa_printf(MSG_DEBUG, "EAP: vendor %u method %u not allowed",
000042  462b              MOV      r3,r5
000044  a159              ADR      r1,|L72.428|
000046  2000              MOVS     r0,#0
000048  6a62              LDR      r2,[r4,#0x24]
00004a  f7fffffe          BL       wpa_printf
;;;231    			   sm->reqVendor, method);
;;;232    		wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_PROPOSED_METHOD
00004e  9500              STR      r5,[sp,#0]
000050  a260              ADR      r2,|L72.468|
000052  2100              MOVS     r1,#0
000054  6a63              LDR      r3,[r4,#0x24]
000056  f8d40090          LDR      r0,[r4,#0x90]
00005a  f7fffffe          BL       wpa_msg
;;;233    			"vendor=%u method=%u -> NAK",
;;;234    			sm->reqVendor, method);
;;;235    		goto nak;
00005e  e086              B        |L72.366|
                  |L72.96|
;;;236    	}
;;;237    
;;;238    	wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_PROPOSED_METHOD
000060  9500              STR      r5,[sp,#0]
000062  a26b              ADR      r2,|L72.528|
000064  2100              MOVS     r1,#0
000066  6a63              LDR      r3,[r4,#0x24]
000068  f8d40090          LDR      r0,[r4,#0x90]
00006c  f7fffffe          BL       wpa_msg
;;;239    		"vendor=%u method=%u", sm->reqVendor, method);
;;;240    
;;;241    	/*
;;;242    	 * RFC 4137 does not define specific operation for fast
;;;243    	 * re-authentication (session resumption). The design here is to allow
;;;244    	 * the previously used method data to be maintained for
;;;245    	 * re-authentication if the method support session resumption.
;;;246    	 * Otherwise, the previously used method data is freed and a new method
;;;247    	 * is allocated here.
;;;248    	 */
;;;249    	if (sm->fast_reauth &&
000070  6e20              LDR      r0,[r4,#0x60]
000072  b1c8              CBZ      r0,|L72.168|
;;;250    	    sm->m && sm->m->vendor == sm->reqVendor &&
000074  6ca0              LDR      r0,[r4,#0x48]
000076  b1b8              CBZ      r0,|L72.168|
000078  6ca0              LDR      r0,[r4,#0x48]
00007a  6800              LDR      r0,[r0,#0]
00007c  6a61              LDR      r1,[r4,#0x24]
00007e  4288              CMP      r0,r1
000080  d112              BNE      |L72.168|
;;;251    	    sm->m->method == method &&
000082  6ca0              LDR      r0,[r4,#0x48]
000084  7900              LDRB     r0,[r0,#4]
000086  42a8              CMP      r0,r5
000088  d10e              BNE      |L72.168|
;;;252    	    sm->m->has_reauth_data &&
00008a  6ca0              LDR      r0,[r4,#0x48]
00008c  6a40              LDR      r0,[r0,#0x24]
00008e  b158              CBZ      r0,|L72.168|
;;;253    	    sm->m->has_reauth_data(sm, sm->eap_method_priv)) {
000090  6da1              LDR      r1,[r4,#0x58]
000092  6ca0              LDR      r0,[r4,#0x48]
000094  6a42              LDR      r2,[r0,#0x24]
000096  4620              MOV      r0,r4
000098  4790              BLX      r2
00009a  b128              CBZ      r0,|L72.168|
;;;254    		wpa_printf(MSG_DEBUG, "EAP: Using previous method data"
00009c  a169              ADR      r1,|L72.580|
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       wpa_printf
;;;255    			   " for fast re-authentication");
;;;256    		reinit = 1;
0000a4  2601              MOVS     r6,#1
0000a6  e004              B        |L72.178|
                  |L72.168|
;;;257    	} else {
;;;258    		eap_deinit_prev_method(sm, "GET_METHOD");
0000a8  a13d              ADR      r1,|L72.416|
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       eap_deinit_prev_method
;;;259    		reinit = 0;
0000b0  2600              MOVS     r6,#0
                  |L72.178|
;;;260    	}
;;;261    
;;;262    	sm->selectedMethod = sm->reqMethod;
0000b2  f8940020          LDRB     r0,[r4,#0x20]
0000b6  7060              STRB     r0,[r4,#1]
;;;263    	if (sm->m == NULL)
0000b8  6ca0              LDR      r0,[r4,#0x48]
0000ba  b920              CBNZ     r0,|L72.198|
;;;264    		sm->m = eap_peer_get_eap_method(sm->reqVendor, method);
0000bc  4629              MOV      r1,r5
0000be  6a60              LDR      r0,[r4,#0x24]
0000c0  f7fffffe          BL       eap_peer_get_eap_method
0000c4  64a0              STR      r0,[r4,#0x48]
                  |L72.198|
;;;265    	if (!sm->m) {
0000c6  6ca0              LDR      r0,[r4,#0x48]
0000c8  b930              CBNZ     r0,|L72.216|
;;;266    		wpa_printf(MSG_DEBUG, "EAP: Could not find selected method: "
0000ca  462b              MOV      r3,r5
0000cc  a16c              ADR      r1,|L72.640|
0000ce  2000              MOVS     r0,#0
0000d0  6a62              LDR      r2,[r4,#0x24]
0000d2  f7fffffe          BL       wpa_printf
;;;267    			   "vendor %d method %d",
;;;268    			   sm->reqVendor, method);
;;;269    		goto nak;
0000d6  e04a              B        |L72.366|
                  |L72.216|
;;;270    	}
;;;271    
;;;272    	wpa_printf(MSG_DEBUG, "EAP: Initialize selected EAP method: "
0000d8  6ca0              LDR      r0,[r4,#0x48]
0000da  6883              LDR      r3,[r0,#8]
0000dc  9300              STR      r3,[sp,#0]
0000de  462b              MOV      r3,r5
0000e0  a176              ADR      r1,|L72.700|
0000e2  2000              MOVS     r0,#0
0000e4  6a62              LDR      r2,[r4,#0x24]
0000e6  f7fffffe          BL       wpa_printf
;;;273    		   "vendor %u method %u (%s)",
;;;274    		   sm->reqVendor, method, sm->m->name);
;;;275    	if (reinit)
0000ea  b136              CBZ      r6,|L72.250|
;;;276    		sm->eap_method_priv = sm->m->init_for_reauth(
0000ec  6da1              LDR      r1,[r4,#0x58]
0000ee  6ca0              LDR      r0,[r4,#0x48]
0000f0  6ac2              LDR      r2,[r0,#0x2c]
0000f2  4620              MOV      r0,r4
0000f4  4790              BLX      r2
0000f6  65a0              STR      r0,[r4,#0x58]
0000f8  e004              B        |L72.260|
                  |L72.250|
;;;277    			sm, sm->eap_method_priv);
;;;278    	else
;;;279    		sm->eap_method_priv = sm->m->init(sm);
0000fa  6ca0              LDR      r0,[r4,#0x48]
0000fc  68c1              LDR      r1,[r0,#0xc]
0000fe  4620              MOV      r0,r4
000100  4788              BLX      r1
000102  65a0              STR      r0,[r4,#0x58]
                  |L72.260|
;;;280    
;;;281    	if (sm->eap_method_priv == NULL) {
000104  6da0              LDR      r0,[r4,#0x58]
000106  bb20              CBNZ     r0,|L72.338|
;;;282    		struct eap_peer_config *config = eap_get_config(sm);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       eap_get_config
00010e  4607              MOV      r7,r0
;;;283    		wpa_msg(sm->msg_ctx, MSG_INFO,
000110  6ca0              LDR      r0,[r4,#0x48]
000112  6883              LDR      r3,[r0,#8]
000114  e9cd5300          STRD     r5,r3,[sp,#0]
000118  a278              ADR      r2,|L72.764|
00011a  2100              MOVS     r1,#0
00011c  6a63              LDR      r3,[r4,#0x24]
00011e  f8d40090          LDR      r0,[r4,#0x90]
000122  f7fffffe          BL       wpa_msg
;;;284    			"EAP: Failed to initialize EAP method: vendor %u "
;;;285    			"method %u (%s)",
;;;286    			sm->reqVendor, method, sm->m->name);
;;;287    		sm->m = NULL;
000126  2000              MOVS     r0,#0
000128  64a0              STR      r0,[r4,#0x48]
;;;288    		sm->methodState = METHOD_NONE;
00012a  70a0              STRB     r0,[r4,#2]
;;;289    		sm->selectedMethod = EAP_TYPE_NONE;
00012c  7060              STRB     r0,[r4,#1]
;;;290    		if (sm->reqMethod == EAP_TYPE_TLS && config &&
00012e  f8940020          LDRB     r0,[r4,#0x20]
000132  280d              CMP      r0,#0xd
000134  d10c              BNE      |L72.336|
000136  b15f              CBZ      r7,|L72.336|
;;;291    		    (config->pending_req_pin ||
000138  f8d700a8          LDR      r0,[r7,#0xa8]
00013c  b910              CBNZ     r0,|L72.324|
;;;292    		     config->pending_req_passphrase)) {
00013e  f8d700b0          LDR      r0,[r7,#0xb0]
000142  b128              CBZ      r0,|L72.336|
                  |L72.324|
;;;293    			/*
;;;294    			 * Return without generating Nak in order to allow
;;;295    			 * entering of PIN code or passphrase to retry the
;;;296    			 * current EAP packet.
;;;297    			 */
;;;298    			wpa_printf(MSG_DEBUG, "EAP: Pending PIN/passphrase "
000144  a17d              ADR      r1,|L72.828|
000146  2000              MOVS     r0,#0
000148  f7fffffe          BL       wpa_printf
                  |L72.332|
;;;299    				   "request - skip Nak");
;;;300    			return;
;;;301    		}
;;;302    
;;;303    		goto nak;
;;;304    	}
;;;305    
;;;306    	sm->methodState = METHOD_INIT;
;;;307    	wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_METHOD
;;;308    		"EAP vendor %u method %u (%s) selected",
;;;309    		sm->reqVendor, method, sm->m->name);
;;;310    	return;
;;;311    
;;;312    nak:
;;;313    	wpabuf_free(sm->eapRespData);
;;;314    	sm->eapRespData = NULL;
;;;315    	sm->eapRespData = eap_sm_buildNak(sm, sm->reqId);
;;;316    }
00014c  e8bd81fc          POP      {r2-r8,pc}
                  |L72.336|
000150  e00d              B        |L72.366|
                  |L72.338|
000152  2001              MOVS     r0,#1                 ;306
000154  70a0              STRB     r0,[r4,#2]            ;306
000156  6ca0              LDR      r0,[r4,#0x48]         ;307
000158  6883              LDR      r3,[r0,#8]            ;307
00015a  e9cd5300          STRD     r5,r3,[sp,#0]         ;307
00015e  a283              ADR      r2,|L72.876|
000160  2100              MOVS     r1,#0                 ;307
000162  6a63              LDR      r3,[r4,#0x24]         ;307
000164  f8d40090          LDR      r0,[r4,#0x90]         ;307
000168  f7fffffe          BL       wpa_msg
00016c  e7ee              B        |L72.332|
                  |L72.366|
00016e  6ba0              LDR      r0,[r4,#0x38]         ;313
000170  f7fffffe          BL       wpabuf_free
000174  2000              MOVS     r0,#0                 ;314
000176  63a0              STR      r0,[r4,#0x38]         ;314
000178  4620              MOV      r0,r4                 ;315
00017a  69e1              LDR      r1,[r4,#0x1c]         ;315
00017c  f7fffffe          BL       eap_sm_buildNak
000180  63a0              STR      r0,[r4,#0x38]         ;315
000182  bf00              NOP      
000184  e7e2              B        |L72.332|
;;;317    
                          ENDP

000186  0000              DCW      0x0000
                  |L72.392|
000188  4541503a          DCB      "EAP: EAP entering state "
00018c  20454150
000190  20656e74
000194  6572696e
000198  67207374
00019c  61746520
                  |L72.416|
0001a0  4745545f          DCB      "GET_METHOD",0
0001a4  4d455448
0001a8  4f4400  
0001ab  00                DCB      0
                  |L72.428|
0001ac  4541503a          DCB      "EAP: vendor %u method %u not allowed",0
0001b0  2076656e
0001b4  646f7220
0001b8  2575206d
0001bc  6574686f
0001c0  64202575
0001c4  206e6f74
0001c8  20616c6c
0001cc  6f776564
0001d0  00      
0001d1  00                DCB      0
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L72.468|
0001d4  4354524c          DCB      "CTRL-EVENT-EAP-PROPOSED-METHOD vendor=%u method=%u -> N"
0001d8  2d455645
0001dc  4e542d45
0001e0  41502d50
0001e4  524f504f
0001e8  5345442d
0001ec  4d455448
0001f0  4f442076
0001f4  656e646f
0001f8  723d2575
0001fc  206d6574
000200  686f643d
000204  2575202d
000208  3e204e  
00020b  414b00            DCB      "AK",0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L72.528|
000210  4354524c          DCB      "CTRL-EVENT-EAP-PROPOSED-METHOD vendor=%u method=%u",0
000214  2d455645
000218  4e542d45
00021c  41502d50
000220  524f504f
000224  5345442d
000228  4d455448
00022c  4f442076
000230  656e646f
000234  723d2575
000238  206d6574
00023c  686f643d
000240  257500  
000243  00                DCB      0
                  |L72.580|
000244  4541503a          DCB      "EAP: Using previous method data for fast re-authenticat"
000248  20557369
00024c  6e672070
000250  72657669
000254  6f757320
000258  6d657468
00025c  6f642064
000260  61746120
000264  666f7220
000268  66617374
00026c  2072652d
000270  61757468
000274  656e7469
000278  636174  
00027b  696f6e00          DCB      "ion",0
00027f  00                DCB      0
                  |L72.640|
000280  4541503a          DCB      "EAP: Could not find selected method: vendor %d method %"
000284  20436f75
000288  6c64206e
00028c  6f742066
000290  696e6420
000294  73656c65
000298  63746564
00029c  206d6574
0002a0  686f643a
0002a4  2076656e
0002a8  646f7220
0002ac  2564206d
0002b0  6574686f
0002b4  642025  
0002b7  6400              DCB      "d",0
0002b9  00                DCB      0
0002ba  00                DCB      0
0002bb  00                DCB      0
                  |L72.700|
0002bc  4541503a          DCB      "EAP: Initialize selected EAP method: vendor %u method %"
0002c0  20496e69
0002c4  7469616c
0002c8  697a6520
0002cc  73656c65
0002d0  63746564
0002d4  20454150
0002d8  206d6574
0002dc  686f643a
0002e0  2076656e
0002e4  646f7220
0002e8  2575206d
0002ec  6574686f
0002f0  642025  
0002f3  75202825          DCB      "u (%s)",0
0002f7  732900  
0002fa  00                DCB      0
0002fb  00                DCB      0
                  |L72.764|
0002fc  4541503a          DCB      "EAP: Failed to initialize EAP method: vendor %u method "
000300  20466169
000304  6c656420
000308  746f2069
00030c  6e697469
000310  616c697a
000314  65204541
000318  50206d65
00031c  74686f64
000320  3a207665
000324  6e646f72
000328  20257520
00032c  6d657468
000330  6f6420  
000333  25752028          DCB      "%u (%s)",0
000337  25732900
00033b  00                DCB      0
                  |L72.828|
00033c  4541503a          DCB      "EAP: Pending PIN/passphrase request - skip Nak",0
000340  2050656e
000344  64696e67
000348  2050494e
00034c  2f706173
000350  73706872
000354  61736520
000358  72657175
00035c  65737420
000360  2d20736b
000364  6970204e
000368  616b00  
00036b  00                DCB      0
                  |L72.876|
00036c  4354524c          DCB      "CTRL-EVENT-EAP-METHOD EAP vendor %u method %u (%s) sele"
000370  2d455645
000374  4e542d45
000378  41502d4d
00037c  4554484f
000380  44204541
000384  50207665
000388  6e646f72
00038c  20257520
000390  6d657468
000394  6f642025
000398  75202825
00039c  73292073
0003a0  656c65  
0003a3  63746564          DCB      "cted",0
0003a7  00      

                          AREA ||i.sm_EAP_IDENTITY_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_IDENTITY_Enter PROC
;;;416     */
;;;417    SM_STATE(EAP, IDENTITY)
000000  b570              PUSH     {r4-r6,lr}
;;;418    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;419    	const struct wpabuf *eapReqData;
;;;420    
;;;421    	SM_ENTRY(EAP, IDENTITY);
000006  b115              CBZ      r5,|L73.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2808              CMP      r0,#8
00000c  d005              BEQ      |L73.26|
                  |L73.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a10d              ADR      r1,|L73.72|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L73.26|
00001a  2008              MOVS     r0,#8
00001c  7020              STRB     r0,[r4,#0]
;;;422    	eapReqData = eapol_get_eapReqData(sm);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       eapol_get_eapReqData
000024  4606              MOV      r6,r0
;;;423    	eap_sm_processIdentity(sm, eapReqData);
000026  4631              MOV      r1,r6
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       eap_sm_processIdentity
;;;424    	wpabuf_free(sm->eapRespData);
00002e  6ba0              LDR      r0,[r4,#0x38]
000030  f7fffffe          BL       wpabuf_free
;;;425    	sm->eapRespData = NULL;
000034  2000              MOVS     r0,#0
000036  63a0              STR      r0,[r4,#0x38]
;;;426    	sm->eapRespData = eap_sm_buildIdentity(sm, sm->reqId, 0);
000038  2200              MOVS     r2,#0
00003a  4620              MOV      r0,r4
00003c  69e1              LDR      r1,[r4,#0x1c]
00003e  f7fffffe          BL       eap_sm_buildIdentity
000042  63a0              STR      r0,[r4,#0x38]
;;;427    }
000044  bd70              POP      {r4-r6,pc}
;;;428    
                          ENDP

000046  0000              DCW      0x0000
                  |L73.72|
000048  4541503a          DCB      "EAP: EAP entering state IDENTITY",0
00004c  20454150
000050  20656e74
000054  6572696e
000058  67207374
00005c  61746520
000060  4944454e
000064  54495459
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.sm_EAP_IDLE_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_IDLE_Enter PROC
;;;190     */
;;;191    SM_STATE(EAP, IDLE)
000000  b570              PUSH     {r4-r6,lr}
;;;192    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;193    	SM_ENTRY(EAP, IDLE);
000006  b115              CBZ      r5,|L74.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2802              CMP      r0,#2
00000c  d005              BEQ      |L74.26|
                  |L74.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a103              ADR      r1,|L74.32|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L74.26|
00001a  2002              MOVS     r0,#2
00001c  7020              STRB     r0,[r4,#0]
;;;194    }
00001e  bd70              POP      {r4-r6,pc}
;;;195    
                          ENDP

                  |L74.32|
000020  4541503a          DCB      "EAP: EAP entering state IDLE",0
000024  20454150
000028  20656e74
00002c  6572696e
000030  67207374
000034  61746520
000038  49444c45
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.sm_EAP_INITIALIZE_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_INITIALIZE_Enter PROC
;;;133     */
;;;134    SM_STATE(EAP, INITIALIZE)
000000  b570              PUSH     {r4-r6,lr}
;;;135    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;136    	SM_ENTRY(EAP, INITIALIZE);
000006  b10d              CBZ      r5,|L75.12|
000008  7820              LDRB     r0,[r4,#0]
00000a  b128              CBZ      r0,|L75.24|
                  |L75.12|
00000c  2001              MOVS     r0,#1
00000e  64e0              STR      r0,[r4,#0x4c]
000010  a12b              ADR      r1,|L75.192|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       wpa_printf
                  |L75.24|
000018  2000              MOVS     r0,#0
00001a  7020              STRB     r0,[r4,#0]
;;;137    	if (sm->fast_reauth && sm->m && sm->m->has_reauth_data &&
00001c  6e20              LDR      r0,[r4,#0x60]
00001e  b1b8              CBZ      r0,|L75.80|
000020  6ca0              LDR      r0,[r4,#0x48]
000022  b1a8              CBZ      r0,|L75.80|
000024  6ca0              LDR      r0,[r4,#0x48]
000026  6a40              LDR      r0,[r0,#0x24]
000028  b190              CBZ      r0,|L75.80|
;;;138    	    sm->m->has_reauth_data(sm, sm->eap_method_priv) &&
00002a  6da1              LDR      r1,[r4,#0x58]
00002c  6ca0              LDR      r0,[r4,#0x48]
00002e  6a42              LDR      r2,[r0,#0x24]
000030  4620              MOV      r0,r4
000032  4790              BLX      r2
000034  b160              CBZ      r0,|L75.80|
;;;139    	    !sm->prev_failure) {
000036  f8d400b4          LDR      r0,[r4,#0xb4]
00003a  b948              CBNZ     r0,|L75.80|
;;;140    		wpa_printf(MSG_DEBUG, "EAP: maintaining EAP method data for "
00003c  a129              ADR      r1,|L75.228|
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       wpa_printf
;;;141    			   "fast reauthentication");
;;;142    		sm->m->deinit_for_reauth(sm, sm->eap_method_priv);
000044  6da1              LDR      r1,[r4,#0x58]
000046  6ca0              LDR      r0,[r4,#0x48]
000048  6a82              LDR      r2,[r0,#0x28]
00004a  4620              MOV      r0,r4
00004c  4790              BLX      r2
00004e  e003              B        |L75.88|
                  |L75.80|
;;;143    	} else {
;;;144    		eap_deinit_prev_method(sm, "INITIALIZE");
000050  a121              ADR      r1,|L75.216|
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       eap_deinit_prev_method
                  |L75.88|
;;;145    	}
;;;146    	sm->selectedMethod = EAP_TYPE_NONE;
000058  2000              MOVS     r0,#0
00005a  7060              STRB     r0,[r4,#1]
;;;147    	sm->methodState = METHOD_NONE;
00005c  70a0              STRB     r0,[r4,#2]
;;;148    	sm->allowNotifications = TRUE;
00005e  2001              MOVS     r0,#1
000060  6360              STR      r0,[r4,#0x34]
;;;149    	sm->decision = DECISION_FAIL;
000062  2000              MOVS     r0,#0
000064  7320              STRB     r0,[r4,#0xc]
;;;150    	eapol_set_int(sm, EAPOL_idleWhile, sm->ClientTimeout);
000066  2100              MOVS     r1,#0
000068  4620              MOV      r0,r4
00006a  6b22              LDR      r2,[r4,#0x30]
00006c  f7fffffe          BL       eapol_set_int
;;;151    	eapol_set_bool(sm, EAPOL_eapSuccess, FALSE);
000070  2200              MOVS     r2,#0
000072  4611              MOV      r1,r2
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       eapol_set_bool
;;;152    	eapol_set_bool(sm, EAPOL_eapFail, FALSE);
00007a  2200              MOVS     r2,#0
00007c  2102              MOVS     r1,#2
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       eapol_set_bool
;;;153    	os_free(sm->eapKeyData);
000084  6c20              LDR      r0,[r4,#0x40]
000086  f7fffffe          BL       os_free
;;;154    	sm->eapKeyData = NULL;
00008a  2000              MOVS     r0,#0
00008c  6420              STR      r0,[r4,#0x40]
;;;155    	sm->eapKeyAvailable = FALSE;
00008e  63e0              STR      r0,[r4,#0x3c]
;;;156    	eapol_set_bool(sm, EAPOL_eapRestart, FALSE);
000090  2200              MOVS     r2,#0
000092  2101              MOVS     r1,#1
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       eapol_set_bool
;;;157    	sm->lastId = -1; /* new session - make sure this does not match with
00009a  f04f30ff          MOV      r0,#0xffffffff
00009e  6060              STR      r0,[r4,#4]
;;;158    			  * the first EAP-Packet */
;;;159    	/*
;;;160    	 * RFC 4137 does not reset eapResp and eapNoResp here. However, this
;;;161    	 * seemed to be able to trigger cases where both were set and if EAPOL
;;;162    	 * state machine uses eapNoResp first, it may end up not sending a real
;;;163    	 * reply correctly. This occurred when the workaround in FAIL state set
;;;164    	 * eapNoResp = TRUE.. Maybe that workaround needs to be fixed to do
;;;165    	 * something else(?)
;;;166    	 */
;;;167    	eapol_set_bool(sm, EAPOL_eapResp, FALSE);
0000a0  2200              MOVS     r2,#0
0000a2  2103              MOVS     r1,#3
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       eapol_set_bool
;;;168    	eapol_set_bool(sm, EAPOL_eapNoResp, FALSE);
0000aa  2200              MOVS     r2,#0
0000ac  2104              MOVS     r1,#4
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       eapol_set_bool
;;;169    	sm->num_rounds = 0;
0000b4  2000              MOVS     r0,#0
0000b6  f8c400a8          STR      r0,[r4,#0xa8]
;;;170    	sm->prev_failure = 0;
0000ba  f8c400b4          STR      r0,[r4,#0xb4]
;;;171    }
0000be  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP

                  |L75.192|
0000c0  4541503a          DCB      "EAP: EAP entering state "
0000c4  20454150
0000c8  20656e74
0000cc  6572696e
0000d0  67207374
0000d4  61746520
                  |L75.216|
0000d8  494e4954          DCB      "INITIALIZE",0
0000dc  49414c49
0000e0  5a4500  
0000e3  00                DCB      0
                  |L75.228|
0000e4  4541503a          DCB      "EAP: maintaining EAP method data for fast reauthenticat"
0000e8  206d6169
0000ec  6e746169
0000f0  6e696e67
0000f4  20454150
0000f8  206d6574
0000fc  686f6420
000100  64617461
000104  20666f72
000108  20666173
00010c  74207265
000110  61757468
000114  656e7469
000118  636174  
00011b  696f6e00          DCB      "ion",0
00011f  00                DCB      0

                          AREA ||i.sm_EAP_METHOD_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_METHOD_Enter PROC
;;;322     */
;;;323    SM_STATE(EAP, METHOD)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;324    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;325    	struct wpabuf *eapReqData;
;;;326    	struct eap_method_ret ret;
;;;327    
;;;328    	SM_ENTRY(EAP, METHOD);
000008  b115              CBZ      r5,|L76.16|
00000a  7820              LDRB     r0,[r4,#0]
00000c  2805              CMP      r0,#5
00000e  d005              BEQ      |L76.28|
                  |L76.16|
000010  2001              MOVS     r0,#1
000012  64e0              STR      r0,[r4,#0x4c]
000014  a134              ADR      r1,|L76.232|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       wpa_printf
                  |L76.28|
00001c  2005              MOVS     r0,#5
00001e  7020              STRB     r0,[r4,#0]
;;;329    	if (sm->m == NULL) {
000020  6ca0              LDR      r0,[r4,#0x48]
000022  b928              CBNZ     r0,|L76.48|
;;;330    		wpa_printf(MSG_WARNING, "EAP::METHOD - method not selected");
000024  a138              ADR      r1,|L76.264|
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       wpa_printf
                  |L76.44|
;;;331    		return;
;;;332    	}
;;;333    
;;;334    	eapReqData = eapol_get_eapReqData(sm);
;;;335    
;;;336    	/*
;;;337    	 * Get ignore, methodState, decision, allowNotifications, and
;;;338    	 * eapRespData. RFC 4137 uses three separate method procedure (check,
;;;339    	 * process, and buildResp) in this state. These have been combined into
;;;340    	 * a single function call to m->process() in order to optimize EAP
;;;341    	 * method implementation interface a bit. These procedures are only
;;;342    	 * used from within this METHOD state, so there is no need to keep
;;;343    	 * these as separate C functions.
;;;344    	 *
;;;345    	 * The RFC 4137 procedures return values as follows:
;;;346    	 * ignore = m.check(eapReqData)
;;;347    	 * (methodState, decision, allowNotifications) = m.process(eapReqData)
;;;348    	 * eapRespData = m.buildResp(reqId)
;;;349    	 */
;;;350    	os_memset(&ret, 0, sizeof(ret));
;;;351    	ret.ignore = sm->ignore;
;;;352    	ret.methodState = sm->methodState;
;;;353    	ret.decision = sm->decision;
;;;354    	ret.allowNotifications = sm->allowNotifications;
;;;355    	wpabuf_free(sm->eapRespData);
;;;356    	sm->eapRespData = NULL;
;;;357    	sm->eapRespData = sm->m->process(sm, sm->eap_method_priv, &ret,
;;;358    					 eapReqData);
;;;359    	wpa_printf(MSG_DEBUG, "EAP: method process -> ignore=%s "
;;;360    		   "methodState=%s decision=%s",
;;;361    		   ret.ignore ? "TRUE" : "FALSE",
;;;362    		   eap_sm_method_state_txt(ret.methodState),
;;;363    		   eap_sm_decision_txt(ret.decision));
;;;364    
;;;365    	sm->ignore = ret.ignore;
;;;366    	if (sm->ignore)
;;;367    		return;
;;;368    	sm->methodState = ret.methodState;
;;;369    	sm->decision = ret.decision;
;;;370    	sm->allowNotifications = ret.allowNotifications;
;;;371    
;;;372    	if (sm->m->isKeyAvailable && sm->m->getKey &&
;;;373    	    sm->m->isKeyAvailable(sm, sm->eap_method_priv)) {
;;;374    		os_free(sm->eapKeyData);
;;;375    		sm->eapKeyData = sm->m->getKey(sm, sm->eap_method_priv,
;;;376    					       &sm->eapKeyDataLen);
;;;377    	}
;;;378    }
00002c  e8bd81ff          POP      {r0-r8,pc}
                  |L76.48|
000030  4620              MOV      r0,r4                 ;334
000032  f7fffffe          BL       eapol_get_eapReqData
000036  4680              MOV      r8,r0                 ;334
000038  220c              MOVS     r2,#0xc               ;350
00003a  2100              MOVS     r1,#0                 ;350
00003c  a801              ADD      r0,sp,#4              ;350
00003e  f7fffffe          BL       os_memset
000042  6ae0              LDR      r0,[r4,#0x2c]         ;351
000044  9001              STR      r0,[sp,#4]            ;351
000046  78a0              LDRB     r0,[r4,#2]            ;352
000048  f88d0008          STRB     r0,[sp,#8]            ;352
00004c  7b20              LDRB     r0,[r4,#0xc]          ;353
00004e  f88d0009          STRB     r0,[sp,#9]            ;353
000052  6b60              LDR      r0,[r4,#0x34]         ;354
000054  9003              STR      r0,[sp,#0xc]          ;354
000056  6ba0              LDR      r0,[r4,#0x38]         ;355
000058  f7fffffe          BL       wpabuf_free
00005c  2000              MOVS     r0,#0                 ;356
00005e  63a0              STR      r0,[r4,#0x38]         ;356
000060  6da1              LDR      r1,[r4,#0x58]         ;357
000062  6ca0              LDR      r0,[r4,#0x48]         ;357
000064  4643              MOV      r3,r8                 ;357
000066  aa01              ADD      r2,sp,#4              ;357
000068  6946              LDR      r6,[r0,#0x14]         ;357
00006a  4620              MOV      r0,r4                 ;357
00006c  47b0              BLX      r6                    ;357
00006e  63a0              STR      r0,[r4,#0x38]         ;357
000070  f89d0009          LDRB     r0,[sp,#9]            ;359
000074  f7fffffe          BL       eap_sm_decision_txt
000078  4606              MOV      r6,r0                 ;359
00007a  f89d0008          LDRB     r0,[sp,#8]            ;359
00007e  f7fffffe          BL       eap_sm_method_state_txt
000082  4607              MOV      r7,r0                 ;359
000084  9600              STR      r6,[sp,#0]            ;359
000086  9801              LDR      r0,[sp,#4]            ;359
000088  b108              CBZ      r0,|L76.142|
00008a  a028              ADR      r0,|L76.300|
00008c  e000              B        |L76.144|
                  |L76.142|
00008e  a029              ADR      r0,|L76.308|
                  |L76.144|
000090  4602              MOV      r2,r0                 ;361
000092  463b              MOV      r3,r7                 ;361
000094  a129              ADR      r1,|L76.316|
000096  2000              MOVS     r0,#0                 ;361
000098  f7fffffe          BL       wpa_printf
00009c  9801              LDR      r0,[sp,#4]            ;365
00009e  62e0              STR      r0,[r4,#0x2c]         ;365
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;366
0000a2  b100              CBZ      r0,|L76.166|
0000a4  e7c2              B        |L76.44|
                  |L76.166|
0000a6  f89d0008          LDRB     r0,[sp,#8]            ;368
0000aa  70a0              STRB     r0,[r4,#2]            ;368
0000ac  f89d0009          LDRB     r0,[sp,#9]            ;369
0000b0  7320              STRB     r0,[r4,#0xc]          ;369
0000b2  9803              LDR      r0,[sp,#0xc]          ;370
0000b4  6360              STR      r0,[r4,#0x34]         ;370
0000b6  6ca0              LDR      r0,[r4,#0x48]         ;372
0000b8  6980              LDR      r0,[r0,#0x18]         ;372
0000ba  b198              CBZ      r0,|L76.228|
0000bc  6ca0              LDR      r0,[r4,#0x48]         ;372
0000be  69c0              LDR      r0,[r0,#0x1c]         ;372
0000c0  b180              CBZ      r0,|L76.228|
0000c2  6da1              LDR      r1,[r4,#0x58]         ;373
0000c4  6ca0              LDR      r0,[r4,#0x48]         ;373
0000c6  6982              LDR      r2,[r0,#0x18]         ;373
0000c8  4620              MOV      r0,r4                 ;373
0000ca  4790              BLX      r2                    ;373
0000cc  b150              CBZ      r0,|L76.228|
0000ce  6c20              LDR      r0,[r4,#0x40]         ;374
0000d0  f7fffffe          BL       os_free
0000d4  6da1              LDR      r1,[r4,#0x58]         ;375
0000d6  6ca0              LDR      r0,[r4,#0x48]         ;375
0000d8  f1040244          ADD      r2,r4,#0x44           ;375
0000dc  69c3              LDR      r3,[r0,#0x1c]         ;375
0000de  4620              MOV      r0,r4                 ;375
0000e0  4798              BLX      r3                    ;375
0000e2  6420              STR      r0,[r4,#0x40]         ;375
                  |L76.228|
0000e4  bf00              NOP      
0000e6  e7a1              B        |L76.44|
;;;379    
                          ENDP

                  |L76.232|
0000e8  4541503a          DCB      "EAP: EAP entering state METHOD",0
0000ec  20454150
0000f0  20656e74
0000f4  6572696e
0000f8  67207374
0000fc  61746520
000100  4d455448
000104  4f4400  
000107  00                DCB      0
                  |L76.264|
000108  4541503a          DCB      "EAP::METHOD - method not selected",0
00010c  3a4d4554
000110  484f4420
000114  2d206d65
000118  74686f64
00011c  206e6f74
000120  2073656c
000124  65637465
000128  6400    
00012a  00                DCB      0
00012b  00                DCB      0
                  |L76.300|
00012c  54525545          DCB      "TRUE",0
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L76.308|
000134  46414c53          DCB      "FALSE",0
000138  4500    
00013a  00                DCB      0
00013b  00                DCB      0
                  |L76.316|
00013c  4541503a          DCB      "EAP: method process -> ignore=%s methodState=%s decisio"
000140  206d6574
000144  686f6420
000148  70726f63
00014c  65737320
000150  2d3e2069
000154  676e6f72
000158  653d2573
00015c  206d6574
000160  686f6453
000164  74617465
000168  3d257320
00016c  64656369
000170  73696f  
000173  6e3d2573          DCB      "n=%s",0
000177  00      

                          AREA ||i.sm_EAP_NOTIFICATION_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_NOTIFICATION_Enter PROC
;;;432     */
;;;433    SM_STATE(EAP, NOTIFICATION)
000000  b570              PUSH     {r4-r6,lr}
;;;434    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;435    	const struct wpabuf *eapReqData;
;;;436    
;;;437    	SM_ENTRY(EAP, NOTIFICATION);
000006  b115              CBZ      r5,|L77.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2809              CMP      r0,#9
00000c  d005              BEQ      |L77.26|
                  |L77.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a10c              ADR      r1,|L77.68|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L77.26|
00001a  2009              MOVS     r0,#9
00001c  7020              STRB     r0,[r4,#0]
;;;438    	eapReqData = eapol_get_eapReqData(sm);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       eapol_get_eapReqData
000024  4606              MOV      r6,r0
;;;439    	eap_sm_processNotify(sm, eapReqData);
000026  4631              MOV      r1,r6
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       eap_sm_processNotify
;;;440    	wpabuf_free(sm->eapRespData);
00002e  6ba0              LDR      r0,[r4,#0x38]
000030  f7fffffe          BL       wpabuf_free
;;;441    	sm->eapRespData = NULL;
000034  2000              MOVS     r0,#0
000036  63a0              STR      r0,[r4,#0x38]
;;;442    	sm->eapRespData = eap_sm_buildNotify(sm->reqId);
000038  69e0              LDR      r0,[r4,#0x1c]
00003a  f7fffffe          BL       eap_sm_buildNotify
00003e  63a0              STR      r0,[r4,#0x38]
;;;443    }
000040  bd70              POP      {r4-r6,pc}
;;;444    
                          ENDP

000042  0000              DCW      0x0000
                  |L77.68|
000044  4541503a          DCB      "EAP: EAP entering state NOTIFICATION",0
000048  20454150
00004c  20656e74
000050  6572696e
000054  67207374
000058  61746520
00005c  4e4f5449
000060  46494341
000064  54494f4e
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.sm_EAP_RECEIVED_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_RECEIVED_Enter PROC
;;;200     */
;;;201    SM_STATE(EAP, RECEIVED)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;203    	const struct wpabuf *eapReqData;
;;;204    
;;;205    	SM_ENTRY(EAP, RECEIVED);
000006  b115              CBZ      r5,|L78.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2803              CMP      r0,#3
00000c  d005              BEQ      |L78.26|
                  |L78.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a10a              ADR      r1,|L78.60|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L78.26|
00001a  2003              MOVS     r0,#3
00001c  7020              STRB     r0,[r4,#0]
;;;206    	eapReqData = eapol_get_eapReqData(sm);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       eapol_get_eapReqData
000024  4606              MOV      r6,r0
;;;207    	/* parse rxReq, rxSuccess, rxFailure, reqId, reqMethod */
;;;208    	eap_sm_parseEapReq(sm, eapReqData);
000026  4631              MOV      r1,r6
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       eap_sm_parseEapReq
;;;209    	sm->num_rounds++;
00002e  f8d400a8          LDR      r0,[r4,#0xa8]
000032  1c40              ADDS     r0,r0,#1
000034  f8c400a8          STR      r0,[r4,#0xa8]
;;;210    }
000038  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

00003a  0000              DCW      0x0000
                  |L78.60|
00003c  4541503a          DCB      "EAP: EAP entering state RECEIVED",0
000040  20454150
000044  20656e74
000048  6572696e
00004c  67207374
000050  61746520
000054  52454345
000058  49564544
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.sm_EAP_RETRANSMIT_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_RETRANSMIT_Enter PROC
;;;448     */
;;;449    SM_STATE(EAP, RETRANSMIT)
000000  b570              PUSH     {r4-r6,lr}
;;;450    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;451    	SM_ENTRY(EAP, RETRANSMIT);
000006  b115              CBZ      r5,|L79.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  280a              CMP      r0,#0xa
00000c  d005              BEQ      |L79.26|
                  |L79.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a109              ADR      r1,|L79.56|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L79.26|
00001a  200a              MOVS     r0,#0xa
00001c  7020              STRB     r0,[r4,#0]
;;;452    	wpabuf_free(sm->eapRespData);
00001e  6ba0              LDR      r0,[r4,#0x38]
000020  f7fffffe          BL       wpabuf_free
;;;453    	if (sm->lastRespData)
000024  68a0              LDR      r0,[r4,#8]
000026  b120              CBZ      r0,|L79.50|
;;;454    		sm->eapRespData = wpabuf_dup(sm->lastRespData);
000028  68a0              LDR      r0,[r4,#8]
00002a  f7fffffe          BL       wpabuf_dup
00002e  63a0              STR      r0,[r4,#0x38]
000030  e001              B        |L79.54|
                  |L79.50|
;;;455    	else
;;;456    		sm->eapRespData = NULL;
000032  2000              MOVS     r0,#0
000034  63a0              STR      r0,[r4,#0x38]
                  |L79.54|
;;;457    }
000036  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP

                  |L79.56|
000038  4541503a          DCB      "EAP: EAP entering state RETRANSMIT",0
00003c  20454150
000040  20656e74
000044  6572696e
000048  67207374
00004c  61746520
000050  52455452
000054  414e534d
000058  495400  
00005b  00                DCB      0

                          AREA ||i.sm_EAP_SEND_RESPONSE_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_SEND_RESPONSE_Enter PROC
;;;384     */
;;;385    SM_STATE(EAP, SEND_RESPONSE)
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;387    	SM_ENTRY(EAP, SEND_RESPONSE);
000006  b115              CBZ      r5,|L80.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  2806              CMP      r0,#6
00000c  d005              BEQ      |L80.26|
                  |L80.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a117              ADR      r1,|L80.112|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L80.26|
00001a  2006              MOVS     r0,#6
00001c  7020              STRB     r0,[r4,#0]
;;;388    	wpabuf_free(sm->lastRespData);
00001e  68a0              LDR      r0,[r4,#8]
000020  f7fffffe          BL       wpabuf_free
;;;389    	if (sm->eapRespData) {
000024  6ba0              LDR      r0,[r4,#0x38]
000026  b1a8              CBZ      r0,|L80.84|
;;;390    		if (sm->workaround)
000028  f8d4009c          LDR      r0,[r4,#0x9c]
00002c  b130              CBZ      r0,|L80.60|
;;;391    			os_memcpy(sm->last_md5, sm->req_md5, 16);
00002e  2210              MOVS     r2,#0x10
000030  f1040170          ADD      r1,r4,#0x70
000034  f1040080          ADD      r0,r4,#0x80
000038  f7fffffe          BL       os_memcpy
                  |L80.60|
;;;392    		sm->lastId = sm->reqId;
00003c  69e0              LDR      r0,[r4,#0x1c]
00003e  6060              STR      r0,[r4,#4]
;;;393    		sm->lastRespData = wpabuf_dup(sm->eapRespData);
000040  6ba0              LDR      r0,[r4,#0x38]
000042  f7fffffe          BL       wpabuf_dup
000046  60a0              STR      r0,[r4,#8]
;;;394    		eapol_set_bool(sm, EAPOL_eapResp, TRUE);
000048  2201              MOVS     r2,#1
00004a  2103              MOVS     r1,#3
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       eapol_set_bool
000052  e001              B        |L80.88|
                  |L80.84|
;;;395    	} else
;;;396    		sm->lastRespData = NULL;
000054  2000              MOVS     r0,#0
000056  60a0              STR      r0,[r4,#8]
                  |L80.88|
;;;397    	eapol_set_bool(sm, EAPOL_eapReq, FALSE);
000058  2200              MOVS     r2,#0
00005a  2105              MOVS     r1,#5
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       eapol_set_bool
;;;398    	eapol_set_int(sm, EAPOL_idleWhile, sm->ClientTimeout);
000062  2100              MOVS     r1,#0
000064  4620              MOV      r0,r4
000066  6b22              LDR      r2,[r4,#0x30]
000068  f7fffffe          BL       eapol_set_int
;;;399    }
00006c  bd70              POP      {r4-r6,pc}
;;;400    
                          ENDP

00006e  0000              DCW      0x0000
                  |L80.112|
000070  4541503a          DCB      "EAP: EAP entering state SEND_RESPONSE",0
000074  20454150
000078  20656e74
00007c  6572696e
000080  67207374
000084  61746520
000088  53454e44
00008c  5f524553
000090  504f4e53
000094  4500    
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.sm_EAP_SUCCESS_Enter||, CODE, READONLY, ALIGN=2

                  sm_EAP_SUCCESS_Enter PROC
;;;464     */
;;;465    SM_STATE(EAP, SUCCESS)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;467    	SM_ENTRY(EAP, SUCCESS);
000006  b115              CBZ      r5,|L81.14|
000008  7820              LDRB     r0,[r4,#0]
00000a  280b              CMP      r0,#0xb
00000c  d005              BEQ      |L81.26|
                  |L81.14|
00000e  2001              MOVS     r0,#1
000010  64e0              STR      r0,[r4,#0x4c]
000012  a110              ADR      r1,|L81.84|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       wpa_printf
                  |L81.26|
00001a  200b              MOVS     r0,#0xb
00001c  7020              STRB     r0,[r4,#0]
;;;468    	if (sm->eapKeyData != NULL)
00001e  6c20              LDR      r0,[r4,#0x40]
000020  b108              CBZ      r0,|L81.38|
;;;469    		sm->eapKeyAvailable = TRUE;
000022  2001              MOVS     r0,#1
000024  63e0              STR      r0,[r4,#0x3c]
                  |L81.38|
;;;470    	eapol_set_bool(sm, EAPOL_eapSuccess, TRUE);
000026  2201              MOVS     r2,#1
000028  2100              MOVS     r1,#0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       eapol_set_bool
;;;471    
;;;472    	/*
;;;473    	 * RFC 4137 does not clear eapReq here, but this seems to be required
;;;474    	 * to avoid processing the same request twice when state machine is
;;;475    	 * initialized.
;;;476    	 */
;;;477    	eapol_set_bool(sm, EAPOL_eapReq, FALSE);
000030  2200              MOVS     r2,#0
000032  2105              MOVS     r1,#5
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       eapol_set_bool
;;;478    
;;;479    	/*
;;;480    	 * RFC 4137 does not set eapNoResp here, but this seems to be required
;;;481    	 * to get EAPOL Supplicant backend state machine into SUCCESS state. In
;;;482    	 * addition, either eapResp or eapNoResp is required to be set after
;;;483    	 * processing the received EAP frame.
;;;484    	 */
;;;485    	eapol_set_bool(sm, EAPOL_eapNoResp, TRUE);
00003a  2201              MOVS     r2,#1
00003c  2104              MOVS     r1,#4
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       eapol_set_bool
;;;486    
;;;487    	wpa_msg(sm->msg_ctx, MSG_INFO, WPA_EVENT_EAP_SUCCESS
000044  4a0b              LDR      r2,|L81.116|
000046  2100              MOVS     r1,#0
000048  f8d40090          LDR      r0,[r4,#0x90]
00004c  f7fffffe          BL       wpa_msg
;;;488    		"EAP authentication completed successfully");
;;;489    }
000050  bd70              POP      {r4-r6,pc}
;;;490    
                          ENDP

000052  0000              DCW      0x0000
                  |L81.84|
000054  4541503a          DCB      "EAP: EAP entering state SUCCESS",0
000058  20454150
00005c  20656e74
000060  6572696e
000064  67207374
000068  61746520
00006c  53554343
000070  45535300
                  |L81.116|
                          DCD      ||.constdata||+0x90

                          AREA ||i.sm_EAP_Step||, CODE, READONLY, ALIGN=2

                  sm_EAP_Step PROC
;;;710    
;;;711    SM_STEP(EAP)
000000  b510              PUSH     {r4,lr}
;;;712    {
000002  4604              MOV      r4,r0
;;;713    	/* Global transitions */
;;;714    	if (eapol_get_bool(sm, EAPOL_eapRestart) &&
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       eapol_get_bool
00000c  b148              CBZ      r0,|L82.34|
;;;715    	    eapol_get_bool(sm, EAPOL_portEnabled))
00000e  2106              MOVS     r1,#6
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       eapol_get_bool
000016  b120              CBZ      r0,|L82.34|
;;;716    		SM_ENTER_GLOBAL(EAP, INITIALIZE);
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       sm_EAP_INITIALIZE_Enter
000020  e029              B        |L82.118|
                  |L82.34|
;;;717    	else if (!eapol_get_bool(sm, EAPOL_portEnabled) || sm->force_disabled)
000022  2106              MOVS     r1,#6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       eapol_get_bool
00002a  b110              CBZ      r0,|L82.50|
00002c  f8d400ac          LDR      r0,[r4,#0xac]
000030  b120              CBZ      r0,|L82.60|
                  |L82.50|
;;;718    		SM_ENTER_GLOBAL(EAP, DISABLED);
000032  2101              MOVS     r1,#1
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       sm_EAP_DISABLED_Enter
00003a  e01c              B        |L82.118|
                  |L82.60|
;;;719    	else if (sm->num_rounds > EAP_MAX_AUTH_ROUNDS) {
00003c  f8d400a8          LDR      r0,[r4,#0xa8]
000040  2832              CMP      r0,#0x32
000042  dd15              BLE      |L82.112|
;;;720    		/* RFC 4137 does not place any limit on number of EAP messages
;;;721    		 * in an authentication session. However, some error cases have
;;;722    		 * ended up in a state were EAP messages were sent between the
;;;723    		 * peer and server in a loop (e.g., TLS ACK frame in both
;;;724    		 * direction). Since this is quite undesired outcome, limit the
;;;725    		 * total number of EAP round-trips and abort authentication if
;;;726    		 * this limit is exceeded.
;;;727    		 */
;;;728    		if (sm->num_rounds == EAP_MAX_AUTH_ROUNDS + 1) {
000044  f8d400a8          LDR      r0,[r4,#0xa8]
000048  2833              CMP      r0,#0x33
00004a  d114              BNE      |L82.118|
;;;729    			wpa_msg(sm->msg_ctx, MSG_INFO, "EAP: more than %d "
00004c  f8540f90          LDR      r0,[r4,#0x90]!
000050  2332              MOVS     r3,#0x32
000052  a209              ADR      r2,|L82.120|
000054  2100              MOVS     r1,#0
000056  f7fffffe          BL       wpa_msg
;;;730    				"authentication rounds - abort",
;;;731    				EAP_MAX_AUTH_ROUNDS);
;;;732    			sm->num_rounds++;
00005a  69a0              LDR      r0,[r4,#0x18]
00005c  1c40              ADDS     r0,r0,#1
00005e  61a0              STR      r0,[r4,#0x18]
000060  f1a40490          SUB      r4,r4,#0x90
;;;733    			SM_ENTER_GLOBAL(EAP, FAILURE);
000064  f04f0101          MOV      r1,#1
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       sm_EAP_FAILURE_Enter
00006e  e002              B        |L82.118|
                  |L82.112|
;;;734    		}
;;;735    	} else {
;;;736    		/* Local transitions */
;;;737    		eap_peer_sm_step_local(sm);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       eap_peer_sm_step_local
                  |L82.118|
;;;738    	}
;;;739    }
000076  bd10              POP      {r4,pc}
;;;740    
                          ENDP

                  |L82.120|
000078  4541503a          DCB      "EAP: more than %d authentication rounds - abort",0
00007c  206d6f72
000080  65207468
000084  616e2025
000088  64206175
00008c  7468656e
000090  74696361
000094  74696f6e
000098  20726f75
00009c  6e647320
0000a0  2d206162
0000a4  6f727400

                          AREA ||i.wpa_debug_close_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_close_syslog PROC
;;;243    
;;;244    static inline void wpa_debug_close_syslog(void)
000000  4770              BX       lr
;;;245    {
;;;246    }
;;;247    
                          ENDP


                          AREA ||i.wpa_debug_open_syslog||, CODE, READONLY, ALIGN=1

                  wpa_debug_open_syslog PROC
;;;239    
;;;240    static inline void wpa_debug_open_syslog(void)
000000  4770              BX       lr
;;;241    {
;;;242    }
;;;243    
                          ENDP


                          AREA ||i.wpa_hexdump_buf||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf PROC
;;;87     
;;;88     static inline void wpa_hexdump_buf(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     				   const struct wpabuf *buf)
;;;90     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;91     	wpa_hexdump(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump
;;;92     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.wpa_hexdump_buf_key||, CODE, READONLY, ALIGN=1

                  wpa_hexdump_buf_key PROC
;;;108    
;;;109    static inline void wpa_hexdump_buf_key(int level, const char *title,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    				       const struct wpabuf *buf)
;;;111    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;112    	wpa_hexdump_key(level, title, wpabuf_head(buf), wpabuf_len(buf));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       wpabuf_len
000010  4607              MOV      r7,r0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       wpabuf_head
000018  4680              MOV      r8,r0
00001a  463b              MOV      r3,r7
00001c  4602              MOV      r2,r0
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       wpa_hexdump_key
;;;113    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;114    
                          ENDP


                          AREA ||i.wpa_key_mgmt_ft||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_ft PROC
;;;65     
;;;66     static inline int wpa_key_mgmt_ft(int akm)
000000  4601              MOV      r1,r0
;;;67     {
;;;68     	return akm == WPA_KEY_MGMT_FT_PSK ||
000002  2940              CMP      r1,#0x40
000004  d001              BEQ      |L87.10|
;;;69     		akm == WPA_KEY_MGMT_FT_IEEE8021X;
000006  2920              CMP      r1,#0x20
000008  d101              BNE      |L87.14|
                  |L87.10|
00000a  2001              MOVS     r0,#1                 ;68
                  |L87.12|
;;;70     }
00000c  4770              BX       lr
                  |L87.14|
00000e  2000              MOVS     r0,#0                 ;68
000010  e7fc              B        |L87.12|
;;;71     
                          ENDP


                          AREA ||i.wpa_key_mgmt_sha256||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_sha256 PROC
;;;71     
;;;72     static inline int wpa_key_mgmt_sha256(int akm)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return akm == WPA_KEY_MGMT_PSK_SHA256 ||
000002  f5b17f80          CMP      r1,#0x100
000006  d001              BEQ      |L88.12|
;;;75     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
000008  2980              CMP      r1,#0x80
00000a  d101              BNE      |L88.16|
                  |L88.12|
00000c  2001              MOVS     r0,#1                 ;74
                  |L88.14|
;;;76     }
00000e  4770              BX       lr
                  |L88.16|
000010  2000              MOVS     r0,#0                 ;74
000012  e7fc              B        |L88.14|
;;;77     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_ieee8021x||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_ieee8021x PROC
;;;51     
;;;52     static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return akm == WPA_KEY_MGMT_IEEE8021X ||
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L89.14|
;;;55     		akm == WPA_KEY_MGMT_FT_IEEE8021X ||
000006  2920              CMP      r1,#0x20
000008  d001              BEQ      |L89.14|
;;;56     		akm == WPA_KEY_MGMT_IEEE8021X_SHA256;
00000a  2980              CMP      r1,#0x80
00000c  d101              BNE      |L89.18|
                  |L89.14|
00000e  2001              MOVS     r0,#1                 ;54
                  |L89.16|
;;;57     }
000010  4770              BX       lr
                  |L89.18|
000012  2000              MOVS     r0,#0                 ;54
000014  e7fc              B        |L89.16|
;;;58     
                          ENDP


                          AREA ||i.wpa_key_mgmt_wpa_psk||, CODE, READONLY, ALIGN=1

                  wpa_key_mgmt_wpa_psk PROC
;;;58     
;;;59     static inline int wpa_key_mgmt_wpa_psk(int akm)
000000  4601              MOV      r1,r0
;;;60     {
;;;61     	return akm == WPA_KEY_MGMT_PSK ||
000002  2902              CMP      r1,#2
000004  d004              BEQ      |L90.16|
;;;62     		akm == WPA_KEY_MGMT_FT_PSK ||
000006  2940              CMP      r1,#0x40
000008  d002              BEQ      |L90.16|
;;;63     		akm == WPA_KEY_MGMT_PSK_SHA256;
00000a  f5b17f80          CMP      r1,#0x100
00000e  d101              BNE      |L90.20|
                  |L90.16|
000010  2001              MOVS     r0,#1                 ;61
                  |L90.18|
;;;64     }
000012  4770              BX       lr
                  |L90.20|
000014  2000              MOVS     r0,#0                 ;61
000016  e7fc              B        |L90.18|
;;;65     
                          ENDP


                          AREA ||i.wpabuf_head||, CODE, READONLY, ALIGN=1

                  wpabuf_head PROC
;;;81      */
;;;82     static inline const void * wpabuf_head(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;83     {
;;;84     	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L91.10|
;;;85     		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L91.8|
;;;86     	return buf + 1;
;;;87     }
000008  4770              BX       lr
                  |L91.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;86
00000e  e7fb              B        |L91.8|
;;;88     
                          ENDP


                          AREA ||i.wpabuf_head_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_head_u8 PROC
;;;88     
;;;89     static inline const u8 * wpabuf_head_u8(const struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91     	return wpabuf_head(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_head
;;;92     }
00000a  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.wpabuf_len||, CODE, READONLY, ALIGN=1

                  wpabuf_len PROC
;;;61      */
;;;62     static inline size_t wpabuf_len(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	return buf->used;
000002  6848              LDR      r0,[r1,#4]
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.wpabuf_mhead||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead PROC
;;;98      */
;;;99     static inline void * wpabuf_mhead(struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;100    {
;;;101    	if (buf->ext_data)
000002  6888              LDR      r0,[r1,#8]
000004  b108              CBZ      r0,|L94.10|
;;;102    		return buf->ext_data;
000006  6888              LDR      r0,[r1,#8]
                  |L94.8|
;;;103    	return buf + 1;
;;;104    }
000008  4770              BX       lr
                  |L94.10|
00000a  f101000c          ADD      r0,r1,#0xc            ;103
00000e  e7fb              B        |L94.8|
;;;105    
                          ENDP


                          AREA ||i.wpabuf_mhead_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_mhead_u8 PROC
;;;105    
;;;106    static inline u8 * wpabuf_mhead_u8(struct wpabuf *buf)
000000  b510              PUSH     {r4,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	return wpabuf_mhead(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       wpabuf_mhead
;;;109    }
00000a  bd10              POP      {r4,pc}
;;;110    
                          ENDP


                          AREA ||i.wpabuf_put_be16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be16 PROC
;;;122    
;;;123    static inline void wpabuf_put_be16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;125    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;126    	WPA_PUT_BE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7028              STRB     r0,[r5,#0]
000016  706c              STRB     r4,[r5,#1]
000018  bf00              NOP      
;;;127    }
00001a  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.wpabuf_put_be24||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be24 PROC
;;;128    
;;;129    static inline void wpabuf_put_be24(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;131    	u8 *pos = wpabuf_put(buf, 3);
000006  2103              MOVS     r1,#3
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;132    	WPA_PUT_BE24(pos, data);
000010  bf00              NOP      
000012  0c20              LSRS     r0,r4,#16
000014  7028              STRB     r0,[r5,#0]
000016  0a20              LSRS     r0,r4,#8
000018  7068              STRB     r0,[r5,#1]
00001a  70ac              STRB     r4,[r5,#2]
00001c  bf00              NOP      
;;;133    }
00001e  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP


                          AREA ||i.wpabuf_put_be32||, CODE, READONLY, ALIGN=1

                  wpabuf_put_be32 PROC
;;;134    
;;;135    static inline void wpabuf_put_be32(struct wpabuf *buf, u32 data)
000000  b570              PUSH     {r4-r6,lr}
;;;136    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;137    	u8 *pos = wpabuf_put(buf, 4);
000006  2104              MOVS     r1,#4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;138    	WPA_PUT_BE32(pos, data);
000010  bf00              NOP      
000012  0e20              LSRS     r0,r4,#24
000014  7028              STRB     r0,[r5,#0]
000016  0c20              LSRS     r0,r4,#16
000018  7068              STRB     r0,[r5,#1]
00001a  0a20              LSRS     r0,r4,#8
00001c  70a8              STRB     r0,[r5,#2]
00001e  70ec              STRB     r4,[r5,#3]
000020  bf00              NOP      
;;;139    }
000022  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.wpabuf_put_buf||, CODE, READONLY, ALIGN=1

                  wpabuf_put_buf PROC
;;;147    
;;;148    static inline void wpabuf_put_buf(struct wpabuf *dst,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    				  const struct wpabuf *src)
;;;150    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;151    	wpabuf_put_data(dst, wpabuf_head(src), wpabuf_len(src));
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       wpabuf_len
00000e  4606              MOV      r6,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       wpabuf_head
000016  4607              MOV      r7,r0
000018  4632              MOV      r2,r6
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       wpabuf_put_data
;;;152    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;153    
                          ENDP


                          AREA ||i.wpabuf_put_data||, CODE, READONLY, ALIGN=1

                  wpabuf_put_data PROC
;;;140    
;;;141    static inline void wpabuf_put_data(struct wpabuf *buf, const void *data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;142    				   size_t len)
;;;143    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;144    	if (data)
00000a  b144              CBZ      r4,|L100.30|
;;;145    		os_memcpy(wpabuf_put(buf, len), data, len);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       wpabuf_put
000014  4607              MOV      r7,r0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       os_memcpy
                  |L100.30|
;;;146    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;147    
                          ENDP


                          AREA ||i.wpabuf_put_le16||, CODE, READONLY, ALIGN=1

                  wpabuf_put_le16 PROC
;;;116    
;;;117    static inline void wpabuf_put_le16(struct wpabuf *buf, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;119    	u8 *pos = wpabuf_put(buf, 2);
000006  2102              MOVS     r1,#2
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       wpabuf_put
00000e  4605              MOV      r5,r0
;;;120    	WPA_PUT_LE16(pos, data);
000010  bf00              NOP      
000012  1220              ASRS     r0,r4,#8
000014  7068              STRB     r0,[r5,#1]
000016  702c              STRB     r4,[r5,#0]
000018  bf00              NOP      
;;;121    }
00001a  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||i.wpabuf_put_str||, CODE, READONLY, ALIGN=1

                  wpabuf_put_str PROC
;;;159    
;;;160    static inline void wpabuf_put_str(struct wpabuf *dst, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;162    	wpabuf_put_data(dst, str, os_strlen(str));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       os_strlen
00000c  4606              MOV      r6,r0
00000e  4602              MOV      r2,r0
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       wpabuf_put_data
;;;163    }
000018  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP


                          AREA ||i.wpabuf_put_u8||, CODE, READONLY, ALIGN=1

                  wpabuf_put_u8 PROC
;;;110    
;;;111    static inline void wpabuf_put_u8(struct wpabuf *buf, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;113    	u8 *pos = wpabuf_put(buf, 1);
000006  2101              MOVS     r1,#1
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       wpabuf_put
00000e  4606              MOV      r6,r0
;;;114    	*pos = data;
000010  7034              STRB     r4,[r6,#0]
;;;115    }
000012  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.wpabuf_set||, CODE, READONLY, ALIGN=1

                  wpabuf_set PROC
;;;153    
;;;154    static inline void wpabuf_set(struct wpabuf *buf, const void *data, size_t len)
000000  6081              STR      r1,[r0,#8]
;;;155    {
;;;156    	buf->ext_data = (u8 *) data;
;;;157    	buf->size = buf->used = len;
000002  6042              STR      r2,[r0,#4]
000004  6002              STR      r2,[r0,#0]
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.wpabuf_size||, CODE, READONLY, ALIGN=1

                  wpabuf_size PROC
;;;51      */
;;;52     static inline size_t wpabuf_size(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;53     {
;;;54     	return buf->size;
000002  6808              LDR      r0,[r1,#0]
;;;55     }
000004  4770              BX       lr
;;;56     
                          ENDP


                          AREA ||i.wpabuf_tailroom||, CODE, READONLY, ALIGN=1

                  wpabuf_tailroom PROC
;;;71      */
;;;72     static inline size_t wpabuf_tailroom(const struct wpabuf *buf)
000000  4601              MOV      r1,r0
;;;73     {
;;;74     	return buf->size - buf->used;
000002  e9d10200          LDRD     r0,r2,[r1,#0]
000006  1a80              SUBS     r0,r0,r2
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  4541503a          DCB      0x45,0x41,0x50,0x3a
000004  20526563          DCB      0x20,0x52,0x65,0x63
000008  65697665          DCB      0x65,0x69,0x76,0x65
00000c  64204541          DCB      0x64,0x20,0x45,0x41
000010  502d5265          DCB      0x50,0x2d,0x52,0x65
000014  71756573          DCB      0x71,0x75,0x65,0x73
000018  74206964          DCB      0x74,0x20,0x69,0x64
00001c  3d256420          DCB      0x3d,0x25,0x64,0x20
000020  6d657468          DCB      0x6d,0x65,0x74,0x68
000024  6f643d25          DCB      0x6f,0x64,0x3d,0x25
000028  75207665          DCB      0x75,0x20,0x76,0x65
00002c  6e646f72          DCB      0x6e,0x64,0x6f,0x72
000030  3d257520          DCB      0x3d,0x25,0x75,0x20
000034  76656e64          DCB      0x76,0x65,0x6e,0x64
000038  6f724d65          DCB      0x6f,0x72,0x4d,0x65
00003c  74686f64          DCB      0x74,0x68,0x6f,0x64
000040  3d257500          DCB      0x3d,0x25,0x75,0x00
000044  4541503a          DCB      0x45,0x41,0x50,0x3a
000048  20427569          DCB      0x20,0x42,0x75,0x69
00004c  6c64696e          DCB      0x6c,0x64,0x69,0x6e
000050  67204541          DCB      0x67,0x20,0x45,0x41
000054  502d4e61          DCB      0x50,0x2d,0x4e,0x61
000058  6b202872          DCB      0x6b,0x20,0x28,0x72
00005c  65717565          DCB      0x65,0x71,0x75,0x65
000060  73746564          DCB      0x73,0x74,0x65,0x64
000064  20747970          DCB      0x20,0x74,0x79,0x70
000068  65202575          DCB      0x65,0x20,0x25,0x75
00006c  2076656e          DCB      0x20,0x76,0x65,0x6e
000070  646f723d          DCB      0x64,0x6f,0x72,0x3d
000074  2575206d          DCB      0x25,0x75,0x20,0x6d
000078  6574686f          DCB      0x65,0x74,0x68,0x6f
00007c  643d2575          DCB      0x64,0x3d,0x25,0x75
000080  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000084  20616c6c          DCB      0x20,0x61,0x6c,0x6c
000088  6f776564          DCB      0x6f,0x77,0x65,0x64
00008c  29000000          DCB      0x29,0x00,0x00,0x00
000090  4354524c          DCB      0x43,0x54,0x52,0x4c
000094  2d455645          DCB      0x2d,0x45,0x56,0x45
000098  4e542d45          DCB      0x4e,0x54,0x2d,0x45
00009c  41502d53          DCB      0x41,0x50,0x2d,0x53
0000a0  55434345          DCB      0x55,0x43,0x43,0x45
0000a4  53532045          DCB      0x53,0x53,0x20,0x45
0000a8  41502061          DCB      0x41,0x50,0x20,0x61
0000ac  75746865          DCB      0x75,0x74,0x68,0x65
0000b0  6e746963          DCB      0x6e,0x74,0x69,0x63
0000b4  6174696f          DCB      0x61,0x74,0x69,0x6f
0000b8  6e20636f          DCB      0x6e,0x20,0x63,0x6f
0000bc  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0000c0  74656420          DCB      0x74,0x65,0x64,0x20
0000c4  73756363          DCB      0x73,0x75,0x63,0x63
0000c8  65737366          DCB      0x65,0x73,0x73,0x66
0000cc  756c6c79          DCB      0x75,0x6c,0x6c,0x79
0000d0  00000000          DCB      0x00,0x00,0x00,0x00
0000d4  4541503a          DCB      0x45,0x41,0x50,0x3a
0000d8  20576f72          DCB      0x20,0x57,0x6f,0x72
0000dc  6b61726f          DCB      0x6b,0x61,0x72,0x6f
0000e0  756e6420          DCB      0x75,0x6e,0x64,0x20
0000e4  666f7220          DCB      0x66,0x6f,0x72,0x20
0000e8  756e6578          DCB      0x75,0x6e,0x65,0x78
0000ec  70656374          DCB      0x70,0x65,0x63,0x74
0000f0  65642069          DCB      0x65,0x64,0x20,0x69
0000f4  64656e74          DCB      0x64,0x65,0x6e,0x74
0000f8  69666965          DCB      0x69,0x66,0x69,0x65
0000fc  72206669          DCB      0x72,0x20,0x66,0x69
000100  656c6420          DCB      0x65,0x6c,0x64,0x20
000104  696e2045          DCB      0x69,0x6e,0x20,0x45
000108  41502053          DCB      0x41,0x50,0x20,0x53
00010c  75636365          DCB      0x75,0x63,0x63,0x65
000110  73733a20          DCB      0x73,0x73,0x3a,0x20
000114  72657149          DCB      0x72,0x65,0x71,0x49
000118  643d2564          DCB      0x64,0x3d,0x25,0x64
00011c  206c6173          DCB      0x20,0x6c,0x61,0x73
000120  7449643d          DCB      0x74,0x49,0x64,0x3d
000124  25642028          DCB      0x25,0x64,0x20,0x28
000128  74686573          DCB      0x74,0x68,0x65,0x73
00012c  65206172          DCB      0x65,0x20,0x61,0x72
000130  65207375          DCB      0x65,0x20,0x73,0x75
000134  70706f73          DCB      0x70,0x70,0x6f,0x73
000138  65642074          DCB      0x65,0x64,0x20,0x74
00013c  6f206265          DCB      0x6f,0x20,0x62,0x65
000140  2073616d          DCB      0x20,0x73,0x61,0x6d
000144  65290000          DCB      0x65,0x29,0x00,0x00
000148  4541503a          DCB      0x45,0x41,0x50,0x3a
00014c  20415320          DCB      0x20,0x41,0x53,0x20
000150  75736564          DCB      0x75,0x73,0x65,0x64
000154  20746865          DCB      0x20,0x74,0x68,0x65
000158  2073616d          DCB      0x20,0x73,0x61,0x6d
00015c  65204964          DCB      0x65,0x20,0x49,0x64
000160  20616761          DCB      0x20,0x61,0x67,0x61
000164  696e2c20          DCB      0x69,0x6e,0x2c,0x20
000168  62757420          DCB      0x62,0x75,0x74,0x20
00016c  45415020          DCB      0x45,0x41,0x50,0x20
000170  7061636b          DCB      0x70,0x61,0x63,0x6b
000174  65747320          DCB      0x65,0x74,0x73,0x20
000178  77657265          DCB      0x77,0x65,0x72,0x65
00017c  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000180  20696465          DCB      0x20,0x69,0x64,0x65
000184  6e746963          DCB      0x6e,0x74,0x69,0x63
000188  616c0000          DCB      0x61,0x6c,0x00,0x00
00018c  4354524c          DCB      0x43,0x54,0x52,0x4c
000190  2d455645          DCB      0x2d,0x45,0x56,0x45
000194  4e542d45          DCB      0x4e,0x54,0x2d,0x45
000198  41502d54          DCB      0x41,0x50,0x2d,0x54
00019c  4c532d43          DCB      0x4c,0x53,0x2d,0x43
0001a0  4552542d          DCB      0x45,0x52,0x54,0x2d
0001a4  4552524f          DCB      0x45,0x52,0x52,0x4f
0001a8  52207265          DCB      0x52,0x20,0x72,0x65
0001ac  61736f6e          DCB      0x61,0x73,0x6f,0x6e
0001b0  3d256420          DCB      0x3d,0x25,0x64,0x20
0001b4  64657074          DCB      0x64,0x65,0x70,0x74
0001b8  683d2564          DCB      0x68,0x3d,0x25,0x64
0001bc  20737562          DCB      0x20,0x73,0x75,0x62
0001c0  6a656374          DCB      0x6a,0x65,0x63,0x74
0001c4  3d272573          DCB      0x3d,0x27,0x25,0x73
0001c8  27206572          DCB      0x27,0x20,0x65,0x72
0001cc  723d2725          DCB      0x72,0x3d,0x27,0x25
0001d0  73270000          DCB      0x73,0x27,0x00,0x00
0001d4  4354524c          DCB      0x43,0x54,0x52,0x4c
0001d8  2d455645          DCB      0x2d,0x45,0x56,0x45
0001dc  4e542d45          DCB      0x4e,0x54,0x2d,0x45
0001e0  41502d53          DCB      0x41,0x50,0x2d,0x53
0001e4  55434345          DCB      0x55,0x43,0x43,0x45
0001e8  53532045          DCB      0x53,0x53,0x20,0x45
0001ec  41502061          DCB      0x41,0x50,0x20,0x61
0001f0  75746865          DCB      0x75,0x74,0x68,0x65
0001f4  6e746963          DCB      0x6e,0x74,0x69,0x63
0001f8  6174696f          DCB      0x61,0x74,0x69,0x6f
0001fc  6e20636f          DCB      0x6e,0x20,0x63,0x6f
000200  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000204  74656420          DCB      0x74,0x65,0x64,0x20
000208  73756363          DCB      0x73,0x75,0x63,0x63
00020c  65737366          DCB      0x65,0x73,0x73,0x66
000210  756c6c79          DCB      0x75,0x6c,0x6c,0x79
000214  20286261          DCB      0x20,0x28,0x62,0x61
000218  73656420          DCB      0x73,0x65,0x64,0x20
00021c  6f6e206c          DCB      0x6f,0x6e,0x20,0x6c
000220  6f776572          DCB      0x6f,0x77,0x65,0x72
000224  206c6179          DCB      0x20,0x6c,0x61,0x79
000228  65722073          DCB      0x65,0x72,0x20,0x73
00022c  75636365          DCB      0x75,0x63,0x63,0x65
000230  73732900          DCB      0x73,0x73,0x29,0x00
